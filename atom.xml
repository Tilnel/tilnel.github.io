<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tilnel&#39;s Blog</title>
  <icon>https://tilnel.github.io/icon.png</icon>
  <subtitle>我们坐在一起，一整晚，一动不动</subtitle>
  <link href="https://tilnel.github.io/atom.xml" rel="self"/>
  
  <link href="https://tilnel.github.io/"/>
  <updated>2099-12-31T15:59:59.000Z</updated>
  <id>https://tilnel.github.io/</id>
  
  <author>
    <name>Tilnel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>序</title>
    <link href="https://tilnel.github.io/20991231-top/"/>
    <id>https://tilnel.github.io/20991231-top/</id>
    <published>2099-12-31T15:59:59.000Z</published>
    <updated>2099-12-31T15:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近来看的人变多了，正好随手调整一下内容。</p><p>人无法对他写下的文字完全忠实。事实上我最近在录入以前的手写稿时，也有大量删改。19-22的册子看起来写了不少，但最终进入到这里的只有寥寥几篇：写的时候完全不讲究，事后自己去读的时候只有捂脸。这也算我本人这一时期的特色了。然而我还是希望“尽量忠实”，尤其是最近一年我觉得我在这方面做得不错。23年8月-24年7月的手写部分，除了一些涉及他人隐私的地方我不得不使用代号以外我几乎是原封不动地录入了。有可能是因为距离现在的我并不遥远所以我对这些文字大体上满意。</p><p>随手浏览一下文章列表，偶然会有几个月的沉寂期。19年以前的部分在考虑补，高中写的东西的确不少；20春-22春夏我的个人生活几乎是停滞的，因为那段时间包含了我状态最差的时候，最繁忙的时候，以及最无所事事的时候，所以就连纸质日记也没有几篇。仔细想来，爆发期其实就是22年秋冬的一段dramatic的感情，之后几乎每个月都有思考和记录。</p><p>介绍完博客的概况，该介绍一下自己了。如你所见这里有很多计算机相关的内容，偶尔也谈点哲学。然而相比于理性世界，我更在乎感性直观的冲击：视觉、味觉、嗅觉、听觉。所以正在努力成为味觉与嗅觉的美学家，从一个调酒师开始，探索饮品的各种可能。其他的成分只要再略读一两篇文字就明了了。</p><p>那么，如果您看到喜欢的文字并且愿意，可以在社交媒体上联系我（评论区并不会及时通知到我个人），这些反馈都会对我有很大帮助。</p><p>Tilnel 2024-10-23 06:42:15</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近来看的人变多了，正好随手调整一下内容。&lt;/p&gt;
&lt;p&gt;人无法对他写下的文字完全忠实。事实上我最近在录入以前的手写稿时，也有大量删改。19-22的册子看起来写了不少，但最终进入到这里的只有寥寥几篇：写的时候完全不讲究，事后自己去读的时候只有捂脸。这也算我本人这一时期的特色</summary>
        
      
    
    
    
    <category term="日常" scheme="https://tilnel.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>未被听闻者-节选</title>
    <link href="https://tilnel.github.io/20250221-listening/"/>
    <id>https://tilnel.github.io/20250221-listening/</id>
    <published>2025-02-21T10:33:00.000Z</published>
    <updated>2025-02-21T10:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>邀您共同参与南京大学现象学研究所读书会（关注微信公众号）</p></blockquote><blockquote><p>Chretien 1998 <em>The Ark of Speech</em></p></blockquote><p>哪里存在倾听之完美，假设有这种完美的话？如果完美的倾听是一种如此透彻的、如此充满理解的倾听，以至于它在某种程度上用清晰的预见包裹住我的言语，以至于它不待我细说就能完全听懂我——无论是我说了的还是没说的——，以至于它总能预见到我语句的运动而从不因此感到惊讶，那么这种倾听反而会趋向于消解我的言语，甚至消解自身之为倾听。这种倾听，远非一种完满的实现，反而会导致毁灭与暴力。在某些意义上，完美的倾听会反转为全然的暴力与控制。我们不想向那些事先已对一切了如指掌的人言说，我们不想要他人代我们完成未说完的句子，我们言说并不是为了放弃自己的存在之位置。诠释亦有其暴力，甚至，有可能，永远都是某种暴力在奠基和引发阐释。如果倾听理解得太多（而人们或许总是理解得太多），它便会变成那穿透我的——而非在言语之炉火旁迎接我的——观看、剖析、洞察。在许多文化传统中，人们都把这种一眼便看穿他人，甚至在别人口未开便洞穿其内心的能力当作天赋归于哲学家或通灵者，但我们要问的是，这所谓天赋是否真的是一种天赋？如果它从他人那里剥夺了他去言说这一责任，换言之，如果它剥夺了他人作为人的不可让渡的重担，那么，它所给予的便还不如夺走的多。</p><p>……</p><p>与他人一同用心去倾听那未被听闻者，这完全不意味着我是在像一位心理学家或解释学家那样捕捉他言语中的未被说出者，也不意味着我是在占据一个突出的、主导性的高位。这里涉及到的是完全不同的东西。倾听他人所说出的未被听闻者，乃是一种耐心而艰难的探索，这条通向事件（事件要求着言语）之独特性的探索之路，有时会迷失方向，有时需重新开始，且充满着关注行为中的即兴发挥和爱抚之举。只有从这里开始，从这种始终处于开端状态的、由须被说出之事奠定其基调的兄弟情谊出发，他人的言语才会变得可被听见，亦即受到尊重。这些言语的口吃、笨拙、不相即、矛盾不再构成障碍，它们因而也不再是主权性言语眼中的缺失或不足；它们本身就是有意义的。但这种意义，与我以所谓专家的方式在我自身中解读出的症状之意义毫无共同处。它见证着言语的对抗性维度，它表明：任何的言语行为都是一场与沉默的肉搏、与那不能被说出却又将会被说出者的肉搏。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;邀您共同参与南京大学现象学研究所读书会（关注微信公众号）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Chretien 1998 &lt;em&gt;The Ark of</summary>
        
      
    
    
    
    <category term="读书" scheme="https://tilnel.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>战地中盘实况报道</title>
    <link href="https://tilnel.github.io/20250216-mujica/"/>
    <id>https://tilnel.github.io/20250216-mujica/</id>
    <published>2025-02-16T12:30:00.000Z</published>
    <updated>2025-02-16T12:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：东风谷氨酸</p><p>来源：bgm.tv</p></blockquote><blockquote><p>Tilnel 评论：个人对mujica的剧情已经没有正面的期待，目前只是不得不接着赤完整坨。因而除了文末期待剧情向上以外，其余观点基本同意。</p><img src="image-20250216203907465.png" alt="发现ep7-13剧透预言成功#7之后的反应" style="zoom:33%;"></blockquote><p>先说立场：本人从第一集开始集集准时看并关注一些场外内容，对部分情况的概述可能有失偏颇</p><p>ep1-ep3</p><p>观众期待保持高位，情节没有明显问题，热度不减当年</p><p>各种假药大行其道，而且都很有讨论空间，因为当前的剧情确实还保留在一种“可以严肃讨论”的框架之内</p><p>部分质疑设定合理性的声音开始出现</p><p>ep4</p><p>转折点</p><p>目前来看，这集后半段的争议主要集中在“剧情速度过快”和“角色ooc为了炸团而炸团”上，但是整体声音没有转向，因为有大莫老师吃瘪和mujica解散的乐子，观众的注意力被吸引了。</p><p>我个人觉得假药势头最不对的一集，核心原因也许就是剧情问题，大家依然愿意相信剧本水平并且尝试自圆其说，于是有了很多在我看来并不合理但是大家都很热衷的说法，但是大家忽略了另一种可能：这剧本不行</p><p>ep5</p><p>好的，慢下来了，这是很多观众的体验。虽然此时出现了很多失望的声音，但是整体还没有完全崩掉。</p><p>此时，我认为mujica现状的根源来了：大篇幅引入mygo角色</p><p>事实上，整体的剧情走向，如果把现实主义先放一放，还是可以接受的嘛。但是把mygo的角色放进来，很多时候剧情就不能由着编剧了。前几集讨论区最大的节奏就是sakiko的行为到底如何评价。当你把几个和sakiko同样人气的角色引入之后，如果写的不好甚至一般，那争议的指数级扩大是可以预见的。</p><p>这是一步险棋，从舆论环境看险棋中的险棋，但是还有走好的可能。</p><p>当然了，编剧也许根本不关心cn的情况。</p><p>ep6-ep7</p><p>至暗时刻（目前）。</p><p>第五集是缓冲，我相信很多人和我想法一样，但是之后的内容和前四集疑似完全脱钩了，这是我主观上感受到的第一个严重不适。</p><p>你的卖点不是黑深残吗？然后就在缓冲之后几乎抛开不谈了？</p><p>其次，对ano的处理真的是灾难性的。我说的灾难性不是说剧情方面。不是爱厨的我的不适感并没有其他观众那么激烈，但是要先看清楚一件事情：</p><p>mygo是同时卖剧情和角色，只是剧情很好让人以为角色不是重中之重，但是邦邦的本质是卖角色和团体，而非剧情。</p><p>但官方为了炒作把mujica的剧情称为最大的爆点，然后没有满足观众需求；这个时候你处理角色就要谨慎了！因为这是企划最后的救命稻草了！</p><p>结果编剧把mygo人气最高的角色的粉丝惹毛了。</p><p>再看sakiko已然是…</p><p>你又没有剧情的硬实力，又没能好好卖角色，就剩下动画本身，结果你的live还…</p><p>回顾和展望</p><p>mujica会遭受重大挫折，tomori没递出去的笔记本会有后续，taki的深入塑造，飞鸟山之战的回旋镖一定会飞回来…</p><p>这些也许都是观众曾经期待过的，这些坑好像都补上了？但是效果呢？</p><p>mujica的失败，舆论胜过剧情。如果你是一个一周只能看完一集而且不动脑子的普通观众，这番也许是可以接受的。但是mujica面对的是什么人，是有史以来最混沌的观众群体之一。你可以把crychic的救赎当成暗线，让mygo来上临门一脚，但是从第五集编剧疑似将mygo视作剧情支柱之后，舆论管理就是必须要考虑的因素了。尤其是官方下场炒作，把热度带起来之后，这就是重中之重了。</p><p>很多人觉得“这剧情没问题啊”，因为他们对整体的路径规划就是我上面说的这些节点，但是怎么把它们串起来，就有屠宰和手术的区别了。</p><p>这玩意早就做完了。我上面的想法都无形中把它视为实时制作放送。</p><p>后续看看mujica要如何重组，我希望还有缓和观众矛盾的可能，我希望剧情还能有所突破（向上）。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作者：东风谷氨酸&lt;/p&gt;
&lt;p&gt;来源：bgm.tv&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Tilnel</summary>
        
      
    
    
    
    <category term="动漫" scheme="https://tilnel.github.io/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>不要幻想绝对真理</title>
    <link href="https://tilnel.github.io/20250211-verity/"/>
    <id>https://tilnel.github.io/20250211-verity/</id>
    <published>2025-02-11T06:55:00.000Z</published>
    <updated>2025-02-11T06:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最高信仰；无条件者；绝对真理。Anyway，只是同一件事情的不同说法，对于此类概念的追求刻在了人类基因里。人已经习惯了凡事问个为什么，眼前的事情全都探明了，A的条件是B，B的条件是C，C……</p><p>人类是一种能够认识到“无穷”的生物。这样的追问也被察觉到，可以无穷地进行下去。</p><p>所以世界应是这样吗？人类只能“以有涯随无涯”，玩一个永远不会终结的游戏，最终陷入一种徒劳，先人认为不是这样的。</p><p>接下来要明确第一个命题，就是自我作为人类个体，一切认识和思考的出发点都是从<strong>人</strong>能够接受的知识开始的。这些知识是关于世界的知识，然而却不是仅属于世界的知识。无论其来源，当知识为人所意识的时候，就已经打上了深深的人的烙印。我们可以管这种东西叫做主体性，一个通俗的比喻是，世界的一切如同二进制的数据，主体性是一套系统软件，而知识则是高度封装的抽象对象。至于这个对象呈现的性质，则很大程度上受到软件如何处理数据的影响。世界被人所认识的过程，实则是在人的观念中刻下世界的一个“投影”。我们从最根本的天性上，只能站在人的角度和立场上来考虑世界的一切。</p><p>启蒙运动就是在这样的思考中，打开了有关“人的权利”的追求。作为人，思考的出发点是人，其目的依然要归于人类，不再允许人屈从于其他的神圣力量。可以说这是一种“人类优先”的思考方式，当然也可以讲得非常朴素：我们只有相信人类自身的理性能力，因为舍此以外别无其他的智慧。</p><p>如果一个人终其一生，处于对于理性能力的不信任而不承认任何一个命题，他一生都只能够在偶然性的泥潭中打转，人的知识就无从增长。人或多或少会持有一些信念，也许是“人是铁饭是钢”，what not。类似的信念实则是长期以来由经验归纳与分析推导出的真命题。在当下它是一种真理，然而也并不见得一直会是真理，假如某天机械飞升的话。</p><p>我们常讲一句话叫，真理只在大炮的射程之内，这话是俾斯麦的。可见如果在大炮射程不及的地方你的真理就不是真理了。一时一地的真理是由大炮这种属于人类的力量守护的。也许有人觉得可笑，认为真理自在人心，真理从世界诞生之时就存在了，不需要你人来守护。但果真如此吗？不妨认为这种不需要守护的东西叫做绝对真理，它飘在宇宙中，揭示着万事万物的演化之法。那么人在这里无需任何行动，因为不论如何行动，事情的结果总是由这个“绝对真理”决定，那么人的自我意识，或者说人与这个世界交互的“操作面板”，都变成不必要的了。人类将如草芥般被支配着，沦为世界的人偶。如果这样是你所满意的，那么大可回到启蒙运动之前的世界去过活。</p><p>崇尚自由的人则充当着真理到现实之间的中介，真理通过人的意识与能动活动实现在这世界上，成为受时间空间限制的相对真理。在此意义上绝对真理反倒是我们开炮的对象，因为对它的幻想阻碍了人的现实行动。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最高信仰；无条件者；绝对真理。Anyway，只是同一件事情的不同说法，对于此类概念的追求刻在了人类基因里。人已经习惯了凡事问个为什么，眼前的事情全都探明了，A的条件是B，B的条件是C，C……&lt;/p&gt;
&lt;p&gt;人类是一种能够认识到“无穷”的生物。这样的追问也被察觉到，可以无穷地</summary>
        
      
    
    
    
    <category term="哲学" scheme="https://tilnel.github.io/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>骨折后那些没人告诉你的事</title>
    <link href="https://tilnel.github.io/20250209-fracture/"/>
    <id>https://tilnel.github.io/20250209-fracture/</id>
    <published>2025-02-09T08:00:00.000Z</published>
    <updated>2025-02-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我是右腿胫腓骨骨折。本文仅讨论下肢骨折，骨盆、上肢、肋骨骨折及脊椎病患者不适合参考。</p><p>做手术前医生大概会问要不要镇痛泵，就是自动给你定时止痛药的装置。理论上是可选，但其实必选，尤其怕痛体质。医生没说，要主动问医生，如果医院里没有那算你倒霉。主要做完手术有疼痛会影响休息。博主相对耐痛，也还是用了，术后几天都没任何痛感。</p><p>初期卧床的阶段，吃饭时吃饭后上半身能抬高尽量抬高。平时时不时也要起身，可以不太久。老是躺着会便秘，别说吃乳果糖，你吃华莱士都不管用。便盆是废物一个，谁用谁知道。</p><p>也不要想着不方便就憋。大肠把水一重吸收，就更难排了。</p><p>做牵引、安排牵引床也许是件好事。你会拥有结实的钢架子和拉手用于起身，甚至上半身可以直立，对排遗很有用。没牵引没这装备。</p><p>关节活动要趁早，医生不说你要问。术后一天，有条件并经医生批准，要努力进行屈膝，足背屈（勾脚），跖屈（绷脚）的练习，谨防筋膜粘连，关节硬化。屈膝一开始有点疼，需要慢慢地增加角度。一个月内，大小腿完全折叠为佳。我隔壁床做前十字韧带重建，第二天康复师进来照着腿就是掰，屈膝过90度为止，疼得龇牙咧嘴。</p><p>早练早活动。晚了，关节硬了，你就糟老罪了。</p><p>早期可能伸膝有点受限属正常。</p><p>手术后局部血管未重建，腿部淤血，大片深红摸着稍微有点疼，属正常。等待血管重新生长后会慢慢消解，此时血供也恢复好了。</p><p>有条件者，上厕所坐马桶。能坐马桶了，心态会变好。能安全地独自做什么事了，都要尝试去做。</p><p>在家这担心那担心，一定记得把平时小问题记下来，复查问医生。省得看了医生又忘掉了。</p><p>大约两个月的时候记得问医生脚能否触地，以及占体重比例，省得脚下没轻没重影响恢复，或者应力刺激不够恢复速度慢。</p><p>胫腓骨骨折，对于腓骨断点在骨干的，可能只做胫骨不管腓骨，这是较为普遍的临床实践，到积水潭医院那也是这么做。有时近端更是不管，因为神经密集。腓骨愈合慢不太影响整体恢复。但腓骨远端到外踝这里的骨折，由于可能影响踝关节活动，一般会干预。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我是右腿胫腓骨骨折。本文仅讨论下肢骨折，骨盆、上肢、肋骨骨折及脊椎病患者不适合参考。&lt;/p&gt;
&lt;p&gt;做手术前医生大概会问要不要镇痛泵，就是自动给你定时止痛药的装置。理论上是可选，但其实必选，尤其怕痛体质。医生没说，要主动问医生，如果医院里没有那算你倒霉。主要做完手术有疼痛会</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Ave Mujica 的未来 - 第五话后评</title>
    <link href="https://tilnel.github.io/20250206-mujica/"/>
    <id>https://tilnel.github.io/20250206-mujica/</id>
    <published>2025-02-06T13:00:00.000Z</published>
    <updated>2025-02-06T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>第五话的问题究竟在哪？单拎一话其实它的观感是不差的，但评分骤降到8.8（事实上B站的大手已经锁分了）表明了一种看空。</p><p>前四话在不断的爆发中揭露了许多队内矛盾，第五话的任务是在前四话紧锣密鼓高信息密度的轰炸之后放缓节奏，承上启下。在炸团已经确定的情况下，对于团队成员的状态以穿插的方式进行叙述。当然要明确目前的主要矛盾在于 Ave Mujica 重组的必然结果和当下团队成员动机不足、责任心不足的矛盾。因而刻画方向应当在于，老成员们不得不回归的理由，以及回归后拥有让队伍发展向好的能力。</p><p>目前第五话对人物积极面刻画不足。大众视角看祥子的人物形象已经跌落谷底。当然也有处理好的部分，比如沉默整集的祥子唯一一句话轻声破防中展现的人物弧光。但更多的信息是负面的——若叶睦闭门不出，祥子不关心睦，也不回初华的消息，正照应 MyGO!!!!! 第13话 Ave Mujica 的短剧中，Doloris 被抛弃而 Mortis 不被爱着。她们都被 Oblivionis 所遗忘。</p><p>B站动漫区头部的相对悲观情绪是在说，剩下的8话篇幅不够，无法以优美的方式和适当的节奏展开对 Ave Mujica 五人的救赎可能产生两种问题，一是节奏急迫，忽视观感；二是逻辑不严谨，强行推进。由此，也可以说第五话的问题就在于它是一季13话而不是16话、20话。祥子作为队魂，是开启 Ave Mujica 复活之路的最关键人物，在这样的重要节点，人物形象依旧在总体下滑。</p><p>也有乐观派，观点大约有几点：1、没完结不要着急下定论 2、人物塑造在进行 3、角色不是圣人，她不闹我看什么？</p><p>两方实际的不同是对待作品立场不同。Ave Mujica 是要成为一个剧情流畅、处处合理、大众的理解度高的故事？还是要成为一个小众解读、卖爆点的故事？</p><p>用一个比喻即可阐明：Ave Mujica 的发展如同棋局。</p><p>再聪明的棋手，在行棋过程中也有可能打出漏勺。你最终可能会赢，也许这个漏勺将棋局推向了较为激烈精彩的局势，但漏勺就是漏勺，棋谱会记得，胜率会下降，你在那个地方总是有一个更好的选择。Ave Mujica 就是这样一盘棋：漏勺已经打了；精彩也的确精彩。获得了讨论度，也有乐子和高光，但精彩的故事大纲和部分人物闪光之外，也有演出发挥失常和逻辑断裂。</p><p>Ave Mujica 的漏洞包括：</p><p>1、来自经纪公司的现实的重压只在炸团后出现。摘面具不担责，日常工作不见人辅助，赔款的时候人来了。</p><p>2、所有的吵架戏通通给人一种感觉：“怎么突然开始说这个了？”团队立身之本的争论犹如儿戏。</p><p>3、高高抬起，轻轻落下。结尾形势紧张，下一话告诉你危机平稳度过，怎么解决的不给你看。第四话炸团结尾尤甚，整个团队在起爆之后瞬间达成开幕即解散的共识。观众是信你按下不表呢？还是应该认为你没能力圆上这个情节呢？</p><p>4、在团队起爆之前，没有为成员归队准备台阶&#x2F;伏笔。那么势必在后续剧情交代，这搞不好就会变成追加设定，强行解释，以及机械降神。</p><p>所以不怪现在有假药。总是说假药看多了，擅自期待，擅自破防。大伙为什么都这么好奇剧情，因为是真的想不到怎么圆。诸多分析向假药都在试图圆上剧情逻辑，是一种无奈之举。</p><p>当厨师端给你一道看上去像宫保鸡丁的菜的时候，你吃了一口顿感味道不对，是否厨师也应该告诉你，“你不要擅自期待这道菜的味道然后擅自破防”？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;第五话的问题究竟在哪？单拎一话其实它的观感是不差的，但评分骤降到8.8（事实上B站的大手已经锁分了）表明了一种看空。&lt;/p&gt;
&lt;p&gt;前四话在不断的爆发中揭露了许多队内矛盾，第五话的任务是在前四话紧锣密鼓高信息密度的轰炸之后放缓节奏，承上启下。在炸团已经确定的情况下，对于团队</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>骨折的上下文（pw为某组群号）</title>
    <link href="https://tilnel.github.io/20241224-fracture/"/>
    <id>https://tilnel.github.io/20241224-fracture/</id>
    <published>2024-12-24T07:00:00.000Z</published>
    <updated>2024-12-24T07:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4012b9bc11f9908a3eaa983fbda97ecf8ca45297bfd23a09a0d7dacba066e2fb">9c591e5321f2e0cfd2bc84047a64292d4fd097cfed96ff968510140273b9aca90c61af8978dc61ca95dd7ff9d5d51bc284cf480af003ac183ebc3c8e6691c96762572263e04afe5836602528fecc296438f6e92cd095e59fbe26b197be0eae32b28a5a850b9d5eee6f7e0432f2a0df87a951a67b0af9699bad7832542af187a36a71fb936e4d31624e31e29beb260a5bf1e6aac6e4b3b76350085bd13b23239fc0f3bbda4ab0af57fac7a7707d4a73f1afc401f7811cfc61e78684d58027786d339a4f618cc20509e2e13c84d50d84d4e404e22258becb884b02001b3977e42891f177d7db479ee4c51ad29e62a662970e8a0c4dd18855e8b0eb232d413cc87c71e38132c93755af04b913c916f2d15912676a5152b11d706ca1236d1b427bdf76fdd66579786eb58bb5cfbec8dfc8ee7dca9864f048009119eb8e3c6709232d4f70abed55f6afe380c4967f7c5d6bdd491bb92cc810cebe72f81417c9051570a29efb9ca22f19fff49cfcb7780cf3844fc92b69b4c323620d6b4f244f39b3ee84e67c00651e4d2ed100d548eb2b8cd0f913d17eece2b35698cf9da9d154a5fbf2203f62c7f48879b4d35614e18e149a4a5b9a5370941955e2bea6b998e19cd1ba57474407849eae7c7f4561097ac6beb61ed33540272883bd9adeb639f73539fc25dc3c731e6e5457333253a376897540f8576c71d140979a8d53435a542c031fc45bb4de8f62a0100a27a27c6e491db5dd9d40c598ce8041a6938d6e15a22667c4eebdceff493457fd4025a6964a4f64a1887adbe33194d72edba6c7ab5bdcf02b5085c8757aa5d2964b30880504a3f69d34f78a733a576507f5a951629b2fd6ca88b2bc0b8dae2e8c921fab044ed713b6ae1972c88e2b182e4a27a055d47f0cefdd4d96c51a32f7e65c0e3fb1b99e50ed3ce6f22cfde5fcb8af76cd2b52ae3a37a71392ecc4662464ff1cae675d66b2478a8d43d3133f2c6d49347a96d6da2a5acba905ded08f8bf730f84f6c7194d26da21cd9dc241863156863e53d3c7641b5ff4785048f23636b08d96eac23039b7c9b927c366b7f585a8161ef89f6cf55f5dfaaf3b922e37a8502988a2e437d41b0031b23d42728b9465adf204b01b9862e05517a3d40cfcb3902e30081eca68aa02489a749e6314b9ad93bff08d90ad4e98207e0d08b2b2fb85618357fdfd02dad5d52612ea7b7882cdd1850a85c756987f2d068d642700325063ca8b22cb0b1c84628c8cc0748ab5a9d134a8f1621aa7f3eebefef33a2e2e66482f9a59d7039fb12aa091061d33a80d28372111c3a44263ed67a753859fdaf1d7f085c812d830c0d5902e7b75b8dda36051b2be7f2cf039e4d2d25c20672f30683628c53bbd7c551b1985416c21d993de2aa4ed51dd57e538b687f86c0275ae30511c1f29d70ccf9e2163b959f59740d3612e092bdc71670894245405cce327555caa7627d7dae5ab49b84d81fc465556ffd9f20d2d00d89bb288903a1d20e92b69d0e04d97ea4d631a528dc07f7225218eee1af05ffcc1f0ca513a07376f15e2df3913283aa16b17cb6ea985d89cbfd9b0adc3e31e64381b12017f827141e1f6767ecf047c46eefc480f33b0fffc24c7eba346ece0ca3d2da0800e1778bd43ba7336596bf515c183a9d62e786e0388a9c651f29e6b22f6ded571c7ecffd9ce28adfe8c340be922ba9f353117533eae95955793e82f0e267f174b3149d0f7573aa28894354293afbe039fef0dac380776004d020adec9631080069875e12336900349f09dcbc96d5df6cf88b206e602cc6ed993fcbdc355465d118b099d74525245a89183caa4c46e5ed564a6119868f153fb5f2c257417111dcaae81a47d478f221222b0402a1dd1fc65ac5578e78c87e900e53545aa0a3c585b997de4f2d18c80a96c09ab52a5711a26e741d3bdeac43d915f9777fbe65dbe91787e9d5508c2ac00eec817bb4a0bd928e9c9534d40c4fea432216b02fe598ddd8a3862afede2b8f00bb554deb6d9f4750d6fda83005b9fd630af827927c3e68b91a09ec02d48d278034e131645830c3525853f77f7b99ecaeb350676b231edf4b939d0b1459e4f0bcc94c4caebe936f76c2b4f7638cfa27f3265d8639634d0d570db9c41d5a0c662db5f034f28b03be0d2861ad1bb7a01ee3eec412c5a1dbed410b4e5303fabac03e0f79d6921e8946bde79b7b885e3ba9c2726307c3f21c6120dfc69c9fd56647657e37c1f35d8d201d45e775c75e0920618518c7bea9b09045c9b3fa80e7250a0d66b01050d490f3b607709dc1aed27eacd75d4d99cea03276d08a0bce85414eb9b647c414bf3e81661527254833a253d05b4518941b373270df0fafab384a3db8dc9253a5bd80ee137ec24ab497f30720d5cbb7fdf2df81a69dbf312cdb2ca1d1290d6da083574bd8c8adc56fd87476f66382db08b0512547a247efde59c04f6f54e6eb5692100db45140497f1b1e83ef8bbed39cd0b1e2f7df7dad8a554538e1265a7fb63461ce7b04887882248873611d3f6ea21c727870ebd4a5fb5a0c4af110e2188e39af5df8414c375da137856b699a18acadef734f5a9d02657f882f48e73dd766c9b381e55a0498b2c04ce28e42a5a972460ce922e1f885a565d283b0f13cca3f6741bdbc0e6bf1e74a22b1b822fa8873625e7ac94280b791e7c02de99862080a971104b803f03f82fd2ba57414ac78c979964eebf67909e6c128decb1cbd1e5020cb712128d6e3d1d650ef48ef01836af7467c75264f50f8a53338eb7ef9629ef3c97470a8742d6acaf32e502bad5bc5a381e7ba11754aad04eb53e48c463eb3dcbd28efa3fb7d69329af4f8b8a093b64f2bbd572d71d95843d52ed5f83f2fa4f08600f5429534695654648c8db5eb17f2e61c67baafe3f49549484e28a457c9906ca723d251803c992a803532ba47965fc225ce899ff0075178ca05bf1f4d4b6e5a951a9f90f405ddc038fdf41ba2a5ad730c011a5dbe6373fb0cf99cc5e51789a1b2aaf99283d0336da5a0a1488c56c8e0477e4988630c09ef13c3701b4da113cd978739ee8ccd49251d6ee9ca8a33f125790a985686206deeeb9f413636e74ee455295e490ad67843edc4f623082787a19fe0793bf052f6ac36e247ee0af34d824b7483af6cc0eaf3a80a23cc7df9ce87a53dab78057193204faaa916793d13e3ea2c2ce7467a9767b92faad691fe8b6e224ee63303b9a95c6a6d8e4f176ecd1fe24bd83b43f922de4e0f0fd87017525c03d847bea9e37ef9637122daa4b01d77de91b5bd81f62101aa087e225555e36f931cc9b70c83f54d5708997340e80c0f3121e39e5b11793381e30e91d2a49e204586612d6ba572b857d91520ab565c136dd85a40125ca1ed756b6b4a063930471da147f3f4ee8f58a84d3af27faf57c264b426491da881702a3e5102aef0360021eb41e922d6cebfc82236c5ba6974dcee0aee024013d7f32db5fb90942af76b80f94f917872d656d508c50d56dc488a65ceb17496cf4133a01e8a7a6ef428e3a17b08174297fc3c9c9eb07c918c6d0ab426a7abcd6c3e0424c51ba8e541f622800f9d4eab3fa04cd4b7abc0f35342c4549618f41a49f2e6e0f52f7d389ff161e45a4a18572fc980ae79eaa03919a4061e70d136d8420619cdfc4c62b38ed6bc089ef465b475b08b94edbe75276815ba795b35a9a3c6aa182009d38061e1c4051d77cccbad8f13d71639a4ed175fe06071efaa8ca25c68d18afd2c7d3a4da2d3008ed226b76d118e51572fc7889c29e33ad6671c0988cab8816fa52a7797c0c1bfa6e7ebf700cbc98533452955c950695768f6d2fe1500caf5924dc716c142851e81dd7c40a7d2391b56f79ae1ff6046617a1e53866df3e81f7f5742e883a936c3365efc0116a25a1bed8886f46ffc96649609c12fb584048be02966198897eea00806f24f0524290a67ca96cf2f46f5e2fde96bdd1474f9078f0c63a45cfac4d4a0eadbd8b8be3baf90e1ca8a476da1cac49bbd1d585edc5a180ca441caa02bf767b1284a855a2d7575a6fcc3f6d24ab65b9cd8c1885eb980c29c77732cc2a2bf2a0be1fa293f4dd3b96aead45b65c0118b939197ac40da13d90823fc14e8bdd57ca2bab0992fe31fb2c66ccd1eb1edc07b845fe5ab4127bcf027c3f27170515bfd6673494a8e9e32178a3fdbce0cecaf804c143f97f19cd63c38c6d6fd3d266d9196e71fe31c7ee7218ff60e2d1c7c471e4545a91e596f2e896c466bed233bf3eb154db8df39e34a4492241080f2c262da581f204481dae83743cca7fe66eb2147f1bbf554cd24eb513969aa9a082ba1660bc696604c80424e741fd034c9e694dac8dcee8b12b53a37d5dd6df4e4997cfa69ecbb56c3978d06dffc7333825b22094a4eff71d41350955b3a0afc9bb4d310b3d65469f7dd61447a78d41b826c8290a61db1494d4ee7ee827ce268eca5b1f2928a28bffcd1230310880801076019bc62b63fac5c43a69a43d8534e9bc95e893957bd371a139b44ab362fceb6fd23f34ff71e702f9171d3abe72ab0b1e5ad9256d9809a5b85b180f37c431677e19c022851852dfb32a1bd263462121ba8953ddd45d99119a353344fde27712892b0eed32788b16d76dd3065861332f3ec2d20a28c6967ba8746293ae1d729de3497749c20c6d956863bd14df0d21d20dac63c8a426ce0ea1d10d482bb7fe95826ec161463ffd5fab96e642dd07a2f38c03407384ce85b398edb33cca6adc18f50ab864dcb64cd6761047a9aa6f08571976ac2db25e0e641975a37e61073d759436d4126bade42cfdf59f624b122d78b6b9a380ff091b1b6002cadcea4bb017a06e73034c77efd5addf546fb926fb0615f84ebc57ff379799c53008cd70b0c1fb0aaaa89c093224d4bc8b174a7da46f310784ddc07fdf6ff40bf11d1495f9df783f46ac3d3fe6a78b36d898d97c33eb3ebf33fbdc53ee6d37e1850a9e685b75ea3b1ec016488e7a0b1b64034993e88459dbf1771c95b0d786afa4b5e705acd5cc28aaa5692964c7bd450d1f1e8899b33074e13fbdcd459ce9bb588a0ef1f8b6849a233e6e3137c9dfc373c000a6635a84e2231434dd4855cdaf465a702e8611dfbfa00c387a16606fe484351f0a1e40bd0ec290d39afb9aad8a514490e3fac4ad2d28a629f30503d7019b34e779ccbb9a4c9d1c8e034aff2a788f2a978b684795b718f4ad2df117c96dda6a13001023f045b753b7a36936585ea6fdf318e26e6f6ec24c95cad9de841a57a7de2a1cc51110b53062beaa9ae96690807f7a689e771f2221e95cfd4231c0f4cad1c6c5ce1017ad3331d9ff068f582f2d8f3c24ab4be144ede2e67d6893fdf7f775bfd5bb65b41c278df053df2dbddf448b46e9ba2dede3dbb7c615b48d2884a2c23cf9abb98548c9c18bc3cece19198bfad51857f1005d7ee47859b3080e21389437feea2fb9fe40fad8620244dba554732f8a2c3cca87cb6ccb18e45eb4e0c4588c3014f7f16ef68544391c38f9ae6e722435d5eed35bc89be9dc1dd7bce5143b893644c0b5c97761bdb91088b3df67e841641952b3bdf3970e415c66068353a87434a3d0075dde7471ca451b0a7466c892b9c32ec6f250f660b13c2f4071d0ecba09b2766aa402493b0a5514956cbd8759da85738232795c6435bb097b190769b8c33e459f132f21c9c4218ffee27f080ebb4b1b0170c0cbed5a5d82cff83f082dc64cf529a13a67fb6cb0a131be065c516a0ff1937ff354f312a3537a72fefdb48705b5a42193d958aa9d79097f817a38082493da369233eed88214a407ee7b07d70a51b5e1fdf8a390f6e9ade1fd406de3579f8ffc3aa1cb06fa281b6cd17eb2c6497439d02926d8209483341f688beab13a1fa91a76fd9abfb6df1b02af04b08dcdd863456e5ae9525637e920cdd0c552186dddb270d962ad32723597f077bc6ceb62a82f3a3851fd908465c396b516b7e55bb2b2bb0ecaaf493774f9e1952c048814fad64757b4443b8c5823ac5c15b3b9dd2499d94f45b013df1cc71154e734e2a12fab233c2293c9054d41f192ace16c59e6ebf9a5980547a6538c016c7aaf8170c0cfcad7884a6f833771e9f4cde06b9684d7640c3eae00639c0557b3a7280a68afef4faecef75353ba51ce025a8f74ecf52f647f2485a50a6734f7d8c5cad4a2333f54285bffaf89e11e58c2e986cffef0f5c4848556bebc2bd4835f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="日常" scheme="https://tilnel.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>哪来那么多长期主义</title>
    <link href="https://tilnel.github.io/20241128-longtermism/"/>
    <id>https://tilnel.github.io/20241128-longtermism/</id>
    <published>2024-11-28T10:59:15.000Z</published>
    <updated>2024-11-28T10:59:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1kABYYeE19">最近哪来的那么多长期主义开箱</a></p><blockquote><p> 我们能否在购买之前就意识到这是一件“长期主义单品”，并在之后的日子里坚持一开始的认知？</p></blockquote><p>个人现役服装中服役时间最久的是一件商场买的肯宁顿风衣（但是1k6且聚酯），品牌也是已经从中国退市一年的SELECTED(听起来是很没品的名字)。但是它可以说是建立了我对风衣这种商品形态的认知，那就是——几乎怎么穿也不应该看到明显起皱的长外套。当然从此我和嘎巴甸（华达呢）这种面料就无缘了。那么最喜欢做这种面料的其实是—-Burberry。到底是谁在喜欢这么难打理的面料？并且一般支数还会比较高，这样容易反光，起皱就更明显了。</p><p>到今年满打满算买到手已经4年了。但是我今年穿这件衣服应该比我前3年加起来都要多。我也不知道为什么把它放在衣柜里躺尸，主要的原因还是以前自己在穿衣这方面克扣自己太多了，几乎没怎么买过衣服——因此我其实没有其他的衣服来搭它。这就很要命。</p><p>当然另一个原因是我以前觉得这样穿太奇怪了。似乎当时还是 cityboy 版本——没事，现在也是。为什么能把这件衣服想起来也要赖它。大概是说ex给我推了几家淘宝店，都是这种风格。后来分手了，连带着这种风格一起不喜欢了。</p><p>以上只是戏言。正经地说，我还是觉得 cityboy 太典了。虽然我自己也买了一两件这种风格的 teeshirt。这种风格差不多就是满大街的底特律517这种，初看觉得这个穿得挺好的。然后看到所有人都在穿像个NPC，就绷不住了。</p><p>当然以我调酒师的身份，最容易走的路线其实还是轻熟，几乎是顺理成章的，不容置疑的。跑题了。</p><blockquote><p>当初觉得帅的东西穿久了或者见识广了也就那回事，反而是随手买的成为了美好的误会。实际上不能长期又能怎么样呢？我当下这一刻的满足是真实的。它短时间内依然能带给我足够的价值。我并不认为我的购物没能长期就失败了。</p></blockquote><blockquote><p>只有拥有了自己的风格，才有所谓的长期主义。时尚一直是来来回回的。</p></blockquote><p>OOTD：大逆不道的西服内穿塞进裤子并外穿开衫毛衣，再把驳头翻到外面。最后把衬衫领翻到驳头外面。（？？？）</p><p>南极人卖的内搭德绒Tee比平圆方中的纯棉款舒适度上好几个层次。虽然不见得是粘纤的原教旨德绒就是了。</p><p>——这样我就可以假装自己在9度的天只穿了3件而且还不觉得冷。主要是领口多了一层，整个保温最薄弱的一环解决了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1kABYYeE19&quot;&gt;最近哪来的那么多长期主义开箱&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;</summary>
        
      
    
    
    
    <category term="时尚" scheme="https://tilnel.github.io/categories/%E6%97%B6%E5%B0%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>【自用】杂项</title>
    <link href="https://tilnel.github.io/20241127-misc/"/>
    <id>https://tilnel.github.io/20241127-misc/</id>
    <published>2024-11-27T14:02:14.000Z</published>
    <updated>2024-11-27T14:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3a846b429e2c41302ce90a4bbfa1690b07f85a82343e66f404b7a6a9c6059e6e">680953028ddd47d9bc33f1e3c96e3f1f5e5c7e34231229e943681291ffab92c8749268f0964a83468d040c412125fa6d384e49db682778d75d02e70c614d5aa016d305904f5cbec93baa5d0dca7b9c570729e2510e59ba26ea54324ae433cab84c317a347544adffd220edecab3eba88dbbe6fd8da059a8a09f406028fdb000b0d611d5cdcfe5bcc063bbdcfda35b8b6b56cfc8ad58acb88c9023955c386f2aec6dffad1a0e5f6b1a1f06c09764496444f5b2c89eb89e9a4a272e3842512fbb14281b9db77b8c1917ebcfcea637e400cda77c4befda04271a90c80bc253393a83cdedb96adcfcd3dbe8e1ce8572d30eae14afaeb4127388b7bb253445198f3965a0cbc7b6c557fd22936615ff315d7b4075a6a015936bdd37730ae7b58cf9826341c130b0b154eb546c5492dd0312042bcb173648a144bde822282a44871cf187ab0a25b2c9190be18b0c6df73bccc6b7e2ecddae3ffa1bd4a521aa3d1fb17ed900dd0f98f2dccd9b1bfbabc4ec48380fee624da1addb429c7a4f22555900f4d30d73e31893d7a70853d315a9c021ba720bfaa892c1ad31f37a47b87a45508c743148f29ff29a2ee59c5f38921de34da123392b7b4b81932e116181039b045d37c5e247a3fd77d6497ebf6fc68a01cbb75692c713b838483a8a6cb332720042ac45bd480f121810a564dd25f2eabc054645f7ffae849f5c508a51f4f8286f9ce9ecc1e0136df0ee5c7bb377764d50f467c90e8c60573c5e0a05a999944539989</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>都 2024 年了你的穿搭还能反映你自己吗</title>
    <link href="https://tilnel.github.io/20241127-wtfyouwear/"/>
    <id>https://tilnel.github.io/20241127-wtfyouwear/</id>
    <published>2024-11-27T06:20:11.000Z</published>
    <updated>2024-11-27T06:20:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>刷了一个非常好玩的 <a href="https://www.bilibili.com/video/BV1oLUkYkEWn">B 站视频</a></p><p>顺手贴一下最近其他比较喜欢的视频列表</p><p><a href="https://www.bilibili.com/video/BV1kABYYeE19">最近哪来的那么多长期主义开箱</a></p><p><a href="https://www.bilibili.com/video/BV16ZU2Y8E5R">小伙连着穿了一周的Rick Owens Kiss Boots，这是他精神发生的变化</a></p><p><a href="https://www.bilibili.com/video/BV14z4y1T7qo">2023十大潮流烂活！｜老钱风、美拉德穿搭、cleanfit、芭蕾风…令人满头问号的时尚？</a></p><p><a href="https://www.bilibili.com/video/BV1WE411n71Y">Lemaire 2020FW</a></p><p>跑个题：<a href="https://www.bilibili.com/video/BV1vEDeYxEU1">齐泽克的简单友谊测试 原作者：Julian Cinema &amp; Philosophy</a></p><p><img src="image-20241127142033289.png" alt="image-20241127142033289"></p><blockquote><p>Working out is modern couture (高定). No outfit is going to make you look or feel as good as having a fit body. Buy less clothing and go to the gym instead. –Rick Owens</p></blockquote><p><img src="image-20241127142716116.png" alt="image-20241127142716116"></p><p><img src="image-20241127142730449.png" alt="image-20241127142730449"></p><blockquote><p>如今，有什么是不能从海鲜市场轻易淘来的呢？</p></blockquote><p><img src="image-20241127142808959.png" alt="image-20241127142808959"></p><p><a href="https://www.bilibili.com/video/BV1ArU7YSEiC">Loewe 2025SS</a></p><p>诡异的 BGM</p><p>大量裙撑（甚至风衣），宽大袖口，各种斗篷、各种印制、各种半透明，大量印花</p><p>少量未来主义</p><p>又见羽毛印花T恤</p><p><img src="image-20241127160615791.png" alt="image-20241127160615791"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;刷了一个非常好玩的 &lt;a href=&quot;https://www.bilibili.com/video/BV1oLUkYkEWn&quot;&gt;B 站视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;顺手贴一下最近其他比较喜欢的视频列表&lt;/p&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="时尚" scheme="https://tilnel.github.io/categories/%E6%97%B6%E5%B0%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>工作随记</title>
    <link href="https://tilnel.github.io/20241125-working/"/>
    <id>https://tilnel.github.io/20241125-working/</id>
    <published>2024-11-25T11:47:50.000Z</published>
    <updated>2024-11-25T11:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先来看一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_stack</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">void</span> *buffer[BT_BUF_SIZE];</span><br><span class="line">  <span class="type">int</span> nptrs = backtrace(buffer, BT_BUF_SIZE);</span><br><span class="line">  <span class="type">char</span> **strings = backtrace_symbols(buffer, nptrs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!strings) &#123;</span><br><span class="line">    perror(<span class="string">&quot;backtrace_symbols&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; nptrs; j++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strings[j]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="image-20241125195032520.png" alt="效果" style="zoom: 67%;"><p>打不出调用栈当中的大多数函数名。这主要是因为编译时没有添加 -rdynamic 参数。</p><img src="image-20241125195158300.png" alt="效果2" style="zoom:67%;"><p>添加之后，就可以有了。这样搞我们就可以省得用 gdb 去调试调试器了。</p><p>打算在项目里引用一些 Log4j 之类的库。想做日志分级。日志里面细的东西实在是太细了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;首先来看一个函数&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Crazy Saturday</title>
    <link href="https://tilnel.github.io/20241125-record/"/>
    <id>https://tilnel.github.io/20241125-record/</id>
    <published>2024-11-25T11:26:05.000Z</published>
    <updated>2024-11-25T11:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在周五夜里唱唱是我这周末做的最错误的决定。 ——typoverflow</p></blockquote><p>周五晚上，大家都叫着要唱，于是这局真成了。这次唱到4点51，吃了和上一次同一家的早餐，搭乘地铁2号线的第二班车回到仙林校区。随后有一分队在824打雀魂直到早上8点多，才各奔东南西北。</p><p>一觉醒来是7点多，本来打算问问吃什么的，说是重庆面馆。但这时候第二场来问了。于是在没有吃饭的情况下前往酒吧。</p><p>我居然能在一个小时里完成洗澡夹头发再画一个白开水的操作，果然人的潜能都是被逼出来的。</p><p>喝两点去唱，唱到四点半打道回府。感觉周一就算起得来也绝非人类了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在周五夜里唱唱是我这周末做的最错误的决定。</summary>
        
      
    
    
    
    <category term="日常" scheme="https://tilnel.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>随便写点</title>
    <link href="https://tilnel.github.io/20241120-misc/"/>
    <id>https://tilnel.github.io/20241120-misc/</id>
    <published>2024-11-20T07:25:03.000Z</published>
    <updated>2024-11-20T07:25:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>感觉一直在做数独。不能再这样了。</p><hr>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;感觉一直在做数独。不能再这样了。&lt;/p&gt;
&lt;hr&gt;
</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>不抽烟了</title>
    <link href="https://tilnel.github.io/20241116-nosmoking/"/>
    <id>https://tilnel.github.io/20241116-nosmoking/</id>
    <published>2024-11-16T11:44:57.000Z</published>
    <updated>2024-11-16T11:44:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>走来计科楼的路上，我想着最近大概足够幸福了，可以不抽烟了。这是一个自我实现的预言。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;走来计科楼的路上，我想着最近大概足够幸福了，可以不抽烟了。这是一个自我实现的预言。&lt;/p&gt;
</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>工作随记</title>
    <link href="https://tilnel.github.io/20241116-working/"/>
    <id>https://tilnel.github.io/20241116-working/</id>
    <published>2024-11-16T04:54:24.000Z</published>
    <updated>2024-11-16T04:54:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(<span class="string">&quot;movq $-1, %rax\n&quot;</span><span class="string">&quot;syscall\n&quot;</span>); <span class="comment">/* won&#x27;t set errno */</span></span><br><span class="line">  <span class="comment">/* syscall(-1); */</span></span><br><span class="line">  <span class="type">void</span> *handle = dlopen(<span class="literal">NULL</span>, RTLD_LAZY);</span><br><span class="line">  <span class="type">long</span> *errno_position = dlsym(handle, <span class="string">&quot;errno&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!errno_position)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Not found&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(*errno_position));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syscall()</code> 事实上还是 glibc 的 wrapper。errno 并不能够被 raw 的系统调用获得，只有 glibc 的 wrapper 能干这件事。我用内联汇编写 syscall 指令，errno 立马就不管用了。</p><p>问题在于 glibc 是怎么知道 syscall 出了什么问题的，感觉有点头秃。</p><p>OK syscalls(2):</p><blockquote><p>Note: system calls indicate a failure by returning a negative error number to the caller on architectures without a separate error register&#x2F;flag, as noted in syscall(2); when this happens, the wrapper function negates the returned error number (to make it positive), copies it to errno, and returns -1 to the caller of the wrapper.</p></blockquote><p>看到这里，我情不自禁地想问，既然 errno 对 kernel 不可见，那么对于 <code>ptrace(PTRACE_PEEKDATA)</code> 这种调用，它就算在成功的情况下也有可能返回 -38(ENOSYS) 这种东西。我怎么知道这个系统调用是成功了还是失败了？</p><p>答案是 ptrace(2):</p><blockquote><p>C library&#x2F;kernel differences: At the system call level, the PTRACE_PEEKTEXT, PTRACE_PEEKDATA, and PTRACE_PEEKUSER operations have a different API: they store the result at the address specified by the <u>data</u> parameter, and the return value is the error flag. The glibc wrapper function provides the API given in DESCRIPTION above, with the result being returned via the function return value.</p></blockquote><p>其实我觉得这样 wrap 一下真的很干。平白无故给我的理解上了一点强度。譬如在 strace 中</p><p><img src="image-20241116132923596.png" alt=""></p><p>我分明就是用内联汇编调用的。然后你告诉我这里无中生有返回了一个 -1。我觉得不行。</p><img src="image-20241116133145608.png" alt="image-20241116133145608" style="zoom:50%;"><p>对于我来说，我就想看到最 raw 的系统调用结果。</p><p>不过对于我们的 tracer 而言，这些都是小问题。现在我们知道如何设置 errno 了：因为 ptrace 获得的永远都是 raw 的 rval，所以只要改 rval(%rax) 就行了。</p><hr><p>关于线程退出状态的问题，可以看一看这个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">foo</span><span class="params">(<span class="type">void</span> *_)</span> &#123;</span><br><span class="line">  <span class="comment">/* syscall(SYS_exit, EXIT_FAILURE); */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pthread_t</span> thrd;</span><br><span class="line">  pthread_create(&amp;thrd, <span class="literal">NULL</span>, foo, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">void</span> *exited;</span><br><span class="line">  pthread_join(thrd, &amp;exited);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;foo exited with %ld\n&quot;</span>, (<span class="type">long</span>)exited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接 exit，则会打印 foo exited with 0。但用 return 的就能打出 1 了。说明 pthread 在 foo return 之后果然是使用了一些同步的操作把返回值写进。如果没有这个操作，返回值就彻底丢掉了。</p><p>为什么是 0，其实是 join 的时候 pthread 干的。</p><img src="image-20241116135339801.png" alt="image-20241116135339801" style="zoom:50%;"><hr><p>对于 thread 的认知可能需要更新一下。</p><p>首先一个进程默认会有一个初始线程。进程是一个资源单位，而线程是一个调度单位。一个进程可以有很多个线程，包括初始的线程。这些线程之间都是平等的，在操作系统视角来说，没有高低，主次之分。任何线程都可以悄悄地似掉，如果没有其他的同步机制的话，那就真的死掉了。</p><p>新创建的线程，只是和创建它的进程同属一个线程组，可以说它是这个进程的子线程，而不能说是之前的线程的子线程。子线程创建新线程，它们依然是平级的。</p><img src="image-20241116141014668.png" alt="image-20241116141014668" style="zoom:50%;"><p>实验的结果</p><hr><p>想要恢复线程，也就是在dump的时候，先研究一下线程之间的关系。然后把cpu上下文装到线程里就行了。</p><p>while clone() 是会返回一些 tid 的。理想状况下，应该控制 tid 和之前一样，但是我该怎么做（？）</p><hr><p>明日任务：rewrite socket syscall</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;先来看一段代码。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>工作随记</title>
    <link href="https://tilnel.github.io/20241113-working/"/>
    <id>https://tilnel.github.io/20241113-working/</id>
    <published>2024-11-13T06:37:30.000Z</published>
    <updated>2024-11-13T06:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>先来做一个数独吧。然后就做了一小时。</p><hr><p>主要就来写一些关于 ptrace 的发现吧。从这样一个小程序说起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    raise(SIGSTOP);</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// tracer</span></span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ptrace(PTRACE_SEIZE, pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACESYSGOOD); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%*c&quot;</span>);</span><br><span class="line">      ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">ptrace_syscall_info</span> <span class="title">info</span>;</span></span><br><span class="line">      <span class="type">int</span> result = ptrace(PTRACE_GET_SYSCALL_INFO, pid, <span class="keyword">sizeof</span>(info), &amp;info);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptrace error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (info.op) &#123;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_ENTRY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;syscall entry: ID = %lld\n&quot;</span>, info.entry.nr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_EXIT:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;syscall exit : ID = %lld\n&quot;</span>, info.entry.nr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_NONE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;None\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_SECCOMP:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Seccomp\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unknown\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 line 11 的注释。在注释掉这一行前，syscall_info 是可以获得相关信息的。但是注释之后，每次都只能获得到 NONE。Man ptrace(2) 理由是，”In case of system call entry or exit stop…limited to type ..NONE unless ..TRACESYSGOOD option is set”。</p><p>我们现在来控制它走几步。</p><img src="image-20241113174529054.png" alt="image-20241113174529054" style="zoom:50%;"><p>依此就是 execve()， NONE， 还有 brk()。</p><p>根据 strace，&#x2F;bin&#x2F;ls 的第一个调用就是 brk()，挺合理的。</p><p><img src="image-20241113174636851.png" alt="image-20241113174636851"></p><p>这里甚至看到 execve() 有返回值（？？）</p><p>那么，其实想要揪出这个 NONE 到底是什么。</p><img src="image-20241113181716326.png" alt="image-20241113181716326" style="zoom:50%;"><p>根本不懂。</p><hr><p>我是呆逼。</p><img src="image-20241113181807456.png" alt="image-20241113181807456" style="zoom:50%;"><p>意思是 <code>SIGTRAP|0x80</code> 是一般的正常的系统调用 invoke&#x2F;return 产生的。而那个 5 应该是有问题的。</p><hr><p>逆天。</p><img src="image-20241113184302150.png" alt="image-20241113184302150" style="zoom: 67%;"><p>这个特性挺能藏。</p><hr><p>接下来，我们将会来观察，在 clone 发生的时候，ptrace 要怎么跟踪</p><hr><p>首先随便讲一下线程这个东西。</p><p>作为 clone() 创建的 linux 原生线程呢，刚创建完后被控制的第一下，就是执行线程入口函数的第一个系统调用。这为我们简化了很多。但是在函数执行完之后，线程就会悄悄地死掉，然后什么也不告诉主线程。</p><p>事实上，thread 自行退出是通过 SYS_exit 系统调用（60号）。它做的仅仅是终结这个执行流；那么就少了一个可以调度到 CPU 上被执行的东西。不太明白这个系统调用对于资源的释放有没有，似乎没有，毕竟 clone() 之前就要准备好线程要使用的资源了，应该是调用者释放。</p><p>在任意一个线程，甚至是主线程，调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall(SYS_exit, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>都可以使当前执行流停止，并且其他的线程继续运行，整个进程基本上没啥大问题。资源应该都是进程层级的东西。</p><p>如果子线程退出，你会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-process</span><br></pre></td></tr></table></figure><p>如果主线程退出，会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-process-&#123;process&#125;</span><br></pre></td></tr></table></figure><p>是的，主线程死了，但是主进程还活着。</p><img src="image-20241113202635648.png" alt="image-20241113202635648" style="zoom:50%;"><p>当然其实 <code>ps -aux</code> 还是可以看到它的状态的。非常地合理。</p><hr><p>作为 tracer，在看到线程 syscall(60) 的时候，只要在 entry 处 detach 一下就好了。当然如果要砍掉一个线程，那只要罚它做一个 SYS_exit 然后 detach。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;先来做一个数独吧。然后就做了一小时。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主要就来写一些关于 ptrace 的发现吧。从这样一个小程序说起&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>新功能：显示我是否在工位干活</title>
    <link href="https://tilnel.github.io/20241112-activity/"/>
    <id>https://tilnel.github.io/20241112-activity/</id>
    <published>2024-11-12T07:49:37.000Z</published>
    <updated>2024-11-12T07:49:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>已实装在 <a href="https://tilnel.github.io/about">about | Tilnel’s Blog</a></p><p>给静态页面加这种东西，疑似有点闲。</p><p>实现分为三步：</p><p>1、判断我是否在工位 - 采取的标准是检测右手边主机是否锁屏</p><p>2、动态更新</p><p>3、将其显示在静态页面上。毕竟 github.io 仓库太慢了</p><h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p>修改 Windows 组策略使得锁定(4800)解锁(4801)事件被记录。写一个cpp获取最后一个事件，挂在后台。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLockUnlockEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hEventLog = <span class="built_in">OpenEventLog</span>(<span class="literal">NULL</span>, <span class="string">&quot;Security&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hEventLog == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open event log.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD bytesRead = <span class="number">0</span>, minBytesNeeded = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="function">std::vector&lt;BYTE&gt; <span class="title">buffer</span><span class="params">(bufferSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadEventLog</span>(hEventLog, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,</span><br><span class="line">                      <span class="number">0</span>, buffer.<span class="built_in">data</span>(), bufferSize, &amp;bytesRead, &amp;minBytesNeeded)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to read event log.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">CloseEventLog</span>(hEventLog);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* pRecord = <span class="built_in">reinterpret_cast</span>&lt;EVENTLOGRECORD*&gt;(buffer.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((BYTE*)pRecord &lt; buffer.<span class="built_in">data</span>() + bytesRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRecord-&gt;EventID == EVENT_LOCK || pRecord-&gt;EventID == EVENT_UNLOCK) &#123;</span><br><span class="line">            std::string eventType = (pRecord-&gt;EventID == EVENT_LOCK) ? <span class="string">&quot;Lock&quot;</span> : <span class="string">&quot;Unlock&quot;</span>;</span><br><span class="line">            std::string message = <span class="string">&quot;Event: &quot;</span> + eventType + <span class="string">&quot;, Time: &quot;</span> + std::<span class="built_in">to_string</span>(pRecord-&gt;TimeGenerated);</span><br><span class="line">            std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">SendUDPMessage</span>(message);  <span class="comment">// 发送事件到目标主机</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 每次检测只发送最新的一个事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        pRecord = (EVENTLOGRECORD*)((BYTE*)pRecord + pRecord-&gt;Length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseEventLog</span>(hEventLog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>把事件信息发到 Linux 主机上。启动一个守护进程，监听消息并生成一个 &#x2F;tmp&#x2F;activity 文件，内容为需要在网站上显示的 html 标签。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#ff0000&#x27;</span> <span class="attr">已经离开了</span>&lt;/<span class="attr">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 nginx</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /activity &#123;</span><br><span class="line">  <span class="attribute">default_type</span> text/html;</span><br><span class="line">  <span class="attribute">alias</span> /tmp/activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h1><p>塞一个 JavaScript 到主题的 js 文件夹里，fetch 这个 html 标签并塞到另一个 html 标签里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123; <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span> &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! Status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;html-container&#x27;</span>).<span class="property">innerHTML</span> =</span><br><span class="line">          html;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to fetch HTML:&#x27;</span>, error);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;html-container&#x27;</span>).<span class="property">innerText</span> =</span><br><span class="line">          <span class="string">&#x27;Failed to load content.&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，为了从 github.io 上跨域访问，需要设置 nginx 的 Head</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /activity &#123;</span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;Content-Type, Authorization&#x27;</span>;</span><br><span class="line">  <span class="attribute">default_type</span> text/html;</span><br><span class="line">  <span class="attribute">alias</span> /tmp/activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把需要的元素装在 About 的 markdown 里面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;html-container&quot;</span>&gt;</span>校园网访问可加载当前状态<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/active.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><div id="html-container">校园网访问可加载当前状态</div><script type="text/javascript" src="/js/active.js"></script>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;已实装在 &lt;a href=&quot;https://tilnel.github.io/about&quot;&gt;about | Tilnel’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给静态页面加这种东西，疑似有点闲。&lt;/p&gt;
&lt;p&gt;实现分为三步：&lt;/p&gt;
&lt;p&gt;1、判断我是否在工位 -</summary>
        
      
    
    
    
    <category term="摸鱼" scheme="https://tilnel.github.io/categories/%E6%91%B8%E9%B1%BC/"/>
    
    
  </entry>
  
  <entry>
    <title>工作随记</title>
    <link href="https://tilnel.github.io/20241112-working/"/>
    <id>https://tilnel.github.io/20241112-working/</id>
    <published>2024-11-12T01:30:58.000Z</published>
    <updated>2024-11-12T01:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>今日目标是把之前的代码改完，并且至少支持 C&#x2F;S 类型的程序。</p><p> 第一步是重新梳理一下，auto 模式和 manual 模式分别到底发生了什么，进而能够在代码中对两种写法进行分开&#x2F;耦合。</p><p>事实上，auto 模式可以视为一种机器提供操作的 manual 模式。因而可以优先分析 Manual。</p><p>手动模式下，大致是这样的流程：</p><ul><li>启动 tracee，推进到初始状态后停下</li><li>等待用户输入，首先是切换“焦点”。进而是“执行一步”。</li></ul><p>此时，running 为全局第一个 state。</p><p>“执行一步”都做了什么？</p><ul><li>首先，作为手动模式，一般来说是顺着往下走，一般来说无须进行自动的状态恢复。</li><li>在某一位置触发了 Choose。此种情况并不需要进行 ckpt，因而只需要停下来，并询问 Choose 应当产生的结果。</li><li>一步执行结束。需要进行 ckpt。如果用户并未指定切换焦点，则下一步仍然在当前的焦点上进行。</li><li>当然，delete last_running; last_running &#x3D; running;</li></ul><p>ckpt 到底做了什么？</p><ul><li>将当前的状态放到 running 中。并且序列化然后写盘</li><li>也许写盘的操作可以在内存压力不大的情况下省去。用正经一点的话来说，就是“改变存储引擎为磁盘&#x2F;内存”<ul><li>但是这个好像并不是瓶颈，不首先考虑。</li></ul></li></ul><p>一个小问题。</p><p>在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="built_in">dwarf_init</span>();</span><br></pre></td></tr></table></figure><p>中，写 <code>std::unordered_map::operator[]</code> 会产生一个 floating point exception。推测 .init 早于了 STL 的实例化。</p><p>一天结束了。记一下我做到哪里了。</p><p>首先我在 Monitor 模块。其次我正在写 configure 的读取。接下来我要改写初始化状态的部分。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;今日目标是把之前的代码改完，并且至少支持 C&amp;#x2F;S 类型的程序。&lt;/p&gt;
&lt;p&gt; 第一步是重新梳理一下，auto 模式和 manual 模式分别到底发生了什么，进而能够在代码中对两种写法进行分开&amp;#x2F;耦合。&lt;/p&gt;
&lt;p&gt;事实上，auto</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>重读 eXplode 知道的事情</title>
    <link href="https://tilnel.github.io/20241111-eXplode/"/>
    <id>https://tilnel.github.io/20241111-eXplode/</id>
    <published>2024-11-11T09:30:39.000Z</published>
    <updated>2024-11-11T09:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The reader should keep in mind that conceptually what EXPLODE does is very simple. If we assume infinite resources and ignore some details, the following would approximate its implementation: 1. Create a clean initial state (§3.3) and invoke the client’s mutate on it. 2. At every choose(N) call, fork N children. 3. Onclient request, generate all crash disks and run the client check method on them. 4. When mutate returns, re-invoke it</p></blockquote><p>这个简化是非常不讲道理的。作为不需要复现这种技术的人来说，当然可以假设你在每一个分支的地方都去作 Fork，但是。。。这始终不是很对。</p><p>对于想要模仿这种做法的人来说，完全找不到任何方法可以忽略过度使用 fork() 带来的进程数量爆炸。问题不光处在系统性能资源上。甚至可以说，连进程数量上限都能摸到</p><p>当然作者的说法是很狡猾的，“你们大可以把这件事情看成是这样”。这句话隐含的意思就是实际情况和他所说的相去甚远。</p><p>当然，作者还是有所补充的：</p><blockquote><p>As a result, EX PLODE unsurprisingly looks like a primitive operating system: it has a queue of saved processes, a scheduler that picks which of these jobs to run, and time slices</p></blockquote><p>所以总的来说，做法还是状态存取和调度器。</p><img src="image-20241111174219924.png" alt="image-20241111174219924" style="zoom:50%;"><p>接下来有点费解。</p><blockquote><p>exhaust all possible combinations of choices within a single mutate call before doing another.</p></blockquote><p>也就是原地把所有的可能性都走一步，再往下走。有一种广搜的感觉，而不是：我尝试这个分支，然后从这里继续往后探索。</p><p>eXplode 的 ckpt 方法是确定性回放。也就是 stateless。</p><blockquote><p>EXPLODE uses computation rather than copying to recreate states.</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The reader should keep in mind that conceptually what EXPLODE does is very simple. If we assume infinite resources and</summary>
        
      
    
    
    
    <category term="Distributed Systems" scheme="https://tilnel.github.io/categories/Distributed-Systems/"/>
    
    
  </entry>
  
  <entry>
    <title>重力</title>
    <link href="https://tilnel.github.io/20241110-gravity/"/>
    <id>https://tilnel.github.io/20241110-gravity/</id>
    <published>2024-11-10T10:13:45.000Z</published>
    <updated>2024-11-10T10:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>桌游组的重力系数也许太高了。可怕。是不是大家身上的负担都太重了？</p><p>虽然这个群可能本身就是这样，群友进来说两句抑郁的话，然后消失，然后过一阵子再来抑郁一下。这些抑郁却又说不出个实在的理由。每种情绪一定有引起它的原因，但是有人似乎是不愿意将这种原因附着于某种俗物，以便为它起一个浮华亮丽的名字。这样还可以敝帚自珍一下。</p><p>也许人都是有远多于自己想象的自尊的。譬如不愿意接受竟然是这么俗套、这么没意思的理由造成了自己的抑郁。于是就需要给原初的创伤套皮，如同河蚌分泌出物质来包裹沙石形成珍珠一样。于是伤口首先变得漂亮；其次变得看起来没有什么破坏力。分析卡在这一层也就没有什么实际的效用了。 </p><p>大概现在还是需要努力有意识地在聊天的时候断断句。但是文字形式的断句效果是很差的，因为文字经过自己的反思的概率是更高的，不一定能够逮到无意识的尾巴。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;桌游组的重力系数也许太高了。可怕。是不是大家身上的负担都太重了？&lt;/p&gt;
&lt;p&gt;虽然这个群可能本身就是这样，群友进来说两句抑郁的话，然后消失，然后过一阵子再来抑郁一下。这些抑郁却又说不出个实在的理由。每种情绪一定有引起它的原因，但是有人似乎是不愿意将这种原因附着于某种俗物，</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
