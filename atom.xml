<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tilnel&#39;s Blog</title>
  <icon>https://tilnel.github.io/icon.png</icon>
  <subtitle>我需要先行到光年以外，为列星指明公转的轨道，否则你便看不到下一夜的闪烁与纷纭。</subtitle>
  <link href="https://tilnel.github.io/atom.xml" rel="self"/>
  
  <link href="https://tilnel.github.io/"/>
  <updated>2099-12-31T15:59:59.000Z</updated>
  <id>https://tilnel.github.io/</id>
  
  <author>
    <name>Tilnel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Preface-三月十日</title>
    <link href="https://tilnel.github.io/20991231-top/"/>
    <id>https://tilnel.github.io/20991231-top/</id>
    <published>2099-12-31T15:59:59.000Z</published>
    <updated>2099-12-31T15:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>人是在变化的，写出来的东西是死的，以至于会很快地反对几天前自己写过的东西，这也是难免的。不过作为一种记录，就不删除了，而是对有问题的内容进行标注。</p><p>Tilnel 2025-03-10 10:10:39</p><p><a href="/20241023-top/">第二版置顶</a></p><p><a href="/20231017-top/">第一版置顶</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;人是在变化的，写出来的东西是死的，以至于会很快地反对几天前自己写过的东西，这也是难免的。不过作为一种记录，就不删除了，而是对有问题的内容进行标注。&lt;/p&gt;
&lt;p&gt;Tilnel 2025-03-10 10:10:39&lt;/p&gt;
&lt;p&gt;&lt;a</summary>
        
      
    
    
    
    <category term="日常" scheme="https://tilnel.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>优化 coding 基础设施</title>
    <link href="https://tilnel.github.io/20250816-ccls/"/>
    <id>https://tilnel.github.io/20250816-ccls/</id>
    <published>2025-08-15T16:00:00.000Z</published>
    <updated>2025-08-15T16:00:00.000Z</updated>
    
    
    
    
    <category term="Linux" scheme="https://tilnel.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>镇江·Bangdream Only</title>
    <link href="https://tilnel.github.io/20250605-zhenjiang-bangdream-only/"/>
    <id>https://tilnel.github.io/20250605-zhenjiang-bangdream-only/</id>
    <published>2025-06-05T06:34:29.667Z</published>
    <updated>2025-06-05T06:34:29.667Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux ext4 文件系统的最简完整教学（译）</title>
    <link href="https://tilnel.github.io/20250605-ext4/"/>
    <id>https://tilnel.github.io/20250605-ext4/</id>
    <published>2025-06-04T16:00:00.000Z</published>
    <updated>2025-06-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据原站要求，本文以 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a> 进行许可。</p><p>原文作者：<a href="https://metebalci.com/">Mete Balci</a></p><p>原文：<a href="https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/">A Minimum Complete Tutorial of Linux ext4 File System</a></p><blockquote><p>挖坑。6 月填</p></blockquote>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;根据原站要求，本文以 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;Creative Commons Attribution-NonCommercial-ShareAlike 4.0</summary>
        
      
    
    
    
    <category term="翻译" scheme="https://tilnel.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>天天</title>
    <link href="https://tilnel.github.io/20250605-day-by-day/"/>
    <id>https://tilnel.github.io/20250605-day-by-day/</id>
    <published>2025-06-04T16:00:00.000Z</published>
    <updated>2025-06-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然没有去很远的地方，但是本学期是往外跑得最多的一学期。原本要么应该静养，要么应该忙点实习相关的事情，然而目前已经全无心思。此时再一味地说自己对学科及业界都并没有那么感兴趣或许为时已晚，也没什么必要。</p><p>如果有可能的话，我非常乐意做一些不需要动脑子的工作。从我到各种地方打杂的经验来看，对脑力要求不高的岗位占了绝大多数。如果我在工作上花了太多的脑力，生活就会变得一团糟，一根筋直接两头堵。我也不知道怎么调整到正常的状态。5 月份的上半月拉了一波工作强度，这时我发现我没有办法把工作和生活平衡好。很多时候晚上 11 点回了宿舍之后打算睡一觉第二天再战，但是突然想到一个什么问题就打开电脑，花上三四个小时做一些小 test，第二天就只能睡到 12 点甚至之后。</p><p>经过一段时间的紧绷之后，只要稍有松懈，又很难再拉紧了。从 17 日开始，我实际上就没做什么工作了。刚巧这段时间活动比较集中，去上海、排乐队、排合唱、去镇江。中间零星的时间实际上也很久，不过一分钟的正经活都没做（</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;虽然没有去很远的地方，但是本学期是往外跑得最多的一学期。原本要么应该静养，要么应该忙点实习相关的事情，然而目前已经全无心思。此时再一味地说自己对学科及业界都并没有那么感兴趣或许为时已晚，也没什么必要。&lt;/p&gt;
&lt;p&gt;如果有可能的话，我非常乐意做一些不需要动脑子的工作。从我到</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Ave Muji咖</title>
    <link href="https://tilnel.github.io/20250605-avemujicafe/"/>
    <id>https://tilnel.github.io/20250605-avemujicafe/</id>
    <published>2025-06-04T16:00:00.000Z</published>
    <updated>2025-06-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>22 日和牢肥去了上海 Animate Cafe 的 Ave Mujica 场。作为喵妈虽然没有人给我塞麦麦的杯垫，但是可以用一个初华的吧唧换 4 个喵梦谷，没想到去之前的预言居然成真了。</p><p>也许是坐在大祥桌布上的缘故，抽奖的时候抽了很多 saki，纯大烫门；并且因此引来了初华。但是这些全都被我熔成大喵了。</p><p>结束 A 咖之后转战百联ZX，几乎把目之所及的麦麦立牌买全了。</p><p><img src="IMG_20250523_003951.jpg" alt="一天的战利品"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;22 日和牢肥去了上海 Animate Cafe 的 Ave Mujica 场。作为喵妈虽然没有人给我塞麦麦的杯垫，但是可以用一个初华的吧唧换 4 个喵梦谷，没想到去之前的预言居然成真了。&lt;/p&gt;
&lt;p&gt;也许是坐在大祥桌布上的缘故，抽奖的时候抽了很多</summary>
        
      
    
    
    
    <category term="日常" scheme="https://tilnel.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>工作随记</title>
    <link href="https://tilnel.github.io/20250514-working/"/>
    <id>https://tilnel.github.io/20250514-working/</id>
    <published>2025-05-13T16:00:00.000Z</published>
    <updated>2025-05-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录了一些拍脑袋的想法。</p><p>1、stateful &#x2F; stateless。</p><p>现在看来，就算 stateful 也不能搞这么重的 state。有点太多余了。</p><p>想到一个事实上的等价性标准，那就是，如果在同一 interleaving 下两个 localstate 对 sharedstate 会产生相同的影响，那么称状态等价。</p><p>这意味着，只需要：</p><ul><li><p>rip &#x3D; rip</p></li><li><p>抽象状态相等</p></li><li><p>inbuffer 相等</p></li></ul><p>2、正确性</p><p>对于 raft 而言，也许只需要证明其在有限几个任期内的正确性，就足以说明问题。</p><p>3、解开 guest.h。单文件其实包含了三个方面的内容：elf，thread(process)，snapshot。但是，目前全都混在一起写了。</p><p>4、用户的 choose 有没有更加简洁的表示方式？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;记录了一些拍脑袋的想法。&lt;/p&gt;
&lt;p&gt;1、stateful &amp;#x2F; stateless。&lt;/p&gt;
&lt;p&gt;现在看来，就算 stateful 也不能搞这么重的 state。有点太多余了。&lt;/p&gt;
&lt;p&gt;想到一个事实上的等价性标准，那就是，如果在同一</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>调试器中的 backtrace：libunwind 的局限与成因，并与 GDB 对比</title>
    <link href="https://tilnel.github.io/20250512-gdb-bt/"/>
    <id>https://tilnel.github.io/20250512-gdb-bt/</id>
    <published>2025-05-11T16:00:00.000Z</published>
    <updated>2025-05-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文章包含 AI 创作，请仔细甄别。</p></blockquote><h2><a href="#mu-lu" class="header-anchor">#</a><span id="mu-lu">目录</span></h2><ol><li>问题现象</li><li>远程 unwinding 的信息来源差异</li><li><code>libunwind</code> 的查表逻辑与 <strong>两级 fallback</strong></li><li>为什么缺少 <code>PT_GNU_EH_FRAME</code> 会导致“丢帧”</li><li>加上 <code>--eh-frame-hdr</code> 后为何立即恢复</li><li>GDB 的多层策略如何弥补缺口</li><li><strong>澄清</strong>：<code>unw_step()</code> 在找不到 FDE 时并非总返回 0</li><li>测试用最小示例代码</li><li>快速检查二进制调试信息的命令</li><li>附录：关键源代码片段（GDB &amp; libunwind）</li></ol><h3><a href="#1-wen-ti-xian-xiang" class="header-anchor">#</a><span id="1-wen-ti-xian-xiang">1. 问题现象</span></h3><p>在完全静态链接的可执行文件上，使用 <code>libunwind‑ptrace</code> 做远程栈回溯，得到的结果常见类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#0 __libc_recvfrom</span><br><span class="line">#1 main</span><br></pre></td></tr></table></figure><p>而实际逻辑调用序列应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main → poll_msg → recvfrom</span><br></pre></td></tr></table></figure><p>同一进程在 GDB 中执行 <code>bt</code> 却能看到完整链。</p><h3><a href="#2-yuan-cheng-unwinding-de-xin-xi-lai-yuan-chai-yi" class="header-anchor">#</a><span id="2-yuan-cheng-unwinding-de-xin-xi-lai-yuan-chai-yi">2. 远程 unwinding 的信息来源差异</span></h3><table><thead><tr><th></th><th><strong>GDB</strong></th><th><strong>libunwind‑ptrace</strong></th></tr></thead><tbody><tr><td>可用 ELF 信息</td><td>在磁盘上打开目标 ELF 与 split‑debug，解析 <code>.debug_*</code>, <code>.eh_frame</code> <strong>全部 section</strong></td><td><strong>仅</strong> 读取进程的 Program Header（segment）映射</td></tr><tr><td>CFI 首选</td><td><code>.debug_frame</code> → <code>.eh_frame</code></td><td><code>.eh_frame</code>（必须先通过 <code>PT_GNU_EH_FRAME</code> 找到）</td></tr><tr><td>备用策略</td><td>prologue sniffer → rbp‑链 → heuristic</td><td>rbp‑链（简化版）</td></tr></tbody></table><h3><a href="#3-libunwind-de-cha-biao-luo-ji-yu-liang-ji-fallback" class="header-anchor">#</a><span id="3-libunwind-de-cha-biao-luo-ji-yu-liang-ji-fallback">3. <code>libunwind</code> 的查表逻辑与 <strong>两级 fallback</strong></span></h3><p><code>unw_step()</code> 内部主要调用 <code>_Ux86_64_step()</code>，流程如下（伪代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ① 是否有缓存的 proc_info？若无：</span><br><span class="line">find_proc_info(ip, &amp;pi) →</span><br><span class="line">    dwarf_find_unwind_table(pid, ip)  // 首选 .eh_frame_hdr 查表</span><br><span class="line">    if (!table)                       // (A) 找不到 FDE</span><br><span class="line">        try_framechain();             // (B) 用 rbp 链 fallback</span><br></pre></td></tr></table></figure><h4><a href="#a-mei-you-fde-fan-hui-unw-enoinfo" class="header-anchor">#</a><span id="a-mei-you-fde-fan-hui-unw-enoinfo">(A) 没有 FDE 返回 <code>‑UNW_ENOINFO</code></span></h4><ul><li>对 <strong>本地 unwinder</strong> <code>unw_step()</code> 会直接返回 0。</li><li>对 <strong>remote‑ptrace</strong> 实现，函数继续尝试 *(B)*：</li></ul><h4><a href="#b-try-framechain" class="header-anchor">#</a><span id="b-try-framechain">(B) <code>try_framechain()</code></span></h4><ul><li>若当前帧保存了 <code>%rbp</code> 且 <code>%rbp</code> 指向合法栈区， 则认为 <code>[rbp]</code> 存 caller 的 <code>%rbp</code>, <code>[rbp+8]</code> 存 caller 的 <code>%rip</code>；</li><li>组装一个“人工”上一帧 → <code>unw_step()</code> 返回 &gt; 0。</li></ul><blockquote><p><strong>因此</strong>：在缺少 FDE 又恰好保留帧指针时，可以继续退到 <code>main()</code>，但 <strong>会跳过所有 frameless 函数</strong>（如 <code>poll_msg</code>）。</p></blockquote><h3><a href="#4-wei-shi-me-que-shao-pt-gnu-eh-frame-hui-dao-zhi-diu-zheng" class="header-anchor">#</a><span id="4-wei-shi-me-que-shao-pt-gnu-eh-frame-hui-dao-zhi-diu-zheng">4. 为什么缺少 <code>PT_GNU_EH_FRAME</code> 会导致“丢帧”</span></h3><ul><li><code>.eh_frame</code> 在静态程序里默认是 <strong>SHT_PROGBITS</strong>，不在任何 <code>PT_LOAD</code> segment；</li><li>远程 unwinder 通过读取 <code>/proc/PID/maps</code> 里的 segment 首地址 + program‑header，<strong>只能</strong>看到 <code>PT_*</code> 指定的段；</li><li>缺少 <code>PT_GNU_EH_FRAME</code> ⇒ 找不到 <code>.eh_frame_hdr</code> ⇒ <code>find_proc_info()</code> 失败 ⇒ 触发 (B) fallback，仅凭 <code>%rbp</code> 链。</li><li><code>poll_msg</code> 恰好省掉帧指针，于是被跳过。</li></ul><h3><a href="#5-jia-shang-eh-frame-hdr-hou-wei-he-li-ji-hui-fu" class="header-anchor">#</a><span id="5-jia-shang-eh-frame-hdr-hou-wei-he-li-ji-hui-fu">5. 加上 <code>--eh-frame-hdr</code> 后为何立即恢复</span></h3><p><code>--eh-frame-hdr</code> 命令让链接器：</p><ol><li>复制 <code>.eh_frame</code> 并生成一个紧凑索引 <code>.eh_frame_hdr</code>；</li><li>插入 <code>**PT_GNU_EH_FRAME**</code> program‑header 指向该索引；</li><li>由于 <code>.eh_frame_hdr</code> 属于可加载 segment，远程进程映射可见；</li></ol><p>于是 <code>_Ux86_64_dwarf_find_unwind_table()</code> 能定位 FDE → <code>poll_msg</code> 拥有 CFI → 回溯链完整。</p><h3><a href="#6-gdb-de-duo-ceng-ce-lue-ru-he-mi-bu-que-kou" class="header-anchor">#</a><span id="6-gdb-de-duo-ceng-ce-lue-ru-he-mi-bu-que-kou">6. GDB 的多层策略如何弥补缺口</span></h3><p>GDB 全流程简略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DWARF‑CFI   (文件级)  → 成功 → 返回</span><br><span class="line">  │</span><br><span class="line">  ├─ 失败</span><br><span class="line">  ▼</span><br><span class="line">prologue‑sniffer (反汇编) → 若发现 push %rbp/mov %rsp,%rbp → 手算上一帧</span><br><span class="line">  │</span><br><span class="line">  ├─ 失败</span><br><span class="line">  ▼</span><br><span class="line">trad‑rbp‑chain (纯链)</span><br></pre></td></tr></table></figure><p>因其拥有磁盘 ELF 信息，不依赖 <code>PT_GNU_EH_FRAME</code>；即便 CFI 缺失，也可借助 sniffer 过 frameless 函数。</p><h3><a href="#7-cheng-qing-unw-step-zai-que-shao-fde-shi-bing-fei-zong-fan-hui-0" class="header-anchor">#</a><span id="7-cheng-qing-unw-step-zai-que-shao-fde-shi-bing-fei-zong-fan-hui-0">7. <strong>澄清</strong>：<code>unw_step()</code> 在缺少 FDE 时并非总返回 0</span></h3><ul><li><strong>若当前函数缺 CFI</strong> <em>且</em> <strong>保留</strong> <code>**%rbp**</code>：会走 (B) 策略，返回 1，继续到 caller；因此最终仍能走到 <code>main()</code>。</li><li><strong>丢帧的根因</strong> 是 frameless 函数（无 <code>%rbp</code>）缺 CFI → 在 fallback 中被“跳过”。</li></ul><h3><a href="#8-ce-shi-yong-zui-xiao-shi-li" class="header-anchor">#</a><span id="8-ce-shi-yong-zui-xiao-shi-li">8. 测试用最小示例</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// demo.c ─── gcc demo.c -static -g -fno-omit-frame-pointer \</span><br><span class="line">//                      -fasynchronous-unwind-tables -o demo </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline,optimize(&quot;no-optimize-sibling-calls&quot;)))</span><br><span class="line">ssize_t poll_msg(int fd, void *buf, size_t len) &#123;</span><br><span class="line">    return recvfrom(fd, buf, len, 0, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char b[1];</span><br><span class="line">    poll_msg(0, b, 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a href="#bian-yi-dui-bi" class="header-anchor">#</a><span id="bian-yi-dui-bi">编译对比</span></h4><table><thead><tr><th>链接选项</th><th><code>libunwind</code> 结果</th><th>GDB 结果</th></tr></thead><tbody><tr><td><strong>无</strong> <code>--eh-frame-hdr</code></td><td><code>__libc_recvfrom → main</code></td><td><code>__libc_recvfrom → poll_msg → main</code></td></tr><tr><td><strong>加</strong> <code>-Wl,--eh-frame-hdr</code></td><td>与 GDB 相同</td><td>相同</td></tr></tbody></table><h3><a href="#9-kuai-su-jian-cha-diao-shi-xin-xi-de-ming-ling" class="header-anchor">#</a><span id="9-kuai-su-jian-cha-diao-shi-xin-xi-de-ming-ling">9. 快速检查调试信息的命令</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 是否包含 PT_GNU_EH_FRAME</span><br><span class="line">readelf -l  a.out | grep EH_FRAME</span><br><span class="line"></span><br><span class="line"># 列出 FDE 覆盖 range，不依赖符号</span><br><span class="line">readelf -wf a.out | head</span><br><span class="line"></span><br><span class="line"># 检验函数是否有帧指针</span><br><span class="line">objdump -dS a.out | less   # 查找 push %rbp / mov %rsp,%rbp</span><br><span class="line"></span><br><span class="line"># 查 libc.a 内部符号及 CFI</span><br><span class="line">ar x /usr/lib/x86_64-linux-gnu/libc.a recvfrom.o</span><br><span class="line">readelf -wf recvfrom.o | head</span><br></pre></td></tr></table></figure><h3><a href="#10-fu-lu-guan-jian-yuan-ma-pian-duan" class="header-anchor">#</a><span id="10-fu-lu-guan-jian-yuan-ma-pian-duan">10. 附录：关键源码片段</span></h3><h4><a href="#10-1-libunwind-src-x86-64-gfind-proc-info-c" class="header-anchor">#</a><span id="10-1-libunwind-src-x86-64-gfind-proc-info-c">10.1 libunwind (<code>src/x86_64/Gfind_proc_info.c</code>)</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (phdr-&gt;p_type == PT_GNU_EH_FRAME) &#123;</span><br><span class="line">    peh_hdr = phdr;</span><br><span class="line">    /* ...读取 hdr, 找到 .eh_frame */</span><br><span class="line">&#125;</span><br><span class="line">/* 如果 peh_hdr 为 NULL → 返回 -UNW_ENOINFO */</span><br></pre></td></tr></table></figure><h4><a href="#10-2-gdb-prologue-sniffer-jian-hua" class="header-anchor">#</a><span id="10-2-gdb-prologue-sniffer-jian-hua">10.2 GDB prologue sniffer (简化)</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct frame_id</span><br><span class="line">prologue_frame_this_id (frame_info *this_frame)</span><br><span class="line">&#123;</span><br><span class="line">    /* 反汇编起始几十字节，找 push %rbp 与 mov %rsp,%rbp */</span><br><span class="line">    if (found)</span><br><span class="line">        compute_previous_frame(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><a href="#jie-yu" class="header-anchor">#</a><span id="jie-yu">结语</span></h3><p><code>libunwind</code> 的“缺帧”症状来源于 <strong>运行时只能依赖</strong> <code>PT_GNU_EH_FRAME</code> <strong>的设计取舍</strong>；当 segment 信息不足或函数 frameless 且无 CFI 时，只能退回极简 <code>%rbp</code> 链，导致中间帧被跳过。GDB 由于离线 ELF + 多级策略，自然更完善。对开发者而言，<strong>在链接阶段加</strong> <code>--eh-frame-hdr</code>、保留 CFI 或帧指针，是让任何基于 <code>libunwind</code> 的调试&#x2F;分析工具完整回溯的关键。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文章包含 AI 创作，请仔细甄别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href=&quot;#mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;span</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB 的 p 命令实现原理简析 via STRACE</title>
    <link href="https://tilnel.github.io/20250510-gdb-p/"/>
    <id>https://tilnel.github.io/20250510-gdb-p/</id>
    <published>2025-05-09T16:00:00.000Z</published>
    <updated>2025-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用 ptrace 控制进程，想要实现类似 gdb 的表达式求值功能。一开始我沿用了以前写的一个简单的表达式求值功能，用来对各种整型表达式求值，并且为其添加了从字符串到地址的变量解析功能。只不过我写表达式解析这种事情不太在行，特别是表达式会带类型，没能实现结构体成员访问、指针成员访问这些功能。另外，gdb 的表达式求值还有一个很强的功能：解析函数符号并执行函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hahaha\n&quot;</span>);</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于这样的一段 C 程序，使用 <code>-g</code> 编译的话，用 gdb 调试将会产生如下的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">(gdb) p main</span><br><span class="line">$0 = &#123;int ()&#125; 0x4017f4 &lt;main&gt;</span><br><span class="line">(gdb) p main()</span><br><span class="line">$1 = 0</span><br><span class="line">(gdb) p foo()</span><br><span class="line">hahaha</span><br><span class="line">$2 = 0</span><br></pre></td></tr></table></figure><p>进一步地，如果程序是动态链接的话，还可以直接调用 printf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) printf(&quot;%x\n&quot;, 114514)</span><br><span class="line">1bf52</span><br><span class="line">$3 = 6</span><br></pre></td></tr></table></figure><p>注意：如果不输出换行的话，在控制台模式下输出有可能会被放在 <code>stdout</code> 的 buffer 中，从而一时看不到。</p><p>如果是静态链接的话，foo.c 就不会包含 <code>printf</code> 符号，从而导致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p printf(&quot;%x\n&quot;, 114514)</span><br><span class="line">No symbol &quot;printf&quot; in current context.</span><br></pre></td></tr></table></figure><p>因为调用的 <code>printf(&quot;hahaha\n&quot;)</code> 会被优化为 <code>puts(&quot;hahaha&quot;)</code>。关于这个优化，请参见 <a href="https://publicclu2.blogspot.com/2013/05/how-gcc-generates-optimized-code-for.html">clu2’s notes: How GCC generates optimized code for printf (and GCC built-in functions)</a></p><blockquote><p>使用 <code>-fno-builtin</code> 可以取消此类优化。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000401126 &lt;foo&gt;:</span><br><span class="line">  401126:       55                      push   %rbp</span><br><span class="line">  401127:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  40112a:       bf 04 20 40 00          mov    $0x402004,%edi</span><br><span class="line">  40112f:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401134:       e8 f7 fe ff ff          call   401030 &lt;printf@plt&gt;</span><br><span class="line">  401139:       c7 05 d9 2e 00 00 01    movl   $0x1,0x2ed9(%rip)        # 40401c &lt;a&gt;</span><br><span class="line">  401140:       00 00 00</span><br><span class="line">  401143:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401148:       5d                      pop    %rbp</span><br><span class="line">  401149:       c3                      ret</span><br></pre></td></tr></table></figure><p>still，这样的调用是可以设置断点的。只不过这样的话，求值会在断点处失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b write</span><br><span class="line">Breakpoint 3 at 0x4192d0</span><br><span class="line">(gdb) p foo()</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x00000000004192d0 in write ()</span><br><span class="line">The program being debugged stopped while in a function called from GDB.</span><br><span class="line">Evaluation of the expression containing the function</span><br><span class="line">(foo) will be abandoned.</span><br><span class="line">When the function is done executing, GDB will silently stop.</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00000000004192d0 in write ()</span><br><span class="line">#1  0x0000000000407205 in _IO_new_file_write ()</span><br><span class="line">#2  0x0000000000405491 in _IO_new_do_write ()</span><br><span class="line">#3  0x0000000000406783 in _IO_new_file_overflow ()</span><br><span class="line">#4  0x0000000000404e4a in puts ()</span><br><span class="line">#5  0x00000000004017e3 in foo () at foo.c:6</span><br><span class="line">#6  &lt;function called from gdb&gt;</span><br><span class="line">#7  main () at foo.c:12</span><br></pre></td></tr></table></figure><p><code>p</code> 还有一个重要的方面就是能够保留表达式计算产生的所有副作用。从上面 <code>printf</code> 将输出写入到 <code>stdout</code> 的 buffer 这点即可略窥一二。事实上，<code>p</code> 可以对所有的合法表达式进行求值，比如变量赋值表达式 <code>a = 1</code>。作为结果，会输出 1，并将这个值直接赋给进程中的那个变量。</p><p><strong>机制：猜测</strong></p><p>实现一般的表达式求值，总的来说可能有两类实现方式：</p><p>1、对于纯表达式的无函数调用求值，可以在 gdb 中解析表达式，做求值。通过解析二进制调试信息获得变量地址、字段偏移量、变量类型。通过 ptrace&#x2F;procfs 获取进程实时信息，读写内存&#x2F;寄存器实际值。</p><p>2、对于所有类型的表达式，都可以分析表达式类型，编译 wrapper 求值函数，注入到 tracee 中，并控制 tracee 执行注入代码求值。</p><p>当我觉得 2 似乎是更方便的（写起来一点也不比 1 方便）时候，我还是老老实实去尝试了解 gdb 的真实做法了。</p><p><strong>机制：分析</strong></p><p>此处我并不想分析 gdb 的源码，因为我读代码的能力一直都很差。因而，寄希望于让程序跑起来，并找机会观测其行为。所幸我们有 <code>strace</code> 这样成熟的工具。</p><p>首先运行 gdb .&#x2F;foo，start，然后输入好函数求值的命令 <code>p main()</code>。这样在输入回车之前，gdb 不会产生任何其他的系统调用而是卡在 read 上。</p><p>接着：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -p $(pidof gdb)</span><br></pre></td></tr></table></figure><p><code>sudo</code> 似乎是必要的。然后我们在 gdb 那里点回车。这让我们能够观察到 <code>gdb</code> 运行这一条命令的时候进行的全部系统调用，一共有 200+ 条。</p><p>当一个进程卡在 gdb 给的 TRAP 之后，如果想要对函数求值，那就只能通过执行 tracee 自身的那个函数了。因而 gdb 一定需要某种办法让进程恢复执行，那么最明显的就是 <code>ptrace(PTRACE_CONT)</code>。在输出的系统调用中，果不其然找到了它的影子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_CONT, 3926087, 0x1, 0)    = 0</span><br></pre></td></tr></table></figure><p>合理推测，它的前面一定是将 tracee 的状态设置到适合进行函数调用的状态的过程；而后面则是收集函数调用结果，以及将状态恢复到调用前的过程。由于它会保留调用所有的副作用，因而这个状态的恢复，仅仅是恢复寄存器上下文。</p><p>去除掉一些无关的调用之后，来看核心部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_GETSIGINFO, 3926087, NULL, &#123;si_signo=SIGTRAP, si_code=SI_KERNEL, si_addr=NULL&#125;) = 0</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br><span class="line">pwrite64(14, &quot;\17\345\377\377\377\177\0\0&quot;, 8, 140737488348408) = 8</span><br><span class="line">ptrace(PTRACE_GETREGS, 3926087, &#123;r15=0x1, r14=0x4a5f68, r13=0x7fffffffe6b8, r12=0x7fffffffe6a8, rbp=0x7fffffffe590,   rbx=0x1, r11=0, r10=0x1, r9=0x110, r8=0x4aa820, rax=0, rcx=0x4b37e0, rdx=0x7fffffffe6b8, rsi=0x7fffffffe6a8, rdi=0x1, orig_rax=0xffffffffffffffff, rip=0x4017fd, cs=0x33, eflags=0x246, rsp=0x7fffffffe590, ss=0x2b, fs_base=0x4b2380,      gs_base=0, ds=0, es=0, fs=0, gs=0&#125;) = 0</span><br><span class="line">...</span><br><span class="line">ptrace(PTRACE_SETREGS, 3926087, &#123;r15=0x1, r14=0x4a5f68, r13=0x7fffffffe6b8, r12=0x7fffffffe6a8, rbp=0x7fffffffe4f8,   rbx=0x1, r11=0, r10=0x1, r9=0x110, r8=0x4aa820, rax=0, rcx=0x4b37e0, rdx=0x7fffffffe6b8, rsi=0x7fffffffe6a8, rdi=0x1, orig_rax=0xffffffffffffffff, rip=0x4017f4, cs=0x33, eflags=0x246, rsp=0x7fffffffe4f8, ss=0x2b, fs_base=0x4b2380,      gs_base=0, ds=0, es=0, fs=0, gs=0&#125;) = 0</span><br><span class="line">pread64(14, &quot;\363&quot;, 1, 4302224)         = 1</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 4302224)        = 1</span><br><span class="line">pread64(14, &quot;\220&quot;, 1, 4594263)         = 1</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 4594263)        = 1</span><br><span class="line">pread64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br></pre></td></tr></table></figure><p>通过查看 <code>/proc/$(pidof gdb)/fd/14</code> 的符号链接，可以看到这个文件指向的是 <code>/proc/$(pidof foo)/task/$(tidof foo)/mem</code>。因而，<code>pwrite/pread</code> 就都是直接读写 tracee 的内存了。推测到，由于要恢复一部分状态，因而 <code>pread</code> 是对当前状态的保存，而 <code>pwrite</code> 是改写。未来在执行完成后，这些读取的状态一定还是会被写回的。</p><p>首先第一个 <code>ptrace</code> 就 get 到 tracee 进入了 SIGTRAP。在此基础上，进行了两个写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwrite64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br><span class="line">pwrite64(14, &quot;\17\345\377\377\377\177\0\0&quot;, 8, 140737488348408) = 8</span><br></pre></td></tr></table></figure><p><code>\314</code> 其实就是我们熟悉的 <code>int 0x3 (0xcc)</code>。<code>140737488348431 = 0x7fffffffe50f​</code>，可以看出这是写在了栈上。</p><p>第二个则是向 <code>0x7fffffffe4f8</code> ，也是栈上的位置写入了一个地址 <code>0x7fffffffe50f</code>。</p><p>接下来通过一系列的 <code>ptrace(PTRACE_GETREGS/PTRACE_SETREGS)</code>，可以看到最终的寄存器状态是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">rbp=0x7fffffffe4f8,   </span><br><span class="line">...</span><br><span class="line">rax=0, </span><br><span class="line">...</span><br><span class="line">rip=0x4017f4,</span><br><span class="line">...</span><br><span class="line">rsp=0x7fffffffe4f8,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，<code>RIP</code> 刚好落在 <code>main</code> 的入口，而 <code>RSP</code> 和 <code>RBP</code> 都落在了刚才写入地址的位置上。可以想见，如果接下来开始执行的话，等到函数退出时，<code>RAX</code> 将会代表函数返回值，并且函数返回地址正好在 <code>RBP</code> 的位置写着，跳转之后，等待程序的会是一个 0xcc。</p><p>只不过，这个 code 真的被执行了吗？并没有。众所都周知，栈区一般都是 <code>prot = PROT_READ | PROT_WRITE</code>，而通常不会是可执行的。事实上，我是在看了 <code>PTRACE_CONT</code> 之后的输出才明白了这一点的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=3926087, si_uid=1000, si_status=SIGSEGV, si_utime=0,       si_stime=0&#125; ---</span><br><span class="line">...</span><br><span class="line">wait4(-1, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGSEGV&#125;], WNOHANG|__WALL, NULL) = 3926087</span><br></pre></td></tr></table></figure><p>这等于说，如果栈区可执行，那么迎接进程的是 0xcc (SIGTRAP)；如果不可执行，就会直接产生一个 SIGSEGV。</p><p>不过这样的话，进程不会直接崩溃吗？在 ptrace 下，是 gdb 先收到 SIGCHLD，标志着子进程状态变化。gdb wait 获得了子进程的 STOPSIG 后，才决定是否发送给进程。进程本身没有收到这个信号，因而不会执行 SIGSEGV 的 SIG_DFL 默认信号处理函数。</p><p>实际上，也许我们也能强行通过注册信号处理函数，给触发了 SIGSEGV 的进程续命。不过这就需要使用 <code>rt_sigprocmask</code> 或是 <code>siglongjmp</code> 这类办法了。</p><p>往后就是恢复进程上下文了。</p><p>当然，对于纯表达式的求值，gdb 的确采用了第一种办法，即当场解析表达式并且通过读进程内存来进行计算。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近用 ptrace 控制进程，想要实现类似 gdb</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>性压抑 allegro</title>
    <link href="https://tilnel.github.io/20250509-repression/"/>
    <id>https://tilnel.github.io/20250509-repression/</id>
    <published>2025-05-08T16:00:00.000Z</published>
    <updated>2025-05-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文包含医疗建议，请仔细甄别。</p></blockquote><p>白天在饭桌上聊天聊到“性压抑”这件事。我不禁想到，我对这种状态似乎有一种“雷达”，对于各种性压抑的表现比较敏感。包括性压抑的人都会说什么话、做什么事，等等。但是一时又没说上来具体都有哪些标志。</p><p>以下讨论不带情感色彩。</p><p>对“性”这件事如果一个人了解颇深，能够掰着指头给你细数性的歧变的类型以及成因，总而言之，对于有关性的科学非常感兴趣，然而又没有性伴侣的人，很有可能是性压抑的。这其实是不能单单用求知来解释，或者并不能说是单纯的“学术”理解。即使是一个学者要作某方面的知识性的研究，归根结底也是某种欲望。其他的领域里，如精神分析临床，与分析者的交互同样也有赖于一种分析家的欲望。如果一个人对性的好奇在实践方面不受挫的话，事实上是很难转而投向性的理论的。</p><blockquote><p>翻开霭氏性心理学的第一页，你就已经性压抑了。</p></blockquote><p>每当人在大谈特谈什么的时候，实际上更多的是掩盖了什么。我询问 ChatGPT 4o，什么是性压抑，它给出的答案是：</p><blockquote><p>性欲的否认或压制，性行为的回避，性话题的禁忌。</p></blockquote><p>这只是某种教科书式的说法。事实上，如果性的话题成为了一种禁忌，那么我们似乎还有一种合法地绕开这种禁忌的方式，那就是把“性”的东西，变成与它恰恰相反的；从“性”这件事中，刨去所有具有性意味的东西。从而剩下一种关于性的学说。</p><p>当然这有点小众了。那么有没有更普遍一点的表现呢？有的，兄弟有的。如果一个人开黄色笑话的频率比较高，或是平时漫不经心地就能说出具有挑逗意味的话来，那么这人是性压抑没跑了。</p><p>其实原理和第一种是相仿的。如果说学说是对于性本身的异化，那么幽默就是对于性的消解。幽默属性使得所有的意味都变为可以回撤的，就像唱歌的时候躲高音一样。</p><p>并且不妨回忆一下，很多作品中的“欢喜冤家”类型的伴侣，似乎你很难想象他们做爱会是什么样的场景。如果是谐星情侣，也许在床上讲个笑话就直接笑软了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文包含医疗建议，请仔细甄别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;白天在饭桌上聊天聊到“性压抑”这件事。我不禁想到，我对这种状态似乎有一种“雷达”，对于各种性压抑的表现比较敏感。包括性压抑的人都会说什么话、做什么事，等等。但是一时又没说上来</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>徐州游记</title>
    <link href="https://tilnel.github.io/20250428-trip/"/>
    <id>https://tilnel.github.io/20250428-trip/</id>
    <published>2025-04-27T16:00:00.000Z</published>
    <updated>2025-04-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>临近五一，桌游组所有人都有点心痒痒：放长假之前总是这样。一个两个的都在讨论五一前后去哪玩，整得我也想找个地方转转了。不过经群友提醒，既然要出去玩的话，为什么不避开五一呢？我想的是找个小城市进行一日游，略加思考之后决定去徐州。</p><blockquote><p>徐州地方，历代，大规模征战五十余次，是非曲直难以论说。但史家无不注意到，正是在这个古战场上，决定了多少代王朝的盛衰兴亡，此兴彼落。所以，古来就有，问鼎中原之说。当年先总理领革命军，分三路汇合徐州，兴师北上。光复徐州的第二天，清帝见大势已去，宣告退位。民国十六年四月，也正是在徐州城郊，我有幸亲率数十万健儿，征讨北洋军阀孙传芳、张宗昌，大获全胜。我不明白为什么大家都在谈论着项羽被困垓下，仿佛这中原古战场，对于我们注定了凶多吉少。二十年前，我从徐州踏上征途，开始了第二次北伐，中华秋海棠叶遂归于一统。本党本军所到之处，民众竭诚欢迎。真可谓占尽天时。那种勃勃生机，万物静法的境界犹在眼前。短短二十年后，这里竟至于一变而为我的葬身之地了吗？无论怎么讲，会战兵力是八十万对六十万，优势在我！</p><p>​                         ——《大决战之淮海战役》，蒋光头</p></blockquote><p>4月23日，正好是南京解放的日子。这趟到徐州，就成为了“嘲笑校长之旅”的一部分，因为这里有淮海战役纪念馆。</p><p>嘲笑校长之旅</p><ul><li>南京，总统府（已不对外开放）</li><li>徐州，淮海战役纪念馆</li><li>西安，兵谏亭</li><li>重庆，白市驿机场</li><li>台湾，总统府（等待对外开放）</li></ul><p>什么时候能走完全线，要看最后一个景点什么时候能访问。</p><hr><p>启程</p><p>24日晚上，经过少量休整，从学校乘坐 Y34 公交前往南京站。我已经有段时间没有感受过这个时间的南京站了。总的来说，在这里你能看到形形色色的人。就用眼睛看到的而言，在候车厅内只要扫一眼就能看到：下身穿超超超短裙的女生，嘴里叼着辣条身穿潮牌的男生，盖小被在路边睡觉的大妈，披着褴褛的皮质西装外套的大爷，身着完全不适合通勤的浅色套西的OL，露着花臂展示短袖背后经典Burberry条纹的精神小伙……看到不同的打扮，仿佛就能看到各种各样的生活。</p><p>火车缓缓行进。笔直的座椅角度让人完全不能休息下来，只能等着眼睛等待到站。据说，这天晚上车里的人数比往常要多很多，一位阿姨说她以往经常坐这班车出差，早上到了就能开始工作……是极度的工作狂了。导致最终车上显得有点拥挤，到处都是站着的人。我腿伤尚未完全痊愈，这时又伸展不开，导致非常不舒服。不过好在只有四个小时。</p><p>中途，广播里还传来了寻医的消息，有乘客突发疾病。如此播放了几轮之后，终于列车缓缓停下——估计是联系途中的急救中心转运到医院了。这还是我第一次遇上这种情况。</p><hr><p>转转</p><p>终于熬完了车程。一出门的寒冷使我意识到这里是秦岭淮河以北。</p><p>站前广场有一定规模。特别是南侧的那家麦当劳——只有一层，面积超级无敌大，但里面还是坐满了，估计是旅客。其中的相当一部分在借用地方来化妆。我想到之前凌晨经过南京站的时候，站外卫生间也有很多在化妆的。大概出来旅游，一定不能输在出片这件事上吧。salute。</p><p>购买一罐魔爪补充能量后，第一站是访问离我最近的徐州老味菜。离车站就一点点远。由于被夹在四家摄影器材店中间以至于已经成为一种梗了。晚上一定要来吃吃这家。</p><p>老味菜对过就是一片共享电动车停放的地方。花30块钱买一张24小时卡，就可以一整天骑电动车移动，非常的划算。我就骑个小车开始熟悉徐州的地形路网。</p><hr><p>早饭</p><p>几乎是直奔菜市场去的。我忘记位置了，总之叫，苏什么丸子汤的一家。丸子汤，就是汤，炸丸子，面皮，还有很多辣椒。很呛，比较油，我吃不太惯。但是它家推荐了还有一些东西，最后我选了两来风。两来风，就是户部山边上那家。早点非常精致，可以看到菜单里有很多88块钱10个的包子、饺子啥的，挺奢华。我点的很便宜，一份辣汤和四个鲜肉蒸饺。辣汤我还不知道是什么东西，大概是里面有一些细条的豆制品，再洒了很多胡椒面，喝得人食管都凉凉的那种刺激感，实在不喜欢。听说有本地人管这个叫胡辣汤，不过和河南那种很不一样。或者是叫“sa汤”。蒸饺当然还是好吃的。</p><hr><p>云龙山 &amp; 云龙湖</p><p>在城区转了老久，最后南下到达云龙湖附近。云龙湖的规模，也就比玄武湖稍大一点。此行目的是找两个地方，一是刘备泉，一是三让亭。典故当然是有的，但是其实都不是古迹，而是后来取了这样的名字。具体为什么一定要到这两个点我也不太明白，大概是奇怪的执着。因为全线禁止掉头，所以沿着云龙湖东的路骑了一个来回才成功找到这两个地点。</p><p>出来之后找苏堤路。苏堤路下有云龙山隧道贯通，而这里面就很神奇。机动车和非机动车并不在同一层跑。非机动车经过的两边有各种各样的店铺，面积都挺大，像是各种专门的批发店、外贸市场之类的。自西向东穿过，就可以到达彭祖园。这里总的来说没什么，彭祖，也许就是逍遥游里面的那个彭祖。</p><p>从隧道穿回去，上中山南路转和平路，这里不进隧道而是骑到上面。此时左手边是徐州博物馆，右手边就还是云龙山。山里其实真的没什么东西。自然风光？只是去走走。主要的估计是几个苏东坡相关的古迹，while我对于古代文人的足迹其实并没有那么热衷。但是一进去各种弯弯绕绕的，还到处都是楼梯，使我的腿不堪重负。</p><hr><p>徐州博物馆 &amp; 乾隆行宫</p><p>从外面看来，这个馆的面积不会很大。东西当然差不多就是那些……我并不是历史考古迷之类的。遗迹、兵器、笔迹，这就是博物馆。现在让我去想的话，大概就能想到金缕玉衣这么一件。事实上，这天刚好赶上本地学生春游的日子，腿脚不太方便的我为了不与所有人挤，竟然要加快脚步赶在他们前面转完。不得不说小孩子还是太吵闹了。</p><p>一个多小时游览完毕，隔壁有个乾隆行宫。行宫也比想象中要小得多了。就是简单的小型园林建筑。</p><hr><p>淮海战役纪念馆</p><p>再次骑上车子，从和平路向东，再向南进入解放路一直走，就能到淮海战役纪念馆，此行的核心。先看纪念塔，再参观纪念馆。</p><p>建议在参观之前，观看《大决战之淮海战役》这部讲述战役历史的电影。电影里有一些名场面，比如“我说总座高见”的邱清泉，还有凯申的战前分析，以及《敦促杜聿明等投降书》的语音播报。稍微知道个大概，进馆参观好歹就有了一些乐趣。</p><p>并不在此长篇阔论。每每参观党史相关的博物馆时，都会感到一种崇高。</p><hr><p>宝莲寺</p><p>从北门出去，迎来一段长途骑行。宝莲寺应该是此行最偏僻的一处，距离有十几公里。我就记得我在车流稀少的三环东路上自由驰骋了很久。</p><p>这时候正是烈日当空。寺院大门口，地面什么的白色漫反射的太阳光几乎能灼伤我的眼球。</p><p>宝莲寺的素面没有西园寺的好吃。不过素包子挺好的。</p><hr><p>把子肉</p><p>当我赶到周记把子肉的时候，店已经关门了。但此时才下午两三点。我这才知道，把子肉就是一天一锅，卖完就算这种的。没办法只能选择连锁店了。也挺好吃，咸口的一大块肉，看着我以为我吃不下，进嘴之后肥肉全都化了，口感相当好。</p><hr><p>接下来就挺零碎的了。在户部山、回龙窝转了转。如果要形容一下的话，那就是和老门东、夫子庙类似的地方。但是也不太一样。户部山有很多很多的老手艺的店铺，不过无非是笔墨字画，裁缝，饰品，古玩。</p><p>在回笼窝转的时候，还发生了这样的事。一位女同志从左边凑近来，突然就开口问我：“你觉得忘记一个人是先忘记他的相貌还是先忘记他的声音？”给我问蒙了，3秒才回过神来。感觉是路上拍段子那种吧？但是拍段子怎么会悄悄从侧面上来就问呢，总之很奇妙。</p><p>去徐州的二次元店看了眼，发现这里的邦谷浓度同样很低。</p><p>临走在徐州老味菜吃了份地锅鸡。这里的老板似乎知道这家店有点出名了。</p><hr><p>体验了一下徐州的地铁。从徐州站上车坐到徐州东站。</p><p>徐州东站感觉面积特别大，站名的牌子延伸到很外面，然后要离开很远才能拍到娃…因为腿已经几乎要爆炸了所以放弃。</p><p>高铁还是太舒适了。可惜只能睡一小时。</p><hr><p>吐槽</p><p>上午我认为这座城市还是非常宜居的，但很快这种想法就改变了。因为这里对于非机动车并不很友好。一天下来我骑行了大约60公里，非机动车道时不时就会消失，要么就是和公交车共用一条道。公交车停下来的时候，就要从公交车左边去超车。如果这个时候它刚好启动的话，司机第一下都是向左变道，把非机动车向路中心继续挤过去，这就很危险了。</p><p>另外一点是，路况比较差。比较典型的是外余窑路，这个地方是真正的地无三尺平，骑在上面感觉屁股都不是自己的了，差点要给哈啰赔修车钱的。一般的路段上，很多井盖及其周围地面都是下凹的，无论方圆。骑车还得小心避开，以免骑到高低落差的缝上造成车辆失控。</p><p>这个地方非机动车有点太多了。我看到很多初中生也在骑电动车上下学。还有很多老头乐，以及走非机动车道的摩托车。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;临近五一，桌游组所有人都有点心痒痒：放长假之前总是这样。一个两个的都在讨论五一前后去哪玩，整得我也想找个地方转转了。不过经群友提醒，既然要出去玩的话，为什么不避开五一呢？我想的是找个小城市进行一日游，略加思考之后决定去徐州。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;徐州地方</summary>
        
      
    
    
    
    <category term="日常" scheme="https://tilnel.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>配镜</title>
    <link href="https://tilnel.github.io/20250424-trip/"/>
    <id>https://tilnel.github.io/20250424-trip/</id>
    <published>2025-04-23T16:00:00.000Z</published>
    <updated>2025-04-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我是个不戴眼镜的人。从小测视力两只眼睛都没有下过 5.0 这个数字，甚至在高中那段用眼强度极高的时期视力短暂地到达过 5.2。我搜索了一下人的视力会不会上升，出来的结果全都是近视度数上升，看来没什么科学依据，就当是一次测量误差吧。不过这也只能表明我没有近视，事实上我可能是有一点散光的，具体表现为我晚上盯着路灯看的时候，左眼会有左上-右下的眩光，右眼会有右上-左下的眩光。两眼加在一起，就是一个“X”型。我以前一直认为这个是每个人眼睛都正常会有的现象，比如有的影像作品中出现的星星，很多都具有一个十字形状的眩光。但我现在才知道，视力正常的人眼是没有这个东西的。但我也说不好，因为我但凡把眼睛睁大点，视野中的各种眩光就会消退。归根结底，只要控制好眼部肌肉的力，让眼球结构产生一些微小的形变，也是可以“不散光”的。何况我眼睛并没有看东西特别费劲的现象。最后还是没有去验光。</p><p>所以当然是去买平光镜啦！高三的时候我也买过一副平光镜，应该是19年春天。一个契机是当时刚刚好到处都在飘梧桐絮，想着买个眼镜多少可以挡一点；另一个契机是后来成为前女友的同学在18年我过生日时送了我一块眼镜布，送完才发现我根本就不戴眼镜。当时我妈也是哄我开心，就去挑了一副。那副眼镜现在看来其实非常不适合我，因为选得实在是太窄了，修饰的效果就像是五官整个往中间聚拢，看起来非常傻。</p><p>后来我很久没动过这个心思，直到开始研究穿衣，就顺便觉得自己可能也需要一些配饰来修饰面部。使我关注眼镜这个品类的还得是 <a href="https://www.bilibili.com/video/BV15y421i7Do">Saint Laurent 2024FW 男装系列</a> 这一场。喜欢看帅哥的必看，喜欢西装的必看。当时觉得第一个出场的哥们很神，后来才知道全世界都觉得他长得像圣罗兰本人所以爆火了一波， 刷淘宝刷小红书都经常能看到这位——以及那副标志性的黑框眼镜。</p><p>这不是契机就来了：社团有人要换眼镜，有人要买墨镜，刚好能凑一车。不过事实上最后这个活动爆火，凑够了两车人以至于决定坐高铁了。</p><blockquote><p><a href="https://www.bilibili.com/video/BV1kmddYCEbH">路上拍的低智小视频</a></p></blockquote><p>丹阳这座县级市除了一下高铁就是眼镜城以外，几乎不能给人特别深刻的印象。很难想象它不是刻意这么设计的。刚好我腿脚不特别利索，拄着拐杖出高铁站。搁别的地方，这时候绝对都是各类司机等待接客。这个地方不需要，取而代之的都是各家眼镜店揽客的。</p><p>往路口走要跨过一道矮栏，边上的大叔看到我拄着拐，立刻叫住我并指了指稍远处的通道。我寻思懒得绕路，于是把拐一拎，直接自己跨过去了，这可能是我能够制造的最接近“医学奇迹”的场景了，谁看谁沉默那种。不过后来好好解释了腿其实快好了。我当时还在想这大叔应该只是路人，一转头手上就多了张名片，是他负责揽客的一家眼镜店……果然这个地方真的只有眼镜。</p><p>一行的四位直奔主题，去了提前咨询过的一家店。陈列柜里展示的各种仿品眼镜还真是挺有意思，等待眼镜制作的过程试戴了很多，可惜忘记拍下来了。</p><p>眼镜拿到手，一出门感觉天色非常不对劲，有点飘雨并且发黄。当时还没有往空气质量这方面想。直到眼镜片上雨水微干，留下黄色的土粒，这才想起查看天气，一看是沙尘暴，AQI 500+——顿时觉得呼吸都有点不顺畅，后咽壁开始刺痛。匆匆解决完午饭就返程了。</p><p><img src="image-20250424140947796.png" alt="眼镜" style="zoom:10%;"><img src="image-20250424141008286.png" alt="娃" style="zoom:21.35%;"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我是个不戴眼镜的人。从小测视力两只眼睛都没有下过 5.0 这个数字，甚至在高中那段用眼强度极高的时期视力短暂地到达过</summary>
        
      
    
    
    
    <category term="日常" scheme="https://tilnel.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>纯杂谈</title>
    <link href="https://tilnel.github.io/20250422-misc2/"/>
    <id>https://tilnel.github.io/20250422-misc2/</id>
    <published>2025-04-21T16:00:00.000Z</published>
    <updated>2025-04-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>说出口的话，在最坏的情况下，就是变成了他人之间互相攻讦的依据。</p><hr><p>当一个有用之人，并且想怎么用就怎么用。譬如有人在背后通过评论我而结成了某种盟友关系，虽然我觉得这种关系不可能长久，但这样也算有用。</p><hr><p>支持什么，不是说认为什么东西是好的。而是直接现实地为这种东西的发展创造条件。</p><p>比如 “支持人类表达心中的真实想法” 这种宏伟的愿景。那么至少要什么都愿意听，如果不喜欢就认真去辩。否则就还是掐灭了这种热情。</p><hr><p>人类都是既坚定又善变的。这一刻坚定地做一个吉普赛人，下一刻坚定地爱上基督徒斗牛士。不确定性是泥土；确定性也是泥土，但是是金色的。</p><p>想要什么东西，其实是先天根植于内心的，我们自己也只是回溯性地揭示已经存在的东西罢了。“知道自己想要什么”，实际上只是一个临时的 Checkpoint。</p><p>我们都是苏格拉底的学生拾麦穗。</p><hr><p>JOJO5 中指示人物死亡命运的「滚石」是一个很有意思的设定。看第 38 话的时候还在疑惑唐突插叙，直到最后一话豁然开朗。荒木在这里表达了他对于“命运”这件事的思考。</p><p>并不是「滚石」决定了人物的命运，它充其量只是显示了这种命运。这是人物的内在矛盾所决定的发展趋势。</p><p>某天下班之后去 711 时，与高先生讨论起现实为什么会如此发展。我当时表达了一种观点，即就本人当时那种近乎癫狂的状态而言，不是在这里摔，就会在那里摔。例证环节过后，他似乎接受了这个说法。</p><hr>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;说出口的话，在最坏的情况下，就是变成了他人之间互相攻讦的依据。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;当一个有用之人，并且想怎么用就怎么用。譬如有人在背后通过评论我而结成了某种盟友关系，虽然我觉得这种关系不可能长久，但这样也算有用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;支持什么，不是说认为什么东西是</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>工作随记</title>
    <link href="https://tilnel.github.io/20250417-working/"/>
    <id>https://tilnel.github.io/20250417-working/</id>
    <published>2025-04-16T16:00:00.000Z</published>
    <updated>2025-04-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>把 ckpt 部分的文档写了</li><li>coding：完善已有功能和写法。<ul><li>主要是，增加安全检查</li><li>改写序列化、反序列化写法。顺手干掉看着不顺眼的类型。<ul><li>尝试使用 cereal。</li></ul></li></ul></li><li>读 DPOR</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;ul&gt;
&lt;li&gt;把 ckpt 部分的文档写了&lt;/li&gt;
&lt;li&gt;coding：完善已有功能和写法。&lt;ul&gt;
&lt;li&gt;主要是，增加安全检查&lt;/li&gt;
&lt;li&gt;改写序列化、反序列化写法。顺手干掉看着不顺眼的类型。&lt;ul&gt;
&lt;li&gt;尝试使用</summary>
        
      
    
    
    
    <category term="科研" scheme="https://tilnel.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>坚持独立自主的和平外交政策</title>
    <link href="https://tilnel.github.io/20250407-announcement/"/>
    <id>https://tilnel.github.io/20250407-announcement/</id>
    <published>2025-04-06T16:00:00.000Z</published>
    <updated>2025-04-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>坚持独立自主的和平外交政策</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;坚持独立自主的和平外交政策&lt;/p&gt;
</summary>
        
      
    
    
    
    <category term="Uncategorized" scheme="https://tilnel.github.io/categories/Uncategorized/"/>
    
    
  </entry>
  
  <entry>
    <title>面纱，人设 allegro</title>
    <link href="https://tilnel.github.io/20250331-veil/"/>
    <id>https://tilnel.github.io/20250331-veil/</id>
    <published>2025-03-31T07:18:42.000Z</published>
    <updated>2025-03-31T07:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>《面纱》讲了一个什么故事呢？其实就是 <em>The Painted Veil</em> 的故事，书名已经写得很明白了。古代有“误点成蝇”的典故，说谁要驱赶画面上的一只苍蝇，最后发现苍蝇根本就在画中。这个书名其实也是一样的。你想揭开什么面纱，但是其实面纱根本就是画的！这还并不等于在说，面纱的后面没有什么东西，毋宁是说面纱从根本上就是这幅画本身。只是画作得到人的意识的时候，人的想象力充当了一个角色，即将这面纱从画作当中剥离开，造成一个幻象。因而，这是一个穿越幻象的故事。</p><p>所谓面纱，无非是一种表象，是客体在我之内。我去认识这个在我之外的客体，好像是把客体剥离出一些什么东西，并容纳到我自身之内。这好像是某种对立，但仅仅是就我作为一个认识者而言的。客体，以及客体的表象，在原初的意义上是同一的。</p><p>跑题了。我想说认识到什么就是什么。恋人之间有一种游戏，叫做“你喜欢我哪一点”。就我个人的游玩体验来说，并没有哪次是真正说到爱人认可的范围里面去的。这就显得我一点也不了解爱人，并且总是在爱人身上寻求一些她没有的东西，而我笨笨的，我以为有，并且每每觉得我真的寻求到了。所以看起来会有点滑稽。</p><p>然而我真诚地认为，我我眼中的他人和他人眼中的我，相较于谁谁眼中的自己，是更加重要的。也许应当认识到，不管你愿不愿意，主体间的关系都充满了一种无意识的，并且是无指向的“虚张声势”。我并不否认他人认为的我的样子，只要那是诚心的；相对地，我也不为那种观点生成与其相符合的行动。于是“面纱”会自行破产。从这个角度上讲，现实的人每天都在 OOC 才是一种正常现象，因为人设是一个回溯性的东西，只有越来越多的行动被考察到才能够趋于完整。固定的人设就其本性而言是未完成的，遵循它反而显得非人类。</p><blockquote><p>调酒师也好，魔术师也罢。有的只不过是一个名称，剩下的与其他人并无二致。</p><p>或者说，我不是什么调酒师，他也不是什么魔术师。我仅仅是我，他仅仅是他。在此之外，无论是自我的身份认同，还是来自他人的身份认同，对于人本身而言都是一场灾难。</p></blockquote><p>所以<strong>普通和理所当然</strong>是什么呢？如果人普通地理所当然地会做什么的话，无非就是从他那未经审视的本性出发做一些必须要做的事情。但我不知道，你不知道，他也不知道。“性格使然”的解释，就一个人永远有潜力做出与这个人的刻板印象不相符的事情的情况而言，是非常苍白无力的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;《面纱》讲了一个什么故事呢？其实就是 &lt;em&gt;The Painted Veil&lt;/em&gt;</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>PGP key 配置记录</title>
    <link href="https://tilnel.github.io/20250327-gpg/"/>
    <id>https://tilnel.github.io/20250327-gpg/</id>
    <published>2025-03-27T05:43:12.000Z</published>
    <updated>2025-03-27T05:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenPGP 是一套开放的互联网讯息加密、验证的标准，而 GnuPG(GPG) 是其一套实现。</p><p>生成你的密钥对并妥善管理，就可以：</p><ul><li>加密通话</li><li><del>放一个 fingerprint 在个人页面里装B</del></li></ul><p>这里有一套比较详细的教学，我只是随手记录一下自己的配置。</p><p><a href="https://ulyc.github.io/2021/01/13/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8A/">2021年，用更现代的方法使用PGP（上） - C的博客 |UlyC</a></p><p><a href="https://ulyc.github.io/2021/01/18/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%AD/">2021年，用更现代的方法使用PGP（中） - C的博客 |UlyC</a></p><p><a href="https://ulyc.github.io/2021/01/26/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8B/">2021年，用更现代的方法使用PGP（下） - C的博客 |UlyC</a></p><hr><p>根据 CC BY-NC-ND 4.0 协议，我不能发布基于原文演绎的内容。我无法分辨记录配置过程是否是一种演绎。因而决定不对自己的配置过程进行发布了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;OpenPGP 是一套开放的互联网讯息加密、验证的标准，而 GnuPG(GPG) 是其一套实现。&lt;/p&gt;
&lt;p&gt;生成你的密钥对并妥善管理，就可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密通话&lt;/li&gt;
&lt;li&gt;&lt;del&gt;放一个 fingerprint</summary>
        
      
    
    
    
    <category term="技术" scheme="https://tilnel.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>先验唯心论体系 理论哲学的第三阶段</title>
    <link href="https://tilnel.github.io/20250327-idealism/"/>
    <id>https://tilnel.github.io/20250327-idealism/</id>
    <published>2025-03-26T16:00:00.000Z</published>
    <updated>2025-03-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>完全根据自己的理解去写的。</p><p>假如人是盲目的，没有任何认识能力的，那么没有客体能够产生出来。</p><p>但理智可以进行直观活动。理智本身就无非是一个促使客体（对理智）产生出来的行动方式。这一理智的行动将理智自身与这种行动分离开来。这种分离就叫做“抽象”，“抽离”。这种行动对于理智而言，则显现为一种产物。</p><p>理智作为行动本身，原初地和客体是合为一体的，因为这个时候，还没有客体对我产生出来。当理智的行动和行动的产物分离开来时。产物就是“概念”。</p><p>概念与客体原初地就是一致的，它们在位于意识彼岸的时候是同一个东西。二者的分离是在意识的产生时发生的。</p><p>但是概念与客体确确实实地在我们地认识中相互对立了。这一对立并不是由别的什么产生，而是由判断产生的。当我们说“这朵花是红的”的时候，“这朵花”的直观，与“红色”的概念就分离了开来，尽管这个判断同样也设定了二者的同一性。</p><p>简而言之，概念与客体有着原初的同一性，而只是因为意识的设定才产生了对立。</p><p><strong>概念，就是意识用以在意识自身之内建构客体的规则。</strong>而客体，则是规则本身的表现。</p><p>从客体当中分离出概念，则需要通过一种直观来进行对接：在意识彼岸与客体对接，在意识之内与概念对接。这种直观称之为<strong>范型化</strong>。</p><p>范型化是将对象直观为一个已规定的对象的过程，也就是对“规则”的直观。比如，将直角三角形、锐角三角形、钝角三角形全部直观为“三角形”。</p><p>我们认识到这一朵花是“红的”，不因为我们曾经见过红色的东西。当我们第一次见到红色的东西的时候，就已经认识到了“红色”的概念。概念不等于语词，红色，Red， 赤い…各种说法，指代的都是同一个概念罢了。</p><p>这与我们通常认识的“抽象”是不同的。普通的抽象能力，是从众多的事物中抽出一种“共相”，也即保留一种普遍者。但是设想：如果我们没有在碰到第一朵红花的时候，就形成“红色”的概念，那么在遇见“红灯”、“红火”的时候，又如何知道这些客体是与红色的概念相联结的呢？</p><p>因而我们不得不承认我们有一种能力，就是从一个客体当中直接地把握作为普遍者的概念的能力（就是在说范型化）。这是一种更高级的“抽象”能力。而从众多事物中抽出一种共相，则是一种经验的抽象能力。</p><p>（我们看似能够创造概念当中不存在的客体。实质上，是对一些已有的建构客体的规则组合在同一客体上，进而在认识的过程中被把握为一个新的概念）</p><p>如果我们能抽去客体当中的全部概念的话——也就是说，去掉了这个概念之后，客体的直观仍然可以被想象。到最后我们不得不承认，一个客体它终究是占据一定的<strong>空间</strong>的。不占据空间的客体是无法想象的。虽然“空间”对于人而言仍然是某种抽象出来的东西，但它并不是抽象概念。说到底人认识的一切东西无不在空间中出现，因此毋宁说，空间是人类认识能力的一种形式。</p><p>如果我们能抽去客体当中的全部直观的话——只剩下概念。我们知道概念是一种规定着客体的东西。如果没有空间的直观，那么这些规定就没有其作用对象，只是纯粹的规定性，而不是任何实在的概念了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;完全根据自己的理解去写的。&lt;/p&gt;
&lt;p&gt;假如人是盲目的，没有任何认识能力的，那么没有客体能够产生出来。&lt;/p&gt;
&lt;p&gt;但理智可以进行直观活动。理智本身就无非是一个促使客体（对理智）产生出来的行动方式。这一理智的行动将理智自身与这种行动分离开来。这种分离就叫做“抽象”，“抽</summary>
        
      
    
    
    
    <category term="谢林" scheme="https://tilnel.github.io/categories/%E8%B0%A2%E6%9E%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Fail2ban for frps</title>
    <link href="https://tilnel.github.io/20250321-fail2ban/"/>
    <id>https://tilnel.github.io/20250321-fail2ban/</id>
    <published>2025-03-26T05:53:36.000Z</published>
    <updated>2025-03-26T05:53:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://yuuza.net/Posts/fail2ban-for-ssh-behind-frp">为 frp 后的 SSH 配置 fail2ban</a><br>参考：<a href="https://www.cnblogs.com/sangria/p/15827740.html">使用 fail2ban 保护 frp 服务</a></p></blockquote><blockquote><p>仍然推荐 pubkey 登录以及为密码添加 2FA。</p></blockquote><p>前置条件：frps 由 systemd 启动。安装了 iptables。</p><p>局限性：仅仅根据连接频率来判断异常连接，而并非判断连接失败。因而有可能因为频繁连接而被误封。</p><p>文件 <code>/etc/fail2ban/jail.d/frps.conf</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[frps]</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">findtime</span> = <span class="number">10</span>m</span><br><span class="line"><span class="attr">maxretry</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">bantime</span> = <span class="number">10</span>d</span><br><span class="line"><span class="attr">backend</span> = systemd</span><br><span class="line"><span class="attr">filter</span> = frps</span><br><span class="line"><span class="attr">journalmatch</span> = _SYSTEMD_UNIT=frps.service</span><br><span class="line"><span class="attr">port</span> = all</span><br><span class="line"><span class="attr">action</span> = iptables-allports[name=frp,protocol=tcp]</span><br></pre></td></tr></table></figure><p>文件 <code>/etc/fail2ban/filter.d/frps.conf</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Definition]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">failregex</span> = ^.*ssh2] get a user connection \[&lt;HOST&gt;:[<span class="number">0</span>-<span class="number">9</span>]*\]</span><br><span class="line">ignoreregex =</span><br></pre></td></tr></table></figure><p>注意 <code>failregex</code> 开头的 <code>ssh2]</code> 部分，用于匹配以 <code>ssh2</code> 结尾的 frp 服务。自行调整匹配内容</p><h2><a href="#frps-pei-zhi" class="header-anchor">#</a><span id="frps-pei-zhi">frps 配置</span></h2><p>设置 <code>log_level = debug</code> 以启用 <code>get a user connection</code> 这类日志就好。</p><p>文件 <code>frps.ini</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">log_level</span> = debug</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><a href="#xiao-guo-yan-zheng" class="header-anchor">#</a><span id="xiao-guo-yan-zheng">效果验证</span></h2><p>fail2ban: <code>sudo fail2ban-client status frps</code></p><img src="image-20250326133204041.png" alt="image-20250326133204041" style="zoom:50%;"><p>并不隐去可恶的攻击者 IP。</p><p>iptables: <code>sudo iptables -L</code></p><img src="image-20250326133321118.png" alt="image-20250326133321118" style="zoom:50%;"><p>两边都有攻击者 IP 才算启动成功。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://yuuza.net/Posts/fail2ban-for-ssh-behind-frp&quot;&gt;为 frp 后的 SSH 配置 fail2ban&lt;/a&gt;&lt;br&gt;参考：&lt;a</summary>
        
      
    
    
    
    <category term="Linux" scheme="https://tilnel.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>轻松自如</title>
    <link href="https://tilnel.github.io/20250322-spring/"/>
    <id>https://tilnel.github.io/20250322-spring/</id>
    <published>2025-03-22T08:53:06.000Z</published>
    <updated>2025-03-22T08:53:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>自由是一种畅快。最近发现自己几乎可以两条腿行走了，虽然距离不算很长。春天也到来了，户外充满了人的气息。即使暂时感到局促不安，但回归生活这件事正在热火朝天地发生着。</p><p>坐在研究生工作室里闲里偷忙式地赶活。转暖的天气让背后稍微沁出一点汗来，又让衣服吸了去，再被穿入门窗的微风带走，一会儿暖和一会儿凉快的，使人静不下心来。转头看向外面，五点钟的阳光依然明亮，照得整个校园那么鲜艳。而我即将在其中自由地行走。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;自由是一种畅快。最近发现自己几乎可以两条腿行走了，虽然距离不算很长。春天也到来了，户外充满了人的气息。即使暂时感到局促不安，但回归生活这件事正在热火朝天地发生着。&lt;/p&gt;
&lt;p&gt;坐在研究生工作室里闲里偷忙式地赶活。转暖的天气让背后稍微沁出一点汗来，又让衣服吸了去，再被穿入门</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://tilnel.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
