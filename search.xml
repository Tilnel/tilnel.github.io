<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Preface-三月十日</title>
      <link href="/20991231-top/"/>
      <url>/20991231-top/</url>
      
        <content type="html"><![CDATA[<p>人是在变化的，写出来的东西是死的，以至于会很快地反对几天前自己写过的东西，这也是难免的。不过作为一种记录，就不删除了，而是对有问题的内容进行标注。</p><p>Tilnel 2025-03-10 10:10:39</p><p><a href="/20241023-top/">第二版置顶</a></p><p><a href="/20231017-top/">第一版置顶</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新年序曲</title>
      <link href="/20260113-misc/"/>
      <url>/20260113-misc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自摔断腿纪年法的诞生以来真是发生了很多事，我同时因为时光被填满而感到漫长，又因为事情接踵而至感到仓促。</p><p>年初在家养伤的时间都在自由充电。被禁锢在床上的三个月里可消遣的项目也只有读书看电影，从各种媒介接受输入。要问收获恐怕已经答不上什么，潜移默化的影响也许有吧。三月慢慢出来走动，在学校过了几个月的逍遥独居日子。也没做什么，和社里快要毕业滚蛋的同学混日子，也许只有我在纯粹地混日子。本来没打算实习，但先是在第三领域被企业的人抓着投简历，转头老板又来电话让我改投另一个部门，这样实习经历的问题也解决了。搬到上海住了几个月，秋招拖拖拉拉到十月才开始忙活，借公司的会议室面试别的公司，在痛苦的等待中接了好像还不错的合同。十一月回到南京，在二〇二五年的末尾进入了彻底的躺平模式，仿佛毕业论文已与我无关。</p><p>年内去了镇江，丹阳，徐州，西安；在上海和南京之间多次往返。拖着还不算很灵活的腿脚到处乱跑，脚力也许就能多回复一点。其中只有西安把我折腾得够呛：从华清池到兵谏亭好一段山路，原来蒋光头当年体力也还不错。</p><p>八月底和在学校认识的女人谈恋爱，十二月底又分手了。这已经是上了大学之后最久的一段了。没什么利益上的考虑反而让我觉得没什么好妥协的，很干脆地放弃了。我想也许长长久久的恋爱不属于我认同的爱情的范式。所以兴许需要重新思考婚姻这件事。</p><p>在那之后又得知两位国际友人分手的消息，当即比我自己分手还要感到遗憾。孩子们，桌游组可能彻底歇逼了。随着毕业的分手的诸如此类的不可抗力因素奖池还在累计，往日种种最终还是再无话说速速动手。届时也许会变成：“我做出这一决定，是基于原则性的考虑的……”。</p><blockquote><p>夫人之相与，俯仰一世，或取诸怀抱，悟言一室之内；或因寄所托，放浪形骸之外。虽趣舍万殊，静躁不同，当其欣于所遇，暂得于己，快然自足，不知老之将至。及其所之既倦，情随事迁，感慨系之矣。</p></blockquote><p>我始终认为这段话是在说人的相处，本就是一群人个性各不相同，偶然找到一个暂时的共通之处，相处而快乐一阵。后来不可避免地有所厌倦，人之间的感情又随着现实的发展产生了变化，只能对当时的欢乐以及后来的变迁感慨一下。这样理解太符合我的认知，甚至是符合我的愿望以至于我现在不知道王羲之原本想表达的是什么了。也许在绝大多数情况下，人与人的关系就像一阵风。</p><p>只有一件事是确定的。那就是我也说不清楚这些是为什么，不知道我在期待什么，不知道自己在想什么。答案只能凝结在寻找的过程当中。</p><hr><p>祝看完的老板永远健康永远快乐永远不死永远爽。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何洗衬衫</title>
      <link href="/20251218-shirt/"/>
      <url>/20251218-shirt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这里讨论的是一般的纯棉衬衫应该怎么<strong>机洗</strong>。更耐造的面料是通用的，但是娇贵的还是请专业人员。</p><p>准备一堆穿过的衬衫、衣领净、洗衣液、衣物消毒液（选用）。</p><p>首先是预处理。衬衫在穿着的过程中，领口、袖口和腋下是比较容易脏的。对于我来说，主要是领口。我觉得这个可能会看得比较直观。穿过的白色衬衫领口会泛黄；对于彩色的衬衫，一般领口处的颜色会因为皮肤油脂渗入，变得深一点。这种我们提前喷好衣领净再去洗。</p><p>处理好特殊部位之后，开始扣扣子。一般的衬衫是7颗纽扣，可以都扣上。如果人比较懒也可以隔一个扣一个。然后我们把衬衫的大身内外翻过来，袖子留在大身的里面，领子你就立起来。这样在洗的时候面料可以把纽扣尽量包裹住，不容易在洗衣机里转的时候把扣子打碎了（树脂扣几分一个，贝壳扣一块钱）。另外袖子在里面呢也防止在洗衣机里拉拉扯扯。扣扣子这一会儿，基本刚才衣领净也就在起效了。</p><p>接下来就正常机洗流程。</p><p>出锅之后把衬衫完全翻到正面来，其实基本上在洗衣机里面就已经翻得差不多了。挂一个肩宽适合的衣架，然后需要手动拉扯整平一下。对于几处要特殊注意：</p><ul><li>门襟，可能比较容易起波浪起皱</li><li>大身侧缝</li><li>袖子与大身的接缝</li><li>袖子的缝合处</li><li>袖子开袖衩处</li><li>袖口衬与袖子的缝合处</li><li>后肩片与后片的接缝</li></ul><p>*总之，就是各种两片布料缝合的地方以及一些边缘，都可以扽一扽去整平。</p><p>一般，我们就悬挂晾干。</p><p>如果要烘干，建议考虑一下几点：</p><ul><li><p>制作精美的衬衫尽量不要烘干，高温损伤会比较严重（使用的辅料的抗造程度、性质不同，可能导致产生的效果很哈人）</p></li><li><p>亚麻面料不要烘干，起皱严重</p></li><li><p>含粘胶纤维不要烘干。又缩又起泡</p></li><li><p>袖口、领底是粘合衬不要烘干。会起泡。当然水洗也会起泡</p></li></ul><p>对于我而言，主要是领子清洁那一步和最后整理的一步很重要。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>和爱人</title>
      <link href="/20251004-misc/"/>
      <url>/20251004-misc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>近期和爱人很好。这是实习以来鼓舞我的事情之一。</p><p>我颇有私心地将我的感情作为磨练我爱人、理解人的能力的一种考验。其实我并不知道我到底做得怎样好，或者怎样坏。也许这样的程度就是“将将好”，也许总归还是不够。我觉得我的热情其实是不足的，但索性爱人没有给我任何大考。说是没有，其实换任何另外的人来也许都不能做得比我好，毕竟她喝完酒之后就会陷入一种深深的…摆出激烈的回撤的姿态。我总是劝慰她下次别喝那么多，而她总是下次一定。在一起的时光甜蜜，而分开的时候，能算是稳定吗？也许我的热情不足这块给了她一些不安，但总之——只要见面就好。这点也不一定会奏效。</p><p>我们有无数的时间不能在一起，这一点可预见地并不会随着我们脱离了学生的身份之后就好转，尤其在我四处物色发展机会的时候，这里要去北京了，那里要去新疆了。而爱人又分离焦虑爆炸，我不敢赌定我是不是每次都能够处理好。也许只有一次次地在城市之间往返，稍微平息一下那样的冲动。</p><p>感情中的我过于稳定了，既像爱人最开始喜欢上我的某一点，也就是一种 NPC 感。我又何尝不是以第三人称视角来看这份感情呢？不过我们彼此之间都没有强迫，于她而言可能是怕添麻烦，而于我而言…可能更多是无所求。这种热情消失的感觉并非是逐渐的，而是从一开始就如此，甚至在别的方面也有体现。</p><p>我似乎并不能一下就说出很多大话来了，同任何人交谈的时候，我开始首先审视自己的态度，然后再审视别人的态度。最后尽量想端水，或者说平衡。我说不清楚这里到底经历了什么。</p><p>我有一个理想中的世界，以及理想中的对话者。祂应当秉持着什么样的态度与我对话。我承认人都有主观的偏好，甚至过于承认了。我拒绝人把主观的偏好推而广之，不加以提示地告诉所有人。也就是拒绝一些“小马过河”式的建议。我希望所有的话都是“我自己的经验是xxx，我觉得xxx。你可以参考一下。”如果有人突然就祂自己的经验而发表论断，我一时竟会感到愤怒，然后想祂也有祂自己的原因，最后多少表达抗议。</p><p>我自己也在逐渐避免这样，也许。为别人提供视角，越来越大于提供观点。因此我也总是把一两个寓言故事挂在口头，作为一种随时的提醒。但我的观点又不能说不强烈，事实上我为我认识到、想明白一些事情感到非常骄傲，或者说是自信。但为了与理想中的对话者这种描述自洽，又不得不收敛一点——兴许在其他人的眼里我可能还是比较 mean。不过我已经努力了。</p><p>与爱人也是这样。我觉得路要自己走，我觉得我不是任何救世主。所以我只是陪伴，以及从旁观看。事实上说也不可能说通，她的焦虑与痛苦，我知道是由她的本性决定，以及可能是因为我而引发的。但如果不爆发出来的话，我也就只能用三言两语去宽慰一下，然后陪伴等待。这是我作为一个对等点能做的所有事。对这个世界的态度，并不是能够学来的；终归有些事，并不是我能解决的…</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FreeBSD TCP 实现中发现的两个 BUG</title>
      <link href="/20250925-freebsd_tcp/"/>
      <url>/20250925-freebsd_tcp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>我宣布现在没人比我更懂 TCP。</p></blockquote><p>见邮件列表 <a href="https://lists.freebsd.org/archives/freebsd-net/2025-September/007578.html">Two different places between TCP socket behavior and RFC documents</a></p><p>虽然没有肉眼可见的 vulunerability &#x2F; exposure 但多少还是被承认为 BUG 了…对方锐意修复中。</p><p>问题1. 关闭时有待处理数据，但未能发送 RST</p><p>根据 RFC 2525 第 2.17 节，当 <code>close()</code> 一个套接字时，如果其接收缓冲区中仍有待读取的数据，应该发送 RST（复位）。</p><p>根据 RFC 1122：主机可以实现一种“半双工”TCP 关闭序列，…不能继续读取数据…如果接收缓冲区中仍有待处理数据时进行 CLOSE 调用，或者在调用 CLOSE 后接收到新数据，TCP 应该发送一个 RST 以表明数据已丢失。</p><p>然而，FreeBSD 的 TCP 套接字并非如此。以下是 TCPDUMP 的输出，显示在套接字有待处理数据时调用 <code>close()</code> 发出的是 FIN（结束）而非 RST：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A &gt; B: Flags [S], seq 2636678338, win 65535, length 0</span><br><span class="line">B &gt; A: Flags [S.], seq 1969223298, ack 2636678339, win 65535, length 0</span><br><span class="line">A &gt; B: Flags [.], ack 1, win 1277, length 0</span><br><span class="line">A &gt; B: Flags [P.], seq 1:6, ack 1, win 1277, length 5</span><br><span class="line">B &gt; A: Flags [.], ack 6, win 1277, length 0</span><br><span class="line">B &gt; A: Flags [F.], seq 1, ack 6, win 1277, length 0</span><br><span class="line">A &gt; B: Flags [.], ack 2, win 1277, length 0</span><br></pre></td></tr></table></figure><p>无论是 <code>close()</code>、<code>shutdown(SHUT_RDWR)</code>、<code>shutdown(SHUT_RD)</code>，还是 <code>SO_LINGER</code> 设置为开启或关闭，都得到相同的结果。而在 Linux 上，同样的操作会得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A &gt; B: Flags [S], seq 2879877684, win 65495, length 0</span><br><span class="line">B &gt; A: Flags [S.], seq 1538598692, ack 2879877685, win 65483, length 0</span><br><span class="line">A &gt; B: Flags [.], ack 1, win 512, length 0</span><br><span class="line">A &gt; B: Flags [P.], seq 1:6, ack 1, win 512, length 5</span><br><span class="line">B &gt; A: Flags [.], ack 6, win 512, length 0</span><br><span class="line">B &gt; A: Flags [R.], seq 1, ack 6, win 512, length 0</span><br></pre></td></tr></table></figure><p>当然，虽然没有发送 RST，但是这里不会像预期的那样导致连接一直保持。因为它的 FIN segment 实际上重新打开了窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A &gt; B: Flags [.], ack 1, win 510, length 0</span><br><span class="line">B &gt; A: Flags [.], ack 66137, win 0, length 0</span><br><span class="line">A &gt; B: Flags [.], ack 1, win 510, length 0</span><br><span class="line">B &gt; A: Flags [.], ack 66137, win 0, length 0</span><br><span class="line">A &gt; B: Flags [.], ack 1, win 510, length 0</span><br><span class="line">B &gt; A: Flags [.], ack 66137, win 0, length 0</span><br><span class="line">B &gt; A: Flags [F.], seq 1, ack 66137, win 1027, length 0</span><br></pre></td></tr></table></figure><p>我们通过发送大量数据，使得对面最终通告了 0 窗口。但在对面进行<code>close()</code> 后，它又打开了窗口。此时发送端就又可以发送数据，包括发送 FIN 了。</p><p>如果发送数据，而对面已经做了接受方向的关闭，则会得到一个 RST；如果发送 FIN，也就能完成四次挥手。看起来都能够使连接关闭。但这里的问题在于，打开接收窗口与关闭接受方向显然是矛盾的。尤其是，打开窗口邀请对面发送数据，而这数据是必定会被自己所拒绝的，这造成了一些不必要的网络流量以及处理资源的浪费。</p><p>另一方面，FIN 标志着优雅地关闭了连接。但这里显然并不优雅。我们需要用清晰的报文来标志异常。</p><p>数据发送&#x2F;强制重置比起主动重置除了少量资源消耗以外，使得关闭这件事整体变得复杂了….</p><p>问题2. 在 SYN-RECEIVED 状态下对旧序列 segment 回复 RST 而非确认</p><p>根据 RFC 793 第 69 页：如果一个传入的 segment 不可接受，应该回复一个确认（这里“应该”没有大写）。</p><p>这应该适用于包括 SYN-RECEIVED 在内的所有状态，但 FreeBSD 的 TCP 套接字并非如此。我用手动构造的 TCP 分段发现了这个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &gt; B: Flags [S], seq 1, win 8192, length 0</span><br><span class="line">B &gt; A: Flags [S.], seq 4054810353, ack 2, win 65535, length 0</span><br><span class="line">A &gt; B: Flags [.], ack 1, win 8192, length 0</span><br><span class="line">B &gt; A: Flags [R], seq 4054810354, win 0, length 0</span><br></pre></td></tr></table></figure><p>预期的行为是发送一个空的确认：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &gt; B: Flags [S], seq 1, win 8192, length 0</span><br><span class="line">B &gt; A: Flags [S.], seq 3620804602, ack 2, win 65495, length 0</span><br><span class="line">A &gt; B: Flags [.], ack 1, win 8192, length 0</span><br><span class="line">B &gt; A: Flags [.], ack 1, win 65495, length 0</span><br></pre></td></tr></table></figure><p>这与 Linux 的行为是一致的。</p><p>上文发送后，维护者似乎不是很明白，于是我作了如下解释：</p><p>考虑以下 TCP 握手序列：</p><ol><li>套接字 A 向处于 TCP_LISTEN 状态的套接字 B 发送一个 SYN（同步）分段 <code>&lt;CTL=SYN&gt;&lt;SEQ=x&gt;</code>。</li><li>套接字 B 转换为 TCP_SYN_RECV 状态，并以 <code>&lt;CTL=SYN,ACK&gt;&lt;SEQ=y&gt;&lt;ACK=x+1&gt;</code> 进行响应。</li><li>套接字 A 没有发送预期的 <code>&lt;CTL=ACK&gt;&lt;SEQ=x+1&gt;&lt;ACK=y+1&gt;</code> 来完成三次握手，而是错误地发送了 <code>&lt;CTL=ACK&gt;&lt;SEQ=x&gt;&lt;ACK=y+1&gt;</code>。</li></ol><p>根据 RFC 文档，对这种窗口外 ACK 的恰当响应应是一个空的 ACK 分段 <code>&lt;CTL=ACK&gt;&lt;SEQ=y+1&gt;&lt;ACK=x+1&gt;</code>。之后，套接字 B 应等待一个有效的 ACK，或者在必要时重新传输 SYN-ACK。</p><p>然而，在 FreeBSD 当前的实现中，它发送了一个 RST（复位）分段，格式为 <code>&lt;CTL=RST&gt;&lt;SEQ=y+1&gt;</code>，这会 prematurely 终止连接。</p><p>这种行为似乎偏离了 RFC 的指导，并可能导致不必要的连接重置。</p><p>对于窗口不同程度的偏离都观察到了这一现象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. expect seq=2, actual seq=0x80000001</span><br><span class="line">2. expect seq=2, actual seq=0x80000002</span><br><span class="line">3. expect seq=2, actual seq=0x80000003</span><br><span class="line">4. expect seq=2, actual seq=0x90000000</span><br><span class="line">5. expect seq=2000001 (0x1e8481), actual seq=1</span><br><span class="line">6. expect seq=1, actual seq=2000001 (0x1e8481)</span><br><span class="line">All of them, under FreeBSD, give a RST reply. Here is the tcpdump of the first</span><br><span class="line">case.</span><br><span class="line"></span><br><span class="line">A &gt; B: Flags [S], seq 1, win 8192, length 0</span><br><span class="line">    0x0000:  4500 0028 0000 4000 4006 0000 7f00 0001</span><br><span class="line">    0x0010:  7f00 0001 22b9 22b8 0000 0001 0000 0000</span><br><span class="line">    0x0020:  5002 2000 4c6e 0000</span><br><span class="line">B &gt; A: Flags [S.], seq 1643153760, ack 2, win 65535, options [mss</span><br><span class="line">16344], length 0</span><br><span class="line">    0x0000:  4500 002c 0000 4000 4006 0000 7f00 0001</span><br><span class="line">    0x0010:  7f00 0001 22b8 22b9 61f0 8960 0000 0002</span><br><span class="line">    0x0020:  6012 ffff fe20 0000 0204 3fd8</span><br><span class="line">A &gt; B: Flags [.], seq 2147483648, ack 1, win 8192, length 0</span><br><span class="line">    0x0000:  4500 0028 0000 4000 4006 0000 7f00 0001</span><br><span class="line">    0x0010:  7f00 0001 22b9 22b8 8000 0001 61f0 8961</span><br><span class="line">    0x0020:  5010 2000 e10d 0000</span><br><span class="line">B &gt; A: Flags [R], seq 1643153761, win 0, length 0</span><br><span class="line">    0x0000:  4500 0028 0000 4000 4006 0000 7f00 0001</span><br><span class="line">    0x0010:  7f00 0001 22b8 22b9 61f0 8961 0000 0000</span><br><span class="line">    0x0020:  5004 0000 fe1c 0000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C23 标准手册拾遗（四）</title>
      <link href="/20250828-c23/"/>
      <url>/20250828-c23/</url>
      
        <content type="html"><![CDATA[<p>今天想赶快把 ext4 的教程翻完。<code>setjmp</code> 拖一下。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C23 标准手册拾遗（三）</title>
      <link href="/20250827-c23/"/>
      <url>/20250827-c23/</url>
      
        <content type="html"><![CDATA[<p><strong>注意到</strong> enum 可以有 underlying type</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">no_underlying</span> &#123;</span></span><br><span class="line">  a0</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="keyword">_Generic</span>(a0, </span><br><span class="line">        <span class="type">int</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">  );</span><br><span class="line">  <span class="type">int</span> b = <span class="keyword">_Generic</span>((<span class="keyword">enum</span> no_underlying)a0,</span><br><span class="line">        <span class="type">int</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 a 一定是 2，没有 underlying type 的枚举值默认是 int。而 b 是实现定义的：enum 的 underlying type 只要能容纳其枚举值即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">underlying</span> :</span> <span class="type">unsigned</span> <span class="type">char</span> &#123;</span><br><span class="line">  a0</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="keyword">_Generic</span>(a0, </span><br><span class="line">        <span class="type">int</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">  );</span><br><span class="line">  <span class="type">int</span> b = <span class="keyword">_Generic</span>((<span class="keyword">enum</span> no_underlying)a0,</span><br><span class="line">        <span class="type">int</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证一定是 1。</p><p><strong>注意到</strong> restrict qualifier</p><img src="image-20250827013334753.png" alt="image-20250827013334753" style="zoom:50%;"><p>像是一种优化提示，告诉编译器我这些指针指向的内容在函数运行期间不会被其他的任何途径访问到。</p><img src="image-20250827013430592.png" alt="image-20250827013430592" style="zoom:50%;"><p>场景：数组在函数当中不会被访问</p><img src="image-20250827013540660.png" alt="image-20250827013540660" style="zoom:50%;"><p>Restriction：只能从作用域内向外访问。</p><img src="image-20250827013815713.png" alt="image-20250827013815713" style="zoom:50%;"><p>例外是作为返回值：</p><img src="image-20250827014023957.png" alt="image-20250827014023957" style="zoom:50%;"><p>详见 6.7.3.1。大半夜读读剩下来几个例子我有点 <strong>注意力涣散</strong></p><p><strong>注意力涣散</strong> 函数声明</p><img src="image-20250827015649287.png" alt="image-20250827015649287" style="zoom:50%;"><p>我以前还真的没有想过，对数组名取地址到底有什么效果。（其实就是普通的取地址）</p><img src="image-20250827015919054.png" alt="image-20250827015919054" style="zoom:50%;"><img src="image-20250827020340055.png" alt="image-20250827020340055" style="zoom:50%;"><blockquote><p>It’s pointer to <code>int[3]</code>，i.e. <code>int (*)[3]</code></p></blockquote><p>scanf 似乎接受 <code>char s[]</code> 字符串的地址 <code>&amp;s</code>，以及字符串的指针 <code>s</code>。它们只是值相同而类型不同。前者会给出类型不匹配的 warning。</p><p><strong>注意到</strong> 这个可以用来作 C 语言课程的教学内容</p><img src="image-20250827020801413.png" alt="image-20250827020801413" style="zoom:50%;"><p>还是在想，是不是 C 语言课程应该首先科普 “指针” 的概念？然后再教别的。在这之前，首先要介绍 “内存” 是怎么工作的。。。</p><blockquote><p>第一节课，应该是数据：类型和数组——的机器和 C 语言表示，以及少量 io。所有东西都简化到内存中去，不考虑寄存器。</p></blockquote><img src="image-20250827021642377.png" alt="image-20250827021642377" style="zoom:50%;"><p>initializer 也会有踩踏。</p><p><strong>注意到</strong> standard attributes</p><img src="image-20250827021900324.png" alt="image-20250827021900324" style="zoom:50%;"><img src="image-20250827023056250.png" alt="image-20250827023056250" style="zoom:50%;"><p>这看起来很能函数式。还有 <code>[[unsequenced]]</code>。明天来写个详细的。</p><blockquote><p>是不是以后算 <code>fib</code> 都不用记忆化存储的？</p></blockquote><p>–答案是不能。看似这个 attr 只能优化掉编译期可以推导出的参数，而不是动态地 cache 相同参数的结果。testcase：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bar.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> n)</span>[[reproducible]];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo(<span class="number">0</span>) + foo(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有 <code>[[reproducible]]</code> 声明，在编译单元 bar.c 中不知道 <code>foo</code> 是纯函数，为了保留副作用，会进行两次调用。声明之后，有两次 <code>foo(0)</code> 纯函数调用，会被合并为一次。</p><img src="image-20250827205144770.png" alt="结果：只调用了一次" style="zoom:50%;"><p><code>0124 = 84 = 42 + 42</code>。</p><p>如果 <code>foo</code> 的调用参数里有运行期变量的话，就一次也无法优化。具体的例子是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) foo(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) foo(i);</span><br></pre></td></tr></table></figure><p>这样会调用 20 次而不是推导出两个循环里有相同参数的调用。</p><p>要观察到这个现象不能放在一个文件里。否则常量折叠会直接干碎所有调用。另外注意添加 <code>-O2/-O3</code> 优化，毕竟 attr 是为了优化而生的。</p><p>检查编译器是否支持：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(__has_c_attribute(reproducible) == <span class="number">202311L</span>);   <span class="comment">// 写在代码任意位置</span></span><br></pre></td></tr></table></figure><p><strong>注意到</strong> C23 支持了 <code>#embed</code>，编译期嵌入二进制文件。</p><img src="image-20250827215953347.png" alt="image-20250827215953347" style="zoom:50%;"><p>哈哈，数学公式爆了</p><img src="image-20250827220402199.png" alt="image-20250827220402199" style="zoom:50%;"><p>使用例：</p><img src="image-20250827220617836.png" alt="image-20250827220617836" style="zoom:50%;"><p>这个编译期嵌入随机数的例子还挺有意思的：</p><img src="image-20250827220804831.png" alt="image-20250827220804831" style="zoom:50%;"><img src="image-20250827221836799.png" alt="image-20250827221836799" style="zoom:50%;"><p><code>limit</code> 参数将影响 <code>if_empty</code> 的判断。</p><p><strong>注意力涣散</strong> 感觉很复杂的 <code>__VA_OPT__</code> 但是一时不知道该怎么用</p><img src="image-20250827223058235.png" alt="image-20250827223058235" style="zoom:50%;"><img src="image-20250827223249347.png" alt="image-20250827223249347" style="zoom:50%;"><img src="image-20250827223303835.png" alt="image-20250827223303835" style="zoom:50%;"><p>看了第二个例子感觉有点懂了。如果 <code>...</code> 存在的话，就把 <code>__VA_OPT__</code> 的参数放进去。没有的话就不放。</p><p>这不是构造函数吗（？）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> H5A(...) __VA_OPT__(0)<span class="comment">/**/</span>__VA_OPT__(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H5B(X) a ## X ## b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H5C(X) H5B(X)</span></span><br><span class="line">H5C(H5A(<span class="number">1</span>)) <span class="comment">// replaced by a0 1b</span></span><br></pre></td></tr></table></figure><p>最后一个例子换一下，中间就会多一个空格。说明每一个 <code>__VA_OPT__</code> 都会产生一个单独的 pp-tokens 而不是连成一个。</p><p><strong>注意力集中</strong> <code>## == # ## # != ##</code></p><img src="image-20250827225010738.png" alt="image-20250827225010738" style="zoom:50%;"><p><strong>注意到</strong> <code>assert()</code> 将会被 <code>NDEBUG</code> 宏 disable</p><img src="image-20250827231726116.png" alt="image-20250827231726116" style="zoom:50%;"><p>有这样的一个 pragma：</p><img src="image-20250827232634911.png" alt="image-20250827232634911" style="zoom:50%;"><p>可以让用户保证类型安全的情况下用这些公式进行计算。</p><img src="image-20250827233027320.png" alt="image-20250827233027320" style="zoom:50%;"><p>复变反三角函数是一个多值函数。因而要 cut 它的一个解析分支出来</p><img src="image-20250827233051809.png" alt="image-20250827233051809" style="zoom:50%;"><p><code>cacos</code> 剪掉了实轴上 [-1, +1] 以外所有的定义域，只保留主值。 （表达可能不精准，我没咋学过复变）</p><p>其他三角函数也类似。</p><p><strong>注意到</strong> <code>&lt;math.h&gt;</code> 中的函数除非文档显式说明了，否则保证不会抛出 <code>SIGFPE</code></p><img src="image-20250828001650146.png" alt="image-20250828001650146" style="zoom:50%;"><p><strong>?</strong></p><img src="image-20250828003521915.png" alt="image-20250828003521915" style="zoom:50%;"><p><strong>注意到</strong> 这些函数可以对齐浮点数的阶数</p><img src="image-20250828010344968.png" alt="image-20250828010344968" style="zoom:50%;"><p>并有判断函数</p><img src="image-20250828010442529.png" alt="image-20250828010442529" style="zoom:50%;"><p>前面还有函数能够 “返回下一个可表示的数”，大概是用于数值计算一类的应用或者是 debug 浮点实现。</p><p>安全的浮点数比较：</p><img src="image-20250828010718800.png" alt="image-20250828010718800" style="zoom:50%;"><p>明天来开 <code>setjmp.h</code>。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C 赋值运算符条件探讨一则</title>
      <link href="/20250825-compatible/"/>
      <url>/20250825-compatible/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前置知识：至少需要知道 C 语言中的 (<code>const</code>) qualifier 的修饰对象</p></blockquote><p>读 C23 手册读到了赋值运算符下面的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> **cpp;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> c = ’A’;</span><br><span class="line">cpp = &amp;p; <span class="comment">// constraint violation</span></span><br><span class="line">*cpp = &amp;c; <span class="comment">// valid</span></span><br><span class="line">*p = <span class="number">0</span>; <span class="comment">// valid</span></span><br></pre></td></tr></table></figure><p>假如 line 4 的赋值可以执行，那么最终 line 6 会改变 <code>const char c</code> 的值。因此不被允许。</p><p>但是仔细想想其实这件事情有点反直觉。因为 line 4 中，<code>cpp</code> 是 <code>const char **</code>，<code>&amp;c</code> 是 <code>char **</code>。这里 <code>cpp</code> 显然是变量而不是常量，因为 <code>const</code> 修饰的是 <code>char</code>。而且因为右操作数是 <code>char **</code>，因而这个赋值似乎并没有 discard 任何的 qualifier（实际上有）。尽管笔者理解不能使得上面的例子成功执行，这样一种目的上的设计“原因”；但并不明白，是哪几条设计或机制在事实上让这样的程序编译得不到通过。毕竟看起来是这么合理。有多合理呢？看看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. assign char * to const char *</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *c;</span><br><span class="line"><span class="type">char</span> *b;</span><br><span class="line">c = b;   <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. assign char ** to const char **</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> **c;</span><br><span class="line"><span class="type">char</span> **b;</span><br><span class="line">c = b;  <span class="comment">// FAIL</span></span><br></pre></td></tr></table></figure><p>第一个例子看起来无比自然、甚至非常常见，以至于我就算在群友的提示下还是花了很久才弄明白第二个为什么不能通过。</p><p>这是为什么呢？我今天下了班再来写…最后那天晚上一回来就一觉睡到早上了。</p><p>首先我们来介绍一个概念：Compatible Type（兼容类型）</p><p>C 语言标准手册 6.2.7 中说：两种类型是 <em>compatible types</em> 如果它们相同。这一小节里介绍了结构、联合体和枚举类型的 compatible 规则。总结下来就是<strong>一一对应</strong>。可以认为，它们的每个成员必须保持类型 compatible、qualifier 一致、attribute 一致且成员名一致。另外，对于数组类型，有一套独特的规则：</p><img src="image-20250826214926309.png" alt="就不翻译了吧" style="zoom:50%;"><p>总之可以理解为全等。</p><p>在此基础上，在 6.7.6.1 里介绍了指针类型的 compatible 规则：</p><blockquote><p>For two pointer types to be compatible, both shall be identically qualified and both shall be pointers to compatible types.</p></blockquote><p>指针本身的 qualifier 必须全等，并且它们指向的类型需要 compatible。</p><p>在 6.7.3 里介绍了一般类型的 compatible 规则：</p><blockquote><p>For two qualified types to be compatible, both shall have the identically qualified version of a compatible type; the order of type qualifiers within a list of specifiers or qualifiers does not affect the specified type.</p></blockquote><p>两个类型必须表达（不是拥有的 “have”）相等地 qualified 版本的 compatible 类型。比如 <code>const volatile int</code> 和 <code>volatile const int</code>。就是说，顺序可以不一样，但是个数和类型必须一样。</p><p>原文里给了一个极端的例子：</p><img src="image-20250826215843215.png" alt="有 qualifier 就是要用" style="zoom:50%;"><blockquote><p>这里可以看出，<code>const</code> 不一定是常量，而是不应被程序修改的量。</p></blockquote><p>接下来回到今天的例子。</p><p><code>char</code> 和 <code>const char</code> 并不 compatible。因为它们是 compatible type <code>char</code> 的 differently-qualified version。</p><p>因而 <code>char *</code> 和 <code>const char *</code> 并不 compatible。因为它们分别指向 incompatible type <code>char</code> 和 <code>const char</code>。</p><p>因而 <code>char **</code> 和 <code>const char **</code> 并不 compatible。因为它们分别指向 incompatible type <code>char *</code> 和 <code>const char *</code>。</p><p>……</p><p>根据我们的观察，我们不可以把 <code>char</code> 赋值给 <code>const char</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">a = b;  <span class="comment">// FAIL</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> c = b;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>因为 Assignment 表达式的通用约束是：</p><img src="image-20250826224645200.png" alt="Assignment operator constraint" style="zoom:50%;"><blockquote><p>左操作数必须是可修改的左值。</p></blockquote><p>注意到 line 5 的写法是 Initialization（6.7.10）。它由 initdeclarator 构成：</p><img src="image-20250826232839654.png" alt="image-20250826232839654" style="zoom:50%;"><img src="image-20250826233012845.png" alt="image-20250826233012845" style="zoom:50%;"><p>initializer 进一步包含了 Assignment-expression（6.5.16）。但是这个 Assignment 表达式并不一定是带等号的式子，它经过语法单元的分解，最终下降到了 primary-expression。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assignment-expression:</span><br><span class="line">  conditional-expression:</span><br><span class="line">    logical-OR-expression:</span><br><span class="line">      logical-AND-expression:</span><br><span class="line">        inclusive-OR-expression:</span><br><span class="line">          exclusive-OR-expression:</span><br><span class="line">            AND-expression:</span><br><span class="line">              equality-expression:</span><br><span class="line">                relational-expression:</span><br><span class="line">                  shift-expression:</span><br><span class="line">                    additive-expression:</span><br><span class="line">                      multiplicative-expression:</span><br><span class="line">                        cast-expression:</span><br><span class="line">                          unary-expression:</span><br><span class="line">                            postfix-expression:</span><br><span class="line">                              primary-expression:</span><br><span class="line">                                identifier</span><br><span class="line">                                constant</span><br><span class="line">                                string-literal</span><br><span class="line">                                ( expression )</span><br><span class="line">                                generic-selection</span><br></pre></td></tr></table></figure><p>所以，line 5 中的 assignment-expression 其实是 <code>b</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> c       <span class="comment">// declarator</span></span><br><span class="line">    =              <span class="comment">// =</span></span><br><span class="line">  b;               <span class="comment">// initializer -&gt; assignment-expression -&gt; -&gt; .... -&gt; identifier</span></span><br></pre></td></tr></table></figure><p>在初始化当中，</p><img src="image-20250826225221876.png" alt="image-20250826225221876" style="zoom:50%;"><p>规则就和 simple assignment 类似，其中 initializer 取标量类型的 unqualified 版本作为其声明类型。</p><blockquote><p>手册没说聚合类型怎么办，虽然实际上都是推广了的。也有可能是我找错位置了。</p></blockquote><p>我们可以把 <code>char *</code> 赋值给 <code>const char *</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *a;</span><br><span class="line"><span class="type">char</span> *b;</span><br><span class="line">a = b;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>其成立的理由在于，它两侧的类型符合 <strong>Assignment 表达式</strong> 的要求。</p><img src="image-20250826220652853.png" alt="part1" style="zoom:50%;"><img src="image-20250826220727168.png" alt="part2" style="zoom:50%;"><p>此处适应的条件是第三个：</p><blockquote><p>左操作数有 atomic, qualified or not 的指针类型（也就是任意指针），而两个操作数都指向了 <strong>或者是 qualified，或者是 unqualified 版本的</strong> compatible types，其中：左操作数指向的类型拥有右操作数指向的类型拥有的全部 qualifier。</p></blockquote><p>我们依次来看：</p><ul><li>左操作数是指针类型。Good</li><li>左操作数指向了 <code>const</code> qualified 的 <code>char</code> 类型；右操作数指向了 unqualified 的 <code>char</code> 类型。char-char 之间 compatible。且 <code>&#123;const&#125;</code> 包含空集。Good</li></ul><p>因而这个赋值表达式的约束成立。</p><p>再来看主角：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> **a;</span><br><span class="line"><span class="type">char</span> **b;</span><br><span class="line">a = b;  <span class="comment">// FAIL</span></span><br></pre></td></tr></table></figure><ul><li>左操作数是指针类型。Good</li><li>左操作数指向了 unqualified 的 <code>const char *</code> 类型；右操作数指向了 unqualified 的 <code>char *</code> 类型。上文提到，<code>const char *</code> 和 <code>char *</code> 并不 compatible。Bad</li></ul><p>即为这段代码编译不过的形式原因。</p><p><code>char *</code> 的 <code>const</code>-qualified 类型是 <code>char *const</code>。所以可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="type">const</span> *a;</span><br><span class="line"><span class="type">char</span> **b;</span><br><span class="line">a = b;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对四因说的一点解释</title>
      <link href="/20250825-cause/"/>
      <url>/20250825-cause/</url>
      
        <content type="html"><![CDATA[<p>亚里士多德提出了四因说，我在这里给出一解。</p><p>质料因，就是全部矛盾的全部方面，主要是主要矛盾的两个方面。矛盾发展当中有什么样的势力，这些势力强弱如何，在质料上决定了矛盾的发展方向。</p><p>形式因，就是主要矛盾本身。什么样的矛盾存在，就会有什么样的发展。</p><p>动力因，就是推动矛盾发展收敛的那个力量。矛盾本来就有怎样的趋势，但经过这样的推手，矛盾看起来突然有了一个显著的方向。可以说质料因充当了这个矛盾的热力学因素&#x2F;必然性，动力因充当了矛盾发展的动力学因素&#x2F;偶然性。</p><p>目的因，就是这一矛盾最终要扬弃自身的趋势。</p><p>跳跃到精神分析的“断句”实践——我喜欢管这个叫实践而不是技巧、技术。在听到提问原因的时候，其实提问者总是在期待这四种当中的某种，通常是动力因和目的因。这时候其实可以回答前两类原因。</p><p>Q：你为什么要问这个？</p><p>A：因为我最近听说xxx感到有点好奇（动力因）&#x2F; 因为我好奇这件事（目的因）&#x2F; 因为我是一个好奇的人而你看起来知道（质料因）&#x2F; 因为我俩在这总得聊点啥（形式因）</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux ext4 文件系统的最简完整教学（译）持续更新中</title>
      <link href="/20250605-ext4/"/>
      <url>/20250605-ext4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>根据原文要求，本文以 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a> 进行许可。</p><p>原文作者：<a href="https://metebalci.com/">Mete Balci</a></p><p>原文：<a href="https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/">A Minimum Complete Tutorial of Linux ext4 File System</a></p><p>2017 年 8 月 25 日</p><p>翻译：Tilnel @ 2025 年 8 月</p><blockquote><p>为了避免歧义，译文的叙述部分使用 1Ki(B) &#x3D; 1024(B) ，依此类推，而不是原文的 K(B)。</p></blockquote><h2><a href="#yin-yan" class="header-anchor">#</a><span id="yin-yan">引言</span></h2><p>我尽量使用例子简洁而全面地描述 Linux ext4 文件系统。</p><blockquote><p>声明：我不是 ext4 方面的专家。尽管我写这篇文章的目标是使其尽量全面足以理解 ext4 如何工作，但也忽略了很多特性。所以这并不是完整的描述。</p></blockquote><p>我管这个叫做“最小完整教程”是因为我会忽略一些可选的部分，以及一些额外的特性，以此保持简洁。在此基础上全面地描述 ext4 的所有功能。ext4 并不简单，所以完全读完可能需要几个小时。</p><p>我没有按照先后顺序去执行教程中的例子，所以由于文件系统是动态的如果你自己去尝试执行的话，可能得到不一样的结果。不过这并不影响我们理解原理。</p><h2><a href="#xiang-guan-zi-liao" class="header-anchor">#</a><span id="xiang-guan-zi-liao">相关资料</span></h2><p>我参考了 <a href="https://web.archive.org/web/20250321071911/https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">Ext4 Disk Layout documentation</a>，ext4 文件系统在 Linux Kernel 中的源码，e2fsprogs（包括 debugfs 和 dumpe2fs），以及 coreutils 的源码（包括 ls）。</p><h2><a href="#li-shi" class="header-anchor">#</a><span id="li-shi">历史</span></h2><p>从 2010 年开始，ext4 就是 Linux 的默认文件系统，它是 ext2、ext3 的继任者。“ext” 的意思是 “extended”，第一个版本的文件系统就叫这个。在 1992 年左右它被采用了很短一段时间后就被 ext2 取代了。2000 年时，支持文件系统日志的 ext3 也诞生了。</p><h2><a href="#jiao-cheng" class="header-anchor">#</a><span id="jiao-cheng">教程</span></h2><h3><a href="#chuang-jian-ext4-wen-jian-xi-tong" class="header-anchor">#</a><span id="chuang-jian-ext4-wen-jian-xi-tong">创建 ext4 文件系统</span></h3><p>如果你在用 Linux，可能你已经把 ext4 作为你的主文件系统了。不过，为了保护你的文件，我们还是重新创建一块来供我们实验吧。这里我在 &#x2F;dev&#x2F;sda 的一个 U 盘上创建了一个 ext4 文件系统。</p><p>首先我创建了一个包含了一个 Linux 分区的 GUID 分区表（GPT）。如果你对 GPT 和 Logical Block Addressing（逻辑块寻址，LBA）不熟，推荐你先阅读我的这篇文章：<a href="https://metebalci.com/blog/a-quick-tour-of-guid-partition-table-gpt/">A Quick Tour of GUID Partition Table (GPT)</a>。</p><p><strong>小心！使用 fdisk 和 mkfs 的时候要非常非常注意。确保你写入的设备上没有重要数据。</strong></p><p>这是分区表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fdisk /dev/sda</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.27.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 14.9 GiB, 16008609792 bytes, 31266816 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 68B7F722-7E83-47F7-BCCC-2C7591B95E0C</span><br><span class="line"></span><br><span class="line">Device     Start      End  Sectors  Size Type</span><br><span class="line">/dev/sda1   2048 31266782 31264735 14.9G Linux filesystem</span><br></pre></td></tr></table></figure><p>逻辑块 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label=" 这里原文写成了 Logical Block，实际上是 Sector 也就是扇区。注意与 Block 相区别。">[1]</span></a></sup>大小是 512 字节。分区从第 2048 个逻辑块开始，到第 31266782 个逻辑块结束。</p><p>我们就在这个分区上创建文件系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkfs -t ext4 /dev/sda1</span><br><span class="line"></span><br><span class="line">mke2fs 1.42.13 (17-May-2015)</span><br><span class="line"></span><br><span class="line">Creating filesystem with 3908091 4k blocks and 977280 inodes</span><br><span class="line">Filesystem UUID: 5ae73877-4510-419e-b15a-44ac2a2df7c6</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line"> 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208</span><br><span class="line"></span><br><span class="line">Allocating group tables: done                            </span><br><span class="line">Writing inode tables: done                            </span><br><span class="line">Creating journal (32768 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br></pre></td></tr></table></figure><p><code>mkfs</code>，制作文件系统（make file system），通过 <code>-t</code> 指定文件系统，这里是 <code>ext4</code>。<code>mkfs</code> 其实是一个 wrapper，它会根据文件系统调用对应的 <code>mkfs.&lt;fs&gt;</code>。所以这里是 <code>mkfs.ext4</code> 在执行。</p><p>这里我们可以看到：</p><ul><li>一个包含了 3908091 个块的文件系统被创建。</li><li>块大小是 4096 字节，这是自动选择的。我们也可以使用别的块大小。<strong>块大小和逻辑块大小（LBA所使用的）并不一样。这里说的约 4 百万个 “block” 指的是文件系统块而不是逻辑块。</strong></li><li>有 977280 个 “inodes”。我们之后将会了解这个。</li><li>文件系统 UUID 就是 GPT 中的分区 UUID。</li><li>有 group tables，inode tables 和 journal（日志）。</li><li>最后有一个统计数据。我在 mkfs 的源码中找了找，发现它实际上也就写了一些文件系统信息。所以文章也不会特别提到。</li></ul><p>文章将会解释所有这些和相关概念。</p><h3><a href="#superblock" class="header-anchor">#</a><span id="superblock">Superblock</span></h3><p>我们从 Superblock 开始，因为它是包含了文件系统基本信息的一片位置固定的区域。我们可以使用 <code>dumpe2fs</code> 的 <code>-h</code> 仅打印 Superblock 选项来导出其内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dumpe2fs -h /dev/sda1</span><br><span class="line"></span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          &lt;not available&gt;</span><br><span class="line">Filesystem UUID:          8eefa5bb-858c-4bd0-b80d-1aebc23de317</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              977280</span><br><span class="line">Block count:              3908091</span><br><span class="line">Reserved block count:     195404</span><br><span class="line">Free blocks:              3804437</span><br><span class="line">Free inodes:              977269</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Reserved GDT blocks:      954</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8144</span><br><span class="line">Inode blocks per group:   509</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Wed Aug 23 11:20:00 2017</span><br><span class="line">Last mount time:          n/a</span><br><span class="line">Last write time:          Wed Aug 23 11:20:00 2017</span><br><span class="line">Mount count:              0</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Wed Aug 23 11:20:00 2017</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          132 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:               256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      648ce1ac-dd8d-40a6-ac6f-238b2e7d97d1</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         (none)</span><br><span class="line">Journal size:             128M</span><br><span class="line">Journal length:           32768</span><br><span class="line">Journal sequence:         0x00000001</span><br><span class="line">Journal start:            0</span><br></pre></td></tr></table></figure><p>这边信息非常多，我会解释其中的大部分。</p><p>ext4 最基础的存储布局概念就是 Block（块）。ext4 以块为单位分配存储空间，就像是 LBA 一样。然而 ext4 Block 大小可能不一样。在 Superblock 中是 4096B &#x3D; 4KiB。文件系统中的 Block 总数是 3908091 个。</p><p>第二个概念是 Block Group（块组），也就是固定数量的连续的块。在我们的文件系统中 Group 大小是 32768 &#x3D; 32Ki。</p><p>我们有 3908091 个block。将其除以 32Ki:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3908091 / 32768 = 119, 因为它不是 32Ki 的整数倍,</span><br><span class="line">所以还会有一个比 32Ki Block 小的 Group。</span><br></pre></td></tr></table></figure><p>所以我们有 119 个 32K Blocks 的 Groups 和一个小的 Group。每个 Block 是 4KiB。由于每个逻辑块（扇区）是 512B，这意味着每个块有 8 个扇区。这就是 ext4 的基本存储安排，如下图所示。</p><p><img src="ext4-block-group-blocks-logical-blocks.png" alt="1 Block Group &#x3D; 32768 File System Blocks &#x3D; 32768 * 8 Logical (Storage) Blocks"></p><p>每一个块组都包含：</p><ul><li>Superblock，包含文件系统的信息。位于每组的第一个块。</li><li>（块）组描述符（表）【(Block) Group Descriptors (Table)】包含了数据块 Bitmap，inode Bitmap 和 inode Table 在块组中的位置。每个块组都有一个组描述符。根据组大小的不同，它有可能占据一块或多个块，并且总是跟在 Superblock 后面。</li><li>预留的<strong><em>组描述符表</em> 块</strong>。这些是为了未来扩展文件系统的时候预留的。ext4 文件系统的大小可以调整，如果是扩展的话，就意味着有更多的块，更多的块组。更多的组描述符就需要空间。通常是紧跟在 GDT 后的 0 或更多个 block。<code>rezise_inode</code>（在 Superblock 的 Filesystem features 中）标志了预留存在与否。</li><li>数据块 Bitmap。标识了哪些数据块已经被使用了。它占据一个 block，位置不固定，在组描述符中指定。</li><li>inode Bitmap。标识了 inode Table 中的哪些项（entries）已经被使用了。它占据一到多个 blocks（经常是多个）并且位置不固定，由组描述符指定。</li><li>数据 Blocks。包含了实际的文件内容。占据一到多个 blocks。块组里除去上文所述，剩下的 block 都属于这部分。</li></ul><p>在 Bitmap 中，每一个 bit 都标识了一个对应的 block&#x2F;inode 的使用情况。由于 Bitmap 占据 1block &#x3D; 4KiB  &#x3D; 32Kibits，故而块组中至多可以有 32Ki 个 blocks——事实上也是这样。并且，一个块组中最多可以有 32Ki 个 inodes，但上面的 Superblock 信息表示，我们只有 8144 个。</p><p>再回头看看 Superblock：</p><ul><li>预留的 GDT 块有 954 个。用作未来文件系统的扩展。</li><li>每组的 inode block 有 509 个。这个数字与 inode size 以及每组的 inode 数量紧密相关。注意到 $256 B * 8144 &#x2F; 4096 B &#x3D; 509$。</li></ul><p>目前为止我们还没有看到 ext4 文件系统布局的全貌。Superblock 的 Filesystem features 中还有两个至关重要的标志在影响着布局：<code>sparse_super</code> 和 <code>flex_bg</code>。</p><h3><a href="#superblock-backups" class="header-anchor">#</a><span id="superblock-backups">Superblock Backups</span></h3><p>Superblock 包含了文件系统的重要信息，丢失就等于文件系统完全损坏了。因而在设计的时候，这些 Superblock 在每个块组当中都有备份，或者说是冗余。然而这可能有点多了，比如在我们的例子中，其实是一个很小的文件系统，120 个块组难道真的要有 120 个备份吗？<code>sparse_super</code> 就标志了这样一件事，即只有少量块组存在 Superblock 的备份，特别是 0 号块组，以及编号为 3, 5, 7 的幂次的块。</p><p>对于我们的这个案例，从 0 到 119 号块组，以下的块组是包含了冗余的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 7 9 25 27 49 81</span><br></pre></td></tr></table></figure><p>如果我们把每个数都乘上 32768 (&#x3D;32Ki， 每组的块数)，就得到了 mkfs 输出过的 Superblock 的备份块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32768 98304 163840 229376 294912 819200 884736 1605632 2654208</span><br></pre></td></tr></table></figure><p><code>sparse_super</code> 也会影响组描述符。在默认情况下，组描述符在每个块组中都会有。但如果 <code>sparse_super</code> 被标记，组描述符就只会出现在上列含有 Superblock backup 的块组中。可以认为 Superblock 和组描述符总是在一起。</p><h3><a href="#kuai-zu-he-dan-xing-kuai-zu-flexible-block-groups" class="header-anchor">#</a><span id="kuai-zu-he-dan-xing-kuai-zu-flexible-block-groups">块组和弹性块组（Flexible Block Groups）</span></h3><p>另一个标志 <code>flex_bg</code> 代表 Flexible Block Groups，也就是弹性块组。这个特性是在 ext4 引入的。FlexBG 简单来说就是块组之上的一级管理，也就是“块组的组”，它把整个大组内所有块组的数据块 bitmap、inode bitmap 和 inode table 都聚合在第一个块组中。</p><p>继续观察之前的 Superblock，可以发现 FlexBG 大小是 16，所以每 16 个连续的块组就打包成一整个弹性组。每个弹性组的第一个块组就会包含下辖所有块组的数据块 bitmap，inode bitmap 和 inode table。</p><p>我们有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120 / 16 = 7 ... 8， 7 个 16BG 和 1 个 8BG 的 FlexBG </span><br></pre></td></tr></table></figure><blockquote><p>注意：我们这里并没有 <code>meta_bg</code> 的 feature。这个 feature 对于块组的安排又是不一样的。</p></blockquote><p>为了理解块组的内容，我认为大体可以将其简化为 3 类（请理解这只是我的描述方式，而不是官方的分类）：</p><ul><li>Type 1a（在 Block Size &#x3D; 1024B 情况下的 0 号块组，Block 0）：Block 0 被标记为使用但实际没有使用（因而前 1024B 都没有被使用）。Block 1 包含了 primary Superblock（主 Superblock，对应备-backup）。接下来是连续的组描述符块和预留的组描述符块。后面和 Type 3 相同。</li><li>Type 1b（在 Block Size &gt; 1024B 情况下的 Block 0）：Block 0 的首部 1024B 作为 padding，没有被使用。从 1024B 的偏移量开始，是 primary Superblock。接下来与 1a 相同。</li><li>Type 2：包含了 Superblock 和组描述符备份的块组。Block 0 是 Superblock，接下来与 Type 1a 相同。</li><li>Type 3：不包含 Superblock 和组描述符备份的块组。可能包含数据块 Bitmap，inode Bitmap，inode Table，以及数据块。Bitmap 和 inode Table 的位置在组描述符中记录，所以顺序可能有变。</li></ul><p>Block 0 首部的 1024B 可能被用作启动码，因而 ext4 不会使用它。</p><p>Superblock 中标识了 “First block value”。它只有在 Block Size &#x3D; 1024 B 的时候才等于 1。其他时候都等于 0。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkfs -t ext4 -b 1024 /dev/sda</span><br><span class="line">$ sudo dumpe2fs -h /dev/sda1 | grep <span class="string">&quot;First block&quot;</span></span><br><span class="line"></span><br><span class="line">First block:              1</span><br></pre></td></tr></table></figure><p>在我们的例子中：</p><ul><li>Type 1b 的 Block Group 有 1 个（0）</li><li>Type 2 的有 9 个（包含了 Superblock 冗余的块）</li><li>剩下全部 110 个都是 Type 3</li></ul><p>当设置了弹性块组的时候，这些每类块组又分为两类，因为在弹性块组中只有第一个<strong>块组</strong><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Error：原文此处是 “since only the first block of Flex Group...” 应为 “first block group of” </br> Warning：文章证明了 1 总是 head，接下来又要证明 2 不可能是 head。说实话应该首先论证这两个不可能，然后提出 Type 3 可以划分，而不是先划出 3 个新的再取消其中两种。看的头昏。">[2]</span></a></sup>中才有 Bitmaps 和 inode Table。这里我会将它们命名为 Type 2-head &#x2F; Type 2-rest，以此类推。Type 1 总是 head，因为它总是 Flex BG 中的 0 号。</p><p>同时，Type 2-head 块组是不可能的。因为备份块的序号总是 <code>3, 5, 7</code> 这些奇数。而 Flex BG 的 size 总是 2 的乘方，也就是偶数，意味着其头部块组的序号也总是偶数。所以 Type 2 作为备份快，不可能位于 Flex BG 的头部。</p><p>现在我们已经完全搞清楚我们的 ext4 文件系统的块组和块的排布了。事实上我们可以用 <code>dumpe2fs</code> 输出所有 Block Groups 的信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dumpe2fs /dev/sda1 &gt; dump</span><br></pre></td></tr></table></figure><p>由于包含了所有块组（120个）的信息，文件会很长。下面逐一地去介绍。</p><hr><p>第一个块组（Block Group 0）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]</span><br><span class="line">  Checksum 0x9a88, unused inodes 8131</span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-1</span><br><span class="line">  Reserved GDT blocks at 2-955</span><br><span class="line">  Block bitmap at 956 (+956), Inode bitmap at 972 (+972)</span><br><span class="line">  Inode table at 988-1496 (+988)</span><br><span class="line">  23630 free blocks, 8133 free inodes, 2 directories, 8133 unused inodes</span><br><span class="line">  Free blocks: 9138-32767</span><br><span class="line">  Free inodes: 12-8144</span><br></pre></td></tr></table></figure><p>正如我们所知道的：</p><ul><li>它包括了 0-32767 号块，因为每个块组有 32Ki Blocks</li><li>Block 0 包含了 Superblock</li><li>Block 1 包含了组描述符（且只有 Block 1 有）</li><li>Block 2-955 是预留的 GDT Blocks</li><li>Block 956 是数据块 Bitmap</li><li>Block 972 是 Inode Bitmap（我们后面再解释为什么不是 957）</li><li>Block 988-1496 是 inode table。$1496 - 988 + 1 &#x3D; 509$，刚好和 Superblock 的信息对得上</li></ul><p>也有不用 <code>dumpe2fs</code> 的办法，那就是手动解析磁盘的数据。</p><p>组描述符是从第二个 block 开始的，所以我们用 <code>dd bs=4096 skip=1</code>。前三个 32 位的数是数据块 Bitmap、inode Bitmap 和 inode Table 的位置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda1 bs=4096 skip=1 count=1 status=none | hexdump -n 12 -s 0 -e <span class="string">&#x27;&quot;%d %d %d\n&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">956 972 988</span><br></pre></td></tr></table></figure><p>块组 0 在本文的分类学下是 Type 1b (head)。</p><hr><p>第二个块组（Block Group 1）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Group 1: (Blocks 32768-65535) [INODE_UNINIT, ITABLE_ZEROED]</span><br><span class="line">  Checksum 0x5017, unused inodes 8144</span><br><span class="line">  Backup superblock at 32768, Group descriptors at 32769-32769</span><br><span class="line">  Reserved GDT blocks at 32770-33723</span><br><span class="line">  Block bitmap at 957 (bg #0 + 957), Inode bitmap at 973 (bg #0 + 973)</span><br><span class="line">  Inode table at 1497-2005 (bg #0 + 1497)</span><br><span class="line">  31809 free blocks, 8144 free inodes, 0 directories, 8144 unused inodes</span><br><span class="line">  Free blocks: 33726-33791, 33793-65535</span><br><span class="line">  Free inodes: 8145-16288</span><br></pre></td></tr></table></figure><ul><li>它有 Superblock backup。因为 $ 1 &#x3D; 3 ^ 0$</li><li>因为有 Superblock backup，所以也有组描述符和预留的块</li><li>它在事实上没有数据块 Bitmap，inode Bitmap 和 inode Table。这些都引用了 Block Group 0 中的（e.g. Block Group 1 的数据块 Bitmap 在 bg #0 + 957）因为 Block Group 1 和 0 在同一个 Flex BG 中。inode Bitmap 和 inode Table 同理。这也就是为什么在 Block Group 0 中，数据块 Bitmap 和 Inode Bitmap 并不是连续的区域了。一个从 956 开始，一个从 972 开始，中间就是 16 Blocks，它们包含了所有块组的数据块 Bitmap 信息（从 0 到 15，$[956, 972)$）。以此类推，inode Bitmap 就是 $[972, 988)$，inode Tables 就是 $[988, 9132)$ (<code>989 + 16 × 509 = 9132</code>)</li></ul><blockquote><p>这里我有点困惑，也许你也有点感觉。在 Block Group 0 中，为什么 inode Table 在 9132 结束，但是可用空间从 9138 开始呢？其实 9132-9137 是已经在使用的数据块。所以这里并没有什么特别的怪事发生。如果重复实验的话，可能会得到不一样的结果。</p></blockquote><blockquote><p>所以在概念上我们其实不能说数据块在遵守这些元数据规定的结构，而是所有的块都是数据块，只不过有一些用来存储元数据了。存储元数据的块在数据块 Bitmap 中也是要被标记使用的。</p></blockquote><p>Block Group 1 在本文的分类学里面是 Type 2-rest。它有 Superblock 备份，但不是弹性块组的第一个（因此没有 Bitmaps 和 inode Table）。</p><hr><p>接下来是 Block Group 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Group 2: (Blocks 65536-98303) [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]</span><br><span class="line">  Checksum 0xeabf, unused inodes 8144</span><br><span class="line">  Block bitmap at 958 (bg #0 + 958), Inode bitmap at 974 (bg #0 + 974)</span><br><span class="line">  Inode table at 2006-2514 (bg #0 + 2006)</span><br><span class="line">  32768 free blocks, 8144 free inodes, 0 directories, 8144 unused inodes</span><br><span class="line">  Free blocks: 65536-98303</span><br><span class="line">  Free inodes: 16289-24432</span><br></pre></td></tr></table></figure><ul><li>没有 Superblock backup。也没有 GDT、RGDT（组描述符表和预留）</li><li>Bitmaps 和 inode Table 都在 BG #0</li></ul><p>BG #2 属于 Type 3-rest。</p><hr><p>接下来我们看看在下一个 Flex BG 的 BG #16：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Group 16: (Blocks 524288-557055) [INODE_UNINIT, ITABLE_ZEROED]</span><br><span class="line">  Checksum 0x8ab4, unused inodes 8144</span><br><span class="line">  Block bitmap at 524288 (+0), Inode bitmap at 524304 (+16)</span><br><span class="line">  Inode table at 524320-524828 (+32)</span><br><span class="line">  24592 free blocks, 8144 free inodes, 0 directories, 8144 unused inodes</span><br><span class="line">  Free blocks: 532464-557055</span><br><span class="line">  Free inodes: 130305-138448</span><br></pre></td></tr></table></figure><ul><li><p>没有 Superblock backup。也没有 GDT、RGDT（组描述符表和预留）</p></li><li><p>存储了 Flex BG 中所有 BG（#16-#31）的 Bitmaps 和 inode Tables</p></li></ul><p>BG #16 属于 Type 3-head.</p><blockquote><p>到这里，所有的分类都看过一遍了。</p></blockquote><blockquote><p>上面每个组的第一行最后都有几个 flag，它们通过节省初始化的时间来加速 mkfs 。</p><p> <code>INODE_UNINIT</code><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="原文下面这段描述是错的。这里改过来了。原文如下：</br>INODE_UNINIT: inode Bitmap is not zeroed, because it can be calculated on-the-fly (e.g. no inodes are used so all of them are free).</br>ITABLE_ZEROED: inode Bitmap is zeroed.</br>BLOCK_UNINIT: Data Block Bitmap is not zeroed. (e.g. no data stored so all of them are free).">[3]</span></a></sup>：inode Table 不清零。在被使用的时候，它们会自然地被覆盖。</p><p><code>ITABLE_ZEROED</code>：inode Bitmap 会被清零。它们标识了 inode Table 中的使用情况，所以是必须初始化的。</p><p><code>BLOCK_UNINIT</code>：数据块未初始化。等到有数据来的时候直接覆盖就好。</p><p>这其实就是懒惰初始化。</p><p>这些特性是被 filesystem feature <code>uninit_bg</code> 决定的。参见 Superblock。</p></blockquote><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这里原文写成了 Logical Block，实际上是 Sector 也就是扇区。注意与 Block 相区别。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Error：原文此处是 “since only the first block of Flex Group...” 应为 “first block group of” <br> Warning：文章证明了 1 总是 head，接下来又要证明 2 不可能是 head。说实话应该首先论证这两个不可能，然后提出 Type 3 可以划分，而不是先划出 3 个新的再取消其中两种。看的头昏。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">原文下面这段描述是错的。这里改过来了。原文如下：<br>INODE_UNINIT: inode Bitmap is not zeroed, because it can be calculated on-the-fly (e.g. no inodes are used so all of them are free).<br>ITABLE_ZEROED: inode Bitmap is zeroed.<br>BLOCK_UNINIT: Data Block Bitmap is not zeroed. (e.g. no data stored so all of them are free).<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C23 标准手册拾遗（二）</title>
      <link href="/20250824-c23/"/>
      <url>/20250824-c23/</url>
      
        <content type="html"><![CDATA[<p><strong>注意到</strong> 预处理器需要总是识别当前可识别的最长的词法单元。</p><img src="image-20250824043459739.png" alt="image-20250824043459739" style="zoom:50%;"><p>比如 <code>1Ex</code> （科学记数法）它并不是 token 但是是 preprocessing token。它被识别为预处理数。即使 <code>Ex</code> 有宏定义且最终生成有效的表达式，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> E1 + 1</span></span><br><span class="line"><span class="number">1E1</span>  <span class="comment">// = 1, instead of 1 + 1</span></span><br></pre></td></tr></table></figure><p>比如 <code>x+++++y</code>，被划分为 <code>x++ ++ +y</code>，即使这不符合语法；如果划分为 <code>x++ + ++y</code> 有可能语法上成立，但是词法划分并不鸟你。</p><img src="image-20250824044558283.png" alt="有图有真相" style="zoom:50%;"><p><strong>注意到</strong> 现在这些全都是关键字了</p><img src="image-20250824044707568.png" alt="仙之人兮列如麻" style="zoom:50%;"><p>回顾 C17 标准，是这样的：</p><img src="image-20250824044843818.png" alt="image-20250824044843818" style="zoom:50%;"><p>主要变化大概是新增了 <code>constexpr</code> <code>true</code> <code>false</code> <code>typeof</code> <code>typeof_unqual</code> <code>nullptr</code> 这 6 个。剩下的就是改了改大小写。</p><p>首先是两个布尔常量宏定义进关键字了，以前需要 <code>#include &lt;stdbool.h&gt;</code>。另外现在有 <code>nullptr</code>。我打开编辑器看了一下 <code>nullptr</code> 不能跳转所以首先不是标识符了。值这块应该是 0 吧。。。</p><p><code>typeof</code> 就是推导表达式的类型；<code>typeof_unqual</code> 应该是推导之后取消 qualifier 吧。这似乎早就是 gcc 的特性了。因为我看 kernel 早就有了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux/container_of.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of_const(ptr, type, member)                           \</span></span><br><span class="line"><span class="meta">        _Generic(ptr,                                                   \</span></span><br><span class="line"><span class="meta">                const typeof(*(ptr)) *: ((const type *)container_of(ptr, type, member)),\</span></span><br><span class="line"><span class="meta">                default: ((type *)container_of(ptr, type, member))      \</span></span><br><span class="line"><span class="meta">        )</span></span><br></pre></td></tr></table></figure><p><strong>注意到</strong> 标准内预定义的标识符只有一个</p><img src="image-20250824052359973.png" alt="image-20250824052359973" style="zoom:50%;"><p>这一集应该还是很经典了。不过什么叫 lexically-enclosing？</p><p><strong>注意到</strong> _BitInt 字面量的后缀是 <code>wb</code></p><img src="image-20250824053242971.png" alt="image-20250824053242971" style="zoom:50%;"><p>_BitInt 字面量会自己寻找出路，按照无负号的部分以及有无符号给自己安一个最小的家。</p><img src="image-20250824053621136.png" alt="image-20250824053621136" style="zoom:50%;"><p><strong>注意到</strong> 在浮点字面量的数字序列当中可以插入单引号。</p><img src="image-20250824054059760.png" alt="image-20250824054059760" style="zoom:50%;"><p>大概是作为一种分隔符，不太懂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> a = <span class="number">120&#x27;000&#x27;000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, a);  <span class="comment">/* 120000000.000000 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意到</strong> 有不同宽度的字符类型</p><img src="image-20250824194746264.png" alt="image-20250824194746264" style="zoom:50%;"><p>它们的字面量也有不同的写法。这里我就懒加载了。</p><p><strong>注意到</strong> digraphs</p><img src="image-20250824195138511.png" alt="image-20250824195138511" style="zoom:50%;"><p><strong>注意到</strong> Generic selection</p><img src="image-20250824214658046.png" alt="image-20250824214658046" style="zoom:50%;"><img src="image-20250824214710684.png" alt="image-20250824214710684" style="zoom:50%;"><p>这允许了某种程度上的 <strong>多态</strong></p><img src="image-20250824215043310.png" alt="我大为震撼" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C23 标准手册拾遗（一）</title>
      <link href="/20250823-c23/"/>
      <url>/20250823-c23/</url>
      
        <content type="html"><![CDATA[<blockquote><p>进行一个通读</p></blockquote><p><strong>注意到</strong> 空指针 deref 是 undefined behavior。曾经在 gcc 中遇到过因为分析出空指针导致整个函数体被优化的情况。我现在 -O0 用多了已经忘了这些东西了。</p><img src="image-20250823122854969.png" alt="image-20250823122854969" style="zoom:50%;"><p><em><strong>shall</strong></em> be a null pointer。如果不是，那就是有问题的…</p><p><strong>注意到</strong> <code>char **argv</code> 是被允许的写法</p><img src="image-20250823123055486.png" alt="image-20250823123055486" style="zoom:50%;"><p>所以，这些参数都不是 constant。似乎不应该写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure><img src="image-20250823124501357.png" alt="image-20250823124501357" style="zoom:50%;"><p>编译优化的基础：只要可观测行为以及跨单元函数调用的结果与抽象语义一致。当然也可以像 E1 一样，<em><strong>Serializable</strong></em>。</p><img src="image-20250823125336800.png" alt="image-20250823125336800" style="zoom:50%;"><p>如果能推导出用 Float 和 Double 出来的结果一样，那么大可以用 Float，虽然这经典不可能；</p><p>浮点计算通常不能改变顺序。</p><img src="image-20250823125648799.png" alt="image-20250823125648799" style="zoom:50%;"><img src="image-20250823125922490.png" alt="image-20250823125922490" style="zoom:50%;"><p><strong>有符号整数</strong> int 的加法受到溢出的影响，也不能随意改变顺序。底层原因是：</p><blockquote><p>有符号整数的加法溢出结果是未定义行为。</p></blockquote><p>例子就是说，overflow 产生了一个 trap。我们必须设想这种行为在某些平台上是可能的。</p><img src="image-20250823131606072.png" alt="image-20250823131606072" style="zoom:50%;"><p>。。。</p><img src="image-20250823141448783.png" alt="image-20250823141448783" style="zoom:50%;"><img src="image-20250823140009503.png" alt="image-20250823140009503" style="zoom:50%;"><p><strong>注意到</strong> 一辈子没用过的浮点数定义 （<code>float.h</code> ），以及十进制浮点数类型 _Decimal32&#x2F;64&#x2F;128</p><img src="819f991d4304d7d639fe911d37b25391.png" alt="img" style="zoom:50%;"><p>居然真的准…而且可以显式转换</p><p>注意正常 gcc 是有针对十进制浮点数的格式化描述符扩展的。十进制浮点是 c23 吸收 gcc 的。然而你需要在configure gcc 的时候 <code>--enable-decimal-float</code> 才可以正常使用 printf。可以这样判断：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v 2&gt;&amp;1 | grep <span class="string">&quot;\-\-enable\-decimal\-float&quot;</span></span><br></pre></td></tr></table></figure><p>没结果就烂了</p><blockquote><p>Decimal floating types are a conditional feature that implementations need not support; see 6.10.9.3.</p></blockquote><p><strong>注意到</strong> stdc 早就有 <code>thread.h</code>  了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">thrd_create</span> <span class="params">(<span class="type">thrd_t</span> *__thr, <span class="type">thrd_start_t</span> __func, <span class="type">void</span> *__arg)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">thrd_join</span> <span class="params">(<span class="type">thrd_t</span> __thr, <span class="type">int</span> *__res)</span>;</span><br></pre></td></tr></table></figure><p>用了一辈子 pthread</p><p><strong>注意到</strong> C 语言有复数类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_complex</span><span class="params">(<span class="type">float</span> <span class="type">complex</span> z)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%f%+f*i\n&quot;</span>, crealf(z), cimagf(z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">float</span> <span class="type">complex</span> a = <span class="number">3</span> + <span class="number">4</span>i;</span><br><span class="line">  <span class="type">float</span> <span class="type">complex</span> b = <span class="number">4</span> + <span class="number">3</span>i;</span><br><span class="line">  print_complex(a + b);</span><br><span class="line">  print_complex(a - b);</span><br><span class="line">  print_complex(a * b);</span><br><span class="line">  print_complex(a / b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.000000+7.000000*i</span><br><span class="line">-1.000000+1.000000*i</span><br><span class="line">0.000000+25.000000*i</span><br><span class="line">0.960000+0.280000*i</span><br></pre></td></tr></table></figure><p><strong>注意到</strong> C 语言已经引入了  _BitInt 类型。我这里最大支持到 65535 位，似乎再也不用高精了。但是输入输出支持是个问题</p><p>但是，<strong>注意到</strong> 可以定义 printf specifier</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;printf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">register_printf_specifier</span><span class="params">(<span class="type">int</span> spec, printf_function func,</span></span><br><span class="line"><span class="params">                                     printf_arginfo_size_function arginfo)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">register_printf_modifier</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span> *str)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">register_printf_type</span><span class="params">(printf_va_arg_function fct)</span>;</span><br><span class="line"></span><br><span class="line">   Callbacks</span><br><span class="line">       <span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">printf_function</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="keyword">struct</span> printf_info *info,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> <span class="type">void</span> *<span class="type">const</span> args[])</span>;</span><br><span class="line">       <span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">printf_arginfo_size_function</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> printf_info *info,</span></span><br><span class="line"><span class="params">                                     <span class="type">size_t</span> n, <span class="type">int</span> argtypes[n], <span class="type">int</span> size[n])</span>;</span><br><span class="line">       <span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">printf_va_arg_function</span><span class="params">(<span class="type">void</span> *mem, va_list *ap)</span>;</span><br></pre></td></tr></table></figure><p>我的建议是，可以提前写好一套框架，并在要使用的时候填空。</p><p><strong>注意到</strong> <code>printf</code> 的 <code>%n</code> 格式化说明符：将当前 printf 的已输出字节数写入指针位置。</p><blockquote><p><strong>格式化字符串漏洞</strong>：如果一个程序允许用户输入格式化字符串，并且没有进行过滤，恶意用户可以利用 <code>%n</code> 来进行<strong>任意地址写入</strong>。攻击者可以传递一个格式化字符串，例如 <code>&quot;%100$n&quot;</code>，这会尝试将一个值写入堆栈上第 100 个参数的位置。如果这个位置正好是攻击者想要覆盖的内存地址，就可以用来修改程序行为或执行恶意代码。</p></blockquote><p><strong>注意到</strong> 现在有 nullptr_t type。需要 <code>#include &lt;stddef.h&gt;</code> 。用 clangd 分析器的时候一定要加上 -std&#x3D;c23 才有</p><img src="image-20250823214635623.png" alt="image-20250823214635623" style="zoom:50%;"><p><strong>注意力涣散</strong><br>$$<br>\begin{align}<br>\text{Standard floating types} &#x3D; &amp; float, \\ &amp;double,\\ &amp;long\ double<br>\end{align}\\<br>$$</p><p>$$<br>\begin{align}<br>\text{Decimal floating types} &#x3D; &amp;\_Decimal32, \\ &amp;\_Decimal64, \\ &amp;\_Decimal128<br>\end{align}\\<br>$$</p><p>$$<br>\begin{align}<br>\text{Real floating types} &#x3D; \text{Standard floating types} \cup \text{Decimal floating types}\\<br>\end{align}\\<br>$$</p><p>$$<br>\begin{align}<br>\text{Complex types} &#x3D; &amp;float\ \_Complex, \\&amp;double\ \_Complex, \\&amp;long\ double\ \_Complex\\<br>\end{align}\\<br>$$</p><p>$$<br>\begin{align}<br>\text{Floating types} &#x3D; \text{Real floating types} \cup \text{Complex types}\\<br>\end{align}\\<br>$$</p><p>$$<br>\text{Corresponding real type}(float) &#x3D; float\\<br>\text{Corresponding real type}(\_Decimal32) &#x3D; \_Decimal32\\<br>\text{Corresponding real type}(float\ \_Complex) &#x3D; float\\<br>…<br>$$</p><p>接下来介绍了这些类型的对齐之类的。</p><p>还有更多的变量分类学我懒得弄了，搞了一堆名词（</p><p>构造 derived（衍生？派生？）类型的方法有：数组、结构、联合、函数、指针、_Atomic (这个居然算衍生类型）</p><p>浮点类型（当然，包括实浮点和复浮点）和整数类型（单包括一个 char）构成算数类型（Arithmetic），这些再与单独的空指针类型 <code>nullptr_t</code> 和指针类型统称为<strong>标量类型</strong>。数组和结构联合都是<strong>聚合类型</strong></p><blockquote><p>。。为什么我要热衷于这种概念背诵的东西，是因为名词罗列整理起来很爽吗，感觉有点收集癖</p></blockquote><p><strong>注意到</strong> 分析器经常报的类型不完整（incomplete type）是有严格定义的。</p><img src="image-20250823224903011.png" alt="image-20250823224903011" style="zoom:50%;"><p><strong>注意到</strong> 这些是 qualifier。qualified type 和 unqualified type 有相同的表达和对齐但是是不同的类型。</p><img src="image-20250823225343005.png" alt="image-20250823225343005" style="zoom:50%;"><p>但 <code>_Atomic</code> 不一样….</p><img src="image-20250823225535141.png" alt="image-20250823225535141" style="zoom:50%;"><p>居然可以有不同的表达和类型。我感觉很难受。想想可能会添加一些保证原子操作需要的的 attr 之类吧。甚至附加一个锁在里面都有可能呢？</p><p>gemini老师说：</p><blockquote><p>举个例子，假设你有一个64位的整型变量，但在一个32位的计算机上，读取这个变量需要两次内存操作：先读取低32位，再读取高32位。如果在两次操作之间，另一个线程修改了这个变量，那么当前线程就会读到一个被损坏的、不完整的值。</p><p>为了防止这种情况，编译器在处理 <code>_Atomic</code> 变量时，可能会采取以下措施：</p><ul><li><strong>添加填充（Padding）</strong>：编译器可能会在变量周围添加额外的空间，以确保该变量在内存中是<strong>对齐</strong>的。这种对齐方式允许硬件在一个单一、不可中断的指令中完成对该变量的读或写。这会改变变量的<strong>大小</strong>和<strong>对齐方式</strong>。</li><li><strong>改变表示方式（Representation）</strong>：为了使用特定的硬件原子指令（例如 <code>compare-and-swap</code>），编译器可能会为原子变量使用一种不同的内部表示形式。这种新的表示形式可能与原始的非原子类型不同。</li><li><strong>使用锁（Locks）</strong>：如果一个数据类型太大，硬件无法一次性进行原子操作，编译器可能会退而求其次，使用内部的锁机制。这虽然不会改变变量的大小，但它从根本上改变了变量的访问方式，这也是其“表示方式”的一部分。</li></ul></blockquote><p>关于 qualifier…</p><img src="image-20250823230138641.png" alt="image-20250823230138641" style="zoom:50%;"><p>const 修饰的是它前面的类型。如果 const 在开头，才修饰后面的。</p><img src="image-20250823230951227.png" alt="image-20250823230951227" style="zoom:50%;"><p>比如多个编译单元里，对同一个符号进行多次声明但类型不兼容。结果是未定义的。</p><img src="image-20250823231417146.png" alt="image-20250823231417146" style="zoom:50%;"><p>神秘的<strong>合成大类型</strong>。while 我想说，其实编译器一般不会管两个编译单元对一个类型声明不一样，之类的事。大概是标准的特色吧</p><p><strong>注意力涣散</strong>  整数类型居然有精度，但实际上就是位宽</p><img src="image-20250823232156830.png" alt="image-20250823232156830" style="zoom:50%;"><p>类型提升规则大致就是 Decimal &gt; Floating &gt; Integer，不同宽的 integer 选更宽，同宽有 unsigned 选 unsigned</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_BitInt(<span class="number">2</span>) a2 = <span class="number">1</span>;</span><br><span class="line">_BitInt(<span class="number">3</span>) a3 = <span class="number">2</span>;</span><br><span class="line">_BitInt(<span class="number">33</span>) a33 = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="number">3</span>;</span><br><span class="line">  a2 * a3 <span class="comment">/* As part of the multiplication, a2 is converted to</span></span><br><span class="line"><span class="comment">              _BitInt(3) and the result type is _BitInt(3). */</span></span><br><span class="line">  a2 * c <span class="comment">/* As part of the multiplication, c is promoted to int,</span></span><br><span class="line"><span class="comment">              a2 is converted to int and the result type is int. */</span></span><br><span class="line">  a33 * c <span class="comment">/* As part of the multiplication, c is promoted to int,</span></span><br><span class="line"><span class="comment">              then converted to _BitInt(33) and the result type</span></span><br><span class="line"><span class="comment">              is _BitInt(33), provided int has a width of at most</span></span><br><span class="line"><span class="comment">              32 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(_BitInt(<span class="number">8</span>) a1, _BitInt(<span class="number">24</span>) a2)</span> &#123;</span><br><span class="line">      <span class="comment">/* Cast one of the operands to 32-bits to guarantee the</span></span><br><span class="line"><span class="comment">         result of the multiplication can contain all possible</span></span><br><span class="line"><span class="comment">         values. */</span></span><br><span class="line">  _BitInt(<span class="number">32</span>) a3 = a1 * (_BitInt(<span class="number">32</span>))a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来讲了讲左值</p><p><strong>注意到</strong> 结构体的成员可以是 const 的。感觉有点反人类。<strong>只能初始化</strong></p><p>今天已经燃尽了，之后再说吧。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>printf 格式化字符串注入浅尝</title>
      <link href="/20250823-vul/"/>
      <url>/20250823-vul/</url>
      
        <content type="html"><![CDATA[<p><strong>注意到</strong> <code>printf</code> 的 <code>%n</code> 格式化说明符：将当前 printf 的已输出字节数写入指针位置。</p><blockquote><p><strong>格式化字符串漏洞</strong>：如果一个程序允许用户输入格式化字符串，并且没有进行过滤，恶意用户可以利用 <code>%n</code> 来进行<strong>任意地址写入</strong>。攻击者可以传递一个格式化字符串，例如 <code>&quot;%100$n&quot;</code>，这会尝试将一个值写入堆栈上第 100 个参数的位置。如果这个位置正好是攻击者想要覆盖的内存地址，就可以用来修改程序行为或执行恶意代码。</p></blockquote><p><img src="image-20250823212029298.png" alt="image-20250823212029298"></p><p>我尝试了很久，发现不能使用。思路是首先修改某个栈上的 rbp 让它不指向调用者的 rbp 而是指向调用者的返回地址，即 *rbp +&#x3D; 8。然后通过这个栈上的指针 access 返回地址的位置，修改为任意函数指针；最后将 rbp 改回。</p><p>失败的原因是，一次 printf 调用会首先把参数取好，而不是多次调用 printf_positional。这意味着我第二步读到的是指针旧值。因而没有任何变化。</p><p>图中展示了我最后仍然是写入了 0x7fffffffe680 (rbp旧值) 的一字节为 0x36，与 succeed 0x401136 一致。</p><p>肯定需要多次调用才能完成此类攻击。思路大概是，逮着 rbp 的值一直薅，把返回地址、返回地址前面（栈上参数）都改个遍，最后等待 return。</p><p>这对于程序也有条件。对于我而言，我能够改动的 rbp 旧值位置已经很靠栈顶了。实际上的返回地址已经在 _start 里。返回到这个函数，能不能运行什么代码都不好说。。更别提注入代码，因为可写的地方都不可执行。最大的可能性是，同时用好这个 vulnerability 和某些库函数之类的。并且条件是有某种神秘服务不经检查地把输入传给 fmt 字符串。</p><p>思路草图（真的很草） “读” 的箭头应指向最上面的 pc</p><p><img src="image-20250823213343937.png" alt="image-20250823213343937"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多个 gdb 实例控制分布式系统</title>
      <link href="/20250817-idea/"/>
      <url>/20250817-idea/</url>
      
        <content type="html"><![CDATA[<p>记录一下这个想法。回头问问 Gemini 这个好不好做</p><p>感觉很好做啊，break send&#x2F;recv 之类的就好了（？）</p><p>要表达式就太好算了</p><p>只不过是不知道效率方面怎么样</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/20250816-tcp/"/>
      <url>/20250816-tcp/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a469854def7fa49e7a21758d54bb1be7b2b919bd6e2592945fab6e1057fa5b75">c54497c1dee52dae5005f58ed849efef1be563d19cdacb66f19117c911ffb041103aeea9c16226c620a81fdf33e9988d452817763d6ad8c72509ba51a46ecb92ce1459d22393403032a2dce61e87f6a62e2f5d60be2e09934f2eea919e46d83f44c3246bac13f90ba554a7dcda2470c45b1500cd4f8f100e3215cc48ec24c5fa649c469226c9a9ef26f3f4cc8633525ef76752082d11229e9f619787578d61cd2beda321fabc24b5f308ff84028351269e9a5297e252d3fafb4a80658493e7106864d6cff641d6a846526d2d26ef9b0358ce5be48d74f5bb5a4e7603e2a554211015b9d0a2d68df9969bdec24f723e286aef1f1e8277cf143a66fbde8826c2e485aac37f5b2b4e347025cce9e883a0b69166ec97918d15a56fa8bb37cf579aa661deb3e8d58a42e12b73c1cf487d959a55ec9ae80ae34453ea87e8a233f9cdede735523cb643860f14c72e051f074e7f26710dde154841a122d313b2c283b007cd001503572ff0ec713c4ef334abe9fb2b40f05a26318100e9c4410be33a8eb8da5719fd2487fc640989dcd515449f3ec4ed28aa9c5a2152b466e5976e88452c7827bb05656237e52584ecfe78f9ab07960f4125a9c147fbdf08e535cd70b4a137ca538d62119e86919a3d1949284857200029668eac0b71108adce414a99e1bd09b916981fc0ad1ffad898640b7117964f74fa8290f44521f42c11a2280abb9e52dcfd452ddec945626f7a411c3650476d8610f45f2637117fe50f12a862dd591581bd514ecd59a181daa2a7f6b951680828a520d3903d66edd5d86bf3ecef0c7d12afd9c14bceee0668dca8ee826af06e85de016a9309d9f832db4a935999aecf5fe0a83f65ca0249cbb98d65cbb9bf432e44f42ac0c783c6962eb785490e75c6a3018bd6f931202e69cc5f3d3b62635910f0d591d78874122e41c7ff59f439b0f41da0294bee311d1bc028ad5dd9e39c8b440736cd557dc26f5ed1abf27f451fe68b28f91f6690f369ad550e2036c74fc1387465c8f7dd436846df88119c01776b409464f7b3fdac9c9c17aca1e8330d96e9eb7e4866763f25691e3a4553f5395e1d1f207c5862b5e7a125de70a94f5e1dd34a8d503af1f4a365bcde435110d7a242eeccda557e8daaf48acc19cdce2650afb44f30c68ae8b04aee91cec558eed3868259dba9ab6ce8ef0c246766276b0dbc2d6ea77874aee84fb52950d41efc30bef6455cea8bd07e04c7bdf6ba1ebbdfc070a78d69847451fbe36ec367806fb7fd438731a467cf8c6b88d4af5271348ad1a4f58cf28207ba02b494a7884b3af37f4f742ddad627ee98759e227c20e54cf56226f3b9d0a34ca4055d8b4bd94624353eb7ba17c3a3ffeb3acce2d91e45542b5d35a50cf2155bc46312d086a32bcca52527dc8e02ee84dc8b546b3fdcf24fb623ea4899a9bb7b874e2b9215426732961ef3b89e7c40fca4a39cf51974fdf6f8e0392c397ed13b57f0b3b9dfd6f23d51dd4dae42ae8071cd83638806d127412346a16ab22bf7fcc2840286bb6b57791065fa30caefc7699f143296a2f561c80107c0c4f994093a857c42c966dc75e2253d12eb445f564deb9dc1759af2fc2d387ae37d584938e89ae04233b29de772e2652d8c3e4a1cf5203ae338df2bcc909f1d31ce03f4e22d2a65ed7f3566410e430678656c1854ca499aa72f030df835567d3de3f7b83a84cddef5f5f6f5152706bdafddd22c8551bafe25ba8cf7e3ba1ff4e294b7183167da5dd936b76028a567ce8222ad057f4dfec75dfdbcfed5f953677fba8bda8be088b8a0f3f5ee7752e9ede80c3d58b1cf4ec00e79fe8cba6214800f3c8f74c5d95d5c8730e0f5f63597a71683c759da781e7df106c46d11e62d560f44c5bbb33101bd7a2d234cbe826f840c8a78b2237561360fa582380e1f68dcb53af4f884379876b6fa9e0c91cd4f6d894621f960270542385414492692003ba2922af06bc9a5ad9fc69734f6062e6ce9b1949e5a02726d0e4a588a15e95a231486f797ed38153e09cd9315bcdc8a052889aa45285b11caf947178d31598843a08561f5c4337ac9e586d1b94ef2e236c2fb62b1dce9e6a5d2bada01a4a521f6e76aa2e198a5c5038b1728013397f020280cd07a51146a7e917de1e98041fdb524b2411ace1c3584f3a8df0498d6c18bbff23852ca9cff788fb8edb09aa526080cbe203eb636e015fe08b065712fee235590c917ae5e54b145a4d78ec85e877660edc648b4b0c414bb4780f2bfe11660d2f8804b594164ac4f79e0608fb643434b450f34e01ae5a3f1ba4a901a899bf7a9cbdb3875a5916a5e365bbed1e35609c2e8d105c78710d8f22f80472198545c6cc65fa93f8b642b8e28b8e6382498225698f9deddf6ace734428301f3eb1619f3cb5a6f3f04ab64b83ac63c2dfe774038328b578566a90935026c69b1d410fb9c987328a2b976f57a753e250096e2fa0b797de8e7aa6ecfbd746b6eedcff3e926759924b15ae7d65a1d31e75b6772777b5b14ed96929ace2c64975adcf89a49fed93f94020af7d5d16a1c686ed76f154353a12c3890bd286f099f4bc855282a1942c5c19cd3c8c10f6dfaf64473e9a54739fa27bacca28b1dd032c9999dd69d7ec01053923c1525afaf31095053289136788252af46e6d6174e78862894cb438b398c2fabfc7edb06ae9f38eb177c8fa0187a7d25b15811e554d61e3a497e9386d035a9fd8eb1bb08e3a27a307658dff45a98e1cb3b67d399ccccc024a093157570a0a3df6e9143c325731e3776bf7b740e98f6481340046124567144e5c72b08102852d9b5fd311b5225bf9ddc312e0e02763679a9e836ff5826e47d502f2bd3f0b6bc01a2696aaf9770975114a7e81078edc91933f11f9015b64003bea6e3ae111536dee3e1ff97531cd2def61f66b50325f5312edc49c2a8b491d4834600c106b8c21879da24a5c8a07f6e6481a881a39bd4d3bb381b563455e8ed5e9f730a2d5c25d1c6a2068787c126d7cd336b755cf939c37d577a72e4ee169a4513b65163f77791bc7860e19cbaaa51d62fd123b1c856434d474e91c4c1019b808a2f7c0fc0456733b4a99242bbacbf53bcfeea9adc12205bc2e24729b294d510b603e1d526d587d18aa2ca19f64d777013eac9aeba5cbd0b1399c700efcc819ca778b5b7f11f38b6e6d1fc17f692bcaa22168100a272b8df4a8ff5c35f5929e901c63ab1ea1d98a144dad507d7ee40b3d77e0661b17d84c65ad7776acbba22de14b4d7b178da7d88df7a5cc316ace82f5991b9684320fbacaac091a873f3df6031b76953993bd8022d66b29c2a0b56c76087dd9875497df5353c69613cd417e56afd941552d7a75e751314d2ca3731bfdbb7b4c0ffb836dfd517e12dc4153c04a3197de26a10cac204ab8d2dd5e140d07c8ee2b0320df727d6969ad7fe4ff4390f97d4496d12a39bdd041869dc7d0a993e32863791040a91c0e5377ae91c0f5916a2f4fac11b0a2814e4c6354d37eff5a3cae74518e994691e0ae6d7cf938554e7a4a2919e82b2c22dffb4bbda8688d784b0f4a8916abd39561fd88b81f5143a3b9aee0024b5e1aa179026f5638d28a4144a1397c1170bb9f3e1025cafd5d7c6bf959bb78affadeb0ecb83585b0b14dd47cad9189e9418022797c85d09b6777008dbff18dfaf576eac77c3b4b4cde018c7903b2531a11002f7afb1bb39893e6f52408726f7d04aa27423fb25d8c25a86183cec939d1903529c836f926e5b251deadd67f24ebd4c1b579d673c2ae51aa0341f979ed154534d30bd164153a2b533ed734b29b04550762fcb523eb7fde9124da2edd5912dd3522031d1a0db57a68107cf0c047b7a4a6dd65241a1deb3a3c4a2b5475cd80188385ec8832f37abed208369bf00b3edb9e25a66b428fbfc11883b0412d1eba0a5b76cddff4cae233d0aa79b5d36be4b79b5aa5170087e4d6dc53e0e4a56a6f1590c56dc20439faf1c77a5655bc37c09e6f525faa4aa83925f1852f34943a886850643f76b90830879a240de492ef4932d8c4a022045070d327bbf4315b75b729cc22b375dd5a6aea23fbdd6b863cd62ebd8e3c79f011dd36c63970567330b0f1802401e5d1a1341a8d927516a4bfb494f4baef0a3d48ccad5aacd5c0f55cfa30dfe995cd102a87bb88558a63973bbe2313a5efd15498009b555114f04c1e91be32b2715d82959d6db4bb359ba00abf38fb1d56878c8c05eef779bad680f9c428ddf9f0e2531dff65d6170f0a6a14b415be99a6532d1efea67240f73fcd5f0e8d36437b129ca0011d075f1e565759fe54e3d3f75d9c5e75d0619f075f686d0f929399d26673b1e15a93538b7510b2ee6eda8ec53b76ce5044d27177ec19e3dd775b2bf949bc5ae35d322d661eb877bf036c9bc10c51b40c76b895d2bf7988de7440eb733a035cf549f069dc9723b62583ba6290066c4333a646dba8a272a4f9abf1552a37a23c2533c26d63e30d7839d66863ffed727dd0e36d5d73c5935cd6ac8f0511a2c81af3d29ad056131f07826798f588147ffb5db6ea283b9ce57e35ec8f5af255b8179c3ba7a5b67d49b57dc931646add310fa253218a57e67ddb0ea32129a09965e778a548ee13fce458766d8a0bde6825b46234f893bc7bf71878babf98f89f9ea5de177677bbd7553f9b99ff3295e58aaa9da24c55ffbf70ba592ea9983a15a3be11386b35f74cbbd2eaf04084696a8e8c0f3ddc25e890ca627a3173eff53898ba6c937e1202142843596ecd018159840c4387f14aa13100c10d51ac657323b3e021aeaa1678a8fe9953ad91eb4209ed13bcfd8bde3735de6c6d24d79b0d49967cd9e3877f253ea416a07a2ec2093633b2b6c6eb32064b769e2ae54dfecb3c376e50a4d49d71a7e92282ee4ed455090758541dd8fcd3206450e8fdc4d623ff487e1f4bb3a13beb19d17faa749dd5a005a71aa820a47bda4cd5d67e134db65b4843e8700a226f3b8d23b779e97f003248f2a8a88e3acf2d1289006c3ba53f09b2c4ac0429e1ef4abadd46e17bed97cd64cc78a46867837146eacba6cf3c166850ce0fd9dea1bbe978d776c1f21a90dcca5bfb0394fde4ac369fa4220f574dcc0f4e691389b3981b446ac5bb850f7e1d2c061a14b7f543e35d04d476fe9984d1c16635be38cdd6ae1fd5775ac9581b64dafefa6ca3960af652f5b854a766e33b3f5fc812306540bddccac39f03f16ed0421b4f2ea36e58bda8a36d52107c696e06af5e0c76a0c2423f0e05968972e37e4e9af01803a88ec5db009f82cc87575930dcd85c2b561eb27683c7078f4c919a35f220f0051077f493b0aa5dfbad11607bef46ba49189c20bc2d649d2a53561cbb0e59678cf695ca51be5519f4473944b70c3ff5ece0c38fc00eb90348f1ec3160587348d155ba4c38a30ac472d4d050c37edcc52cd7c9397a1e5c8979230cc913ac629d2edcf42526084351b4247b23612dae2f73daed9f00a9430cf7e7abb5f916c5f23ba7e7656a294e61b81b01ce404d9d2a80bac9c2e20858a6064566e77f5233792e265327250bc1f5e4446aa1a86250b814203fcabae01a33be043278b92a2f83dde408d90ff895cb81821562ed89f0c1730ff8038f4556812ac0322557f71f9da2f51ee1d25d38f2da4bed1ff7f4464d752e9893102799b99bdb47564a2ef67f96dada350de7a95295de3f0b630bf5ea0eed8860d4dff5d7e312e86c647223ee0850db0b5cfb2c5fd2c5ee7ae7345d4ecda8c8ee57274078458aa0b40ee56ff00dfb37c33ea951de49a598749e2ebac0d13dc05b327b34a4fe0bf9598cae31e9cdaee5e7b800f4a3436c80d545a3eb43d1f221aab1c9376fc675124f1042b244589624af11598870f9f01184d1fe58c5bb63f88671e606f7716a41e54e94d20f544627bfe07c10565f73078ffd465d69890e6dc5634703cff4526e1f708581ab149e84f529e4eee9a57b106dfb9fff24e3aed0f9b6d8184d68c487463527e9f539cf01ee3f70029ef109283090636891e3fdaf99d8ae157143ccdf211ee63df8198b158c339cb28f9e693b8983f5dc7739baa2a182bb8f5b11d6194121393c7ca770ce4db8ed68e111bab160612247b083c8092525260bb57c6e5b0b374aa22573a5cdae81b3b444f9bc1b9e16e577146b562d293b0045ff5d056a947274289c2a5e779f6bda38489a590e2607eec530bddf0b538db4b1fc046973c90b684599ecab40373d1187e289987a4b52242471b5cea8ed4329b2ee73cfa277d0e198400b7a6fa968e8f887f7088fe093d72dd8fe22cb547d0ea4796809b72e3f28301ac47826d69cdd9a3d66942f9ca1ff2ac11402e065351d56344a5c30acc96b6303f301b0eefebb7ffd875ab73550ea975f2603a48aa1e0f4a14691e0e9ecf4da90c249c681a581a145bc7a6e8222709a6d57cb1da63fd904f102bc701901efa3c47a8f9cc520685066156fc601173c463ef0b6609fe0e89e7bfa6a8e435939fd18d93fd9c4bb886ec5be5d5cc482884fd6a8d79c6de5ed87dea0ea3c55b7bf518997d48ec122b777b760c241c17fffcf1fb10f0256812c2d98f26102fc6ca6e5094e9a5b290622f6e22c9b9fc78b7393377bee7af814d7b82fc68832b099b194dea8ae7fe2373c890636c1a89b6d4c57d29ee112a0fe5c86ba8b9b51e59cd8d1aafc369336776975f33edf9d086532f3aa3c1db68b8e53cda3b4f6583105b46f98aa2d817c2bc0a17eaa1db9172f943a705f34e06eb6b2662147ccd8cf7cd2306d76912121ad807e62c3e5f4d301fe05a68801d823b1dca32d62a6edb55c8a535275ef6a25b5282ae5eb68e3442964e283ea7a3414b6d1ea45cc5113309918892e0eb2e2a133d32d21eb19b45e9692eab206b23ad10e320310443982735037aa22c5051d26172cc90588fb2a1a243708909204bfaaf3d05da470af81be377b38deed485a80487b4c71b9956d7eefb73836989ddec595346b62cd92092728d53a680770882eb71a010ee691995b3b078febca16cbc3a431add6ea99c5b839a3fccdcccfb4332c10c52043d8fa0a501749b2a8989ced9c8e4a5652cb0fc3f8685a177139a2d7e508251813f0161adef5bdff804c9f9b3dbd8f62a044fea4af878793f3d953f75466a4763707a446c9d1cc846d22498a394fc507d9e6117cd5b6edb5bf10915e75ab232ca2400bd427c8712fbfc4c6a1903fd93553422849453d9b487c7840303a124910a962670818add656030b9cd6efb6e8da7bc6398696ffba74328eb57a9d0b4d53651afc8db1e6f4453c4ef068d1dc9d90f41f3083ed52605331249df2115f895e6b2ba7454fd3b5d13754358fbcf5052e5c6780145b33880d3a6b1522d79656e37c91af7f57a5577a060e96aa2d18f1d45eea2ae98661b2177d8304b843afdb4ab985bb6bde5948311cd7f53224a5dea2cd090244a4d3f3df907faffd58f75a952964d808af44b0d6055f586fd076e3ee296d1e359bc8434fee2786f3c0378f61d45fe5b531892688ccbec49d2c847fd7986f034dc35416c2370a57fe9c5517ca0d0f1d99e0c77b826feeaab0c2c647b90a88cb64c78012a461bd8c6920bfa598fdb6fc17c436735946002a19fb5177571828a7966b511c0b93d1d4504bcaace9dcfd17d0d67f7a70bbbc365905439e9a9e042349a07a9f74a59e0c9f6b5d10cedfdf2dd4d33a0eb41e34d864a63fd737169a2ab2d51e9f739dd7acfb5a224f83140bb55b380c7027a27a170883ced0a114e26bacdcd3fda6103204cf49a5590160006f7aba249fffcdb5d3d4f06e5612edff5f661fbbdc62e5b01809e1ea58e11dd16ea16daacb87348f6f7c5cfe2bd59d049a510f20eed868e8b241a58f2f74be1f544e57044f53df5d3859c9f0187f6b0ad47a1e5304aff95b564d2759ed1a48d07aa2a7fe13aadf6ecfe09d8c0e6d006f967750f104b945633b2ffadb00e996fe26f10c2a8f5dc97bd3295db218d783d4b04da4e01b137be81d36d66ce2a760bc67840d1463044b56121d83f89bc520502ce977c67b13185f293b3663bc1b5205bfa29c4c9a8365de6b1cf1fde62b8da630f5bc0adce929b00a386960d910c2b0db9ab060de0a1c3bdad17c254c3be93d283efb2e4a78971d516a88796c4810f4986fcf4ee7a9a086c3bed06ba3c2459f2e29595ff56fc0124a9bb3965ee6711e97e253a7696273d8fecfa6c5fea69e7f2bcef9c5fbfd532a5c1116c57b04055ff2688bbf5b07c53b2cf1072cd564f39b5fa3b6a93eccfed30fa9e655ec68e2ff4e416ece24c3f956446a8debae10e0fa2a3407ebfed8ae9c23e2b943847ed944fde6a451b631ec721c28e3b465d390d86e397cd6b388165d9c2f62318a9a4fbd046cc7898ba5c1023da364382f387692ae5b636bbcfefef10cb37720213e634d23fab8184cb04d375afb0fb9d4ec6bec1131a560d653f0c61c67c31f0f16df63ecd9dfa72725488c061af624162ee1c62ebed404a30233fe420fd4ae1afd0544681010f622345a5ff83cb588ce69c736ec78007443db33b77e11a2fac32d03af016530ec4fdc0e880b75a9745929f68dd4120ddc3b7599a31e8d66ad203e5af6b9263a55ea3dee63f3706e32fe98a70a93b7dff4640d231c75fe840f6a4d8d86c329fc679970a8c95bedfc7e85c770f96592e8661b0f440c2af4c35c7c1fe55791cbf3c91d5066fa010284d86c30833c8dd789600199be1e9d4896bb6abe7beebcbb0024e3c7e8f5d2c6ac3118aa2357e925520ba0f9f9654fe0481ef3b719b7dc5f60695c8b7e2f6871d0fadec447923a077daeea55ffcd45a2948b4f55c2dce569d4736fe163ea3afc54735d0ad2d7b9507369e415414ed0e66e5d78daaba49ff1b30e2dc15e54032d1b5bc496427cd1a1e7552bcf36a5fa822f233602dc391849b957defbb8ad9cfacd707cb829caa0b1738b5793c86e141bee2b535a84ef674cecdf2fc8668b2682e27c70694f77ec86fd3d4e9647e89837a0d4be2837a941d61db850783006be132abb15a1c6758d2b96373a04120526b20a9772b037bfbc663146c2c9faf631d5746db21b1203d60e005d14060e4660a11c2583a6eaeeece92bae814e8acc61ce33065f869e33a408fdf08173751ade28fa3a38e92481466eae2c8955a67bfabb5c309a0871bc16a7ed4b966567496b1f225ab9e73ffea4fc76e38958d64e5421bf00389856c3a7f8fac734e5060e937f0712f75b43c2edc91c9229b7430a990345ecaaa6a27f365d54ddc71c2c2e8407d85ef0d9ac5adbc4e3de39322100b3339fd32331e98655ad8fd6be116eb5df708bd2c8e0ff82e7af5eafd841954eabcafed1a153803c8c80eaaf75b84d55b7731190abe2a891899358cd1f2987105af42e37e65e3b5444b8b17c918b8a9b1684d795277ac83d3cd261ed31266df75f978cbe3d95571853b0bdb52fb0d0292f6d324c751e0156ee2a2950df131ce3255f1347f863bed3daa94873f1312b698890c6047d282642486de913710bbafc96e8aaedcc2e5177c848f44aeb3e289dfb9a0bbf1809dd25a6a85998c8e045bb1a194151b5b09928ae0fd795199b97fdd43263e5f7770ac9acf2fc7bd49ac556ea04f68e747c020a77f1b1fe83af947874c275db92792da55b0934c558ba64dfa74688b2b4cffb0b8caf5c4cd759937953afe1fa79641d8316f84ab3d7f4ae8028afd5062ba6d2d836d9adca3004feb069e729a74c361b17badb09d5c31a8ff04cc42a9a9e43cf2014ed00f51bbfa45f5941374a3d71b4e864f907b56c54f9be593d191d937f3163c1a681dd3522714d3861d85c00947b13b5b05f28c20651c155f967681836389fe396e6ae7a427cb48be491f135d4390fc15875ae52640aaa1a9292ed03e1fbacd9b944a6933400a1f880a914c9366c99c5c17fbad37e89443bc998e9afd45f15a7e7d90d34f5c73c3ba7a62cc7f9975e732813c241bc5f492a49d68bda1834338ec1725d99ff84db44cd238d8e02551d359ebf47a9944efc5fdf89489db4fd0bf6083558e0bf7a5c5f7af085a1cb158b6c1cd0972f9a7cd127676a0df7366d386b19783b05917d469d3fb199806ec149bf15bd0b8ab662c8408f46f7867bee5580dd6aa1166eeab4bf1b8f1a4cfb07f4f0973b54d4dd56dd858caadd1963b370e71ba679fc6a609f2adeb0b530fdead6899ce41d377d12cb52c41abeb0341aa573ffd2c4fab1774807bb2744108f2e5015b60d9d41d43d4d356b3854bbdad5f73e869e3f4ea66021fc463f5c3729ad03de055e60e7748d3cb9bc9ed42e669610b6cfbd08b5bbeb6dcc0f1c3cff1054d5f43c23f36888de6766a097d04408605d58c490426375db42eb7f3f9137237a1ea43ef62e1e2bec4431898efd16833d88e0505c5ec1b31dd2fdc2166082b0f5188fffb4931b1a6a806308e7ac2c0b32813a438dd4155a2cac47ab6cc2a41c8d50b656e4672669f8b57985f592a8fdea4acdeff8bfcbc86771821cd631485179d055b1a6775df5192db1f76c2fec37f992fe5d5933a01697cfd937d3e9d2fb55d96641262f1f2aad5d181c9fc4be18b6ce831ff42b45f5d30dbd82578e3da5a1e34ef98a2677c4f2a0bf4d11bd08b9f05b43d91e56f5257f8f7c445f8962f063865171bfe3250c0cc54d84047cd4b30e13d6a75d84939f85353017bdc5dbe23c3095d413323d68b8d094e83d9537a49ed0ff1df4ecaf2a37a093db7a304d30b0a6ba6d18109f323ec6b91225b04e5cdd42bb6a49bfe6ba84df84cf69c35ff7172e5de67cd05cd684200a53cd01d6d8b219bfe6e67006cf38306d3390c99b7e83fe25c92f35b1788395da71fbe950aa783c11facc90f43cd618dc4e5661a38e864bf02c3c40573acbf12cba0a709a65ec12d1cd5a0ed4d10934569379ad34b8cc87a8e00802ed2c26f25c3ae77f4d6acca0d75537c4b41cd4311957c13af5dbe90ee474f2503a00f57aca9181bbf14aabe6f0694ec5bf9ea69e0a6c83273bfc4dbb69d3c8d04f48eec02831160541aabbd94eecf0fef5a77a35751d24d68daed7c40b8ae69efc5d3a6868bd3a2dc77e98d179583366bfc1d9fbd9de741bd142df2a9a21eb304960f2aa607b2cfd3bb520e420a0444f7fe9fd9de2fd83d4ea9e5f467fe8b20862545cdbf370aefa25fe692ba0454ba2f1ada7fba6e17a00bcda17889307c6982fc284452a3718840232db25fac562c9dcc10957dd2b8b682629b2982110aac05ee285a7a7f782b72e3017a884ea086264e3efcaf613753ce7fa1141d1715c76aa862f285a732e4a3ae5efb1dd3e8d2286a9b96e24132d298669c79fc6b6407176613da29d948c9ed6182dd808c12cbb16001e26adf903014fbe469a33ef1328e5f56496689d1efa971b99b81e9354199682c28aa80b88c2a67b0039e70467523b8ece62779018c9346142b600b14b5181bd4e5102ad604597ed2010db874807141909d68c18643056418ba8e632504781aac74707224103bd26b27b4dd07c8c3ccbdd5e6e2ef02a8dea36b61c025ea510c1ff210811f91071041feeb70d2e5bbb426b975e1a96bc26bfff00a7689467302aac6395efcbac648c3bee63cd5541807ee961c27b308169a6a776968c6583227696124513e7e1e617600c4d6a6e6bfc9a7983ce27c6a7679beddbb200e65a8389e2d6d08167a91c0a1056ca8c7292dc69617dd4d5049694da5eebb24649fa07e1316f339a1444a046781d9bc3b96b4fd573407b17a13ad2fcb0ace4217cb36edffae016390563208808389ae42457d5e12422dbeda402e4d51a10a126b68090c4788d3c801371851771ad5d4e38be4fc78b8221a8feda160a0c205509802230c22eb2ac89a2416a8af6797d4d26e35dbdfc321cddfa9cab14a4f473ce27e11850bfa2745f3097941a9722870915c09cd162cfc33a5af65c19f3a75dbcf6d5dd8534899d349618a3b5618dae1740debaa303548f02d50518a0592b5a5d3b1a4309aa3132f4209128dbeab22ef2cce68b34f59e09ecbabc655219eca6a62705c06bcf470931de72071336ee7438b3394b1f6ca9ddccbc5810453e1d500fb7f33524a87961fe1b9f369a9c8132373bc029df01e50d444b9b4ef5374f8f929f3a5c5d5b58ad8cf92fa23d047826f8096e983782fd94d009a504d74a691a0d7d942bd73aa231a74cf48eb5fc597b2d625e6f601a3ba461c20374e70efc242b14129a833116a32884a9758a8cbd5675434534f1c118e88a501c720c1f53e2081d6edca2f7c0ce55462927dff66b7d106f7f54a970a645448cbe23a7f81a266877fc9816d2967186e29a4d8fbfafc3ce5616c992f12c1e5009746cacbb697ee41e767b1a2a1f70d77b3f00e24605868f0e9d6cdcd231b96d25b37f87ec39ed91dabe3eed829f0a67f04d20d9ac9c146a397b2869dec895596a5d6213f87f944f218349e9aba3caa41877e8d0edba2de33b6c19aee5968acbf539c40ba296598ee7f2a4a56efdb6ed4396112a9eb98e68d45d6fc4850001b8539b5ff413be9f14886cbcdd3592590730278f14f13993ba8478d80b7ab04749774665312440993dc1762f3ce1dc0004c391c45ecb46e288f1e6e5030bd9eb38a60a326eb53426a131c0ed6b70b293d27945059a1b2b960a6c12e3356140273ef1036e3c5cc1c7f923ffc3787e2d7ebd490861e2b46d29d8b4231837e4e52a9f8d69d14d176cfe1d0126361659226ae2b5981895b317ba105dde849905f34d69c0b5a7f6e3d44d78119afee0ff1578e9c8f759706c7e0be8da66eb272b2886d156d423577092bdbcf44b1acb0eaf70b26b71cb1c51de4eb9c61995b225d51750424e0be4401f2b61bbab0cddc676edf6f409d8abd1413fbe4e6b1471b5ba25c9f2b25fa5d7bc6d8e949bb01beb12408d7b5ea9e8768eb46ff401de24db23b33416909aad21f91421959fe2ffbbb0a6e47d9fa0134223b82b043d8ea2146e70d445057e76e7d02b08e8a791b612a738af4c6054515d904a9ad45b6dea997f9ee92a1d704097f9c99ef3efec5f6dcbb46bb1c4bae2bd95f6d4110e334ebd81feed8b3524e48de9069536ebd4d0fd219f65f24661fd01475dc5b02f8d325b23c54aed71e8a869f9bea7d7c5daaa25d612e1db301b0562f7083d5cfc78697129f2584a82dd8d1b933ef7fa2afde933df02f393f6e3ebc4ef68554b699e4cdca920c4b3a3efff35b58279fda9edf20fd075e5ccf7d735ebb1eb280b7fc75c00ebf0a024600ad2a6d4a8394313e56a63bde565e63cf00f1e0fa44beb2e86784ecc9324d2bb90f9605c13e2cabde986674d4757edcf114985e345321b8bf603fd4521cea5c02f421e472eb260a55bfd840daf39152ef16b220bf57339e8ee3fad1205287ad273decb95539702a8ef728f6772f6b009f1c12cd3852cf1822540e185598c075a73f94946f41e4714623fec0adc6a6d8c3ff102bb7a6db2e50e5b002a7ac47742920223f2f99bfa6f3b797aafcd821b7898e458518a0837de153eaf47513d1ec087d2775a840755586fc5bd180154f52bcb27f614253b8d368ee10c250e8997ad625b8fcf6b5abcb7d030c677fca405af204a2006c6f17a9e02e28b2862b4b448a2d22eb7537e12bfb01e87e1dc69f66d3ab3546aad985ac2831d777b91d8a328039103099da451ca33690e6dc17b3518ed5a0a031d28d093615bfdefab0324aa01b6a6d1ba6dd589cc33c0dca7e5d28323ad69490cd336a27a4b478b343e63b1a3509015ed4fdd6f83655a727e31ed1e80186e247e87698f9682dd4796b5f536a7d00fa647056858c7c72a126b6f8740036b17ea1e6d2ef3ee955a28ab32b3f089503df5145aa66448d1f4a5fdba51af0518ddec7de6df6c4fa141a30a69fa0393d4fdb0de977d42d9bda1ca15d4836053f735eb9a75a3ca7624e9eaa756bdfb274cfd40688ac5d40c22d2a96ed37d02d7b8d95f47a9568e2a0f48a8d8147ead6fef1bb43d4e7344da3bbcd3d3c98dca3268a712954867b325515720bb71165d379b9cd0b8b7a4dd6944fe9530443a32742f070cae46ef6b4ecc1f76987d4330183ad1f9f5ba849f8ed3135a5f9e95c63891fdadf80ca20d845ee5e043eb927ff389d9256af4dc01bf54f6c1faa3fa52420b8d9218812d6e459a2f722123fb07d15b272261c3438a07d275c5b8df99aa6ce00e72702c3b14560de0c94d8ea129093fd716ab9e4363be795a446b8c312caaa0e4a5a65a58196cb9d40700587c59659f5809691fdd5312534a1ed1086269f0cf89f91367ce55f1263205bb4d8930fbf82a76eb4ddbbc8ec52971f77db406a949c578944ddb92a8e87e896852a2e4f4627bd0ae3f92587d5d4178ea4875e464924509563baa5122c6f2d55ed7c8210e20d78db89bf11fbcaa64c886f2d9b87e65fcebf0323040896e4f25bdaa8b0ce8ae13bc572a2c5bafcb1cd62bdf212947cf910535a6743106a08396d2f2495aeccccbe54b949c58ce8ee23eab2ac1ecb865f782846233f8fd261fe291e8eac311ded1a37f3fdfebfc61c75ceea1860483ce3d7e8b066ddc061304031e8b95c46c14db036e83f5967f8e8dde01272256d8629c4f77110587d7724d35219964481c8203a7d618ce9d8049380c6f8956214d49e19a0cd3f0a0008fafe12837bcb978b7db07594e5a0d0c0bf110eb5a1c0568d433a91b864052c7d71b71db7a5e2e3688113066e78c71ae28d277b428b0a7d1451ad124cea12def08413144cee693cfc4720739cfec549f8c7fc0fde6bee8fc3595e5633300506aad65204e022b3bc218126b5b2d1367efeff469cd0053b76c26d436ccb2069ed14e8a1cdd738c59dace4532989656775da0eda9c973d63abd281a685ed9d6b3f0658e7c4cf952fd1159c6b34ecccd175af86e12bd22a2af20a611a118600ca2c0d35e506a9b882cc1cc8bf332ee51093b2b7de6d373545196a22daec884a388ce7be9a0d59602d9430369f69c006dc9f1742fdd4f1ccb60621180b8d8310b3fb7d70508fa338581f85eefede9920ff5b0c16715cde8ee8d57376b1920f3912988af138a4d25937d7a497536123fd4bb35a0d1fa861c86a4a1006dd29478dcd732b320fe77df5e157da9ca283909d8a1ae87bbf501586b479a6f882a68b1fe53c326cc059febf894bd9a3ad4f483ba67c879fa41ebcc62f7a79804c80a969e7bb8882d6325f31ee33597ee89390c357543851d3807fbedbb0247642d29832f61e16820dba8c23a3fbcf03eec92ff773e72846e598599ab3a3afa01cf135b4d6eb70763432668083b8ac0c56c9d1fea8f0bfc1bc1004d3bc34c6e6c5803d07766086a14c0bb6a7dc0a506eb3c0e54d1fc9c05bac447334779cf50cd06b3748ec5bd53721e19a2cbe760d393e059746dbfe8160c39c19bc17a322f0e0f082d560e413a633fda3e668bbc93fa8501866449311620177fdee5b792ba268819eca29022130bf506ccf31716bd327933446acdc37f6b0568b78b3d6d99fbc155bad6f2d2caf9a3e6ceb3dc95ab2ea3d36b49a63ea9af2502bd6e48f134469a5dce4ef0ebc5c5a961e0cbf9d0c4b2d9b29334b41ff70bf7476d8dee393bae273aa2b85fc2ea8df819cf7a371d9e53943ce86b4b0c52abf1d5a4f86e2b0d38f7f6d5000e56de09949947d4277200ed855f571ee7765085d57949e2f865d46b41700c7e3a87c02a779af6a15d5247a86c7aa7c232d255048a709b42418b6279414f673ad6d10a4dea7efd77990ef4a43eb63a3b06140decb15bef9496bd62a20f378e45e21ecc4d64fe67969f4a7f9cc1cacff52f31b1a5a54a972ee2ec5102c982cd89f36fe05920f68ee0de592c05a3cbd2054adff29e412458bd8ac57bc160bef0159eda842fe410eba7d28bdb40a1d7db7fe350fd03f24c82e9408999690ec9689bf9f20f6c43ad046910fe5df571636687be69212336d80442817be27c69c5c8a591926acbe600c0034591985cc4ce33bca0dd08f4df49ee8420d95c80eea68a73a0e4437846991127795292fd71e6b1c89bbc1b2f5449500d70071fcdbe2c683963242f619c2c1b2b6626360c7e72f1bd7bad9cafea6d0adf502548e3bc000bb56e9ad3e698fb1527ae3e271195dfd690051f9d1e2defac752f2d4aa326baf931c16fcf8e662009725b271239a6aedb1e3d8de9ee39346226bf2c40ce62046c60ae42e661ccfd8a01b02d2dae1ae85108c17695ab48715cf8518024344929c40576abb82b92584619bd532d4f64feb2565970c39d6140240f6b9b00b7162b3f2899b7170e3aaeb0f9871792b9d2217bb6c066720719058d5e0edc2c7e737f9ee9df38dbeb301843e30e7e86b360ac7900dcf91ee6ff6f34ce0b259084a72c7ca28ddabc4c6083de47ef106a3d52cb44666840f23f39737e284987b67dd5caa99ddd0bf6a389acbf9025466d754d8b0dcc81b323810054b616827a79db5a940a412902b749fee33ac010232cc132de811927f38cd3f5ce5ffafeb1a786dbb4332a3090dcff54683f48cfd9700ff06129f01ff1d33f2357c5c19d75bb55b626ac74613379e65311ee035390cc4046f80350f7fc9cb0e41dbadc6ab83a6ea45c8998e56be6d6225d04ae18c8454cc5e2d880d17f50469662169078c5124ac1a810d5279f77a66b19a5541cf31a8c406ad246de0cc93606a1525a7cc3ae0f73ac5580a48be4a2fc6f807f24fbf1d3a691417064498953478b19405d32c3f8f1fd9505c3784b2b0e0a50398c089e2c8c24e214370a18e4c07f25de9876b0e90a81150498533858cdceb1e62bfb673e905d5e54e2d6be953cc8a10d2245fadb8667be234a2366f234027bf1b46df9fb81be550b2d9d5e0da3f9f9456c4d78ee89289478892d121312c3abbf13d2d59777d5f7596210c883b7f0cfd99a21d97bbb2a0acbe7b078af5f5e3a14cb4808af1b57005a0463b43d1d9ff786bc133343c3dbaaf47f3f4515988e4b7f3f8ee2461b6a909bbb33aee7f5e38f09ba29de8935d59181d2c96dbbbf3a3e49bfeeb63c97bc367b952f485201a63667808e7af30f85e1425a6b8a8dd00be8f246e476f2ffba7934363b882d162e56bb85253873b95a6f8918fa2e3ed2ee7398e4374eed49fa97a25af2ea7d58e95063c8d1cb9c1d493f6188e9119c7f183707279bbb1626f3ec0660925703952a5b60c81d9ec2a4c2a59e5b99272948e10256781b5c63e1c8298a244207d836640283c28b46f9eab45ceb7104a5f94fcfd49fad18a471f2a30de0cc2db465a9b13858df2397d7fb5cd2302baf33d57a9afc56157b0d6907e24743dc2629b43c36ade318d11f8e4d9adba6c068eb094f8eb0d44fd34fe939037342ebdbee39fae6bea20f6ebe66535a2c3e2e93aa2b417e427bd80fd5187d94ae4cc9f86aa94903ad2333949110452835cb1131dc58188acff7ef56431e3322a596e761d981e847cd769083f5f8b87e1a5289aed3d4309de17fbfb5b8d97dac1dab58b529d82db1a90c9693a5284ce7c460bdc8e0b2be18e33c5fa7295e48afc757495facd05aecdd1a7e879d8dfe677b59c2bebbdf8ec816b5bfd9d11c633f61ebe626280c060b7f3b955bd7cfedf283dde2b0718915100335e0567701722aab20564028bc03d24138f89d491a3b9b9f1ca6e25332a90b4811053c30922b26897aec2f78ed24251add6ef5eb27ad52a7fbbbf13c569656e70a3a31506ec9f9d6394f6315a6a2cbddda6fb58f144ce386ce132e002b78b7d3d3db3d434ef536359f7e5ce5dda34462ac7a8508c92fc998b6abfa364a55bc8a8eb6281d364ef6a8aab8fc33e95b0f379c5ee7aa05eefefdeebcaf7edde526f954d9300cae7c8e0f8cb8c39f6cfe00c24b490adf13cd0869087b341dc4d65fc92a92cad1f59ab705f451e143bd17d28bad2ba3ccf577d2a9a6c996b394af96bf8af8c879f94a4de45646fc61054d30022a530896e77b502b4ffcfa490af1f73ab1b921202b81f45878a5e5676ed6f4c8f0f945723706ca6edcf6dd61e957eaf9d7799aa6d83f99d86742cab89d65a0900a0d19b47555583383d93e457101a50aecb2d956f32bb8f81d8d170f4c002fdedc1a426626616bb9e030b068c02ccc730b7d6aba55ec8af47428a63c43ec06d08575388d7bd40485886270fe779f76fb14d803e6d79efb4ad87913a8124fe68bfac8d983ca794319be034c45a7efeb0e68621f87fcba3934314b2340259aeb2921442d3f3457bc2692fa10c01610d388edabad17c1f748c08d8f6e7de8a33707ffd3286be02fabd94b9bcd902ae6c5e2c1f8f988058768f8a5c2d1349d1a9e97fe9dc5ea5d1abcb08d0e187b9737df80f49b68d7efe5dce51c182595d067192d5c2b3a30bb5b65f5ff5884941399c601bbe9c535b39af2670ca8506414590cc2e1ba2bf9831a94220d6a8a50ae37ca9ab4aefabba560c9cf839e4eb6ae1cea310ac3ba13dcaf51b16cbea5a7742e045a4b519f9861c6f0db6ceeba4c38391e901171ff0c2e1ba1c7e49b61374a57b55fd87cf0abe65fc0a79e6d9f958a4fa5c56aec01526bf47d51175cb5b027e8dc315013c766733a5f0ceb9cfd499022fa73f081bb2578b1f0639ece141b6b8bdfe75dd94814d8090c54a33ea1a7e98bed123c7d27ccd884cb48cb75407c45272d6b9c04c3a5c99a022b132786782455b832eb5b59f25b4074c03549af38c58eafd45cfd109a8ba477005cc03b6e99a68b967db8150db8a63b420ff55f7a01804a57e35efdd985a536d4de2da15853eb01f7b65dfb269c0640dee0105e4bbaed4284a0303a8f028ff2d1b3a64f93d80e7f31a01743abccaa389425d9f1cf8f5884bc26b1d74819fcc64ce0891550dd1feea6eb7890cc8e76017347d3fc69216dfc9ab3488e24792e1f042ba9c058b077958e6549c6e60fe4298f5f8243e2ee3e7227836d1776c71ddbfeb7c8b40825cfd2c223b0c34ae1b75e5022f8c4b65eb8bc44c3b4c89babc1cbef1ddaae29d343283ec19b9f7c6428042615aa5082c164bfb3fa33e7a2d9ecf48bc2e0a5d85c3f48dba40500062c422592695ec88fd261b3a3a3015cb836c14e59e3bf21ef2740d19d9ee23a76a4c66e859d7d8ba43a22a7e83be7706cbd88cfe5df9b7b3616cbfbbd729445b44af5a6ac4305584e150930814f121ba0172d37fe5d8d54df0d70fca2852fc904dba9129ce4d66ec6e9d3512ce896904376bd4d83c26ec5ef8cd969e467556c193d4d2809bc1fa7cb7870b0a19b0cea3d6cc81d0de66f677c4ed19543068f4a7f8d345365fe8f492c30595c5e7f40c6d0cee1c8648d1c08e4204039e7563151c589e404b76c8e4f9fd7c6aaea07563ec76175c531086546a5b5d8aa47a336ed8846d4f5a742d8d8136e8fcb01f594386e8c9b34d785e09a37323f13c46d48bfec401de9e804a0fccdaea84f20c5acfe56ef82f14a17f94f02b19e6b360d879729dfcfcefa3aaea6fd1421dfd0dfacea76d44258d053e3f4208db4d9c18dc2d600768ea6a40795a280c23305a57ebf66949ff9121a712a450c585889153e0c474a482cf9e5901ab0ef74d88aaa661011134c7fa0727bc3d61aa43cab05facb8e9ffb3d5069f073c7f419b1233bdf9040c3bfb09251faa9af4daea08380f34fd184133b76861b8f62eda9e403c79a0ff887f4828a5feafc7572af5de6af61495e9c7c2a31d5452a567322f317ac4a4a5ed98b4494bc0a9ea919dcf90f5b5b4f6631ca8f6dadf9873c8405025ed1d712d2bfcfb7896e74a1d9e2a8a244a2829bfbc26872e9cc4441bcbb51f6b360b0192e280d84a8f845c913a044e2cf2515d876149659cc6f11fbbd8dbb315497a74eeeb430165c7af325fcc7d9dee7725dfc6dd31ca38110d05af09f1befe29de82ee2194fdfddaa89d594a086fa420c0aa1d97dbcd875a2599f204eea0c09bbdd83d0f44f46556de07482718a1b23e5cc7d35c1a58a5bdce0a6557c88c794f74cd136dda2f1e3a1aefabfe606a8de1c327287bce40ce406c46bd10d2d1a0552caae9980b2546b94130713893f96dc015c4a2b23efa8c73e8d0555530ba61978e3ef4e8740ef3d91bfdb2496846dc885d5d24bbe3b6e5a0fb80a9d2b970a3beec7ceb7568d6e20c1463d2a75d6958b8aee59e03be0e605f70bafade389be8f0acf750ab79a5401cea807e337d75a5d5abfbb7f855b2b7c4861dc53b9c2fb823b01d6d8671e374db313b7c6c0e89b29b21936e65ab833e6b3f17e411fdd61269258bc4a4c92a4fc54c6b49eabf53757f73713e37881fdc7c0a8a97ea07ef602ddccc71236e74f21beab65a117402cb45bf4b7fa66083d1181d8a88e11ffb4bda36e5d85da8401ba493b760a2ff8e82361d912eb17956dabe0c82add81731e9b29e5a9642d4248aae205f01885007b5460d12ae4774956c01f06f3777a5b1ed18f99663a09d523c8c4c1eb4b3ec546fc6d316f2f0fe3d75a01b1e36d4b9daa46d3d2dc15cce10f298db6563e64b2d9d597b5d64e83de9bbfa423180c4b98f463ed1937a7709dc79b5f68c0fc8f3c12748ecf23e938fa5d3b84d7b7bcbb11728d2480393087b9634f9d44725c05c6927cffe79d79147a383e5c048749c1c67aea5bfb7a9f72ab835a58be20d34e648752abe751049da48ca331050649de0da6a9171becab813dc0f0c44ba41912debff200f1d7b0f78fdf274a01a4068cb233b9c261f91d4a6caad94582313f2c05657ffcd1efa66baa63d4ba9a2d6c33e77321364ae2f8047e651865681f7d81664c80700c016ff688fdd2c8ee137ce58850c923966ee0436a34a8013053290a0262fb83260dbea71a18985cb7707d8e242fcfa4aa4fb71023aa567a0ac5490eeaa18d0f70f5a28ff320b6593a6e5ef7a30565741d337ecf82b854a48bfd6aebdd0c1fd48e896b515c9ba610295675e1af97ae371b409c84ed9302f695edda19bbee2a57c051de3d4dfb798f6dfe58692438d6c215b9b0e31e251c04ee97b026ea6fb2da02e5ad7b021c1ef3252d0c6f28fe4f35dee8d04fcb60c414934b424b1cbdb3fff8f4f77fe70ee02733c4da1dad636bbfab510f598db35bfe189a636a2b5a5ec005c091b674b604c58871edafa77a3b88bf555204ca43e99db53b3c163d5bac7f23038c648242101b426f8ad50bba0aa4df2da5bd9eb495a0f6d003545a8c9407dd46baeca95750bfd9148284092b5a3b490b275c926f72e8f64b8a6c4a38e205ac9944107cd047d5c72299cf9dfde5c9d37adc986b3ca3ae7dd5290dfea9dc475ebd009b28f68edb669533c6a8b56f60b906621a9e16c7ed6f8d75eae5510c0794e9abde54b869633b5b6d5b00a81df98fdd2e638e0219c8f27f88fd9f1703c65ba84ea4f2f91290d541e15aab02de545cb5d0b32177df4e770dad4c42dfff399daf2d5260b0867f576eb0acf2795377a3d4a5dc12fb69f9d68ebeb7e53c7aeab294c250a28117f5435ec80d737e4d005b5fad1f8caf33b7f7aa1a04ac63cb6d226a002c2115cb527b2efdbd9d430e7474ef17d11c650b0ce5da7a6302d85b5b1f8fd9078947f9c8316fbb1663897cd5dd34d1aa6342b3779cba5f75ce2c06a37d0cceaa6143d225ac6df218fb41309d2133f9ad36863ffe83d21aef8f2a2c59accf33589390c060e695e2b3de8c91cb5b6f91147fb6631bf8b8c34625c6dd1573beb50ebea089b42ecd13f93720bb9cb8a094168bf04f03d653ff6f573e5b63187d42085a9d866dcb83a42e78fbea623f556960977dbbe3bc1ce5072c8ca88dc15cceda311d6f521a6bf944ec0656e3bbdc91f91d702f0c078ce7a31895bec59e9a4c5678a97356173cbee7db7a50fff3cb36d2bec705fa649d723dff5703a92a857894d7fec3ebcc87bbdc4bbf38dd8366bdf54ec13ec243997f40c1d213e35fe9ce973c0be62151df2d237b02e0d48256811485505997566f23ad0877b628628fef44b7b43b2dcc60436e4a51e09f16eee82b7a4da0d7973f08af13facbd1d8d6332c1554972c549cf174dab986778815df6188edf293a6df0db5154d9cfa1a7d6b2f0bf293df6cc6dd1c66f415f052e447e66b19c08e47b21565a1060ff40c988a1d004059f659354a2009fecb4d4f1259908bc6a0d2de4590be8652cd93c3543bad39b8857049ce4436b799dbce7c15757811d5613915fd0fc3f468e1ecf050a18b72ad2f696cc8a17b8dcaca1b496e2756547c080740ff20855501e55f3194ed2f65b0ae9155f720184629b1dfb0a3148fad86d8ccd8baa50c93e67dac14517bd990a2c472ae965f1363b93a4cc8de10d4046410983fcbb911a41eca36e7b091d262d923e1f975ce33b1f7fce425d530174cdbaed2c6983802710985665924eae1dd7bc54dec207c1873c1158775e08002857635b2e6ee172fd562b4ed341a7750abd514e508bb79eb1dda4687326467b6db2f7e560c272f51f48a0d1af11fe619327c16f2dc0ad38cc7540a318de891c0689036f3d10cb9b16933d22e05c821ee783bf945e148889cb90d86f0b3427a3984e4c823742114ebc71a0550d59c930c0761becfb5e47363ede7feba5eb25c85d1a00031cbb1f7c2676f8ebc10766866057cbda9661cc635a8ff24e3c1a7dbe429f7c9b70f83f590ec4659556233f85fd0d5b82eee31d233421a196216020f1fa46c04c2db426a62c0c35f5738d457ff8b09182a72cb1b45a3ad66eb82721da39349a1b92a1a293404dbc6e4da55c1a38c682a40025e7797dc082208117789d5ba2ee5e26591c28295267df42192f02978b10090ed9eef272ed428bb625f8c051cdcb0e694ff4f288acacc2cc68bc6211bd211afe33f993ff237249748d380ce4546402876aed686d53e294ea7e2058429ee7e89edb32fb29fea3caf0b9ac8e1f41aa7732bf1ae37b897526964b174c8e8c18a72809b2317a063c43e04b6f48929f824cf12ec92034a752e2bfa1e9f1cb83c5efa37fd09346133e21b2cddbb3ff5e2fad683f0213e0c8e3de4992ad0542bf9ddb9a4e0292a673b4b4fedaccb7f3f67a75b43be6a662a6f7dab91870e0a32a0c8700d3d9e310b159259357e901fd6651a5b4be9ae271861dd7dbae68683cb4935bed82bfdf7692fdc063f04fc75a43bc1a1a9cc618eacb082036613aa28bae3aa15a63cc4f4522f16001c7e0be639e8dfe8cc1e2b5d2aff4c47009991241bca31772f328801f304cbf965e0a8fd934a93d5ba4f49493f646367e2a27d8062e794e4055d8d01c48268872d95475274ef54c558c65ac1759c43778a95aae6c736ffc81568f9787bf2fc631058322698e2149b3c54edce2c8dfc1b3236d7b8da8803adbca7af488797c8bf6633445ff8e09115ef465793dbce95789a123f1b57bb8e9c812cf00faea082c9341f5fc49c794abdd84c8e8fcead67117863921b2fc6f599c7b1666f2da01a6eb21b0f94828995884854c90a8664b3c72eab42e9e49756fec4e5bbf189e409f9a3573fad4f20811f7b5c778e23a968d4c3154a725ed65b6c28ba72b6f075ca321463f3e2793a107945841f652cce37ed73c6d34144d5888cd5991b5f328bf0e2f126da630590663049e279651f4430fd732e5cf8fb80e353f337a1c0a7554437f432f5ce50672b32f1853afdbc42240b51d383d8c206469015e9cfb4e3ca31929e998d2a8c2b130358e39da1f6c5e3fe7e06c4e6315d26a6df460a61357d751a37ce785bddd9d032a450e6a93a0e248dac52fbd0fa38cc4646780c19a8f8c3d4bf48edc189f405071f7ea47e5668f27fa5d2bb7a56a40d4ba7fbd427475ca7425be295ed787d33f1a0f272d4e52ba7ca15a18ec9cb7823aef1d6211ac120d55dc26c8b2c041942b632751342a2c20fc2440de60aa3f433a695dfb67471bd19c38ecbc11e54ca2742a5ad859009c82017c26f0885dd8e71d240d34a8346d98eb79855724eca8e6241aeb0761997f906195275cd7601f1e762742b4a1ce4b5afb9a39b2a3310bcab0f68e22f3f85d6ed75535d40e4b9a0b41cbb6bf09b596d84bd6230c7fc5936e7c9224aadef13f08b79618a2495b77ec7a54cbab58cdecd1efa1042ec30f48b400cfcb426d6448b9e65a52fd323591fa965eafcb0e5fb57baef11332744d39ce109ca70b2e3da8db4c6a4b103ca1c8d7295284da654755a49c87f35bc1b38d6d1e0c9e29005d4ee474df1df96f0505c4d0163acdb8a8a3488497661c1e5dbc2bbf7cd26c6ff286cc7fc762d0f4e0b3c65a29f0fea39432029a137d118527316e7c65944292f3da9aa4a896deab13fc946e48a81e4fbb476edc7fa30ce126fabf95302b0c2c4d04a1c601f81224d58521f3705849efda8e9a462dca2defc85d0ee0bb1c861cb4a3623d6df18ad5b366eea57f286d8b9c69526aa1886cbf64e6620588793c53cbd8799672c8db8520161ba85d228a9146245b184b6fdb7b1a38d8b7b7d64b0bf7a653fa1819c26d5b51be184eac1c67112428a64040ae0ba8536a8d113c11424583371f4c872557fe425960f6a635bd83a7381de4f8d9fcb318d3aa913694c9efd36c2819170bfef4bf7b3f577aa7a8a5149c9ab4053003993ae2a73aad39a5d3f9d673090c41da92b737dc291854c282bce87448317b63d5003c2f29177f2ff973f5a4f3f46e6667e086a4405d79a455d3050fcb3fe5fb5750735a62847ee2865d5f7d758be614d25313857d605d64c538402605adf407b9fc4217f89fe6d0c5bf89e0bed155ba67b140fe1ecedd743308e354d718eb9da340d6b793ef22128afe90772c212c1417a09dcd18f407c236190fd9c94be8868b6b44f6d717d2d6908c936b17f23885f120eb70d03e2a4275a140818971ec184c5305dda635d334554014cb47b97a886e2faf62029681f11a7b3bb76914f871850be7c91b779a38a201c516c48c0f8f83b9654f287e6da262c6163b1a77e34741f0719f7809e7192869faeb187b9fe339f74406e47034e7f9ef90be412a414e4077f1cbdd61ea7d763737e81a136f46652025e8ec92352d3efa071675a84854d10df21ba74ae14dc111a96f9bb6cdc6b831d8e379eaa18017c8282be49fe2732d42e5c7bdbf400fc9e8030f3117107b8537e8261bfcd2e376f16474b51ca8b2a7359754d3082dceb1ec3ae625c10b84aca1270acc84ffe71f95c089a0db61ce3ab6a7cdae67e3add5c884ea0be3580a148d99d31e3c03e7a73c2a5f48bc635d6c42620c51504f1b4f3106d70f1d814a0c322c26906ffd0b5c7940f7cdeb3fcf6186715e5f5558871483f1d724e417dbce5c951313f0a43786512eb78d8b75426fe6bd9a0ecdc3bdc32c94e867c553e32246a4305c8cce7ff6bfe6d661b3d707bc2eef4859bd1a5086aa4eec3a145f37b7917734981648714744a19a1ff8a502834afd365d6e28ac9b86a118ccf3735eb24125ff8eab89d1335bb678b53fc950b6f7d088cf2a81b6adc8fed7468d3df7d62c1be71eaa402bfa6525879bb17a83a6ab312c6eebd1dc7d35418db8c8011bbaaa24cdf172d6c7e1911cf18ed8745e51aa4a6bde4fce3ca2adec509974d3a9fb92c0bbfdd6ef29608b22a6352fe863fb61072135c9702baa1c67c95af4e5023efc4fc48f25b56424e64f21daf1a0de223fcf103768a0b01553bde6ba989fc55d2ce709bfb432cda361b6438554935ae6428b655169ac261fd697f8894608301f13742998167f05e035b7171dee68679fabb9b2bf9c994c3061adc145aaa68fbb9138f2ba112c6b221c3530a956432f8e8aef6f4dbcd7bc186e6004fedb26d194d72f39f12c878fdc931d046267b0976ad87e0907b2e83bdd0e927eb7fd134f94136c828317c12d2f6e621fa6e4267e9c9950e02a458cdc2c5e265ba41252d0ba7df3336b3f661e47d2b706aaa36c01a0ebc7a8a6ce918ed9d761fba65e87a60eaa90fdc3895ed9daec42b430f0d99884fd3230a08039504eca3ff78ba5e0548a3edb3cda1205fb508b0cbbf176f1519f410707b17824ee11a140b79480157e6f009c38f3f6291103b0760fa3e0dfc9c0750dd5f2c18d9f11124a4437fc3025fdcd1f6c2d4740c036c3d3d567273da7c30f60a6a80cabb1348b1706b989d49bd97715ab26703ff3923badaaf6811c2b95bb631fe7d9ccc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优化 coding 基础设施，以及若干有用/没用的新闻</title>
      <link href="/20250816-ccls/"/>
      <url>/20250816-ccls/</url>
      
        <content type="html"><![CDATA[<p>今天在编译新的 gcc，试了试 gccrs 编译器，以及 gcc 对 -std&#x3D;c23 的支持（主要是 auto 关键字）。</p><p>gccrs 完全没法用：写了个 hello world，告诉我 println! 没定义，因为 std 库不能编译。好吧……</p><p>auto 关键字支持得挺好。</p><p>顺带一提 gcc 整个编译流程好慢好慢。</p><p>给自己编了一套即插即用环境配置脚本：</p><p><a href="https://github.com/Tilnel/dotfiles">Tilnel&#x2F;dotfiles: coding environment configure</a></p><p>基本上就是 C&#x2F;C++ 的 vim + coc.nvim + ccls 这一套。这次把 clangd 换成了 ccls，用一段时间看看。</p><p>发现了 <a href="https://mirrors.cernet.edu.cn/">教育网联合镜像站</a> 所有地方的配置都可以统一使用这个，会自动选择最快的 source 跳转。</p><p>发现 <a href="https://github.com/Tencent/rapidjson">GitHub - Tencent&#x2F;rapidjson: A fast JSON parser&#x2F;generator for C++ with both SAX&#x2F;DOM style API</a> 的 Release 版本无法通过编译。git 的版本是对的。而 Ubuntu 镜像站未经验证地使用了 Release 版，坑了我一把。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>需要、有无的意识 allegro</title>
      <link href="/20250816-allegro/"/>
      <url>/20250816-allegro/</url>
      
        <content type="html"><![CDATA[<p>不需要某事物的人不会意识到他有或没有。</p><p>让我们用反例来验证一下：我没有近视眼镜——虽然我也不需要这个东西。这里看似是意识到了，实际上并非“意识到”，而是作了陈述。我还可以举出一万种我没有的东西，但是它们并非对于当下存在活动的反应。<br>弗雷尔卓德-大龙曰：“没有烟，不得劲”。对应的就是需要的场景。如果没有这个嗜好，恐怕人一辈子也不会想到这件事。<br>譬如曾经你原有一件衣服，后来买了新衣服之后收了起来，想不起来穿。这时候你也意识不到你有这样一件衣服，并且还意识不到你这件衣服没了。</p><p>由此，“需要”是先于对“有无”的意识的。我可以提供什么？我还缺少什么？这些都必须先有需求，无论外部还是内部的，才能作出回答。<br>恋人间陷入的焦虑，经常属于此类。“你到底想怎样？你到底要什么？”这话其实没说完，叫：如果我拿得出我就给你，如果没有那我也没办法。原先存在的是一种对于可能性的敞开，在遭遇到“需要”之后，可能性就“收敛”、固着了。</p><p>对可能性的敞开，实际上就是“烦”，是 care；而固着的那个过程就像是沉沦。这些都是此在存在的样态。</p><hr><p>原本想写“需要”先于“有”。即不只是先需要才想起来有没有，而是先需要才能真切地“有”和“无”。现在路走了一半，在这里只要再证，对“有无”的意识先于“有无”本身。这部分卡住了。</p><hr><p>写这些是因为我想起这样一个话题，在恋情中我能给予对方什么？想着想着发现自己不知道，也许对方真实地需要我才可能判断自己有没有，甚至我本没有的但是一遭遇到需要便“凭空”有了。</p><p>譬如安全感一类的模糊感觉。我能提供“安全感”吗？我也不知道。但一经被需要，这种能力的可能性就会立即得到答案。有时甚至于，“需要”&#x3D;产生，即产生并非需要引发的后续事件，而是其本身的一个结果。不论被需要者有没有，但“需要”和需要者本身就已经决定了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>镇江·Bangdream Only</title>
      <link href="/20250605-zhenjiang-bangdream-only/"/>
      <url>/20250605-zhenjiang-bangdream-only/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>天天</title>
      <link href="/20250605-day-by-day/"/>
      <url>/20250605-day-by-day/</url>
      
        <content type="html"><![CDATA[<p>虽然没有去很远的地方，但是本学期是往外跑得最多的一学期。原本要么应该静养，要么应该忙点实习相关的事情，然而目前已经全无心思。此时再一味地说自己对学科及业界都并没有那么感兴趣或许为时已晚，也没什么必要。</p><p>如果有可能的话，我非常乐意做一些不需要动脑子的工作。从我到各种地方打杂的经验来看，对脑力要求不高的岗位占了绝大多数。如果我在工作上花了太多的脑力，生活就会变得一团糟，一根筋直接两头堵。我也不知道怎么调整到正常的状态。5 月份的上半月拉了一波工作强度，这时我发现我没有办法把工作和生活平衡好。很多时候晚上 11 点回了宿舍之后打算睡一觉第二天再战，但是突然想到一个什么问题就打开电脑，花上三四个小时做一些小 test，第二天就只能睡到 12 点甚至之后。</p><p>经过一段时间的紧绷之后，只要稍有松懈，又很难再拉紧了。从 17 日开始，我实际上就没做什么工作了。刚巧这段时间活动比较集中，去上海、排乐队、排合唱、去镇江。中间零星的时间实际上也很久，不过一分钟的正经活都没做（</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ave Muji咖</title>
      <link href="/20250605-avemujicafe/"/>
      <url>/20250605-avemujicafe/</url>
      
        <content type="html"><![CDATA[<p>22 日和牢肥去了上海 Animate Cafe 的 Ave Mujica 场。作为喵妈虽然没有人给我塞麦麦的杯垫，但是可以用一个初华的吧唧换 4 个喵梦谷，没想到去之前的预言居然成真了。</p><p>也许是坐在大祥桌布上的缘故，抽奖的时候抽了很多 saki，纯大烫门；并且因此引来了初华。但是这些全都被我熔成大喵了。</p><p>结束 A 咖之后转战百联ZX，几乎把目之所及的麦麦立牌买全了。</p><p><img src="IMG_20250523_003951.jpg" alt="一天的战利品"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作随记</title>
      <link href="/20250514-working/"/>
      <url>/20250514-working/</url>
      
        <content type="html"><![CDATA[<p>记录了一些拍脑袋的想法。</p><p>1、stateful &#x2F; stateless。</p><p>现在看来，就算 stateful 也不能搞这么重的 state。有点太多余了。</p><p>想到一个事实上的等价性标准，那就是，如果在同一 interleaving 下两个 localstate 对 sharedstate 会产生相同的影响，那么称状态等价。</p><p>这意味着，只需要：</p><ul><li><p>rip &#x3D; rip</p></li><li><p>抽象状态相等</p></li><li><p>inbuffer 相等</p></li></ul><p>2、正确性</p><p>对于 raft 而言，也许只需要证明其在有限几个任期内的正确性，就足以说明问题。</p><p>3、解开 guest.h。单文件其实包含了三个方面的内容：elf，thread(process)，snapshot。但是，目前全都混在一起写了。</p><p>4、用户的 choose 有没有更加简洁的表示方式？</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试器中的 backtrace：libunwind 的局限与成因，并与 GDB 对比</title>
      <link href="/20250512-gdb-bt/"/>
      <url>/20250512-gdb-bt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章包含 AI 创作，请仔细甄别。</p></blockquote><h2><a href="#mu-lu" class="header-anchor">#</a><span id="mu-lu">目录</span></h2><ol><li>问题现象</li><li>远程 unwinding 的信息来源差异</li><li><code>libunwind</code> 的查表逻辑与 <strong>两级 fallback</strong></li><li>为什么缺少 <code>PT_GNU_EH_FRAME</code> 会导致“丢帧”</li><li>加上 <code>--eh-frame-hdr</code> 后为何立即恢复</li><li>GDB 的多层策略如何弥补缺口</li><li><strong>澄清</strong>：<code>unw_step()</code> 在找不到 FDE 时并非总返回 0</li><li>测试用最小示例代码</li><li>快速检查二进制调试信息的命令</li><li>附录：关键源代码片段（GDB &amp; libunwind）</li></ol><h3><a href="#1-wen-ti-xian-xiang" class="header-anchor">#</a><span id="1-wen-ti-xian-xiang">1. 问题现象</span></h3><p>在完全静态链接的可执行文件上，使用 <code>libunwind‑ptrace</code> 做远程栈回溯，得到的结果常见类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#0 __libc_recvfrom</span><br><span class="line">#1 main</span><br></pre></td></tr></table></figure><p>而实际逻辑调用序列应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main → poll_msg → recvfrom</span><br></pre></td></tr></table></figure><p>同一进程在 GDB 中执行 <code>bt</code> 却能看到完整链。</p><h3><a href="#2-yuan-cheng-unwinding-de-xin-xi-lai-yuan-chai-yi" class="header-anchor">#</a><span id="2-yuan-cheng-unwinding-de-xin-xi-lai-yuan-chai-yi">2. 远程 unwinding 的信息来源差异</span></h3><table><thead><tr><th></th><th><strong>GDB</strong></th><th><strong>libunwind‑ptrace</strong></th></tr></thead><tbody><tr><td>可用 ELF 信息</td><td>在磁盘上打开目标 ELF 与 split‑debug，解析 <code>.debug_*</code>, <code>.eh_frame</code> <strong>全部 section</strong></td><td><strong>仅</strong> 读取进程的 Program Header（segment）映射</td></tr><tr><td>CFI 首选</td><td><code>.debug_frame</code> → <code>.eh_frame</code></td><td><code>.eh_frame</code>（必须先通过 <code>PT_GNU_EH_FRAME</code> 找到）</td></tr><tr><td>备用策略</td><td>prologue sniffer → rbp‑链 → heuristic</td><td>rbp‑链（简化版）</td></tr></tbody></table><h3><a href="#3-libunwind-de-cha-biao-luo-ji-yu-liang-ji-fallback" class="header-anchor">#</a><span id="3-libunwind-de-cha-biao-luo-ji-yu-liang-ji-fallback">3. <code>libunwind</code> 的查表逻辑与 <strong>两级 fallback</strong></span></h3><p><code>unw_step()</code> 内部主要调用 <code>_Ux86_64_step()</code>，流程如下（伪代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ① 是否有缓存的 proc_info？若无：</span><br><span class="line">find_proc_info(ip, &amp;pi) →</span><br><span class="line">    dwarf_find_unwind_table(pid, ip)  // 首选 .eh_frame_hdr 查表</span><br><span class="line">    if (!table)                       // (A) 找不到 FDE</span><br><span class="line">        try_framechain();             // (B) 用 rbp 链 fallback</span><br></pre></td></tr></table></figure><h4><a href="#a-mei-you-fde-fan-hui-unw-enoinfo" class="header-anchor">#</a><span id="a-mei-you-fde-fan-hui-unw-enoinfo">(A) 没有 FDE 返回 <code>‑UNW_ENOINFO</code></span></h4><ul><li>对 <strong>本地 unwinder</strong> <code>unw_step()</code> 会直接返回 0。</li><li>对 <strong>remote‑ptrace</strong> 实现，函数继续尝试 *(B)*：</li></ul><h4><a href="#b-try-framechain" class="header-anchor">#</a><span id="b-try-framechain">(B) <code>try_framechain()</code></span></h4><ul><li>若当前帧保存了 <code>%rbp</code> 且 <code>%rbp</code> 指向合法栈区， 则认为 <code>[rbp]</code> 存 caller 的 <code>%rbp</code>, <code>[rbp+8]</code> 存 caller 的 <code>%rip</code>；</li><li>组装一个“人工”上一帧 → <code>unw_step()</code> 返回 &gt; 0。</li></ul><blockquote><p><strong>因此</strong>：在缺少 FDE 又恰好保留帧指针时，可以继续退到 <code>main()</code>，但 <strong>会跳过所有 frameless 函数</strong>（如 <code>poll_msg</code>）。</p></blockquote><h3><a href="#4-wei-shi-me-que-shao-pt-gnu-eh-frame-hui-dao-zhi-diu-zheng" class="header-anchor">#</a><span id="4-wei-shi-me-que-shao-pt-gnu-eh-frame-hui-dao-zhi-diu-zheng">4. 为什么缺少 <code>PT_GNU_EH_FRAME</code> 会导致“丢帧”</span></h3><ul><li><code>.eh_frame</code> 在静态程序里默认是 <strong>SHT_PROGBITS</strong>，不在任何 <code>PT_LOAD</code> segment；</li><li>远程 unwinder 通过读取 <code>/proc/PID/maps</code> 里的 segment 首地址 + program‑header，<strong>只能</strong>看到 <code>PT_*</code> 指定的段；</li><li>缺少 <code>PT_GNU_EH_FRAME</code> ⇒ 找不到 <code>.eh_frame_hdr</code> ⇒ <code>find_proc_info()</code> 失败 ⇒ 触发 (B) fallback，仅凭 <code>%rbp</code> 链。</li><li><code>poll_msg</code> 恰好省掉帧指针，于是被跳过。</li></ul><h3><a href="#5-jia-shang-eh-frame-hdr-hou-wei-he-li-ji-hui-fu" class="header-anchor">#</a><span id="5-jia-shang-eh-frame-hdr-hou-wei-he-li-ji-hui-fu">5. 加上 <code>--eh-frame-hdr</code> 后为何立即恢复</span></h3><p><code>--eh-frame-hdr</code> 命令让链接器：</p><ol><li>复制 <code>.eh_frame</code> 并生成一个紧凑索引 <code>.eh_frame_hdr</code>；</li><li>插入 <code>**PT_GNU_EH_FRAME**</code> program‑header 指向该索引；</li><li>由于 <code>.eh_frame_hdr</code> 属于可加载 segment，远程进程映射可见；</li></ol><p>于是 <code>_Ux86_64_dwarf_find_unwind_table()</code> 能定位 FDE → <code>poll_msg</code> 拥有 CFI → 回溯链完整。</p><h3><a href="#6-gdb-de-duo-ceng-ce-lue-ru-he-mi-bu-que-kou" class="header-anchor">#</a><span id="6-gdb-de-duo-ceng-ce-lue-ru-he-mi-bu-que-kou">6. GDB 的多层策略如何弥补缺口</span></h3><p>GDB 全流程简略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DWARF‑CFI   (文件级)  → 成功 → 返回</span><br><span class="line">  │</span><br><span class="line">  ├─ 失败</span><br><span class="line">  ▼</span><br><span class="line">prologue‑sniffer (反汇编) → 若发现 push %rbp/mov %rsp,%rbp → 手算上一帧</span><br><span class="line">  │</span><br><span class="line">  ├─ 失败</span><br><span class="line">  ▼</span><br><span class="line">trad‑rbp‑chain (纯链)</span><br></pre></td></tr></table></figure><p>因其拥有磁盘 ELF 信息，不依赖 <code>PT_GNU_EH_FRAME</code>；即便 CFI 缺失，也可借助 sniffer 过 frameless 函数。</p><h3><a href="#7-cheng-qing-unw-step-zai-que-shao-fde-shi-bing-fei-zong-fan-hui-0" class="header-anchor">#</a><span id="7-cheng-qing-unw-step-zai-que-shao-fde-shi-bing-fei-zong-fan-hui-0">7. <strong>澄清</strong>：<code>unw_step()</code> 在缺少 FDE 时并非总返回 0</span></h3><ul><li><strong>若当前函数缺 CFI</strong> <em>且</em> <strong>保留</strong> <code>**%rbp**</code>：会走 (B) 策略，返回 1，继续到 caller；因此最终仍能走到 <code>main()</code>。</li><li><strong>丢帧的根因</strong> 是 frameless 函数（无 <code>%rbp</code>）缺 CFI → 在 fallback 中被“跳过”。</li></ul><h3><a href="#8-ce-shi-yong-zui-xiao-shi-li" class="header-anchor">#</a><span id="8-ce-shi-yong-zui-xiao-shi-li">8. 测试用最小示例</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// demo.c ─── gcc demo.c -static -g -fno-omit-frame-pointer \</span><br><span class="line">//                      -fasynchronous-unwind-tables -o demo </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline,optimize(&quot;no-optimize-sibling-calls&quot;)))</span><br><span class="line">ssize_t poll_msg(int fd, void *buf, size_t len) &#123;</span><br><span class="line">    return recvfrom(fd, buf, len, 0, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char b[1];</span><br><span class="line">    poll_msg(0, b, 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a href="#bian-yi-dui-bi" class="header-anchor">#</a><span id="bian-yi-dui-bi">编译对比</span></h4><table><thead><tr><th>链接选项</th><th><code>libunwind</code> 结果</th><th>GDB 结果</th></tr></thead><tbody><tr><td><strong>无</strong> <code>--eh-frame-hdr</code></td><td><code>__libc_recvfrom → main</code></td><td><code>__libc_recvfrom → poll_msg → main</code></td></tr><tr><td><strong>加</strong> <code>-Wl,--eh-frame-hdr</code></td><td>与 GDB 相同</td><td>相同</td></tr></tbody></table><h3><a href="#9-kuai-su-jian-cha-diao-shi-xin-xi-de-ming-ling" class="header-anchor">#</a><span id="9-kuai-su-jian-cha-diao-shi-xin-xi-de-ming-ling">9. 快速检查调试信息的命令</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 是否包含 PT_GNU_EH_FRAME</span><br><span class="line">readelf -l  a.out | grep EH_FRAME</span><br><span class="line"></span><br><span class="line"># 列出 FDE 覆盖 range，不依赖符号</span><br><span class="line">readelf -wf a.out | head</span><br><span class="line"></span><br><span class="line"># 检验函数是否有帧指针</span><br><span class="line">objdump -dS a.out | less   # 查找 push %rbp / mov %rsp,%rbp</span><br><span class="line"></span><br><span class="line"># 查 libc.a 内部符号及 CFI</span><br><span class="line">ar x /usr/lib/x86_64-linux-gnu/libc.a recvfrom.o</span><br><span class="line">readelf -wf recvfrom.o | head</span><br></pre></td></tr></table></figure><h3><a href="#10-fu-lu-guan-jian-yuan-ma-pian-duan" class="header-anchor">#</a><span id="10-fu-lu-guan-jian-yuan-ma-pian-duan">10. 附录：关键源码片段</span></h3><h4><a href="#10-1-libunwind-src-x86-64-gfind-proc-info-c" class="header-anchor">#</a><span id="10-1-libunwind-src-x86-64-gfind-proc-info-c">10.1 libunwind (<code>src/x86_64/Gfind_proc_info.c</code>)</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (phdr-&gt;p_type == PT_GNU_EH_FRAME) &#123;</span><br><span class="line">    peh_hdr = phdr;</span><br><span class="line">    /* ...读取 hdr, 找到 .eh_frame */</span><br><span class="line">&#125;</span><br><span class="line">/* 如果 peh_hdr 为 NULL → 返回 -UNW_ENOINFO */</span><br></pre></td></tr></table></figure><h4><a href="#10-2-gdb-prologue-sniffer-jian-hua" class="header-anchor">#</a><span id="10-2-gdb-prologue-sniffer-jian-hua">10.2 GDB prologue sniffer (简化)</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct frame_id</span><br><span class="line">prologue_frame_this_id (frame_info *this_frame)</span><br><span class="line">&#123;</span><br><span class="line">    /* 反汇编起始几十字节，找 push %rbp 与 mov %rsp,%rbp */</span><br><span class="line">    if (found)</span><br><span class="line">        compute_previous_frame(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><a href="#jie-yu" class="header-anchor">#</a><span id="jie-yu">结语</span></h3><p><code>libunwind</code> 的“缺帧”症状来源于 <strong>运行时只能依赖</strong> <code>PT_GNU_EH_FRAME</code> <strong>的设计取舍</strong>；当 segment 信息不足或函数 frameless 且无 CFI 时，只能退回极简 <code>%rbp</code> 链，导致中间帧被跳过。GDB 由于离线 ELF + 多级策略，自然更完善。对开发者而言，<strong>在链接阶段加</strong> <code>--eh-frame-hdr</code>、保留 CFI 或帧指针，是让任何基于 <code>libunwind</code> 的调试&#x2F;分析工具完整回溯的关键。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB 的 p 命令实现原理简析 via STRACE</title>
      <link href="/20250510-gdb-p/"/>
      <url>/20250510-gdb-p/</url>
      
        <content type="html"><![CDATA[<p>最近用 ptrace 控制进程，想要实现类似 gdb 的表达式求值功能。一开始我沿用了以前写的一个简单的表达式求值功能，用来对各种整型表达式求值，并且为其添加了从字符串到地址的变量解析功能。只不过我写表达式解析这种事情不太在行，特别是表达式会带类型，没能实现结构体成员访问、指针成员访问这些功能。另外，gdb 的表达式求值还有一个很强的功能：解析函数符号并执行函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hahaha\n&quot;</span>);</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于这样的一段 C 程序，使用 <code>-g</code> 编译的话，用 gdb 调试将会产生如下的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">(gdb) p main</span><br><span class="line">$0 = &#123;int ()&#125; 0x4017f4 &lt;main&gt;</span><br><span class="line">(gdb) p main()</span><br><span class="line">$1 = 0</span><br><span class="line">(gdb) p foo()</span><br><span class="line">hahaha</span><br><span class="line">$2 = 0</span><br></pre></td></tr></table></figure><p>进一步地，如果程序是动态链接的话，还可以直接调用 printf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) printf(&quot;%x\n&quot;, 114514)</span><br><span class="line">1bf52</span><br><span class="line">$3 = 6</span><br></pre></td></tr></table></figure><p>注意：如果不输出换行的话，在控制台模式下输出有可能会被放在 <code>stdout</code> 的 buffer 中，从而一时看不到。</p><p>如果是静态链接的话，foo.c 就不会包含 <code>printf</code> 符号，从而导致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p printf(&quot;%x\n&quot;, 114514)</span><br><span class="line">No symbol &quot;printf&quot; in current context.</span><br></pre></td></tr></table></figure><p>因为调用的 <code>printf(&quot;hahaha\n&quot;)</code> 会被优化为 <code>puts(&quot;hahaha&quot;)</code>。关于这个优化，请参见 <a href="https://publicclu2.blogspot.com/2013/05/how-gcc-generates-optimized-code-for.html">clu2’s notes: How GCC generates optimized code for printf (and GCC built-in functions)</a></p><blockquote><p>使用 <code>-fno-builtin</code> 可以取消此类优化。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000401126 &lt;foo&gt;:</span><br><span class="line">  401126:       55                      push   %rbp</span><br><span class="line">  401127:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  40112a:       bf 04 20 40 00          mov    $0x402004,%edi</span><br><span class="line">  40112f:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401134:       e8 f7 fe ff ff          call   401030 &lt;printf@plt&gt;</span><br><span class="line">  401139:       c7 05 d9 2e 00 00 01    movl   $0x1,0x2ed9(%rip)        # 40401c &lt;a&gt;</span><br><span class="line">  401140:       00 00 00</span><br><span class="line">  401143:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401148:       5d                      pop    %rbp</span><br><span class="line">  401149:       c3                      ret</span><br></pre></td></tr></table></figure><p>still，这样的调用是可以设置断点的。只不过这样的话，求值会在断点处失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b write</span><br><span class="line">Breakpoint 3 at 0x4192d0</span><br><span class="line">(gdb) p foo()</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x00000000004192d0 in write ()</span><br><span class="line">The program being debugged stopped while in a function called from GDB.</span><br><span class="line">Evaluation of the expression containing the function</span><br><span class="line">(foo) will be abandoned.</span><br><span class="line">When the function is done executing, GDB will silently stop.</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00000000004192d0 in write ()</span><br><span class="line">#1  0x0000000000407205 in _IO_new_file_write ()</span><br><span class="line">#2  0x0000000000405491 in _IO_new_do_write ()</span><br><span class="line">#3  0x0000000000406783 in _IO_new_file_overflow ()</span><br><span class="line">#4  0x0000000000404e4a in puts ()</span><br><span class="line">#5  0x00000000004017e3 in foo () at foo.c:6</span><br><span class="line">#6  &lt;function called from gdb&gt;</span><br><span class="line">#7  main () at foo.c:12</span><br></pre></td></tr></table></figure><p><code>p</code> 还有一个重要的方面就是能够保留表达式计算产生的所有副作用。从上面 <code>printf</code> 将输出写入到 <code>stdout</code> 的 buffer 这点即可略窥一二。事实上，<code>p</code> 可以对所有的合法表达式进行求值，比如变量赋值表达式 <code>a = 1</code>。作为结果，会输出 1，并将这个值直接赋给进程中的那个变量。</p><p><strong>机制：猜测</strong></p><p>实现一般的表达式求值，总的来说可能有两类实现方式：</p><p>1、对于纯表达式的无函数调用求值，可以在 gdb 中解析表达式，做求值。通过解析二进制调试信息获得变量地址、字段偏移量、变量类型。通过 ptrace&#x2F;procfs 获取进程实时信息，读写内存&#x2F;寄存器实际值。</p><p>2、对于所有类型的表达式，都可以分析表达式类型，编译 wrapper 求值函数，注入到 tracee 中，并控制 tracee 执行注入代码求值。</p><p>当我觉得 2 似乎是更方便的（写起来一点也不比 1 方便）时候，我还是老老实实去尝试了解 gdb 的真实做法了。</p><p><strong>机制：分析</strong></p><p>此处我并不想分析 gdb 的源码，因为我读代码的能力一直都很差。因而，寄希望于让程序跑起来，并找机会观测其行为。所幸我们有 <code>strace</code> 这样成熟的工具。</p><p>首先运行 gdb .&#x2F;foo，start，然后输入好函数求值的命令 <code>p main()</code>。这样在输入回车之前，gdb 不会产生任何其他的系统调用而是卡在 read 上。</p><p>接着：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -p $(pidof gdb)</span><br></pre></td></tr></table></figure><p><code>sudo</code> 似乎是必要的。然后我们在 gdb 那里点回车。这让我们能够观察到 <code>gdb</code> 运行这一条命令的时候进行的全部系统调用，一共有 200+ 条。</p><p>当一个进程卡在 gdb 给的 TRAP 之后，如果想要对函数求值，那就只能通过执行 tracee 自身的那个函数了。因而 gdb 一定需要某种办法让进程恢复执行，那么最明显的就是 <code>ptrace(PTRACE_CONT)</code>。在输出的系统调用中，果不其然找到了它的影子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_CONT, 3926087, 0x1, 0)    = 0</span><br></pre></td></tr></table></figure><p>合理推测，它的前面一定是将 tracee 的状态设置到适合进行函数调用的状态的过程；而后面则是收集函数调用结果，以及将状态恢复到调用前的过程。由于它会保留调用所有的副作用，因而这个状态的恢复，仅仅是恢复寄存器上下文。</p><p>去除掉一些无关的调用之后，来看核心部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_GETSIGINFO, 3926087, NULL, &#123;si_signo=SIGTRAP, si_code=SI_KERNEL, si_addr=NULL&#125;) = 0</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br><span class="line">pwrite64(14, &quot;\17\345\377\377\377\177\0\0&quot;, 8, 140737488348408) = 8</span><br><span class="line">ptrace(PTRACE_GETREGS, 3926087, &#123;r15=0x1, r14=0x4a5f68, r13=0x7fffffffe6b8, r12=0x7fffffffe6a8, rbp=0x7fffffffe590,   rbx=0x1, r11=0, r10=0x1, r9=0x110, r8=0x4aa820, rax=0, rcx=0x4b37e0, rdx=0x7fffffffe6b8, rsi=0x7fffffffe6a8, rdi=0x1, orig_rax=0xffffffffffffffff, rip=0x4017fd, cs=0x33, eflags=0x246, rsp=0x7fffffffe590, ss=0x2b, fs_base=0x4b2380,      gs_base=0, ds=0, es=0, fs=0, gs=0&#125;) = 0</span><br><span class="line">...</span><br><span class="line">ptrace(PTRACE_SETREGS, 3926087, &#123;r15=0x1, r14=0x4a5f68, r13=0x7fffffffe6b8, r12=0x7fffffffe6a8, rbp=0x7fffffffe4f8,   rbx=0x1, r11=0, r10=0x1, r9=0x110, r8=0x4aa820, rax=0, rcx=0x4b37e0, rdx=0x7fffffffe6b8, rsi=0x7fffffffe6a8, rdi=0x1, orig_rax=0xffffffffffffffff, rip=0x4017f4, cs=0x33, eflags=0x246, rsp=0x7fffffffe4f8, ss=0x2b, fs_base=0x4b2380,      gs_base=0, ds=0, es=0, fs=0, gs=0&#125;) = 0</span><br><span class="line">pread64(14, &quot;\363&quot;, 1, 4302224)         = 1</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 4302224)        = 1</span><br><span class="line">pread64(14, &quot;\220&quot;, 1, 4594263)         = 1</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 4594263)        = 1</span><br><span class="line">pread64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br><span class="line">pwrite64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br></pre></td></tr></table></figure><p>通过查看 <code>/proc/$(pidof gdb)/fd/14</code> 的符号链接，可以看到这个文件指向的是 <code>/proc/$(pidof foo)/task/$(tidof foo)/mem</code>。因而，<code>pwrite/pread</code> 就都是直接读写 tracee 的内存了。推测到，由于要恢复一部分状态，因而 <code>pread</code> 是对当前状态的保存，而 <code>pwrite</code> 是改写。未来在执行完成后，这些读取的状态一定还是会被写回的。</p><p>首先第一个 <code>ptrace</code> 就 get 到 tracee 进入了 SIGTRAP。在此基础上，进行了两个写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwrite64(14, &quot;\314&quot;, 1, 140737488348431) = 1</span><br><span class="line">pwrite64(14, &quot;\17\345\377\377\377\177\0\0&quot;, 8, 140737488348408) = 8</span><br></pre></td></tr></table></figure><p><code>\314</code> 其实就是我们熟悉的 <code>int 0x3 (0xcc)</code>。<code>140737488348431 = 0x7fffffffe50f​</code>，可以看出这是写在了栈上。</p><p>第二个则是向 <code>0x7fffffffe4f8</code> ，也是栈上的位置写入了一个地址 <code>0x7fffffffe50f</code>。</p><p>接下来通过一系列的 <code>ptrace(PTRACE_GETREGS/PTRACE_SETREGS)</code>，可以看到最终的寄存器状态是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">rbp=0x7fffffffe4f8,   </span><br><span class="line">...</span><br><span class="line">rax=0, </span><br><span class="line">...</span><br><span class="line">rip=0x4017f4,</span><br><span class="line">...</span><br><span class="line">rsp=0x7fffffffe4f8,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，<code>RIP</code> 刚好落在 <code>main</code> 的入口，而 <code>RSP</code> 和 <code>RBP</code> 都落在了刚才写入地址的位置上。可以想见，如果接下来开始执行的话，等到函数退出时，<code>RAX</code> 将会代表函数返回值，并且函数返回地址正好在 <code>RBP</code> 的位置写着，跳转之后，等待程序的会是一个 0xcc。</p><p>只不过，这个 code 真的被执行了吗？并没有。众所都周知，栈区一般都是 <code>prot = PROT_READ | PROT_WRITE</code>，而通常不会是可执行的。事实上，我是在看了 <code>PTRACE_CONT</code> 之后的输出才明白了这一点的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=3926087, si_uid=1000, si_status=SIGSEGV, si_utime=0,       si_stime=0&#125; ---</span><br><span class="line">...</span><br><span class="line">wait4(-1, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGSEGV&#125;], WNOHANG|__WALL, NULL) = 3926087</span><br></pre></td></tr></table></figure><p>这等于说，如果栈区可执行，那么迎接进程的是 0xcc (SIGTRAP)；如果不可执行，就会直接产生一个 SIGSEGV。</p><p>不过这样的话，进程不会直接崩溃吗？在 ptrace 下，是 gdb 先收到 SIGCHLD，标志着子进程状态变化。gdb wait 获得了子进程的 STOPSIG 后，才决定是否发送给进程。进程本身没有收到这个信号，因而不会执行 SIGSEGV 的 SIG_DFL 默认信号处理函数。</p><p>实际上，也许我们也能强行通过注册信号处理函数，给触发了 SIGSEGV 的进程续命。不过这就需要使用 <code>rt_sigprocmask</code> 或是 <code>siglongjmp</code> 这类办法了。</p><p>往后就是恢复进程上下文了。</p><p>当然，对于纯表达式的求值，gdb 的确采用了第一种办法，即当场解析表达式并且通过读进程内存来进行计算。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>性压抑 allegro</title>
      <link href="/20250509-repression/"/>
      <url>/20250509-repression/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文包含医疗建议，请仔细甄别。</p></blockquote><p>白天在饭桌上聊天聊到“性压抑”这件事。我不禁想到，我对这种状态似乎有一种“雷达”，对于各种性压抑的表现比较敏感。包括性压抑的人都会说什么话、做什么事，等等。但是一时又没说上来具体都有哪些标志。</p><p>以下讨论不带情感色彩。</p><p>对“性”这件事如果一个人了解颇深，能够掰着指头给你细数性的歧变的类型以及成因，总而言之，对于有关性的科学非常感兴趣，然而又没有性伴侣的人，很有可能是性压抑的。这其实是不能单单用求知来解释，或者并不能说是单纯的“学术”理解。即使是一个学者要作某方面的知识性的研究，归根结底也是某种欲望。其他的领域里，如精神分析临床，与分析者的交互同样也有赖于一种分析家的欲望。如果一个人对性的好奇在实践方面不受挫的话，事实上是很难转而投向性的理论的。</p><blockquote><p>翻开霭氏性心理学的第一页，你就已经性压抑了。</p></blockquote><p>每当人在大谈特谈什么的时候，实际上更多的是掩盖了什么。我询问 ChatGPT 4o，什么是性压抑，它给出的答案是：</p><blockquote><p>性欲的否认或压制，性行为的回避，性话题的禁忌。</p></blockquote><p>这只是某种教科书式的说法。事实上，如果性的话题成为了一种禁忌，那么我们似乎还有一种合法地绕开这种禁忌的方式，那就是把“性”的东西，变成与它恰恰相反的；从“性”这件事中，刨去所有具有性意味的东西。从而剩下一种关于性的学说。</p><p>当然这有点小众了。那么有没有更普遍一点的表现呢？有的，兄弟有的。如果一个人开黄色笑话的频率比较高，或是平时漫不经心地就能说出具有挑逗意味的话来，那么这人是性压抑没跑了。</p><p>其实原理和第一种是相仿的。如果说学说是对于性本身的异化，那么幽默就是对于性的消解。幽默属性使得所有的意味都变为可以回撤的，就像唱歌的时候躲高音一样。</p><p>并且不妨回忆一下，很多作品中的“欢喜冤家”类型的伴侣，似乎你很难想象他们做爱会是什么样的场景。如果是谐星情侣，也许在床上讲个笑话就直接笑软了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>徐州游记</title>
      <link href="/20250428-trip/"/>
      <url>/20250428-trip/</url>
      
        <content type="html"><![CDATA[<p>临近五一，桌游组所有人都有点心痒痒：放长假之前总是这样。一个两个的都在讨论五一前后去哪玩，整得我也想找个地方转转了。不过经群友提醒，既然要出去玩的话，为什么不避开五一呢？我想的是找个小城市进行一日游，略加思考之后决定去徐州。</p><blockquote><p>徐州地方，历代，大规模征战五十余次，是非曲直难以论说。但史家无不注意到，正是在这个古战场上，决定了多少代王朝的盛衰兴亡，此兴彼落。所以，古来就有，问鼎中原之说。当年先总理领革命军，分三路汇合徐州，兴师北上。光复徐州的第二天，清帝见大势已去，宣告退位。民国十六年四月，也正是在徐州城郊，我有幸亲率数十万健儿，征讨北洋军阀孙传芳、张宗昌，大获全胜。我不明白为什么大家都在谈论着项羽被困垓下，仿佛这中原古战场，对于我们注定了凶多吉少。二十年前，我从徐州踏上征途，开始了第二次北伐，中华秋海棠叶遂归于一统。本党本军所到之处，民众竭诚欢迎。真可谓占尽天时。那种勃勃生机，万物静法的境界犹在眼前。短短二十年后，这里竟至于一变而为我的葬身之地了吗？无论怎么讲，会战兵力是八十万对六十万，优势在我！</p><p>​                         ——《大决战之淮海战役》，蒋光头</p></blockquote><p>4月23日，正好是南京解放的日子。这趟到徐州，就成为了“嘲笑校长之旅”的一部分，因为这里有淮海战役纪念馆。</p><p>嘲笑校长之旅</p><ul><li>南京，总统府（已不对外开放）</li><li>徐州，淮海战役纪念馆</li><li>西安，兵谏亭</li><li>重庆，白市驿机场</li><li>台湾，总统府（等待对外开放）</li></ul><p>什么时候能走完全线，要看最后一个景点什么时候能访问。</p><hr><p>启程</p><p>24日晚上，经过少量休整，从学校乘坐 Y34 公交前往南京站。我已经有段时间没有感受过这个时间的南京站了。总的来说，在这里你能看到形形色色的人。就用眼睛看到的而言，在候车厅内只要扫一眼就能看到：下身穿超超超短裙的女生，嘴里叼着辣条身穿潮牌的男生，盖小被在路边睡觉的大妈，披着褴褛的皮质西装外套的大爷，身着完全不适合通勤的浅色套西的OL，露着花臂展示短袖背后经典Burberry条纹的精神小伙……看到不同的打扮，仿佛就能看到各种各样的生活。</p><p>火车缓缓行进。笔直的座椅角度让人完全不能休息下来，只能等着眼睛等待到站。据说，这天晚上车里的人数比往常要多很多，一位阿姨说她以往经常坐这班车出差，早上到了就能开始工作……是极度的工作狂了。导致最终车上显得有点拥挤，到处都是站着的人。我腿伤尚未完全痊愈，这时又伸展不开，导致非常不舒服。不过好在只有四个小时。</p><p>中途，广播里还传来了寻医的消息，有乘客突发疾病。如此播放了几轮之后，终于列车缓缓停下——估计是联系途中的急救中心转运到医院了。这还是我第一次遇上这种情况。</p><hr><p>转转</p><p>终于熬完了车程。一出门的寒冷使我意识到这里是秦岭淮河以北。</p><p>站前广场有一定规模。特别是南侧的那家麦当劳——只有一层，面积超级无敌大，但里面还是坐满了，估计是旅客。其中的相当一部分在借用地方来化妆。我想到之前凌晨经过南京站的时候，站外卫生间也有很多在化妆的。大概出来旅游，一定不能输在出片这件事上吧。salute。</p><p>购买一罐魔爪补充能量后，第一站是访问离我最近的徐州老味菜。离车站就一点点远。由于被夹在四家摄影器材店中间以至于已经成为一种梗了。晚上一定要来吃吃这家。</p><p>老味菜对过就是一片共享电动车停放的地方。花30块钱买一张24小时卡，就可以一整天骑电动车移动，非常的划算。我就骑个小车开始熟悉徐州的地形路网。</p><hr><p>早饭</p><p>几乎是直奔菜市场去的。我忘记位置了，总之叫，苏什么丸子汤的一家。丸子汤，就是汤，炸丸子，面皮，还有很多辣椒。很呛，比较油，我吃不太惯。但是它家推荐了还有一些东西，最后我选了两来风。两来风，就是户部山边上那家。早点非常精致，可以看到菜单里有很多88块钱10个的包子、饺子啥的，挺奢华。我点的很便宜，一份辣汤和四个鲜肉蒸饺。辣汤我还不知道是什么东西，大概是里面有一些细条的豆制品，再洒了很多胡椒面，喝得人食管都凉凉的那种刺激感，实在不喜欢。听说有本地人管这个叫胡辣汤，不过和河南那种很不一样。或者是叫“sa汤”。蒸饺当然还是好吃的。</p><hr><p>云龙山 &amp; 云龙湖</p><p>在城区转了老久，最后南下到达云龙湖附近。云龙湖的规模，也就比玄武湖稍大一点。此行目的是找两个地方，一是刘备泉，一是三让亭。典故当然是有的，但是其实都不是古迹，而是后来取了这样的名字。具体为什么一定要到这两个点我也不太明白，大概是奇怪的执着。因为全线禁止掉头，所以沿着云龙湖东的路骑了一个来回才成功找到这两个地点。</p><p>出来之后找苏堤路。苏堤路下有云龙山隧道贯通，而这里面就很神奇。机动车和非机动车并不在同一层跑。非机动车经过的两边有各种各样的店铺，面积都挺大，像是各种专门的批发店、外贸市场之类的。自西向东穿过，就可以到达彭祖园。这里总的来说没什么，彭祖，也许就是逍遥游里面的那个彭祖。</p><p>从隧道穿回去，上中山南路转和平路，这里不进隧道而是骑到上面。此时左手边是徐州博物馆，右手边就还是云龙山。山里其实真的没什么东西。自然风光？只是去走走。主要的估计是几个苏东坡相关的古迹，while我对于古代文人的足迹其实并没有那么热衷。但是一进去各种弯弯绕绕的，还到处都是楼梯，使我的腿不堪重负。</p><hr><p>徐州博物馆 &amp; 乾隆行宫</p><p>从外面看来，这个馆的面积不会很大。东西当然差不多就是那些……我并不是历史考古迷之类的。遗迹、兵器、笔迹，这就是博物馆。现在让我去想的话，大概就能想到金缕玉衣这么一件。事实上，这天刚好赶上本地学生春游的日子，腿脚不太方便的我为了不与所有人挤，竟然要加快脚步赶在他们前面转完。不得不说小孩子还是太吵闹了。</p><p>一个多小时游览完毕，隔壁有个乾隆行宫。行宫也比想象中要小得多了。就是简单的小型园林建筑。</p><hr><p>淮海战役纪念馆</p><p>再次骑上车子，从和平路向东，再向南进入解放路一直走，就能到淮海战役纪念馆，此行的核心。先看纪念塔，再参观纪念馆。</p><p>建议在参观之前，观看《大决战之淮海战役》这部讲述战役历史的电影。电影里有一些名场面，比如“我说总座高见”的邱清泉，还有凯申的战前分析，以及《敦促杜聿明等投降书》的语音播报。稍微知道个大概，进馆参观好歹就有了一些乐趣。</p><p>并不在此长篇阔论。每每参观党史相关的博物馆时，都会感到一种崇高。</p><hr><p>宝莲寺</p><p>从北门出去，迎来一段长途骑行。宝莲寺应该是此行最偏僻的一处，距离有十几公里。我就记得我在车流稀少的三环东路上自由驰骋了很久。</p><p>这时候正是烈日当空。寺院大门口，地面什么的白色漫反射的太阳光几乎能灼伤我的眼球。</p><p>宝莲寺的素面没有西园寺的好吃。不过素包子挺好的。</p><hr><p>把子肉</p><p>当我赶到周记把子肉的时候，店已经关门了。但此时才下午两三点。我这才知道，把子肉就是一天一锅，卖完就算这种的。没办法只能选择连锁店了。也挺好吃，咸口的一大块肉，看着我以为我吃不下，进嘴之后肥肉全都化了，口感相当好。</p><hr><p>接下来就挺零碎的了。在户部山、回龙窝转了转。如果要形容一下的话，那就是和老门东、夫子庙类似的地方。但是也不太一样。户部山有很多很多的老手艺的店铺，不过无非是笔墨字画，裁缝，饰品，古玩。</p><p>在回笼窝转的时候，还发生了这样的事。一位女同志从左边凑近来，突然就开口问我：“你觉得忘记一个人是先忘记他的相貌还是先忘记他的声音？”给我问蒙了，3秒才回过神来。感觉是路上拍段子那种吧？但是拍段子怎么会悄悄从侧面上来就问呢，总之很奇妙。</p><p>去徐州的二次元店看了眼，发现这里的邦谷浓度同样很低。</p><p>临走在徐州老味菜吃了份地锅鸡。这里的老板似乎知道这家店有点出名了。</p><hr><p>体验了一下徐州的地铁。从徐州站上车坐到徐州东站。</p><p>徐州东站感觉面积特别大，站名的牌子延伸到很外面，然后要离开很远才能拍到娃…因为腿已经几乎要爆炸了所以放弃。</p><p>高铁还是太舒适了。可惜只能睡一小时。</p><hr><p>吐槽</p><p>上午我认为这座城市还是非常宜居的，但很快这种想法就改变了。因为这里对于非机动车并不很友好。一天下来我骑行了大约60公里，非机动车道时不时就会消失，要么就是和公交车共用一条道。公交车停下来的时候，就要从公交车左边去超车。如果这个时候它刚好启动的话，司机第一下都是向左变道，把非机动车向路中心继续挤过去，这就很危险了。</p><p>另外一点是，路况比较差。比较典型的是外余窑路，这个地方是真正的地无三尺平，骑在上面感觉屁股都不是自己的了，差点要给哈啰赔修车钱的。一般的路段上，很多井盖及其周围地面都是下凹的，无论方圆。骑车还得小心避开，以免骑到高低落差的缝上造成车辆失控。</p><p>这个地方非机动车有点太多了。我看到很多初中生也在骑电动车上下学。还有很多老头乐，以及走非机动车道的摩托车。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配镜</title>
      <link href="/20250424-trip/"/>
      <url>/20250424-trip/</url>
      
        <content type="html"><![CDATA[<p>我是个不戴眼镜的人。从小测视力两只眼睛都没有下过 5.0 这个数字，甚至在高中那段用眼强度极高的时期视力短暂地到达过 5.2。我搜索了一下人的视力会不会上升，出来的结果全都是近视度数上升，看来没什么科学依据，就当是一次测量误差吧。不过这也只能表明我没有近视，事实上我可能是有一点散光的，具体表现为我晚上盯着路灯看的时候，左眼会有左上-右下的眩光，右眼会有右上-左下的眩光。两眼加在一起，就是一个“X”型。我以前一直认为这个是每个人眼睛都正常会有的现象，比如有的影像作品中出现的星星，很多都具有一个十字形状的眩光。但我现在才知道，视力正常的人眼是没有这个东西的。但我也说不好，因为我但凡把眼睛睁大点，视野中的各种眩光就会消退。归根结底，只要控制好眼部肌肉的力，让眼球结构产生一些微小的形变，也是可以“不散光”的。何况我眼睛并没有看东西特别费劲的现象。最后还是没有去验光。</p><p>所以当然是去买平光镜啦！高三的时候我也买过一副平光镜，应该是19年春天。一个契机是当时刚刚好到处都在飘梧桐絮，想着买个眼镜多少可以挡一点；另一个契机是后来成为前女友的同学在18年我过生日时送了我一块眼镜布，送完才发现我根本就不戴眼镜。当时我妈也是哄我开心，就去挑了一副。那副眼镜现在看来其实非常不适合我，因为选得实在是太窄了，修饰的效果就像是五官整个往中间聚拢，看起来非常傻。</p><p>后来我很久没动过这个心思，直到开始研究穿衣，就顺便觉得自己可能也需要一些配饰来修饰面部。使我关注眼镜这个品类的还得是 <a href="https://www.bilibili.com/video/BV15y421i7Do">Saint Laurent 2024FW 男装系列</a> 这一场。喜欢看帅哥的必看，喜欢西装的必看。当时觉得第一个出场的哥们很神，后来才知道全世界都觉得他长得像圣罗兰本人所以爆火了一波， 刷淘宝刷小红书都经常能看到这位——以及那副标志性的黑框眼镜。</p><p>这不是契机就来了：社团有人要换眼镜，有人要买墨镜，刚好能凑一车。不过事实上最后这个活动爆火，凑够了两车人以至于决定坐高铁了。</p><blockquote><p><a href="https://www.bilibili.com/video/BV1kmddYCEbH">路上拍的低智小视频</a></p></blockquote><p>丹阳这座县级市除了一下高铁就是眼镜城以外，几乎不能给人特别深刻的印象。很难想象它不是刻意这么设计的。刚好我腿脚不特别利索，拄着拐杖出高铁站。搁别的地方，这时候绝对都是各类司机等待接客。这个地方不需要，取而代之的都是各家眼镜店揽客的。</p><p>往路口走要跨过一道矮栏，边上的大叔看到我拄着拐，立刻叫住我并指了指稍远处的通道。我寻思懒得绕路，于是把拐一拎，直接自己跨过去了，这可能是我能够制造的最接近“医学奇迹”的场景了，谁看谁沉默那种。不过后来好好解释了腿其实快好了。我当时还在想这大叔应该只是路人，一转头手上就多了张名片，是他负责揽客的一家眼镜店……果然这个地方真的只有眼镜。</p><p>一行的四位直奔主题，去了提前咨询过的一家店。陈列柜里展示的各种仿品眼镜还真是挺有意思，等待眼镜制作的过程试戴了很多，可惜忘记拍下来了。</p><p>眼镜拿到手，一出门感觉天色非常不对劲，有点飘雨并且发黄。当时还没有往空气质量这方面想。直到眼镜片上雨水微干，留下黄色的土粒，这才想起查看天气，一看是沙尘暴，AQI 500+——顿时觉得呼吸都有点不顺畅，后咽壁开始刺痛。匆匆解决完午饭就返程了。</p><p><img src="image-20250424140947796.png" alt="眼镜" style="zoom:10%;"><img src="image-20250424141008286.png" alt="娃" style="zoom:21.35%;"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>纯杂谈</title>
      <link href="/20250422-misc2/"/>
      <url>/20250422-misc2/</url>
      
        <content type="html"><![CDATA[<p>说出口的话，在最坏的情况下，就是变成了他人之间互相攻讦的依据。</p><hr><p>当一个有用之人，并且想怎么用就怎么用。譬如有人在背后通过评论我而结成了某种盟友关系，虽然我觉得这种关系不可能长久，但这样也算有用。</p><hr><p>支持什么，不是说认为什么东西是好的。而是直接现实地为这种东西的发展创造条件。</p><p>比如 “支持人类表达心中的真实想法” 这种宏伟的愿景。那么至少要什么都愿意听，如果不喜欢就认真去辩。否则就还是掐灭了这种热情。</p><hr><p>人类都是既坚定又善变的。这一刻坚定地做一个吉普赛人，下一刻坚定地爱上基督徒斗牛士。不确定性是泥土；确定性也是泥土，但是是金色的。</p><p>想要什么东西，其实是先天根植于内心的，我们自己也只是回溯性地揭示已经存在的东西罢了。“知道自己想要什么”，实际上只是一个临时的 Checkpoint。</p><p>我们都是苏格拉底的学生拾麦穗。</p><hr><p>JOJO5 中指示人物死亡命运的「滚石」是一个很有意思的设定。看第 38 话的时候还在疑惑唐突插叙，直到最后一话豁然开朗。荒木在这里表达了他对于“命运”这件事的思考。</p><p>并不是「滚石」决定了人物的命运，它充其量只是显示了这种命运。这是人物的内在矛盾所决定的发展趋势。</p><p>某天下班之后去 711 时，与高先生讨论起现实为什么会如此发展。我当时表达了一种观点，即就本人当时那种近乎癫狂的状态而言，不是在这里摔，就会在那里摔。例证环节过后，他似乎接受了这个说法。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作随记</title>
      <link href="/20250417-working/"/>
      <url>/20250417-working/</url>
      
        <content type="html"><![CDATA[<ul><li>把 ckpt 部分的文档写了</li><li>coding：完善已有功能和写法。<ul><li>主要是，增加安全检查</li><li>改写序列化、反序列化写法。顺手干掉看着不顺眼的类型。<ul><li>尝试使用 cereal。</li></ul></li></ul></li><li>读 DPOR</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>坚持独立自主的和平外交政策</title>
      <link href="/20250407-announcement/"/>
      <url>/20250407-announcement/</url>
      
        <content type="html"><![CDATA[<p>坚持独立自主的和平外交政策</p>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面纱，人设 allegro</title>
      <link href="/20250331-veil/"/>
      <url>/20250331-veil/</url>
      
        <content type="html"><![CDATA[<p>《面纱》讲了一个什么故事呢？其实就是 <em>The Painted Veil</em> 的故事，书名已经写得很明白了。古代有“误点成蝇”的典故，说谁要驱赶画面上的一只苍蝇，最后发现苍蝇根本就在画中。这个书名其实也是一样的。你想揭开什么面纱，但是其实面纱根本就是画的！这还并不等于在说，面纱的后面没有什么东西，毋宁是说面纱从根本上就是这幅画本身。只是画作得到人的意识的时候，人的想象力充当了一个角色，即将这面纱从画作当中剥离开，造成一个幻象。因而，这是一个穿越幻象的故事。</p><p>所谓面纱，无非是一种表象，是客体在我之内。我去认识这个在我之外的客体，好像是把客体剥离出一些什么东西，并容纳到我自身之内。这好像是某种对立，但仅仅是就我作为一个认识者而言的。客体，以及客体的表象，在原初的意义上是同一的。</p><p>跑题了。我想说认识到什么就是什么。恋人之间有一种游戏，叫做“你喜欢我哪一点”。就我个人的游玩体验来说，并没有哪次是真正说到爱人认可的范围里面去的。这就显得我一点也不了解爱人，并且总是在爱人身上寻求一些她没有的东西，而我笨笨的，我以为有，并且每每觉得我真的寻求到了。所以看起来会有点滑稽。</p><p>然而我真诚地认为，我我眼中的他人和他人眼中的我，相较于谁谁眼中的自己，是更加重要的。也许应当认识到，不管你愿不愿意，主体间的关系都充满了一种无意识的，并且是无指向的“虚张声势”。我并不否认他人认为的我的样子，只要那是诚心的；相对地，我也不为那种观点生成与其相符合的行动。于是“面纱”会自行破产。从这个角度上讲，现实的人每天都在 OOC 才是一种正常现象，因为人设是一个回溯性的东西，只有越来越多的行动被考察到才能够趋于完整。固定的人设就其本性而言是未完成的，遵循它反而显得非人类。</p><blockquote><p>调酒师也好，魔术师也罢。有的只不过是一个名称，剩下的与其他人并无二致。</p><p>或者说，我不是什么调酒师，他也不是什么魔术师。我仅仅是我，他仅仅是他。在此之外，无论是自我的身份认同，还是来自他人的身份认同，对于人本身而言都是一场灾难。</p></blockquote><p>所以<strong>普通和理所当然</strong>是什么呢？如果人普通地理所当然地会做什么的话，无非就是从他那未经审视的本性出发做一些必须要做的事情。但我不知道，你不知道，他也不知道。“性格使然”的解释，就一个人永远有潜力做出与这个人的刻板印象不相符的事情的情况而言，是非常苍白无力的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PGP key 配置记录</title>
      <link href="/20250327-gpg/"/>
      <url>/20250327-gpg/</url>
      
        <content type="html"><![CDATA[<p>OpenPGP 是一套开放的互联网讯息加密、验证的标准，而 GnuPG(GPG) 是其一套实现。</p><p>生成你的密钥对并妥善管理，就可以：</p><ul><li>加密通话</li><li><del>放一个 fingerprint 在个人页面里装B</del></li></ul><p>这里有一套比较详细的教学，我只是随手记录一下自己的配置。</p><p><a href="https://ulyc.github.io/2021/01/13/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8A/">2021年，用更现代的方法使用PGP（上） - C的博客 |UlyC</a></p><p><a href="https://ulyc.github.io/2021/01/18/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%AD/">2021年，用更现代的方法使用PGP（中） - C的博客 |UlyC</a></p><p><a href="https://ulyc.github.io/2021/01/26/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8B/">2021年，用更现代的方法使用PGP（下） - C的博客 |UlyC</a></p><hr><p>根据 CC BY-NC-ND 4.0 协议，我不能发布基于原文演绎的内容。我无法分辨记录配置过程是否是一种演绎。因而决定不对自己的配置过程进行发布了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系 理论哲学的第三阶段</title>
      <link href="/20250327-idealism/"/>
      <url>/20250327-idealism/</url>
      
        <content type="html"><![CDATA[<p>完全根据自己的理解去写的。</p><p>假如人是盲目的，没有任何认识能力的，那么没有客体能够产生出来。</p><p>但理智可以进行直观活动。理智本身就无非是一个促使客体（对理智）产生出来的行动方式。这一理智的行动将理智自身与这种行动分离开来。这种分离就叫做“抽象”，“抽离”。这种行动对于理智而言，则显现为一种产物。</p><p>理智作为行动本身，原初地和客体是合为一体的，因为这个时候，还没有客体对我产生出来。当理智的行动和行动的产物分离开来时。产物就是“概念”。</p><p>概念与客体原初地就是一致的，它们在位于意识彼岸的时候是同一个东西。二者的分离是在意识的产生时发生的。</p><p>但是概念与客体确确实实地在我们地认识中相互对立了。这一对立并不是由别的什么产生，而是由判断产生的。当我们说“这朵花是红的”的时候，“这朵花”的直观，与“红色”的概念就分离了开来，尽管这个判断同样也设定了二者的同一性。</p><p>简而言之，概念与客体有着原初的同一性，而只是因为意识的设定才产生了对立。</p><p><strong>概念，就是意识用以在意识自身之内建构客体的规则。</strong>而客体，则是规则本身的表现。</p><p>从客体当中分离出概念，则需要通过一种直观来进行对接：在意识彼岸与客体对接，在意识之内与概念对接。这种直观称之为<strong>范型化</strong>。</p><p>范型化是将对象直观为一个已规定的对象的过程，也就是对“规则”的直观。比如，将直角三角形、锐角三角形、钝角三角形全部直观为“三角形”。</p><p>我们认识到这一朵花是“红的”，不因为我们曾经见过红色的东西。当我们第一次见到红色的东西的时候，就已经认识到了“红色”的概念。概念不等于语词，红色，Red， 赤い…各种说法，指代的都是同一个概念罢了。</p><p>这与我们通常认识的“抽象”是不同的。普通的抽象能力，是从众多的事物中抽出一种“共相”，也即保留一种普遍者。但是设想：如果我们没有在碰到第一朵红花的时候，就形成“红色”的概念，那么在遇见“红灯”、“红火”的时候，又如何知道这些客体是与红色的概念相联结的呢？</p><p>因而我们不得不承认我们有一种能力，就是从一个客体当中直接地把握作为普遍者的概念的能力（就是在说范型化）。这是一种更高级的“抽象”能力。而从众多事物中抽出一种共相，则是一种经验的抽象能力。</p><p>（我们看似能够创造概念当中不存在的客体。实质上，是对一些已有的建构客体的规则组合在同一客体上，进而在认识的过程中被把握为一个新的概念）</p><p>如果我们能抽去客体当中的全部概念的话——也就是说，去掉了这个概念之后，客体的直观仍然可以被想象。到最后我们不得不承认，一个客体它终究是占据一定的<strong>空间</strong>的。不占据空间的客体是无法想象的。虽然“空间”对于人而言仍然是某种抽象出来的东西，但它并不是抽象概念。说到底人认识的一切东西无不在空间中出现，因此毋宁说，空间是人类认识能力的一种形式。</p><p>如果我们能抽去客体当中的全部直观的话——只剩下概念。我们知道概念是一种规定着客体的东西。如果没有空间的直观，那么这些规定就没有其作用对象，只是纯粹的规定性，而不是任何实在的概念了。</p>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fail2ban for frps</title>
      <link href="/20250321-fail2ban/"/>
      <url>/20250321-fail2ban/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://yuuza.net/Posts/fail2ban-for-ssh-behind-frp">为 frp 后的 SSH 配置 fail2ban</a><br>参考：<a href="https://www.cnblogs.com/sangria/p/15827740.html">使用 fail2ban 保护 frp 服务</a></p></blockquote><blockquote><p>仍然推荐 pubkey 登录以及为密码添加 2FA。</p></blockquote><p>前置条件：frps 由 systemd 启动。安装了 iptables。</p><p>局限性：仅仅根据连接频率来判断异常连接，而并非判断连接失败。因而有可能因为频繁连接而被误封。</p><p>文件 <code>/etc/fail2ban/jail.d/frps.conf</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[frps]</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">findtime</span> = <span class="number">10</span>m</span><br><span class="line"><span class="attr">maxretry</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">bantime</span> = <span class="number">10</span>d</span><br><span class="line"><span class="attr">backend</span> = systemd</span><br><span class="line"><span class="attr">filter</span> = frps</span><br><span class="line"><span class="attr">journalmatch</span> = _SYSTEMD_UNIT=frps.service</span><br><span class="line"><span class="attr">port</span> = all</span><br><span class="line"><span class="attr">action</span> = iptables-allports[name=frp,protocol=tcp]</span><br></pre></td></tr></table></figure><p>文件 <code>/etc/fail2ban/filter.d/frps.conf</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Definition]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">failregex</span> = ^.*ssh2] get a user connection \[&lt;HOST&gt;:[<span class="number">0</span>-<span class="number">9</span>]*\]</span><br><span class="line">ignoreregex =</span><br></pre></td></tr></table></figure><p>注意 <code>failregex</code> 开头的 <code>ssh2]</code> 部分，用于匹配以 <code>ssh2</code> 结尾的 frp 服务。自行调整匹配内容</p><h2><a href="#frps-pei-zhi" class="header-anchor">#</a><span id="frps-pei-zhi">frps 配置</span></h2><p>设置 <code>log_level = debug</code> 以启用 <code>get a user connection</code> 这类日志就好。</p><p>文件 <code>frps.ini</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">log_level</span> = debug</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><a href="#xiao-guo-yan-zheng" class="header-anchor">#</a><span id="xiao-guo-yan-zheng">效果验证</span></h2><p>fail2ban: <code>sudo fail2ban-client status frps</code></p><img src="image-20250326133204041.png" alt="image-20250326133204041" style="zoom:50%;"><p>并不隐去可恶的攻击者 IP。</p><p>iptables: <code>sudo iptables -L</code></p><img src="image-20250326133321118.png" alt="image-20250326133321118" style="zoom:50%;"><p>两边都有攻击者 IP 才算启动成功。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轻松自如</title>
      <link href="/20250322-spring/"/>
      <url>/20250322-spring/</url>
      
        <content type="html"><![CDATA[<p>自由是一种畅快。最近发现自己几乎可以两条腿行走了，虽然距离不算很长。春天也到来了，户外充满了人的气息。即使暂时感到局促不安，但回归生活这件事正在热火朝天地发生着。</p><p>坐在研究生工作室里闲里偷忙式地赶活。转暖的天气让背后稍微沁出一点汗来，又让衣服吸了去，再被穿入门窗的微风带走，一会儿暖和一会儿凉快的，使人静不下心来。转头看向外面，五点钟的阳光依然明亮，照得整个校园那么鲜艳。而我即将在其中自由地行走。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L&#39;Amour</title>
      <link href="/20250322-lamour/"/>
      <url>/20250322-lamour/</url>
      
        <content type="html"><![CDATA[<p>爱情是一种不可能性。因异质性而起的爱情引出的可能是不可调和的矛盾。直面矛盾的此刻，决定解决矛盾的时候，本真的爱情才算开始。</p><p>此刻逃回之前的幻梦，不承认创伤更像是陷入了对创伤的强迫性重复。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Microsoft 账户登录远程桌面</title>
      <link href="/20250320-rdp/"/>
      <url>/20250320-rdp/</url>
      
        <content type="html"><![CDATA[<p>背景：原来在 Windows 上使用本地账户登录，切换到使用 Microsoft 账户登录。本地 PIN 码登录正常，远程桌面连接不上。</p><p><a href="https://answers.microsoft.com/en-us/windows/forum/all/how-to-connect-via-rdp-to-main-microsoft-account/d2f2b165-f582-425a-bfc9-7e8ce0da8766">How to connect via rdp to main Microsoft account - Microsoft Community</a></p><p>这篇完全没用。Microsoft Community <strong>SUCKS</strong></p><p><a href="https://superuser.com/questions/1715525/how-to-login-windows-remote-desktop-rdp-in-windows-11-when-microsoft-account-a">How to login windows remote desktop (RDP) in windows 11 when Microsoft account and Hello Pin enabled? - Super User</a></p><p>这个是对的。答案是需要在被连接的机器上使用 Microsoft 账户密码登录一次，但是首先要关闭这个：</p><img src="GRnKq.png" alt="Enable Passwords" style="zoom:50%;"><p>登录之后再打开也是可以的。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Balenciaga 2025FW</title>
      <link href="/20250318-balenciaga/"/>
      <url>/20250318-balenciaga/</url>
      
        <content type="html"><![CDATA[<p>垃圾俯拍视角，我明白要展现场地，其实就是来来回回的走道。场地有可能有设计，但场地有设计有点不太可能。</p><p>前面的 look 看着都太社畜了。出现了大量看起来能干电焊的墨镜。</p><p>尊重，但我想说 bro 太像外星人了。</p><img src="image-20250318144421303.png" alt="image-20250318144421303" style="zoom:25%;"><p>惊现亚比。领子很奇异。</p><img src="image-20250318144327987.png" alt="image-20250318144327272" style="zoom:25%;"><p>添加了一些穿撕烂的T恤的肌肉男。难道是对清瘦体型审美疲劳了吗？</p><p>添加了一些从脚穿到大腿根的皮靴？胶靴？还是裤子？</p><img src="image-20250318145207094.png" alt="image-20250318145207094" style="zoom:25%;"><p>一些挂着金银铜牌的体育生；一些超高开叉的裙子，甚至到后面裙子只剩半边。</p><p>最后出场的是棉被王吗？一边走一边猛摇头，看起来精神状态很美丽。</p><img src="image-20250318145627497.png" alt="image-20250318145627497" style="zoom:25%;">]]></content>
      
      
      <categories>
          
          <category> 时尚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>购置了新设备</title>
      <link href="/20250318-laptop/"/>
      <url>/20250318-laptop/</url>
      
        <content type="html"><![CDATA[<p>从牢杨手里收了一台三丧的 Galaxy Book S。的确迫切地需要一台轻薄的笔记本，即使是一台 ARM 的，即使它的内存只有 8GB。但基本也就是用来连连远程。</p><p>机器本身只有两磅多点重，握持手感很好，但应该没有人会没事握持笔记本。有 LTE，有指纹，有双扬声器，甚至有触屏。唯一感到不满意的只有键盘——毕竟是这么薄的本子（0.46”），键程肯定是长不到哪里去。ARM 所带来的续航能力是重中之重，之前也有一台笔记本但是续航很差以至于根本就懒得拿出来用。</p><p>没什么性能可言，同样没什么发热可言，没什么噪音可言。在这么薄的情况下，依然保证了 3.5mm 耳机孔这种外星科技。</p><p>我发现 Windows 自带的远程连接应用好像就是要比其他平台上的优化要好点。我记得自己从大二的时候就开始在学校里到处连自己电脑的远程，在一个低延迟的千兆网下，打字还是稍微有点卡，远程播放视频绝对没有这么顺畅。但是现在打这篇文字的时候，感觉就是在本地的 Windows 上操作。并且播放视频在原画质的前提下，体感差不多是 30 帧这样。</p><p>2020 年的本子，时至今日以一个便宜的价格收了。拿来打打字还是绝佳的。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梦</title>
      <link href="/20250314-yume/"/>
      <url>/20250314-yume/</url>
      
        <content type="html"><![CDATA[<p>我记得自己先在和两个我不认识的朋友在一家台球厅打球。但是进去之后拿起球杆发现怎么都是螺丝刀头的球杆？挑了半天之后终于找到合适的，却看到一起的两个人已经把球桌当成牌桌，准备开始玩桌游了。我想也行吧。</p><p>桌游的规则是这样的。总得来说，还是扑克牌，但是有两张特殊点数的。我记得我抽到了一张特殊点数，是37点。每个人手里拿一些牌，要求组成一部分牌，然后它们的总和要正好等于90，这样也许是互相交换。到最后谁手中集齐了两张特殊点数的就赢了。听起来是不是很无厘头？一个很无聊的游戏。但是梦里的我在玩的时候，根本就跟不上节奏。我还在掰着指头算和的时候，别人都已经打出来了。然后游戏就结束了，我接到邦邦的一个电话，叫我赶紧过去玩。</p><p>我就真的坐着公交车去了。乘车的路上看到了非常不寻常的景色：高楼大厦和自然景观非常紧凑地组合在一起，我不禁怀疑，南京这里真的有这么些湖和公园吗？南京真的有这栋楼和这条路吗？终点是一个小公园，我在那里见到了邦邦，还有他的四位同学。我去到那里似乎只是为了听取那四位同学的和解报告：他们互相之间似乎有很复杂的男女关系，但现在准备完全和解。我表示了赞成。过程中我收到一些消息，是斯嘉丽发给我的，大致是想同我和解之类的内容，但我在听朋友讲话就没有仔细查看。</p><p>等到后来闲下来再翻手机，聊天框里就变成了清一水的对我的指责和贬低。但我应该也没做错什么。于是我悲伤了，邦邦在边上安慰我。</p><p>醒来觉得甚是可笑。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ave Mujica Ep11 - 丰川定治支系破产论</title>
      <link href="/20250314-togawa/"/>
      <url>/20250314-togawa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本创作中含有医疗建议，请仔细甄别。</p></blockquote><p>让祥子赶紧去瑞士，不一定单单是因为初华的事。事实上丰川定治和丰川清告作为同一系，是有着利益绑定的。丰川清告亏损168亿，很可能是家族内部陷害造成的。作为这一系的话事人丰川定治，他也就只能做出“辞退临时工”这种对于他而言不痛不痒的惩罚，算是一种弃车保帅。</p><p>不过你的小弟被干掉了，自己还能独善其身吗？丰川定治说过，“你根本不懂丰川家族的恐怖”。这是100%的真情流露。事实上这后面的利益纠缠的复杂度远超想象。目前，丰川定治还能依靠拥有丰川家的一个血脉——丰川祥子，来保全自己的地位。之前也提到过成为祥子监护人的说法。不过，在丰川清告知道自己这边丰川家血脉就只剩祥子一个的时候，还放祥子出去跟她爹过这种事，我觉得老登说实话也没什么手腕，感觉很快就要被找理由踢出去了。</p><p>而只有与丰川本家的大手解绑，丰川祥子才能获得真正的自由。因而恐怕初音初华的真相最终捅到丰川本家这件事，大概是势在必得的。</p><p>至于你说，祥子由于拥有丰川家的血脉，所以不会被本家放弃吗？很难说。丰川家又不是没人了，真不差祥子一个，特别是这一系似乎有一种伴X显性遗传病：看起来没男的；而且外婆和母亲都是英年早逝；而且她们都在那之前生下了女儿。如果这种猜想成真，那么丰川祥子还是有50%的概率会得这种遗传病。本家对这件事的态度估计是摇摆的：如果丰川定治有实权有资源，那么是值得拉拢的对象，遗传病的可能性就没什么影响；如果丰川定治在家族内失势，那么又给了本家一脚把他们踹走的理由。</p><p>那么丰川定治到底失势了吗？或者说其实他一直根基不稳？我认为是的。否则他不可能这么谨慎。目前定治在丰川集团内应该并不掌握很大的话语权。结合他急着把祥子赶去瑞士这种事，有一种挟持人质的感觉。</p><p>当然，最后祥子肯定是要获得自由的。与丰川家的大手解绑是最现实的办法。因此，初音初华的真相捅到老家那里，然后老登失势，直接被踢出家族。以后，祥子就像是刘备离开了曹操，“吾乃笼中鸟、网中鱼，此一行如鱼入大海，鸟上青霄，不受笼网之羁绊也！”能够容留祥子的，果然只有Ave Mujica的世界了。</p><p><del>综上所述，丰川祥子组建Ave Mujica的目的乃是匡扶汉室。</del></p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2025年1月追番总结</title>
      <link href="/20250314-anime/"/>
      <url>/20250314-anime/</url>
      
        <content type="html"><![CDATA[<blockquote><p>按个人的喜欢程度排序。喜欢不代表认为好。</p><p>持续更新到全部追番完结</p></blockquote><p>很久没有认真追番了。刚好在家躺了两个多月，想着打发时间，没想到带来的快乐远超预期。</p><p>按进度看完：10</p><p>已放弃：4</p><p>随缘放弃：7</p><hr><p><strong>Bang Dream! Ave Mujica</strong></p><p>说实话我没有因为这部番着急上火什么的。一开始追番真的是因为感到前期宣发，曲目，以及第一话中有很多可供解读的东西。如果能够成功预言一些内容，多少能够说明我的理解能力还是够用的。但事实证明我天真了，因为Bushiroad实在是拉了坨大的，直接诠释了什么是“无法预测的命运之舞台”。</p><p>从第7话开始，这部动画已经没有什么解读的必要了，因为知道它的确没什么逻辑可言，不合理的剧情就是发生了。不过一旦接受了这种设定，顺从剧情的思路，每一话倒是还有一些快乐源泉。尤其是讨论它很快乐，吐槽烂活也很快乐，总得来说虽然烂但是情绪价值也拉满了。不过情绪价值主要还是来源于社区。</p><p>第11话的个人回，形式上略显单调。当然对偶说还在发力。剧情上，补完的前期设定显然是烂活。但依然有<em>可笑</em>的地方，并且李子演出上大分。姑且认为无功无过。</p><hr><p><strong>金牌得主（舞冰的祈愿）</strong></p><p>我感觉舞冰的祈愿这个名字更好听而且双关诶。因为女主的名字就是 Inori（祈）。</p><p>不得不说滑冰的画面做得真不错。然而我感觉小光的滑冰画面做得比女主的要漂亮很多，也许是因为人设比女主漂亮吧。毕竟连动画里自己都吐槽女主的发型像一条炸虾（笑），虽然感觉不那么好看但是很有个性的，尤其是让人直观地感受到一种“追赶”。</p><p>剧情节奏合理，不拖泥带水，也不匆忙。悬念设置适当，而不是每一次都吊人胃口。很好地在小孩之间的竞争中穿插了大人之间的羁绊，双线并进。</p><hr><p><strong>群花绽放，仿如修罗</strong></p><p>简称花修罗。本季还有异修罗（没看）。</p><p>朗读、播报题材，相当新颖，并且非常合本人胃口。女主很可爱，学姐很帅，各种女女关系性也有，男女关系性也有，不得不品尝。</p><p>节奏当然是有点慢的了，对应题材正好。朗读时候的演出画面很棒，就算是日语也可以试着代入。</p><hr><p><strong>中年上班族转生恶役</strong></p><p>纯粹看得开心。一开始以为和<strong>转生成为恶役大小姐</strong>有点像，但是此处有大叔视角，甚至还有大叔家人视角。</p><p>虽然感觉有点贫穷，但对于一些演出的表现也不吝啬。</p><hr><p><strong>全修。</strong></p><p>不是泛式推它，我不会点开。事实上我是从第六周开始赶上进度的。前面真的没什么好说的，非常公式，而且我对于女主掏出一支笔开始“变身”的演出感到有点不适（我看任何类型的变身都有一种羞耻感），尤其是BGM居然一直在念叨“Zenshuu”，感觉尬爆了！！！</p><p>但是随着女主的过去、异世界真相的揭露，剧情的走向倒是更加扑朔迷离了。</p><p>每一话都有neta元素。</p><p>按照我的解读，异世界故事的剧情不可避免地走向BE，然后女主苏醒回到现实世界，并带着这次“初恋”的体验，继续进行着初恋的创作。</p><p>作画挺好。画面饱和度偏高。无从吐槽的男主发色：黄得没边了。</p><hr><p><strong>在冲绳喜欢上的女孩方言讲得太过困扰</strong></p><p>翻版毛妹。旅游宣传片。</p><p>三角关系确实比较有意思，我一如既往地喜欢败犬辣妹（辣妹+1）。</p><hr><p><strong>天久鹰央的推理病历</strong></p><p>OP|ED很好看，有一种日剧感。然而正片的作画简直穷到家了。是吧P9。</p><p>三集连播，然后第四集就跳票，放了个总集篇。</p><p>整个医院非常无能，傻逼精神科医生因为女主指出自己的诊断失误，就禁止女主进入精神科；因为女主诊断正确带来诉讼麻烦就要取消女主所在的综合诊疗部。我想说衬托也不是这么衬的。</p><p>红莲的诅咒篇最后非常非常降智，大家都站在随时可能点燃的汽油中间话疗。女主骑着摩托车冲进火场，但是也不能把两个人都带出来，最后人自己走出来了，车子就在里面烧掉了。到这里实在是没法忍了。</p><p>八九话想搞个温情的，但是效果一般般。</p><p>也许看下去的唯一动力是女主人设还不错，看到高智商和一张有点可爱的脸我就走不动路了。</p><hr><p><strong>这公司有我喜欢的人</strong></p><p>典。发糖。开一局。挺好玩的随便看看</p><hr><p><strong>一杆青空</strong></p><p>闲着没事可以看看美少女打高尔夫。有女女关系性。路人都是天使。</p><p><em>有喵梦代餐</em>。</p><p>辣妹+1。</p><hr><p><strong>我和班上最讨厌的女生结婚了</strong></p><p>典。恋爱喜剧。唯一想看的是败犬辣妹（辣妹+1）的结局。</p><hr><p><strong>黄昏旅店</strong></p><p>设定有意思，但单元剧情太无聊了。看两话搁置了。</p><hr><p><strong>刹那之花（瞬间百合）</strong></p><p>画面使眼睛进化；大雷嗯摇；唐突３分钟做饭环节；第一话没进世界观。放弃了。</p><hr><p><strong>蜂蜜柠檬苏打</strong></p><p>能上高中上中专，只为在中专被欺负之后被男主救。0人脑回路正常。放弃了。</p><hr><p><strong>灰色：幻影扳机</strong></p><p>我想说我很喜欢灰色系列。但是这个续作和原作独立，没有什么观看欲望。看了一话，搁置。</p><hr><p><strong>S级怪兽《贝希摩斯》被误认成小猫，成为精灵女孩的骑士(宠物)一起生活</strong></p><p>货真价实的厕纸，没有看的必要。露点福利注意。4倍速看了4话，放弃了。</p><hr><p><strong>我家有个阿宅女忍者</strong></p><p>无聊。一话放弃。</p><hr><p>下载了但是根本没看的：</p><p><strong>Fate&#x2F;Strange Fake</strong>：谁让你真的一年更新一话了</p><p><strong>我的可爱对黑岩目高不管用</strong>：抽空倍速看一下</p><p><strong>魔法使的约定</strong>：看一下相关视频</p><p><strong>上班族去了异世界后成了四天王</strong>：看一下相关视频</p><p><strong>欢迎来到日本，精灵小姐</strong>：抽空倍速看一下</p><hr><p>没下载但是也许准备看一下的：</p><p><strong>异修罗</strong></p><p><strong>药屋少女的呢喃</strong>：要补上一季</p><p><strong>在地下城寻求邂逅是否搞错了什么 第五季 丰饶的女神篇</strong>：需要补前作</p><p><strong>青之箱</strong></p><p><strong>Re0</strong></p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>言语、理解、解释 allegro</title>
      <link href="/20250314-understanding/"/>
      <url>/20250314-understanding/</url>
      
        <content type="html"><![CDATA[<p>言语活动是将思维的理解化为言语的活动；理解活动是将言语化为思维的理解的活动。就自我作为思索着的言语者的本性而言，其内部必须存在着这两种对立的活动。</p><p>言语、理解、解释的活动是不能不共存的。因为言语活动是实际上取消不掉的。言语活动和理解活动存在着一种绝对对立：言语背后有着一个唯一的实在的东西，以至于当理解活动试图将其纳入自身的时候，总是会得到某种抵抗，因而形成一种僵持。而言语又有可以生产的性质，这种生产试图取消这种对立的僵持情况，即在言语和理解活动之间作出一种解释。然而这种解释活动本身不过是一种具体受限的言语-理解活动。这种无限进展的过程，当你直观到它的时候，总是发现它停留在某一个阶段。然而就自身而言，还是自在地运行着。判断作为解释活动的最终结果，就其质料而言只是理解活动的产物，而就其形式而言只不过是一种言语活动的产物。</p><p>解释活动只是在实在的言语和观念的理解当中进行一种拉锯的活动，它在二者之间不断移动，分配着那个原初的实在性，也就是通俗意义上讲的，对于解释权的分配。因为言语不愿给出解释权，而理解却有着从言语当中无限地攫取解释权的倾向。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渐行渐远</title>
      <link href="/20250309-highschool/"/>
      <url>/20250309-highschool/</url>
      
        <content type="html"><![CDATA[<p>我已经不知道有多久没有看到高中同学的消息了。</p><p>其实也不尽然，因为还是有几位同学在少量地更新着，此外的大多数人处于在社交媒体上消失的状态。而这更新的少数人，无论我对他们的观点、立场认同与否，都有一点共性，就是从高中开始他们就经常会冒出很奇异的想法。对于我而言，这类人可能更像是人类一点。</p><p>大多数人在几年的沉默之后，在我这里仿佛已经不是活生生的人，而只剩下一个代号了。有些同学以前可能和我玩得也挺好，但是对于思考的交流却并不多。高中生能谈什么？不过就是一些稚嫩的世界观罢了。然而连这些都没有，更别提作这类交流的习惯了。时至今日，如果要再重新了解一位老同学，也就只有这样几个粗糙的方面：在从事什么行业，学习什么专业，处于社会结构的哪一层。然后似乎就可以对这个人下一个武断的结论了，因为纵使我试图从生活方面来了解一个人，也没有任何材料可以参考；甚至就算想要主动了解些什么，也没有可供引起一个话题的材料。</p><p>这种神秘感在我这里发展，逐渐产生了抵触和恐惧。众所周知恐惧就是来源于某种未知的东西。我一方面不怎么在乎不熟悉的人怎么看我，一方面又试图操控这种看法。像染发、打耳洞这种事情，我也说不好有多少是做给这些人看的，总觉得如果自己变成这种更加陌生的样子，该恐惧的就另有其人。我想把这种因为很久不联系而产生的疏远感做实，于是我就好像真的没什么可在意的了。也会想象如果高中同学要见面的话，我这副样子少说也让一些人吃惊一下，就像我发现一位老熟人改变了性别那样吃惊了一下。</p><p>我当然也是有罪过的。我想到大四的时候有谁来邀请我去KTV，但是我完全没回复消息。因为那段时间正是我对很多事情最厌烦的时期。不知道从哪个时期开始，我就没有主动联系过谁了；于是恰好谁也没有主动联系我。请允许我在这里推己及人，这种放弃联系的原因很大程度上是因为认为勉强保持联系是一件很没有意思的事情了。如此看来，这种分手也是有其必然性的。大家不过是被绑定了一段时间而已，最终认识到其实不是一路人。</p><p>然而我和很多初中同学仍然保持着很好的友谊。这又是一个未解之谜了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系纲要-第三章</title>
      <link href="/20250311-cite2/"/>
      <url>/20250311-cite2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>评价：读完这个不一定读得懂原文，但一定懂了。</p></blockquote><blockquote><p>作者：KraefiNNN (Bilibili)</p><p>来源：<a href="https://kr4nkiez.notion.site/2284d898ab1640738e1268ca38a22260">Notion 文档</a></p></blockquote><div class="toc"><!-- toc --><ul><li><a href="#ben-zhang-ti-yao">本章提要</a></li><li><a href="#1-jue-dui-zong-he-de-yan-yi">1 绝对综合的演绎</a><ul><li><a href="#1-1-zi-wo-de-er-chong-fen-lie">1.1 自我的二重分裂</a></li><li><a href="#1-2-zi-wo-de-jue-dui-zong-he">1.2 自我的绝对综合</a><ul><li><a href="#1-2-1-jue-dui-zong-he-shi-tong-yi-xing-de-zhong-jie">1.2.1 绝对综合是同一性的中介</a></li><li><a href="#1-2-2-jue-dui-zong-he-de-wu-xian-fen-ge">1.2.2 绝对综合的无限分割</a></li></ul></li></ul></li><li><a href="#2-jue-dui-zong-he-de-zhong-jian-huan-jie">2 绝对综合的中间环节</a><ul><li><a href="#2-0-dao-yan">2.0 导言</a><ul><li><a href="#2-0-1-zi-you-di-mo-fang">2.0.1 自由地模仿</a></li><li><a href="#2-0-2-li-lun-zhe-xue-de-ren-wu">2.0.2 理论哲学的任务</a></li></ul></li><li><a href="#chang-duan-jie-shi">长段解释</a></li><li><a href="#2-1-jie-duan-yi-cong-yuan-shi-gan-jue-dao-chuang-zao-xing-zhi-guan">2.1 阶段一: 从原始感觉到创造性直观</a><ul><li><a href="#2-1-1-yuan-shi-gan-jue-zi-wo-zhi-guan-zi-shen-wei-shou-dao-xian-ding-de">2.1.1 原始感觉: 自我直观自身为受到限定的</a></li><li><a href="#i-zi-wo-chu-yu-wei-bei-zhi-guan-de-you-xian-zhi-zhuang-tai">I 自我处于未被直观的有限制状态</a></li><li><a href="#ii-zi-wo-bei-zhi-guan-wei-you-xian-zhi-de-zi-wo">II. 自我被直观为有限制的自我</a></li><li><a href="#iii-bu-chong-shuo-ming">III. 补充说明</a></li><li><a href="#2-1-2-yuan-shi-zi-wo-yi-shi-zi-wo-zhi-guan-zi-shen-wei-jin-xing-zhi-guan-de">2.1.2 原始自我意识: 自我直观自身为进行直观的</a></li><li><a href="#i-que-ding-huo-dong-de-yan-yi">I. 确定活动的演绎</a></li><li><a href="#ii-que-ding-huo-dong-de-zhong-jian-bu-zou">II. 确定活动的中间步骤</a></li><li><a href="#2-1-3-chuang-zao-xing-zhi-guan">2.1.3 创造性直观</a></li></ul></li><li><a href="#2-2-jie-duan-er-cong-chuang-zao-xing-zhi-guan-dao-fan-si">2.2 阶段二: 从创造性直观到反思</a></li><li><a href="#2-3-jie-duan-san-cong-fan-si-dao-jue-dui-yi-zhi-huo-dong">2.3 阶段三: 从反思到绝对意志活动</a></li></ul></li></ul><!-- tocstop --></div><h1><a href="#ben-zhang-ti-yao" class="header-anchor">#</a><span id="ben-zhang-ti-yao">本章提要</span></h1><p>先验哲学的起点<strong>自我意识原理</strong>是<strong>唯一的绝对活动</strong>: 自我本身和自我的所有规定性, 以及所有其他对自我确立起来的东西, 都是由这一活动确立起来的.</p><p>前一章已经演绎出了自我的两种活动: 自由的受限定的活动 (现实的) , 以及不可限定的活动 (观念的) . 两者产生于自我意识的绝对活动的”绝对分析” (我起的名) . 要达到意识, 则两者必须进行综合. 这就是自我意识的绝对活动的后半部分: <strong>绝对综合</strong>.</p><p>两者的绝对综合, 就是达到观念活动和现实活动的<strong>绝对同一</strong>性, 达到主客同一体. 限制已经被设定在现实活动中, 所以也需要设定在观念活动中. 理论哲学的第一部分就是<strong>绝对综合</strong>; 第二部分则是<strong>绝对综合的中间环节</strong>, 一步步将现实活动会合于观念活动.</p><h1><a href="#1-jue-dui-zong-he-de-yan-yi" class="header-anchor">#</a><span id="1-jue-dui-zong-he-de-yan-yi">1 绝对综合的演绎</span></h1><p>我们的 (理论哲学的) 任务是, 现实活动中的限制, 必须同时也设定在观念活动中. 绝对综合将实现这个目标. 不过, 本节只是证明其必然存在.</p><h2><a href="#1-1-zi-wo-de-er-chong-fen-lie" class="header-anchor">#</a><span id="1-1-zi-wo-de-er-chong-fen-lie">1.1 自我的二重分裂</span></h2><p>观念和现实的原始结合存在于<strong>绝对活动</strong>中. 自我意识的原始活动同时是观念的和现实的: 自我意识是纯粹观念的, 又对自我  (通过自我意识) 呈现为纯粹现实的.</p><p>自我因其直观自己的本性, 而将自己限制为对象. 限制同时是观念的和现实的: 限制是自己设立的; 同时自己又被限制为对象. 因此绝对活动就分裂为<strong>二重活动</strong>: 被限制的活动 (限制独立于它) 和作限制的活动 (不可被限制) .</p><p>在产生意识之前, 自我是纯粹的客观性, 主观性是通过意识才附加上去的. 作限制的活动限制了客观性 (被限制的活动) , 使其到达意识. 因而其本身就无法被限制, 也无法到达意识. [因为作限制活动留在意识之外,  所以限制就不被意识为依赖于自己的, 而显得是独立于自己的. ]</p><p>分裂后的二重活动, 其单独的任何一个都不再是自我了. 被限制的活动变成了对象, 是纯粹的客体; 作限制的活动没有变成对象, 是纯粹的主体.</p><h2><a href="#1-2-zi-wo-de-jue-dui-zong-he" class="header-anchor">#</a><span id="1-2-zi-wo-de-jue-dui-zong-he">1.2 自我的绝对综合</span></h2><p>自我达到意识, 不能通过其中之一, 而是通过这二重活动的<strong>综合</strong>.</p><p>这个活动是自我<strong>去意识它自己</strong>的活动, 是自我的<strong>绝对综合</strong>. 它是<strong>摆动</strong>于被限制活动和作限制活动之间的第三种活动. 这个活动产生了自我的意识.</p><p>[自我本身是复合的二重活动, 自我意识则是对自我的综合活动]</p><p>两种活动的作限制和被限制的关系, 构成了它们的<strong>对立</strong> (<strong>斗争</strong>) . 它们的斗争是自我的<strong>相反活动方向</strong>的斗争:  被限制活动的方向是<strong>无限地创造</strong>, 是离心的; 作限制活动的方向是<strong>被自己所意识</strong>, 是向心的.</p><p>自我既然拥有自我意识, 那么本就追求这两种相反的方向, 它恰恰生于这两种对立方向的冲突. 因此, 自我的对立必定被保持下来. 我们需要探究对立保持下来的方式.</p><p>然而, 由于斗争双方互相抵消, 互相毁灭, 斗争本身就<strong>不能持久</strong>. 既然自我是不断追求<strong>自我同一</strong>的活动, 那么它的前提就是<strong>持续的内在矛盾</strong>. [没有持续的矛盾, 就没有持续的同一活动. 例如, 如果不留着麻匪, 麻匪剿完了就没得剿了, 因而剿匪的活动也不存在了. ] 所以斗争不持久的结果, 就是完全不活动的状态, 自我就不是自我了. 所以斗争又<strong>必须持久</strong>.</p><p>正是第三种活动 (自我的绝对综合) ——通过<strong>竭力保持</strong>这个矛盾, 产生了某种同一性, 产生了两个对立活动的某种内在联系——维持了矛盾的持久存在.</p><p>自我的原初矛盾既不能消失, 因为它是自我同一活动的前提; 也不能依靠矛盾自身就长久保持. 矛盾能持久, 只是因为它<strong>必须</strong>持久, 也就是说, 是因为 (由于这个必然性产生的, 维持矛盾, 并且因而将同一性带入到矛盾中的) <strong>努力</strong>.  这种努力就是绝对综合.  [自我意识本身就是这样的矛盾体. 我们确信它存在, 是因为人的自我意识能通过先验考察的方式, 把握到它的存在. 它是不证自明的. 这个矛盾体, 因其矛盾而同一的<strong>本性</strong>, 就强制出这样的无限矛盾, 以及与其共生的无限综合. ]</p><h3><a href="#1-2-1-jue-dui-zong-he-shi-tong-yi-xing-de-zhong-jie" class="header-anchor">#</a><span id="1-2-1-jue-dui-zong-he-shi-tong-yi-xing-de-zhong-jie">1.2.1 绝对综合是同一性的中介</span></h3><p>到现在我们知道, 表现在自我意识中的同一性并非是原初同一性, 而是造出来的<strong>经过中介的同一性</strong> (绝对综合的中介) .</p><p>我们最初的起点——主体和客体的同一性——是不能自己成立的, 而必须通过绝对综合的中介. 因为自我的对立活动具有相反的方向, 所以绝对综合活动就是<strong>摆动于相反方向中</strong>的活动.</p><h3><a href="#1-2-2-jue-dui-zong-he-de-wu-xian-fen-ge" class="header-anchor">#</a><span id="1-2-2-jue-dui-zong-he-de-wu-xian-fen-ge">1.2.2 绝对综合的无限分割</span></h3><p>我们到目前为止, 已经证明了两个活动的对立. 在自我意识活动 (绝对综合) 之前, 这两种活动并没有根据被设立为有限的, 因而两种活动都是无限的(infinite 这里指的是无穷持续性) . 从而两种活动的斗争也是无限的.</p><p>无限的斗争只能用一种<strong>无限的行动系列</strong>来统一. [因为无限的斗争是无穷持续的<strong>动态</strong>的斗争, 它不会僵持, 而是受到摆动的绝对综合活动的维持. 就像在第二章中证明的, 自我表现为向无限进展的有限状态, 其活动维系于不断扩展限制和不断作出限制之间的矛盾. ] 这就说明, 绝对综合包含了无限的行动系列.</p><p>由于自我意识的全部活动就是自我 (原始二重性) 的意识 (绝对综合) , 绝对综合就必须<strong>将自我的一切都确立起来</strong>. 因此我们在绝对综合的中间环节中就会看到, 自我中的一切是怎样逐级产生的. 反过来说, 自我的一切, 无非是绝对综合的中介环节.</p><p>自我中的主体和客体是绝对对立的, 力图消除对方, 同时又不能消除对方. 两者通过力图消除对方, 才能使自己存在. 而如果消除一方, 另一方也就不能存在了 (这是不允许的, 不存在没有客体的主体, 或者是没有主体的客体) .</p><p>为什么两者力图消除对方?</p><p>主体和客体不是排排坐的两个小宝宝, 而是你死我活的斗争双方. 主体力图<strong>完全限制</strong>住客体, 使其完全成为意识中的对象. 客体力图完全<strong>摆脱</strong>主体的限制, 使自己超越主体的认识.  [例如我看见一只水杯, 主体力图用杯子型, 陶瓷, 乳白……一系列限制来将其完全变成和意识中的观念等同的东西; 客体力图不断用烧制的细小不规则处, 杯口的污渍, 底部的凹凸……一系列无限丰富的内容来成为独立于主体的存在物. ] 两者是性质不同的, 但是同样侵彻性的活动. 主体追求完全的认识, 将不受认识的客体废除; 客体追求完全的不受限制, 将能够进行认识的主体废除.</p><p>正因主体和客体是<strong>绝对</strong>对立的东西, 自我才必须进行绝对综合来中介它们.  就是说, 主体和客体必然地完全对立, 要求自我必须通过完全的综合来中介, 才能产生具有同一性的自我意识. 这里表明了自我意识的强制性, 不得不进行自我意识.</p><h1><a href="#2-jue-dui-zong-he-de-zhong-jian-huan-jie" class="header-anchor">#</a><span id="2-jue-dui-zong-he-de-zhong-jian-huan-jie">2 绝对综合的中间环节</span></h1><h2><a href="#2-0-dao-yan" class="header-anchor">#</a><span id="2-0-dao-yan">2.0 导言</span></h2><p>我们已经推演出, 自我意识是绝对活动. 它是无条件的活动, 而对自我确立了<strong>一切</strong>. 绝对活动并非是我们之前假定的, 不证自明的经验自我意识, 而是<strong>原初</strong>的活动——它是经验自我意识产生的根基, 本身并没有形成现实意识 (一切现实意识毕竟是有限的意识) .</p><p>绝对活动是绝对自由的, 同时也是绝对必然的.  [它本质上是绝对精神的活动, 或者说华子的活动] 绝对活动是无条件的活动, 是确立一切的原初活动. 它是绝对自由的, 因为其不受任何外物限制; 它是绝对必然的, 因为一切行动都是出于其本性的必然行动.</p><p>我们也可以从经验间接确证这个<strong>绝对活动</strong>的<strong>存在</strong>及其<strong>性质</strong>.</p><p>首先, 反思经验意识, 我们的意识作为有限制的意识, 必然产生于某种无限制的活动; 经验意识在时间中的<strong>一致性</strong>, 让我们只能假设<strong>一种</strong>绝对活动作为起源.</p><p>其次, 在经验自我意识中, 对自我的意识<strong>每一刻</strong>都蕴含着对于客观世界的意识. 对于这种<strong>持久的一致</strong>, 我们只能设想主客观在最原初的地方就已经是同一的, 并且这种同一会在后来产生的, 更高阶的活动, 也就是经验自我意识中体现.</p><h3><a href="#2-0-1-zi-you-di-mo-fang" class="header-anchor">#</a><span id="2-0-1-zi-you-di-mo-fang">2.0.1 自由地模仿</span></h3><p>我们现在知晓了绝对活动是<strong>主客观同一</strong>的活动, 那么我们怎么能从中获得某些具体的内容呢? 我们所用的方法就是<strong>自由地模仿</strong>. 自由的模仿是随意的活动, 其可以模仿出绝对活动.</p><p>第一, 自由的模仿是<strong>随意</strong>的.</p><p>绝对活动是产生一切时间的活动, 因而是在一切时间之外的; 而经验自我意识则属于时间序列 (石器时代, 青铜时代, ……火器时代, 信息时代, ……) 的一定阶段. 虽然, 经验意识自我被约束在时间之内, 因而是受时间序列中的因果的制约的; 但其完全有力量通过<strong>反思</strong>打断时间序列, 进行随意的哲学思考. [也就是说, 哲学反思可以让人跳出现实限制, 自由地进行思考. ]</p><p>第二, 自由的模仿可以<strong>体现</strong>绝对活动.</p><p>我们知道, 绝对活动为自我确立了一切. 处在时间中的经验自我意识能够产生的, 无非<strong>就是</strong>绝对活动所产生的东西, 因为经验自我意识是绝对活动的一个部分. 我的经验序列无非就是绝对活动的演化过程的一部分. 对经验自我而言, 我就是我的<strong>自由</strong>活动; 但对绝对活动而言, 经验自我无非就是绝对活动的(<strong>必然</strong>且自由的)产物. 所以, 自我的随意模仿, 同样也是对绝对活动的有效摹本.</p><p>一般地讲, 一切哲学的构造都是对于绝对活动的构造的模仿. 自我的绝对活动进行演化, 就会产生出 (历史的) 必然<strong>行动</strong>序列 (<strong>A</strong>) . 而在哲学<strong>反思</strong>中, 我们从时间序列中切出, 回溯到那个产生一切的原初活动, 这就形成了哲学家的自由<strong>思考</strong>序列 (<strong>B</strong>) . A是<strong>必然</strong>的原本; B是<strong>自由</strong>的摹本.  [A对于B是现实的, 因为绝对活动设立了哲学家的受限制状态; B对于A是观念的, 因为哲学家及其思考序列的产生, 无非是绝对活动的自由且必然的行动. ]</p><p>假如哲学反思做出的是完满的模仿, 就会得出真正完满的哲学. [谢林作为吹牛大王, 认为可以终结掉哲学. 然而……]</p><h3><a href="#2-0-2-li-lun-zhe-xue-de-ren-wu" class="header-anchor">#</a><span id="2-0-2-li-lun-zhe-xue-de-ren-wu">2.0.2 理论哲学的任务</span></h3><p>前面已经演绎出, 自我意识是绝对对立活动的斗争. 原初无限扩展, 因而后来受到限制的活动称为<strong>现实的, 客观的活动</strong>; 在这种无限中直观自身, 作限定, 因而不可限定的活动称为<strong>观念的, 主观的活动</strong>.</p><p>两种活动都是原初无限的, 现实的活动是因为观念的活动而被限定的. 自我意识活动仅仅说明了客观活动是如何受限的, 而观念活动仅仅是这个限制的依据, 因而并未受到限定.</p><p>客观的活动是原初未受限制的, 因而是后来被加以限制的, 它在<strong>质料</strong>上是自由的, 在<strong>形式</strong>上是受限的; 而主观的活动是全然不受限定的, 假如其受到限制, 那么在<strong>质料</strong>上就是不自由的, 而在<strong>形式</strong>上是自由的.</p><h2><a href="#chang-duan-jie-shi" class="header-anchor">#</a><span id="chang-duan-jie-shi">长段解释</span></h2><p>在经验自我意识中, 对任何事物, 例如一个杯子的认识, 都是主客观同一的.</p><p>杯子作为客观的活动, 其质料是自由地按客观事物的本性呈现的 (如材料, 颜色等) , 而形式则是受观察者的观念活动规定的 (如杯子形状, 用于盛液体等). 反过来说, 认识杯子的观念活动, 其在质料上就必须依照客观事物的呈现 (其就是白色的, 就是有水垢, 无法更易) , 只在形式上可以自由规定 (我认识其是杯子, 而不是茶壶或者甜甜圈) .</p><p>可以如此总结, 意识中的对象都是主客同一体, 其<strong>质料取决于客观, 形式取决于主观</strong>.</p><p>观念活动 (在形式上) 的不可限定性就是理论哲学全部<strong>构造</strong>的基础.</p><p>整个哲学无非是自我意识 (的构造) 的一部历史, 就是绝对综合这个活动的全过程. 我们需要将其一环一环地划分, 以期一步步理解整个的绝对综合.</p><p>理论哲学的<strong>任务</strong>就是说明观念活动是如何受到限定的 [主客观毕竟需要同一] , 其推演的动力就是不受限定的观念活动.</p><h2><a href="#2-1-jie-duan-yi-cong-yuan-shi-gan-jue-dao-chuang-zao-xing-zhi-guan" class="header-anchor">#</a><span id="2-1-jie-duan-yi-cong-yuan-shi-gan-jue-dao-chuang-zao-xing-zhi-guan">2.1 阶段一: 从原始感觉到创造性直观</span></h2><h3><a href="#2-1-1-yuan-shi-gan-jue-zi-wo-zhi-guan-zi-shen-wei-shou-dao-xian-ding-de" class="header-anchor">#</a><span id="2-1-1-yuan-shi-gan-jue-zi-wo-zhi-guan-zi-shen-wei-shou-dao-xian-ding-de">2.1.1 原始感觉: 自我直观自身为受到限定的</span></h3><h3><a href="#i-zi-wo-chu-yu-wei-bei-zhi-guan-de-you-xian-zhi-zhuang-tai" class="header-anchor">#</a><span id="i-zi-wo-chu-yu-wei-bei-zhi-guan-de-you-xian-zhi-zhuang-tai">I 自我处于未被直观的有限制状态</span></h3><p>自我意识的两种对立活动在绝对综合中被合并起来, 就会产生一种<strong>共同的东西</strong>——<strong>质料</strong>. [主观和客观的对立活动, 被绝对综合所中介, 产生的是物质. ]</p><p>因为质料是对立的无限活动的产物, 所以它必然是一种有限的东西. [未明子语: 谢林这里赖皮的, 没讲明白为啥是有限的. ] 这里的斗争是<strong>固定了的斗争</strong>, 质料将对立的方向 (向心的直观与离心的扩展) 合而为一, 从而变成<strong>静止</strong>的了.  质料是自我产生的对自我意识而言第一个<strong>现实</strong>的东西, 而两种活动在绝对综合之前并不是现实的.  [现实的活动之所以被观念活动意识到为现实的, 就是因为其在质料, 即斗争的僵持处发现了异己的东西, 也就是现实的活动. ]</p><p>质料就是两种活动斗争的僵持平衡. 观念和现实的活动僵持住, 产生了物质性, 也就是质料. 一切质料都是对立活动平衡的单纯表现, 就像是一个跷跷板两边的重量相互对抗, 质料就是跷跷板的支点. 质料不是通过自由创造随意产生的, 而是绝对综合的必然产物. [不过, 此处的质料只是作为假想模型存在, 因为离开形式的质料是不存在的. ]</p><p>这个中介了主客观的第三种活动, 如果能够持久存在, 那么就会是<strong>主客同一体的构造</strong>. [自我意识的原初活动就是成为对于自己的对象, 正是这造成了自我的原初二重分裂. 分裂出的对立活动必须通过主客的一种共同构造来同一起来, 这就是无限多环节的绝对综合所做的事. ] 假如自我可以直观这个构造, 就能达成主客同一的自我意识 (完满的自我) .</p><p>然而, 这个第三种活动并不能持久.</p><p>第三种活动产生的条件是主客观活动的僵持住了的斗争. 主观活动作为斗争的一方, 必然也就需要随之受到限制. 在第二章 (1.1.1) 中说过, 两种活动是真正对立的活动, 那么观念活动也必然能受到现实活动的限制.</p><p>然而, 观念活动是被设立为绝对不可限制的, 因而也就不能真正被限制, 所以这个第三种活动也就不能持久. [想象一方是学生, 一方是班主任, 班主任强令体育课变为自习课. 虽然两方存在斗争, 但由于班主任是手握权力的一方, 所以斗争不可能真正持续, 而是迅速以班主任的胜利为结局. ]</p><p>这种斗争的<strong>不平衡性</strong>是产生真正意义上的世界的必要条件. 假如世界卡在这种僵局里, 那么就仅有一种不动的世界, 既没有感觉也没有直观.</p><p>另一方面来说, 主观活动需要直观这个构造, 其前提就是要<strong>脱离</strong>出这个构造来, 将这个构造作为对象进行直观.</p><p>因此, 这时候只有现实活动受到限制, 而观念活动仍是绝对不受限制的.</p><h3><a href="#ii-zi-wo-bei-zhi-guan-wei-you-xian-zhi-de-zi-wo" class="header-anchor">#</a><span id="ii-zi-wo-bei-zhi-guan-wei-you-xian-zhi-de-zi-wo">II. 自我被直观为有限制的自我</span></h3><p>我们已经说明, 在斗争中, 现实的活动陷入了有限制状态, 而观念活动也应当受到限制. 这是说, 观念活动, 即进行直观的活动, 应当进行<strong>受限制的直观</strong>, 从而意识到受限制的现实活动.</p><p>直观活动所依据的, 无非是观念活动和现实活动中同一的东西. 而主客观是<strong>经过中介</strong>的同一, 其中必然有<strong>不一致</strong>的地方, 所以才能够被<strong>看做</strong>是同一的, 而非原初就是同一的.</p><p>两者的不一致就是现实活动中的界限. 主客观原初是同一的, 正是因为自我意识活动进行了限定, 才分裂出了主观和客观活动. 自我原初就是活动, 而现实活动则成为了被限定的活动.</p><p>一方面, 观念活动在现实活动中发现了肯定的东西, 也就是<strong>活动性</strong>, 从而将其看做自我; 另一方面, 观念活动在现实活动中发现了否定的东西, 也就是说<strong>对活动的停止</strong>, 从而将其看做某种非我的东西.  [否定的东西是质料, 肯定的东西是形式. ]</p><p>现实活动中否定的东西, 就是<strong>表现为</strong>不是自己设定的, 而仅仅能被<strong>感觉</strong>的东西 (偶性的东西) . 而肯定的东西, 即形式, 就是自我的构造. [将原初自我想象为一位画家, 它想表现美. 观念活动就是完满的美, 而现实活动就是创作出的作品. 作品无疑表达了画家的创作, 因此其中肯定的东西就是他想要表达的美; 而美以有限的画作的形式呈现, 必然不能完美表达其构思, 因此必然蕴含着否定的东西, 也就是不完美. ]</p><p>观念活动感觉到某种非我的东西, 这仅仅在进行直观活动时才会发生. 实际上并非真正存在非我的东西.</p><p>在现实活动中被感觉的否定的东西, 无非是第二章 (1.1.1) 中, 在设立对象化自我时必定设立的非我, 也就是<strong>对活动的停止</strong>.  [例如, 构想一个立方体, 我们会感觉到这个立方体, 因而就无法在这个立方体里面感觉到别的东西, 立方体以内的活动就被<strong>停止</strong>了. 质料和形式同一, 质料停止了直观立方体以外的别的活动, 而形式则是以立方体的方式进行活动.  (此处存疑) ]</p><p>在自我意识活动造成的原初分裂中, 现实活动只是被限制住了, 而还没有被观念活动所直观. 在先后序列上, 观念活动先限制现实活动, 再直观现实活动, 而不能同时进行. [例如, 画家在绘画时, 不能在作画的同时观察自己的画作, 而只能交替进行. 先作画, 后观察. ] 所以观念活动进行直观时, 直观到的异于自我的东西, 就是之前的限制活动的结果. 限制活动所做的, 就是否定限制以外的一切活动, 也就是施加<strong>对活动的停止</strong>. 作直观活动时, 限定活动已经结束, 只在现实活动中留下了限定的结果, 所以直观活动会发现不依赖于它的限制.</p><p>因此, 限制能被设立进不可限定的观念活动中, 只是因为限制本就是观念活动自身设立的. 限制就是观念活动在此前结束了的活动.</p><p>在原初分裂中, 产生的只有观念活动和现实活动, 而不存在任何的意识. 而在原始感觉阶段, 观念活动直观到了受限制的现实活动, 因而将自己意识为受限制的自我.</p><h3><a href="#iii-bu-chong-shuo-ming" class="header-anchor">#</a><span id="iii-bu-chong-shuo-ming">III. 补充说明</span></h3><p>感觉的基础就在于, 自我<strong>不可能</strong>同时将自己限定为对象, 又将自己直观为受限定的对象. 所以当自我进行直观时, 限定活动已经结束, 而成为<strong>对活动的停止</strong>了.</p><p>我们坚持, 自我的受限制状态就是自我意识活动的结果. 因为外来作用怎样变成表象或知识, 是不可思议的.</p><p>一个客观事物作用于主观的自我, 怎样产生出主观的表象来, 是全然不可理解的. [例如, 一片红色的布, 假设其在客观上是某些特定分子的特定结构, 那么, 其为什么会在主观中<strong>呈现为红色的布</strong>这一表象? 这是完全无法解释的. ]</p><p>因此, 存在和知识活动 (客观事物和表象) 必定原初是同一个东西, 否则两者不可能在意识中同一在一起. 存在作为创造性的东西来看, 就是知识活动; 知识活动作为被创造的产物来看, 就是存在. [红色的布无非就是<strong>能呈现出红色的布的表象</strong>的活动; 直观到红色的布的表象的活动无非就是<strong>红色的布本身</strong>. ]</p><p>另外要解释的一点, 就是自我<strong>怎样</strong>感觉到有限制状态的.</p><p>存在 (客观性) 所表达的永远只是直观活动的某种被限制状态. “空间的这一部分里有个立方体” 无非意味着 “我的直观在空间的这一部分里只能以立方体的形式来活动” . 因此, 认识的实在性就仅仅来源于独立于直观的有限制状态.</p><p>低劣的唯心论不承认直观到的有限制状态是独立于直观者的, 然而先验唯心论只是断言, 感觉从来不是<strong>外部</strong>的自在之物的印象作用, 而仅仅是<strong>自我本身</strong>的被停止了的活动.</p><p>独立于直观的有限制状态, 完全是因为<strong>限定出对象化自我的活动</strong>和<strong>直观到自身受限定的活动</strong>是两个活动. 自我的本性有意识到自身的无限倾向, 这是一种不受限的对自身的反复创造. 观念活动在限定出对象化自我时, 对这个自我还没有任何意识; 而在进行直观时, 观念活动才感觉出这种受限定状态. 设定现实活动的限制的活动, 这个活动并不能被意识到, 因而自我就不能将限制意识为是自己设立的.</p><p>最后对这个命题进行补充说明: 任何有限制状态都仅仅是通过自我意识的活动而产生的. 先验唯心论只能说明存在性 (形式) , 而不能说明有限制状态特定地是什么样的 (质料) .</p><p>自我意识必然的本性就是意识到自身并返回自身, 这就使得有限制状态必然存在. 这解释了为什么<strong>一般来说</strong>一定会有受限制状态, 却并没有解释为什么是某种<strong>特定</strong>的受限制状态.  [例如, 我一般来说有一部手机, 但特定来说我有一部华为13promax冷锋蓝. ]</p><p>所有具体的表象, 也就是说自我的部分的有限制状态都是属于原始的有限制状态. 原始有限制状态是在自我意识活动产生主客观二分时, 以及后来的绝对综合时, 一劳永逸地设定起来的. 自我总是停留在这种有限制状态之中.</p><p>自我设定有限制状态时, 一定同时设定<strong>特定</strong>的有限制状态.  [就像画家作出一个人时, 一定是作出一个特定的人, 比如说蒙娜丽莎. ]</p><p>这种特定的有限制状态, 其之所以是这样而不是那样, 只能被我们接受, 而无法加以推演.  [就像画家尽管知道要画的内容, 但对其<strong>具体</strong>画出来的效果却并不事先知晓. ] 不过, 只要这种特定的有限制状态被给出来, 自我意识的活动就是一贯连续的了, 一切后来活动都取决于最初的原始受限制状态. [比如, 踢出一颗球, 只要脚最初的力给定, 球后续飞行的状态就一贯地被确定了. 这就是说, 给定一个特定的第一推动, 宇宙的全部具体内容就随之确定了. ]</p><h3><a href="#2-1-2-yuan-shi-zi-wo-yi-shi-zi-wo-zhi-guan-zi-shen-wei-jin-xing-zhi-guan-de" class="header-anchor">#</a><span id="2-1-2-yuan-shi-zi-wo-yi-shi-zi-wo-zhi-guan-zi-shen-wei-jin-xing-zhi-guan-de">2.1.2 原始自我意识: 自我直观自身为进行直观的</span></h3><p>在前一节中, 自我直观到自己是受到限制的, 这就是自我在进行原始感觉. 感觉活动只是产生出被感觉的东西来, 从而进入意识的自我只是<strong>被感觉的东西</strong>, 而非<strong>主动进行感觉的活动</strong>.</p><p>自我在原始感觉活动中沉湎于被感觉的东西, 固定于被看到的那个受限制的东西中. 这样的自我只是一种被动性, 只是<strong>被动地忍受</strong>限制的<strong>东西</strong>, 而不是<strong>追求活动</strong>而受到限制的<strong>主体</strong>. [齐泽克举过一个例子, 一位假佛教徒 (无意冒犯真正的佛教徒) 如果用刀杀了人, 他并不会感到罪恶. 因为在他眼中, 主动活动的自己并不存在, 自己只是眼中所看的一堆舞动的现象. 所谓杀了人, 也不过是现象的外在必然运动, 使得人的要害飞到了自己手上的刀尖中. ]</p><p>所以, 本节的课题就是: 自我怎样成为主动进行感觉的活动.</p><p>原始感觉中, 于意识中产生的自我仅仅是被限制的东西. 感觉活动对主观和客观自我进行中介, 产生的仅仅是对于受限制状态的被动性的感知. 自我应该是<strong>被自己</strong>限定的, 并且也应该直观到这一点. 所以说自我应当成为主动进行感觉的自我.</p><p>在原始感觉中, 主体和客体被感觉活动中介在一起, 然而感觉活动中又有新的对立, 作感觉的活动与被感觉的东西, 这种新的对立必须有一种新的活动中介在一起. 而新的活动又将包含对立, 如此这般以致无穷. 我们可以从此看出绝对综合为什么有无限多的环节.</p><p>我们厘清一下目前为止理论哲学的过程.</p><ol><li>在最初的分裂里, 仅仅是现实活动受限制, 而观念活动完全不受限制. 对于观念活动而言, 受限制就是在意识, 因而此时还没有意识.</li><li>在原始感觉中, 观念活动在现实活动中进行直观, 因而感觉到限制. 不过, 观念活动仅仅是在现实活动之内进行直观时才受到限制. 因而受到限制的只是作感觉的活动, 进入意识的只是作为被感觉物的现实活动.</li><li>现在, 作感觉的活动被称为<strong>被动性</strong>的活动, 因其在现实活动中进行直观时, 也受到其中的限制. 这种被动性的活动并未得到直观, 或者说, 观念活动仍未被限制. 我们力图意识到作感觉的活动, 同时限制观念活动.</li></ol><h3><a href="#i-que-ding-huo-dong-de-yan-yi" class="header-anchor">#</a><span id="i-que-ding-huo-dong-de-yan-yi">I. 确定活动的演绎</span></h3><p>感觉就是自我在自身中发现某种与自己对立的东西. 既然自我仅仅是活动, 那么这种对立物就是<strong>对活动的否定</strong>, 或者说是<strong>受作用的状态</strong>. 自我需要意识到, 自己是<strong>作感觉者</strong>, 也就是说, 自我必须将现实活动中的被动性, 也设定到观念活动中来. 这只能通过一个新的活动来实现——<strong>确定</strong>活动.</p><p>经验主义无法解释, 为什么自我能够意识到自己是作感觉者. 经验主义声称, 客观事物从外部作用于自我, 使自我产生了相应的反映, 也就是感觉. 然而, 这种反映论将感觉解释为反作用, 就像一面墙将射过来的皮球弹回去一样. 反作用只能解释被动性, 而不能解释对被动性的意识. 自我应当意识到自己是感觉者, 而非被感觉的东西.</p><p>自我必须是能动的, 所以才能作为感觉者. 能动的自我就是观念的活动, 因为其不受限制. 观念活动之所以是不受限的, 是因为它与受限的现实活动相对比, 是因为它可以<strong>超越界限</strong> (overleap the boudary) .</p><p>如果我们回想一下感觉过程, 就会发现每一感觉中都必有一种活动, 它对印象作用进行认识, 而不依赖于这一作用. 这种活动确定了一种受限制的活动性, 或者说被动地受限的主动性, 这使自我成为感觉者. 之前, 自我只是将自己当做印象作用本身并沉湎其中; 而现在自我则主动地认识印象作用.</p><p>自我要成为作感觉者, 就应主动将对立物纳入到观念活动中来 (也就是纳入意识) . 不过对立物无非就是设定在现实活动中的界限, 所以就要将界限纳入观念活动.  [在之前, 观念活动在进行感觉时, 接触到现实活动中看似由非我设立的界限, 界限只是感觉活动所受限的边界. ]</p><p>问题是, 观念活动之所以是观念的, 只是因为它<strong>在界限之外</strong> (fall beyond the boundary). 所以, 将界限接纳到观念活动中, 就需要将界限设立到界限之外, 这就形成了一个矛盾. 这个矛盾将由<strong>确定活动</strong>解决.</p><ol><li>观念自我或许可以<strong>废除</strong>界限, 这样界限就只是观念的了, 也就进入到观念活动. 但是界限是自我本性的必然产物, 因而是不能被废除的, 必须作为界限而纳入观念活动. [废除界限就相当于魔法, 创世主的随意玩乐, 一会变个马, 一会又让马变成牛——这是不可能的. ]</li><li>观念自我或许可以<strong>产生</strong>界限. 但是, 这样并不能解释, 为什么产生的界限可以与现实活动的界限相一致. 就算两者一致, 我们不过也只是让观念自我限制自身, 从而又重演了自我的原初分裂罢了. 这让我们回到最初的起点, 并未前进一步.</li><li>因此, 我们必须找到一个介乎于废除和产生之间的活动——<strong>确定</strong>活动. 确定活动的对象必须是独立于自我的; 在确定活动中, 对象又成为依赖于自我的. 在确定活动中, 对象作为<strong>不确定者</strong>而被废除, 作为<strong>确定者</strong>而产生.</li></ol><p>问题一: 观念活动要确定界限, 这意味着什么?</p><p>之前, 界限在意识中所留下的无非是<strong>被动性的痕迹</strong>. 留下的就是感觉活动所感觉到的, 受非我限制的结果. 自我并不意识到感觉活动. 这种被动性 (感觉活动中受非我限制) 仍然是<strong>不确定</strong>的, 并且不被意识的.</p><p>然而, 任何被动性都应是<strong>确定</strong> (特定) 的被动性, 因为其产生于对活动的<strong>特定</strong>否定. 如果这种被动性能被确定到意识中, 那么界限也就被确定到意识中了.</p><p>被动性是感觉活动的单纯材料, 是纯被感觉的东西. 如果观念自我能将被动性纳入一个<strong>确定的区域</strong>——一个特定的操作区域, 那么被动性就能被确定. 自我仅在这种区域内是被动的, 而在其外是主动的.</p><p>这种确定活动就是一种作创造的活动, 并且其用于创造的材料就是原初被动性.</p><p>问题二: 怎样设想这种作创造的活动?</p><p>自我如果不是主动的, 那么就不能创造这种区域. 但是, 如果自我不被这种活动所限制, 就不能创造这种有限制的区域 (因其是确定的) . 自我作为限制者是主动的; 同时作为<strong>特定</strong>限制的限制者, 它自己就变成受限的了 (只能做特定限制) .</p><p>因此这种作创造的活动就是主动性和被动性的绝对<strong>统一</strong>. 如果界限不是<strong>预先存在</strong>的, 自我就不能确定界限, 因此自我在确定活动中是被动的. 同样地, 自我仅仅是在<strong>主动致力于</strong>确定界限时是受限的, 因而其是主动的. 在确定活动中, 主动性和被动性互为前提.</p><p>通过确定活动, 观念自我成为具有<strong>主动性</strong>的对象 (感觉者) , 它仅仅在自己的确定活动中受限制, 是一种主动地受限制的东西 (limited in its activity) . 正因如此, 自我就不再是感觉活动中的, 纯粹被感觉的东西 (<strong>非我</strong>) , 而是成为了其对立物 (<strong>现实自我</strong>) . 所以确定活动将为我们在意识中真正产生出<strong>自我和非我的对立</strong>.</p><h3><a href="#ii-que-ding-huo-dong-de-zhong-jian-bu-zou" class="header-anchor">#</a><span id="ii-que-ding-huo-dong-de-zhong-jian-bu-zou">II. 确定活动的中间步骤</span></h3><p>在我们推演出的确定活动中, 主动性和被动性是互为前提的, 这是一种循环论证.</p><p>我们通过对界限的限制 (确定活动) 来解释限制是怎样被设立于观念活动的. 但是, 观念活动为什么会去限制被动性呢? 我们认为确定活动中的活动性以被动性为前提. 矛盾的是, 被动性之所以存在, 同样也是以活动性为前提的.</p><p>确定活动让界限纳入到观念活动内, 这就使观念活动不再成为观念活动了. 观念活动之所以是观念的, 仅仅是因为其超越界限. 这个矛盾其实已经隐含在「作感觉者 (主体) 应当成为对象 (客体) 」中了.</p><p>只有一种可能, 就是<strong>超越界限</strong>和<strong>受到限制</strong>对于观念自我来说是<strong>同一件事</strong>. 自我恰恰是因为超越界限, 在其观念性中, 成为现实的和受限的.</p><p>问题: 怎样设想这种事情?</p><p>自我中存在两种活动, 超越界限的观念活动, 以及约束在界限内的现实活动. 两者彼此对立并彼此联系, 从而成为自身. 这需要第三种活动使两者同一, 这种活动是同时位于界限之内和之外的.</p><p>这就是 I 部分中提出的确定活动. 接下来通过一些中间步骤进行详细推演.</p><ol><li><p>在原始感觉中, 自我已经将自己直观为受限者了. 但是, 自我如果不超越界限, 就不可能直观自身为受限者. 因为受限仅仅是相对于无限而言的. 这种超越界限的活动就是感觉活动, 其本身仍需要被设立为自身的对象. 只有这样自我才能被意识为作感觉者.</p></li><li><p>这就是说, 不仅之前的客观元素 (受限制状态) 需要成为对象, 主观元素也需要——超越界限的活动需要成为自我的对象. 然而, 自我要直观到超越界限的活动, 就必须将其与受到限制的活动相对立起来. 所以, 在确定活动中, 自我同时直观到超越界限的活动和受到限制的活动, 同时被直观为观念的和现实的. 这样才能成为作感觉的活动. 自我将自己直观为作感觉者, 就是要将自己同时直观为观念的和现实的. 这是确定活动, 它本身是一种作创造的活动. 这第三种活动就能够使主动性和被动性的循环论证, 在一个活动中同时对自我产生出来, 也就解决了问题.</p><ol><li>在自我理智史的第一个活动中 (自我意识活动, 即原初分裂), 自我是一般地被直观的 (华子的创世活动) , 被直观就是被限定 (造物时的原初设定) .</li><li>在第二个活动 (感觉活动) 中, 自我是确定地被直观的 (意识到限制是什么特定的样子) . 直观限制的活动就是一种新的活动, 它超越界限, 将第一个活动中的作限制者和被限制者同一起来 (自我将自己直观为界限) , 然而本身却在意识之外. 所以, 自我中产生了作感觉者 (主体) 和被感觉者 (客体) 的新的对立.</li><li>在第三个活动 (确定活动) 中, 新的对立被同一起来. 自我在确定活动中意识到了自在之我和自在之物 (self-in-itself &amp; thing in itself) .</li></ol></li><li><p>在确定活动中, 自我震荡于超越界限的活动和受到限制的活动之间, 使两者作为互相联系的<strong>对立物</strong>被确立在意识中.</p><p>问题A: 观念活动被固定为意识中的什么东西?</p><p>既然他被固定下来, 他就不再是纯粹活动. 它被理解为一种固定下来 (因而被认识) 的, 但是对立于现实自我的活动. 既然它能被固定下来, 它就需要一种<strong>观念性</strong>的基底 (它本来应是不受固定的) ; 既然它是对立于现实自我的活动, 它就同样也是<strong>现实</strong>的了. 它就是<strong>自在之物</strong> (thing-in-itself) .</p><p>解释: 原初限制的全部基础就是自我的观念活动. 因而, 它现在是作为<strong>一切限制的基础</strong>被意识. 它不是作为活动被意识——因为自在之我现在仅仅是现实的 (不是对活动的否定) ——而是作为自我的现实的对立物 (非我) 被意识.</p><p>自在之物现在无非就是<strong>观念活动的影子</strong>. 观念活动虽然在界限之外, 但是其影子却作为自在之物被投射回意识. 它因此是自我的创造活动的产物.  [我们现在的立场, 在某种程度上是和独断论者相同的——自在之物是独立于自在之我现实存在的, 不过对我们而言仅仅是在意识中是这样. ]</p><p>自在之物通过观念活动的作限制活动对于自我产生, 作为结果被遗留下来, 但是限制活动本身却被自我<strong>忽视</strong>了. 虽然自在之物是自我自身的产物, 但是自我对此<strong>一无所知</strong>. 而且, 只要自我还局限于自在之物和自在之我互为前提的循环 (也就是意识) 中, 自我就必然保持这样的无知状态. 只有哲学家才能断开循环, 穿透这样的幻觉.</p><p>绝对综合的推演现在已经进行得很远了, 在意识中甚至第一次出现了界限之外的东西. 原始感觉中, 仅仅是界限被揭露; 现在界限之外的某物被揭露, 也就是解释了界限的原因. 原始感觉活动现在被直观, 自我因而不再是被感觉物, 而是作感觉者. 自我在确定活动中意识到的, 就是界限之外的观念活动 (曾经的感觉活动) , 其不再是<strong>自我的活动</strong>, 而必须变成自在之物才能进入意识.</p><p>问题B: 受限制的, 现实的活动成为了什么东西?</p><p>既然观念活动成了自在之物, 那么现实活动就成了自在之物的对立物, 也就是<strong>自在之我</strong>. 一直以来总是主客同一体的自我 (原初自我) , 现在成为了某种自在的东西. 自我主观的方面被带到了界限之外, 而被看做自在之物; 留在界限之内的是自我客观的方面.</p><p>现在, 自我和其对立物的<strong>分离</strong>, 不仅仅是被哲学家所思考到, 而且确实被自我<strong>意识</strong>到了. 自我意识中两个对立物, 就是感觉的确定性所依赖的基础, 并且自我怎样成为做感觉者的问题也完全解决了.  [确定性就是, 自我不仅知道界限, 而且知道界限的源头就是自在之物. ]</p><p>经验论到现在都无法解释的问题——从纯粹被动性的自我到主动和思考着的自我的转变——现在通过确定活动迎刃而解了. 确定活动的天才之处 (谢林: 我是天才! ) 在于设立出非我, 同时在做限定和受限制的活动中, 在主动性和被动性的相互规定中作直观.</p><p>[在确定活动中, 自我无非是对感觉活动本身进行直观, 在这个直观中感觉的主动性和被动性互为前提. 对立于自在之我的自在之物恰恰是作为<strong>存在性的无</strong>而进入意识的, 它仅仅通过意识中属于它的成分彰显自己, 本身隐而未显. 感觉活动中, 自我在现实活动中察觉到观念活动设立的界限; 而现在感觉活动本身与作限制的观念活动的关系被意识, 那么观念活动就作为它者而甩出自我, 成为自在之物. ]</p></li><li><p>现实和观念活动中震荡 (确定活动) 的产物就是<strong>自在之物</strong>和<strong>自在之我</strong>. 现在我们要探究的是, 两者是<strong>怎样</strong>被这种活动所<strong>确定</strong>的.</p><ol><li>自我是纯粹客观, 但其仅仅是在与自在之物的相互关系中是这样. [自在之我包含了所有的表象和主动性; 自在之物限制出了被动性, 以及是表象创造的源泉. ] 如果作限制者仍在自在之我之内, 那么自我就只能通过呈现为被规定的而被规定 (感觉活动阶段) , 因而就不是活动的自我. 现在, 正因为规定者跑到外面了, 自我才成为被规定的活动者了. 这正是独断论者所坚持的, 自我之外的限制者——他们最高也只达到这个阶段. 这个过程中哪个自我 (thing &amp; self) 是活动的并不重要, 因为自我现在是限制与活动的互为前提. 囊括了主客体的整个自我都是活动的, 只不过自在之我分有客体的活动性, 而自在之物分有主体的活动性.</li><li>自在之物仅仅且完全就是自在之我的绝对<strong>对立物</strong>. 既然自我被确定为活动, 物就相应地被确定为相反的活动. 然而, 设立对立物一定是设立特定的对立物 [例如空间中的立方体与空间本身的对立. 两者都是确定的东西, 而非空泛的. ] , 因而物同样是作为受限的<strong>确定</strong>的东西而对立于我的. 现在我们就发现了,  I 中为什么说自在之我也会反过来限制被动性 (确定限制自在之我的活动) . 自在之物的被动性, 作为受到限制的限制状态, 之所以能进入意识, 仅仅是因为自我和自在之物之间的对立. 自在之物就其是对立于自我的活动而言, 是<strong>一般</strong>限制的基础; 就其是受限制 (受确定) 的活动而言, 是<strong>特定</strong>限制的基础. 那么, 是什么限制了物? 正是也限制着自我的那同一个界限. 自我中<strong>活动性</strong>的量越多, 物中<strong>非活动性</strong>的量也就越多, 反之同理. 它们恰恰就是通过这样的互相限制而投身于相互作用中. 这样的<strong>互相确定</strong> (interdetermination) 现在只是被哲学家把握. 不过, 在接下来的<strong>另一种活动</strong>中, 自我也会以很不同的方式意识到这点. 界限仍然是分裂时最初设定的那样, 不过它除了是自我的界限, 现在也是物的界限. 物所拥有的部分无非是原初限定活动中从自我中凿去的部分. 不过, 自在之物仍显得是受到独立于自我的限定的. 观念活动受到限定, 就是因为其超越界限并且被直观到是这样的.</li><li>我们还可以知道, 界限是<strong>怎样</strong>被确定的. 既然其同时是自我和物的界限, 那么其基础在任何一个中都不能多于另一个. 如果界限源于自我 (界限是自我设定的) , 那么自我的主动性就不会受制于被动性; 如果界限源于物, 那么物 (自我在物所产生的丰富内容前所表现) 的被动性就不会需要自我的主动性为条件. 简而言之, 如果界限源于某一方, 那么确定活动就不能成其为确定活动了. 既然界限不在于物和我的任何一方, 那么其就无处栖身——它之所以存在, 就是因为它存在; 它之所以如此, 就是因为它是如此. 它是完全不讲道理地对这两者存在的, 因而其呈现为某种完全<strong>偶然性</strong>的东西. 存在于直观中的东西就是界限, 它完全对于物我两方都是偶然的; 对于界限更加精确的确定现在还做不到, 只有在后面的活动中才行.</li></ol></li><li><p>这个产生物我对立的震荡并不能持久, 因为其又产生了新的对立 [意识这一切的确定活动本身没有被意识] . 然而自我的本性是和自己绝对同一. 自我的所有活动都源自于自我<strong>内在的矛盾</strong>. 自我既然是绝对同一的, 它就不需要任何东西来限定其活动, 除了自我自身的二重化. 而且, 自我的所有理智活动都依赖于这个持续不断的内在矛盾.</p><p>在确定活动中, 这矛盾表现为自我和自我之外的某物之间的对立, 并且, 如果派生开来的话, 是观念和现实活动的对立. 自我如果能在原初限定中直观自己, 那么它必须同时向外扩展并超越限定. 限制, 必然性, 强制感——这些都只能相对立于一个不受限制的活动而被感觉到. 在想象缺席的情况下, 没有什么东西是真实的. 因此, 在感觉活动之中本来就设立了矛盾. 自我同时是受限又超越界限的.</p></li></ol><p>这种矛盾既不能被完全解决, 又无法持久存在. 因此其只能通过一个新的第三活动同一起来.</p><p>这个新的活动必然是一种直观活动, 因为观念自我在其中将会被限制 (即被直观) .</p><p>这种直观因而是对于直观的直观——二阶直观, 我们称为<strong>创造性直观</strong> (productive intuition) . 感觉活动是一阶直观, 其是简单的, 根本无从定义——因为所有定义都是综合命题.  [例如, 杯子的纯感觉是完全简单的, 任何杯子的概念以及隐含的意味都是后来的综合知识. ]</p><h3><a href="#2-1-3-chuang-zao-xing-zhi-guan" class="header-anchor">#</a><span id="2-1-3-chuang-zao-xing-zhi-guan">2.1.3 创造性直观</span></h3><p>笛卡尔宣称: 给我物质和运动, 我能推演出整个宇宙!</p><p>先验哲学家说: 给我由对立活动组成的自然——其中一个活动向无限扩展, 另一个活动在这种无限中直观自身——我能呈现出理智的整个表象体系.</p><p>其他的科学都<strong>预设</strong>了完备的<strong>理智</strong>作为其条件, 而哲学家则洞察其起源, 并且在眼前将其<strong>产生</strong>出来. 创造性直观第一次将自我的原初限制也设定到观念活动中 (被意识) , 并且向<strong>理智</strong>迈出第一步.</p><p>创造性直观是对上一步创造 (确定) 活动本身的直观, 其必然性已经从自我活动的机制导出. 我们仍可以从<strong>知识的概念</strong>出发, 说明创造性直观活动的必然性.</p><p>所有知识的<strong>实在性</strong>都是假借于一种直接的认识, 这种认识必须在 (一阶) <strong>直观</strong>中获得. [通过确定活动, 我们第一次获得了完整的直观, 也就是完整的感觉活动, 而非仅有物的原始感觉. ] 概念仅仅是实在性的<strong>影子</strong>, 是通过一种<strong>再生产性的力量</strong> (二阶直观) 投射出的. 而这种力量本身又以<strong>更高的力量</strong> (一阶直观) 为前提——而更高的力量是产生于自身内一种<strong>原初力量</strong> (原初分裂) .</p><p>我们先喷一喷<strong>蛇皮版的观念论</strong>. 他们将表象的起源设立为外在于表象和自我的东西 [比如康德的物自体] . 他们消除了认识中所有的直接性, 因而任何知识都变成幻觉了. 假如直观产生于外物的印象作用, 那么由印象作用转移到自我中的绝不是外物<strong>本身</strong>, 而只是它的<strong>作用</strong>. 然而在直观中物体自身是直接呈现的, 而非只是其作用.</p><ul><li>有人解释, 通过推论, 这种作用就可以完全取代事物的位置. 但是, <strong>在直观中</strong>我们根本找不到任何推断或者因果关联的痕迹; 因此直观中出现的不可能是推断的纯粹产物, 而只可能是物自身.</li><li>有人解释, 外在作用能激发自我的创造活动, 使得事物抵达到感觉中. 但是, 这也不能解释外部事物 (印象作用的源头) 得以到达自我直观中的<strong>直接传递过程</strong>.  [假如传递的是印象作用而不是物自身, 那么创造活动怎么能产生出对物自身的直观呢? ] 他们只能假设一种完全掌握灵魂, 并且渗透其中的力量, 这样才能操控自我不错漏地表象出物自身. 这就是独断论经典的论调, 他们给外物的表象源头套上神秘的面纱, 假装做出了解释, 而实际上让详尽的解释根本不再可能. 他们甚至可能将<strong>事物的表象的这种不可理解的产生</strong>归功于上帝, 它是全知全能的, 不可能也是可能的. 这些独断论宝宝好像从来也不知道哲学的规则: 在哲学中不能预设任何东西. 就算是看起来最平常, 最熟悉的概念也不例外. 因此, <strong>自我</strong> (内在) 和<strong>事物</strong> (外在) 的分离是需要<strong>论证推演</strong>的, 不能直接作为现成的结论使用. [不能直接假设个上帝, 然后把问题丢给祂. 不然哲学还思考个毛线咧. ] 正因为我们要论证这个分离, 所以我们就需要从<strong>尚未存在这种分离的地方</strong>出发, 在第一原理中内在和外在是融混在一起的. 因而, 在破除独断论的无理由假设时, 哲学家自然而然地采用了一元论的前提, 因而也一以贯之地是一种观念论.</li></ul><p>相反, <strong>我们的观念论</strong>在<strong>自我</strong>的一种既<strong>观念又现实的活动</strong>中寻找物的起源. 正因为它是最纯粹的观念论, 同时就是最纯粹的实在论了. 最完美的实在论就是事物在事物中看到的只是自己的实在性, 由自己的活动所限制的实在性. 因而这样一种事物的内在灵魂就能够贯通事物内部, 像艺术大师完满地认识自己的作品一样, 从根本上洞察事物的内在机制.</p><p>独断论者根本无从证明那种外部作用到底是怎样的. 然而, 作为对于知识的实在性的保证, 我们必须期望了解它的机制. 人们必须了解从物质向精神升华的过程, 从而了解知识的实在性的基础.</p><p>要理解事物向自我的转移, 必须避免庸常的立脚点——认为精神中不存在任何<strong>无意识</strong>的东西, 精神中除了意识领域, 再没有别的领域. 如此才能理解, 为什么理智会在其创造物中流连忘返, 就像艺术家在其作品中着迷失神一样. 我们要明白, 必然和自由结合在一起的一种活动是存在的.</p><p>关于「直观」这个词, 我们必须排除所有类似于感觉的东西. 尽管看 (seeing) 是一种直观, 但是直观远远比视觉活动的内涵更广. 一般人用光线来解释直观活动, 但实际上<strong>光线本身</strong>就是直观活动. [???]</p><p>所有创造性直观都产生于自我的永恒矛盾, 自我因其回到自身同一的趋势而被迫持续地活动. 它在自身的创造活动中是受限制和束缚的, 就像自然在产生自己的过程中所受的束缚一样.  [物质按照其原初设定好的本性, 自由而必然地活动. ] 通过直观的整个理论, 我们将完全解释清楚这件事.</p><p>创造性直观的理论将从之前的这个结论推演: 当超越界限和受到限制的活动相互关联时, 它们就作为对立物 (物和我) 被固定下来.</p><p>问题: 超越界限的活动怎么能被固定下来, 从而也受到限制呢?</p><p>这是因为, 超越界限的活动并不是作为活动而被限制的, 而是作为受直观的对象而同时被限制的. 超越界限的活动仅仅在活动时才是不可限制的, 而当其成为对象, 就另说了.</p><p>在创造过程 (确定活动) 中, 直观活动 (感觉活动) 现在同样成为了被直观者 (自在之我) , 因而也成为了现实的. 就其是直观者而言, 这种直观活动虽然在创造中被限定, 但仍保持是不受限定的. 它仅仅是在创造过程中被限定了, 仅仅是暂时被限定了; 而不像现实活动一样, 持续地受限.</p><p>理智的所有创造活动都有赖于不可限定和受到限制的活动间的矛盾, 因而创造活动也会像这种矛盾一样是无限的.</p><p>自我必然包含一种超越界限的活动, 因为它必须超出创造活动, 将自己看做作创造的. 另一方面, 如果</p><h2><a href="#2-2-jie-duan-er-cong-chuang-zao-xing-zhi-guan-dao-fan-si" class="header-anchor">#</a><span id="2-2-jie-duan-er-cong-chuang-zao-xing-zhi-guan-dao-fan-si">2.2 阶段二: 从创造性直观到反思</span></h2><h2><a href="#2-3-jie-duan-san-cong-fan-si-dao-jue-dui-yi-zhi-huo-dong" class="header-anchor">#</a><span id="2-3-jie-duan-san-cong-fan-si-dao-jue-dui-yi-zhi-huo-dong">2.3 阶段三: 从反思到绝对意志活动</span></h2>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（八）</title>
      <link href="/20250311-idealism/"/>
      <url>/20250311-idealism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有一个特别好玩的事情。我今天读了一堆人读这本书的笔记。几乎每一份都不约而同地在第三章第一阶段这个地方戛然而止了。What can I say?</p></blockquote><blockquote><p>事到如今，我又迷失在细节里了。因此首先对这一章到目前为止的内容进行一个梳理。谢林的写作结构其实还是很松散的。<br>读了一个我比较认同的<a href="/20250311-cite2.md">解读</a>，我把它装到了脑袋里面，后面就快快地过。<br>因此这个系列基本完结了。</p></blockquote><p>谢林在一二两章推演了先验唯心论的原理，并演绎了先验唯心论。这里复习一下。</p><img src="image-20250311101422438.png" alt="image-20250311101422438" style="zoom:50%;"><p>首先原理是说，知识有一个最高原理。第一章就是首先阐明，这种原理是必要的，以及如果真有这种原理的话，它会有什么性质。进而通过这些性质演绎出原理本身。对于这一原理，谢林并没有给出一句话的总结。如果非要有一句话的话，那就是，<strong>一切知识的原理要在于主观的和客观的东西所会合的那一点，在这一点上主体和客体是同一个东西，同一和综合是同一件事情，这一点只能够是自我意识，因为它同时被表象和作表象，将自己变为自己的客体</strong>。</p><p>先验唯心论的一般演绎，是从这一原理出发的。但到底要演绎什么出来？ 从我们的原理中可以看出，唯心这一点是显明的。然而“先验”在哪里呢？先验的意思就是说我们还要超越一种独断的超验唯心论，因为超验的唯心论完全不care你知识的实在性。它认为所有的知识都是一种主观的自由创造罢了，包括整个世界也是如此。但是先验唯心论就不是这样。只要你是一个人类，你都能够感受到这个世界的强制性，有自由，但是也不是随心所欲的自由。理论知识是有一种强制感的。先验唯心论就是要在保留一种自由的情况下，还要解释客观世界的实在性，也就是<strong>根据精神活动的内在原则完全说明世界产生过程的机制</strong>。</p><p>为了解释，只能作这种设想：自我之内有两种活动，整个存在是受到阻滞的自由的表现，等等。整个演绎就是演绎这两种活动。由两种活动，再上升到唯心论和实在论，理论哲学和实践哲学。</p><img src="image-20250311101438911.png" alt="image-20250311101438911" style="zoom:50%;"><p>现在我们从先验唯心论出发了。我们要演绎理论哲学体系，也就是阐明第二种活动，无限地直观自身的活动，是如何可能、如何发生的。按照之前的说法，就是要演绎一种“主体发生学”。我们首先要推演一种绝对综合，再把它细细地切成臊子。</p><p>首先演绎。总之就是自我意识需要在两种活动的对立中，通过第三种活动，也就是绝对综合的中介来维持矛盾的存在。这第三种活动就是在二者之间来回摆动的活动，使得双方分享实在性。自我是那两种活动，而自我意识则是第三种活动。</p><p>因而有一问题需要解决，即被认为不可限定的观念活动是如何遭受限定的。</p><img src="image-20250311101452469.png" alt="image-20250311101452469" style="zoom:50%;"><p>第一个时期，从原初感受到生产性直观。老实说不知道是什么意思，先来看看内容。</p><p>课题A，自我如何直观到自己是受限定的。我们想把直观活动本身包含在被直观的建构之内，是不可能永远成功的。所以只有实在活动了。实在活动被限定（哲学家视角），然而还未被直观（对我自身，观念自我而言尚且不是受限定的）。因而这里讨论的实际上仅仅是“观念活动是如何去直观实在活动的”。</p><p>两种活动原初地都是观念的。而之所以区别，是因为两者之间有界限，而这界限又是设定在实在活动当中的。这样，实在活动中又必定要包含某种观念的东西，因而与观念活动关联在了一起。</p><p><strong>观念的活动是自我在实在活动中变自身为对象的无限倾向</strong>。是实在活动自己设立了自己的对立面罢了。但自我并不知道。自我只能是通过将这种被限制状态直观为某一<strong>非我</strong>的作用，从而把自身直观为受到限定的。</p><p>总之，自我所能觉察的不过是与自我所对立的东西，自我不过是活动，所以只是觉察到一种活动的否定，也就是<strong>已扬弃的活动</strong>。这已扬弃的活动，就发展为一种对象。</p><p>虽然还是怪怪的，有点拧巴，不过还是圆上了。有的地方写得多余，也许可以放到附论中去，保留着显得逻辑不通畅。</p><blockquote><p>但是，谢林还打算讲，<em>原初不可限定的观念活动是如何得到限定的</em> 吗？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>登校感想</title>
      <link href="/20250311-schooling/"/>
      <url>/20250311-schooling/</url>
      
        <content type="html"><![CDATA[<p>第一天大概有点高兴，又是吃辣的，又吃冷的又吃热的，又空腹吃药，又没在新房间开空调，总之各种原因，第一天这个觉睡得很不安生。一会儿冷，一会儿肚子难受的，一会儿又觉得房间里气味没散掉。最后我打开了 <a href="https://live.bilibili.com/1883358196">CS-advent 的直播间</a>，听了一小会儿 G2 vs NaVi 的比赛，竟然奇迹般地失去了意识。</p><p>睡到快 8 点自然醒。一睁眼一点光线都没有。这个房间的位置窗户只能开半扇，平时就有点阴森了，打开灯也好不到哪里去。昨天因为太累了太晚了，回到宿舍的时候浑身上下都在发酸，怕打扰到隔壁就没有洗澡，于是早上来洗。</p><p>吃早饭还有路人帮忙拿筷勺，还遇到陈阳帮我把盘子端走了，阿里嘎多，世上还是好人多。</p><p>总归是行动不便，几乎花了一个半小时才完成上班之前的这点流程。不过只要不急就不会出问题。不过是否意味着我应该早点起床呢？</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（七）</title>
      <link href="/20250310-idealism/"/>
      <url>/20250310-idealism/</url>
      
        <content type="html"><![CDATA[<p>71</p><p>上文说到，自我设定非我，然后非我在被自己所感觉到的时候，仅仅能够被认为是一个异己的限定性，这是一种因为<strong>自我不能直观自我为正在进行直观的</strong>所造成的错觉。</p><p>自我借以限定它自身的活动无非是自我意识的活动。我们完全不能设想一个外部刺激带来了某种表象或知识。<em>同样地</em>，这里这句话的意思是，对象作用于自我和它作用于一个客体是不同的，因为自我里面还有主观的东西，不同之处就在于，对象还要作用于主观的东西，被主观的东西规定。如果相同的话，那么产生的不过就还是客观上被规定的东西。这里扯因果律的地方先不看。所以为什么原始的存在会变为知识呢？我们知道表象是会变成知识的。所以这种会合只能通过“表象本身也是一种存在”来理解，这是一种唯物论的理解。</p><p>谢林认为，唯物论暂时还是不可理解的。他断言等到唯物论完善的时候，本身也就和先验唯心论没有什么区别了。为什么就没有区别了呢？因为在这里，被认识的物质本身成为了一种幻影（表象），这其实就是理智的东西。唯物论就像唯心论一样，以理智的东西为根本了。当然这不是说存在是知识活动的一种结果，不是一种因果关系。这两种东西实际上本来是在自我之内的同一个东西，正因为是同一个东西，所以才是有可能会合的。接下来从两个方向继续解释：<strong>存在（物质）作为创造性的东西来看，是一种知识活动；知识活动作为被创造的产物来看，就是存在</strong>。</p><p>叽里呱啦说了几句，最后一句话很重要。假设只有质料是属于物的，那么这玩意在到达自我之前，就是完全没有形式的。表象也就是没有形式的，这根本无法想象。仔细想想，这就是在批康德把形式都放在自己这里，把杂多放在经验性的感受那里。这里最终想说明，表象是既具形式也有质料不可分割的，而且这些因素都包含于我。这时候我们再往前看就很简单了：如果知识活动是有创造力（生产力）的，那么它完全而彻底地具有生产力，也就是知识活动必须生产着一切，而不是仅仅生产着一部分内容。知识活动以外是没有任何东西能够进入知识成为知识的，所有存在着的东西都与知识本身是同一的。</p><blockquote><p>翻来覆去，还是自我设定非我。</p></blockquote><p>72</p><p>我们说完自我设定非我了，那么自我又是如何感觉到这种“非我”，也即有限制状态的呢？为什么自我会把这种闲置状态把握为一种对立的东西？</p><p>实在性维系于感觉。哲学要解释认识的实在性，就必须解释感觉，否则一败涂地。因为<strong>一切认识的真理性都毫无疑问地是以伴随着认识的强制感为基础的</strong>。真理之所以为真理，是因为我们并不能凭空捏造真理，是就是是，不是就是不是。而直接接受的感觉，无疑是认识中最为强制性的，因为它代表着一种不经中介的认识。</p><p><strong>存在（客观性）所表示的永远只是直观活动或创造活动的一种被限制状态。</strong>“空间的这一部分里有个立方体”，这无非意味着“我的直观在这一部分空间里只能以立方体的形式来活动”。直观只是一种限制，而在直观之外还有一种限制，这种限制才成为了认识的实在性的根据。如果抛弃了这种根据，只剩下直观活动本身作的限制，那就会是一种独断的、超验的唯心论。先验唯心论受到攻击无非就是因为被误解为那种独断超验的唯心论，而事实上我们根本不需要反驳：因为没有人会相信那种谬论。</p><p>如果有人认为，“感觉不是外部的印象作用，表象中没有自在之物甚至没有偶性，对自我的印象作用上不能设想有什么合理的东西”是一种独断的唯心论的话，那么我们只好承认这确实是我们的（先验）唯心论。但是知识的实在性告诉我们，人并不能自由地有意识地制造原始有限制状态。也就是说，并不是人随心所欲地创造着一切。自我设定非我，这不假；不过这种设定是一种无意识的、不由自主的、必然的设定，而非一种随意的设定。这就是先验唯心论与独断的唯心论的区别。</p><p><strong>先验唯心论只是断言自我根本感觉不到物自身，也感觉不到从事物向自我过度的某种东西，而只是直接感觉到自我本身，感觉到自我本身的被消除的活动。</strong>虽然如此（知道感觉到的东西还是自我本身），先验唯心论还是要说明，我们为什么会将自我的观念活动设定的受限制状态直观为异己的东西。</p><blockquote><p>简单地读了一下还是卡住了，整体逻辑理得一坨。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（六）</title>
      <link href="/20250309-idealism/"/>
      <url>/20250309-idealism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>重申：主观理解，仅供参考</p></blockquote><p>68</p><p>上文提到的，又在此处着重号的部分做了总结：自我觉察到的被限制状态是一个和自我对立的东西，是非我所设定的。我只能将其直观为非我所限定的，即便自我从根本上设定这一切。接下来点艹康德，因为他提出了一个自在之物与对象的二分。自在之物是什么呢？是现象后面那个不可被认识的底层代码。谢林说，你康德搞了个“自在之物”，多虚伪，你这辈子也就这样了，你就只能停留在这种观点上了。意味着他谢灵还要在此之上更进一步。这种自在之物就是一种异己的限制状态的来源，它是自为根据的。从这种立场出发就会得出，感受并不是一种纯粹的接受性，而是存在自发性的。自发性属于自我，而接受性属于自在之物，于是我们认识到的客体就显现了两个方面的内容：肯定者作为自我的产物（这里对应康德的先天直观形式等等所提供的一个先验对象），以及否定者（偶性）作为非我，也就是自在之物的产物。</p><p>接下来，谢林就要开始超越康德了。概括说来，就是这个非我仍然是自我设定出来的，就是自我设定非我。</p><p>自我察觉到这种异己的限定性，这使得在我们看来，偶性不可通过自我加以解释，而肯定者却是自我本身的建构。但“自我”（我们哲学家的客体）察觉到自己是由一个对立面所限定的，这件事也是有条件的，即这种察觉仍然是在自身之内发生的。</p><p>我们并不是说与自我对立的东西是在自我之内存在着的，而是自我察觉到它存在，这意味着只有在与自我的察觉相关联的时候，这种东西才是与自我相对立的，而不是本来就与自我绝对对立的。一句话，自我察觉是对立存在的前提。</p><p>69</p><p>在觉察活动中，被觉察者已经不是纯粹的自我，而是被作用的自我。而被觉察者的异己性也仅仅是就觉察者之作为觉察者来说而是的。</p><p>进一步解释，这种活动能觉察的是与自我对立的东西，自我无非是活动。因而被觉察的只能是对活动的否定，也就是已扬弃的活动，而不是直接感觉到某种客体。对活动的否定事实上可推论出一个客体来，这是我们很久以后才要讨论的。</p><p>总之，自我感觉的永远只是它的已扬弃的活动，那么被感觉者实际上也就是自我自身。以这种方式，将自我直观为被限定的。</p><p>70</p><p>（课题A的）附论</p><p>1.按照这种演绎，感受（感觉）的可能性的基础在于：</p><p>a) 两种活动的平衡已经被破坏，于是那个主体客体建构的共同者消失。这时的自身直观就只能是单纯客体的。因而可以将感受理解为一种劣化的处于受限状态的完满自身直观。</p><p>b) 直观自身的无限倾向，必须借助于两活动中共同的东西，也即肯定的东西来感受否定的东西，才可能发生。</p><blockquote><p>评价为有点多余。</p></blockquote><p>2.感觉的实在性的基础是自我不把被感觉的东西直观为通过自我建立的，而是非我建立的。即使我们现在已经明白了自我设定非我这一点，但自我意识却不知道，因为我们无法把自己直观成作直观的自我。在作直观时，被直观者仅仅是被限定的。这种不可能性就是一切感觉的实在性的基础。</p><p>因此，以为被限制状态是绝对异己的东西，特别是认为有一种自在之物，是一种错觉。为什么会有这种错觉呢？因为那个使得自我受到限制的活动，与自我直观到自己为受限制的活动，并不是同一个活动。它们也许同时作用，但在形式上是不同的。</p>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（五）</title>
      <link href="/20250308-idealism/"/>
      <url>/20250308-idealism/</url>
      
        <content type="html"><![CDATA[<p>64</p><p>2.但是这一共同的东西却不持久，下面给出原因。</p><p>上文说到如果能持续下去，就会是自我本身的构造，然而马上否定了</p><p>a) 这段按照先刚一本要更对一些，老版本有错。意在表达观念活动因为本身陷入了一种斗争，因而与对方必须是相互限定着的才可被设想。这种对立并不是消灭、褫夺，以至于取代了对方成为唯一的活动，而在于作为实在活动的对立面、否定者而存在。</p><p>65</p><p>b) 但是观念的活动被限定设想为绝对不受限定的，不可能真正地受到限定。因而这种共同者因为对立本身并不是真正的而不可能持续存在。括号内进行了补充解释，其核心的意思在于，如果说这种产物真的能够持久，说明这种综合统一的环节达到一劳永逸的成功，因而再也没有理由诞生出新的东西来，整个体系就又回到僵死的状态。这样就揭露了<strong>这种综合其实是一种必然失败的行动</strong>。</p><p>3.因而在第三者当中的完满直观随即宣告破产。直观本身参与构造，因而它完不成直观自身的活动，而只能产生一种无限的倾向。因而观念活动仍然作为一种剩余没有受到限定。</p><p>4.所以剩余的课题就只有这一个：实在自我如何能够对观念自我而言也成为受限定的？因为 a. 实在自我本身按照已推导出的机制受限定；b. 观念自我根本不受限定。因而只有解释，自我何以会直观到自己是受限定的。</p><p>66</p><p>a) 实在活动与观念活动是如何统一又是如何区分的？这只能从实在活动之中去找。区别的根据是实在活动的界限，而同一关联的根据则是说明实在活动必包含某种观念的东西，这是如何可以设想的？</p><p>谢林这样设想到，在设定那种界限之前，我们根本认识不到观念活动的其他特征。二者原初地看来都是非客观的，都是观念活动</p><p>b) 在此基础上推论。实在活动里有观念的东西，这使得它成为自我的一个活动；而又有否定性的东西，这使得它成为实在的。观念活动之所以使自我直观到实在活动与自身的统一，要依赖于对其中否定性的东西的意识。这种异质性、差异性是在同一性之先的。就实在活动中观念的东西而言，两活动是关联的；就否定性的东西而言，两种活动就被分开。</p><p>67</p><p>括号里的内容比较重要，不过意思也是浅显的，即因为直观者不知道一切限制都是自我的，因而只能察觉到客观东西里的否定者不是由它自己设定的。这是哲学家立场与自我立场的区别。</p><p>因而，自我仅仅能察觉到一般的否定者，一般的限定，作为单纯的经验因素。</p>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>争论的部分宿命</title>
      <link href="/20250307-quarrel/"/>
      <url>/20250307-quarrel/</url>
      
        <content type="html"><![CDATA[<p>看过《颂乐人偶》的朋友们多少都会在很久之后意识到第四话结尾炸团的灾难性演出。你们在吵什么？这都哪跟哪啊？一旦认真分析起来了，就会发现吵架的主角甚至没有弄明白自己哪些话是有帮助的，有些话是完全帮倒忙的。当然到这里肯定就能得出一个结论，那就是编剧这段吵架戏完全是按照本能写出来的，只是互怼而已。</p><p>然而这种争论的发展在我看来堪称真实。当然这还不是说，争论着就脱离了原来的话题，转而对对面进行总体攻击，这部分在第三话火车站时已经展示了。比起真实争论来说，这已经属于非常清晰的了，至少大家想的都还是把对面驳倒，至于驳倒观点还是驳倒人你先别管。而真实的争论到最后往往是更加灾难的。下面让我们来看看究竟都能发生什么事。</p><p>这里讨论的“争论”，当然是指有严肃的出发点，并尽力做了克制的。然而一般还是吵不好。</p><p>1、注意力涣散</p><p>有的时候话赶话的说快起来，就容易进入忘我的状态。容易注意不到对方逻辑的连贯性，只能就对方最近说的一句话进行反驳，最后被抓住这种漏洞一棍子打死。当然这也有赖于对方拥有较强的注意力。如果双方都比较头昏，有的时候说着说着两个人的观点就完全不冲突了，变成你说你的，我说我的；然而还是继续自动驾驶，继续争论下去。</p><p>这种情况建议都静下来慢慢地完整地表达完自己的观点，甚至是以书面形式表达，然后做充分交换。</p><p>2、争来争去争定义&#x2F;立场</p><p>事实上如果认识到了争论的本质在于定义权的问题，这就代表双方的立场完全不同。这种时候就完全可以进入扣帽子流程了。但灾难就在于认识不到，就一个两边连定义都不同的观点争了半天相持不下，完全是在浪费口舌。</p><p>定义权问题的解决有的时候甚至已经不在于批判的武器了，而在于用现实将对面驳倒。所以这类问题本身不适合争论，但适合用于判断敌友。</p><p>3、从百草园吵到三味书屋</p><p>多发于打比方的时候。一旦双方的思维进入了一件更加具体的事情以后，就赖在里面不出来了，因为讨论具体的事情是简单的，就此立即点评是更加符合本能的。只能说有的时候一些具体情境下的思想实验是必要的，但一定要确保双方都能够撤出来。</p><p>解法与1相同。</p><p>当然，总的来说还是希望和平地充分交换意见，以及在特定时候使攻击性回归其表达喜恶的本质而不是夹杂着理性的批评。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>恋人的天堂和地狱</title>
      <link href="/20250307-erotic/"/>
      <url>/20250307-erotic/</url>
      
        <content type="html"><![CDATA[<p>这个讨论起始于空友的一个问题。</p><blockquote><p>为什么一起下地狱像情话，一起上天堂就像邪教洗脑？</p></blockquote><p>乍一听确实是这么回事，不过咨询群友之后得到了否定的说法，认为同样不现实的情况下，上天堂可能会更加意乱情迷。面对这种说法，我一开始是拒绝的，因为我对宗教这方面并不熟悉，我所思考的“上帝”是从笛卡尔开始的，于是似乎从来都被塑造为一个最高的理性者，所以无法想象到上了天堂之后的恋人能进入一个看似非理性的幸福状态。感受到最高理性的幸福倒是可以想象的。</p><p>群宗教领域大神认为上帝一直都代表着爱。仔细想了想倒也是，但还是不认为这有多色情，于是群友不得不向我隆重推荐了<em>圣女大德兰的神魂超拔</em>。这是一组巴洛克时期的雕塑作品。</p><img src="800px-Ecstasy_of_Saint_Teresa_September_2015-2a.jpg" alt="undefined" style="zoom: 50%;"><blockquote><p>“我看见在他的手里有一支金质的长矛，在铁质的矛尖处似乎有小小的火花。他看似好几次把长矛插进我的心脏，刺穿我的内脏。当他把矛拔出来的时候，似乎要把我的内脏也拔出来，让我全人燃烧在天主的大爱之中。这痛苦是如此巨大，让我不禁呻吟，然而这种极致的痛苦带来的甜蜜却也如此非凡，让我什至生不起摆脱它的愿望。现在满足我的灵魂的无外于天主。这痛苦不是身体上，而是灵性上的，尽管身体也分担了一份痛苦。现在在我的灵魂和天主之间的是无比甜蜜的爱的抚摸。我祈求良善的天主，让认为我在说谎的人也能亲自体验我所体验到的。”</p></blockquote><p>我认可了。不过允许我稍微做一些辩解。神之爱的色情之处大抵在于两个方面，一是对于一切的审判、净化，另一方面是对一切的接受、宽宥，是有罪之人面对神的时候，对于那种绝对尺度的诚服，以及面对绝对的真善美之时的崇高的幸福感。严格来说，这只是人对神的爱。而另一边则是一种普遍的慈爱。如果一对恋人到了天堂能够感到意乱情迷，那绝不是出于恋人之爱，而是两个人都成为了神的俘虏。这看起来有点NTR。</p><p>想到这里，我不禁要点名两部电影。一部是<em>巴黎Q娘</em>，另一部是<em>成为约翰·马尔科维奇</em>。因为两部电影都包含着这样一个结构：一对恋人，遇上了作为“欲望”的化身的女主角，于是都爱上了女主角。不过结果是不一样的。前者是女主用一种行为艺术、社会实验的方式，引导爱人面对欲望，走到一起；而后者则是强制弹出了一个人。不过谁又知道这里的女主角到底是地狱还是天堂呢？</p><p>我能够想到，如果恋人决心要一起下地狱了，那一定是两个人紧紧地连在一起对抗着地狱。也有一句老话说是，一个外部的敌人是爱情的最好的助力。这一点在很多经典的爱情故事当中都存在，而关于这种结构的分析也非常经典——当恋人拥有了一个外部的阻力时，这种对抗成为了事实上维持着二人关系的力量。爆款齐泽克视频说，因为有伴侣，所以才会有小三；但小三的存在却反而使得伴侣互相纠缠难以分开。这时一旦小三消失了，那么正宫的位置似乎也就不值得坐了，伴侣也会离开。其实是同样的结构。这揭示着一个重要的事实：<strong>你根本就不要幸福，你只是想要羁绊</strong>。我们都是在外部性的危机中确证自身存在的，正如恋人的联结在一个外部的“地狱”存在之下不断地加强了。“入则无法家拂士，出则无敌国外患者，国恒亡”，也是这个道理。</p><p>所以也许还是去地狱吧。我果然是没有宗教信仰的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（四）</title>
      <link href="/20250307-idealism/"/>
      <url>/20250307-idealism/</url>
      
        <content type="html"><![CDATA[<p>62</p><p>上回提到整个哲学无非就是对原始行动序列的自由模仿和自由复制。第一个序列原始活动对第二个序列复制活动模仿活动是现实的，第二个序列对第一个来说是观念的。我们可以任意地渗入第二个序列，借此进行一些哲学的观察，但只是形式上任意地打断和延续，我们不能改变其中的内容的分毫，因为这都是原始活动确定好了的。哲学研究着意识的原始产生过程，因此需要进行模仿。它是有关两个序列的科学，而其他科学则只有原始活动序列，因为它们都不需要思考所研究对象的知识在意识之中的发生机制。<strong>研究哲学的天赋就在于模仿中重新意识到原始行动中所包含的必然性</strong>。</p><p>自我意识，（自我）是两个绝对地相互对立的活动之间的斗争。我们把其中一个原初地走向无限的活动称作实在的、客观的、可限定的活动，把另一个在上述无限性中趋向于直观自身的活动称作观念的、主观的、不可限定的活动。</p><p>第三小段就没有那么好解读了。首先这里提出了一个目标，我们要把全部的自我意识活动作为研究对象，也就是限定起来。第一种活动已经由第二种活动限定了，<strong>第二种活动的限定，尤其在于它作为原初不可限定的活动的情况下，又该如何设想</strong>？这是提要中写的，有待后续解决的。不过，谢林给出了一种从结果而言的理解，就是假设这种活动的限定可被设想，那么“客观的活动作为原初的不受限定的，但恰恰因此可被限定的活动就质料而言是自由的，但就形式而言是受限制的；主观活动作为原初的不可限定的活动在遭受限定的时候，就恰恰因此就质料而言不是自由的，仅仅就形式而言是自由的”，不懂也不要紧，因为后面还有演绎。谢林并且就此提出，理论哲学的全部建构都是基于观念活动的这种不可限定性，在实践哲学中兴许就是基于另一方面实在活动的原初未被限定性，也就是有待被限定。</p><p>63</p><p>揭露自我意识的绝对活动中的无限多的行动，是一个无限的课题，而我们只有有限的列举一些重要的环节，如感觉。哲学就是自我意识进展的一部历史，各时期构成了那唯一的绝对综合，而这历史的根源就是被假定为不可限定的观念活动。理论哲学的课题就是说明限制的观念性，这等同于说明原初不可限定的观念活动何以能受到限定。此处部分地揭示了答案，即这种根据就来自于限制的观念性。</p><blockquote><p>但在我看来，只是把它分为了两个子课题，因为这种等价性反而不是显然的。</p></blockquote><p><strong>第一个时期——从原初感受到生产性直观</strong></p><p>A. 课题：说明自我怎样得以直观它自身为受到限定的？</p><p>解决</p><p>1.当自我意识的两个相互对立的活动在第三个活动中彼此渗透，就产生出前两个活动的共同者。</p><blockquote><p>……渗透是先刚的说法，老译本说“把自身贯穿在第三种活动中”。</p></blockquote><p>这里说的是作为产物的共同者，还没有涉及到第三种活动本身。这共同者作为无限活动的产物，自身是有限者，这个产物将运动中的斗争固定下来，将双方都保存在自身以内因而合而为一。而对立的统一，不能看作对双方的消灭，而是一种平衡的持续存在。</p><p>中间有句话略显突兀，“但共同者必定是某种实在的东西，因为对立双方在综合之前仅仅是观念的，应当通过综合而转变为实在的”。原初活动不是实在的吗？怎么在这里又变成了观念的？这是因为整个辩证法运动的过程还没走完，我们说实在它分裂出了一个观念来直观自身，对立就此产生。但如果不回到自身，这种实在与观念就都是未完成的，而有待最终合题的实在的综合统一。这样看来先验唯心论也是相当唯物的。</p><p>64</p><p>括号内补充说明，这种产物就是单纯的质料，因而是实在而无活动的。实在的东西无非形式与质料，无形式则质料不可单独存在，因而它是无运动的。因此物质的创造就其质料而言有了基础。质料是对立活动的平衡。假如共同的东西能持续存在下去，那它就是自我自身的一个建构了，而且是同时作为主体和客体，因为原初自我要变为自身为客体，只有通过双重化它自身，成为一个分裂的主客对立，并再度扬弃这一对立，才能再次在这一建构中被直观。此时它同时作为主体和客体（完整的自我）而成为自己的客体。</p>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（三）</title>
      <link href="/20250306-idealism/"/>
      <url>/20250306-idealism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从这次开始，同时参考先刚的译本。</p></blockquote><p>59</p><p>第七个小节说明了这种推演的形式，即为正反合的辩证法的形式。绝对实在性和绝对否定，二者本身都并没有什么实在性可言，这种对立仅仅是观念的对立。然而自我有其实在性，这种实在性不是从什么别的地方获得，而正是在变自己为对象的过程中，扬弃了一部分实在性，不再是绝对的实在性，而是在一系列限制之下能够把握的实在性。绝对的否定也将因此而分有一部分实在性。这样一种分享实在性的活动，只有自我摆动于二者之间才有可能；而自我摆动于二者之间，仅仅在于对立双方也都是我自我的活动。因此谢林认为，正反合的运动过程是我们可以从精神的机制中抽象出来的。</p><p>II 绝对综合的各个中间环节的演绎</p><p>如何理解演绎？演绎在数学中就是从起始的条件，一步步推证下去。不过，演绎这词原来是用于戏剧上的，它表示对一系列发生过程的展示。当然哲学本身是不证自明的，它不能落到那种形式主义的窠臼中。谢林为这种演绎呢，也给出了提要，首先就是从演绎所需的前已说明的事实开始，这是一种准备工作。</p><p><strong>自我意识是一个绝对的活动，通过这个活动，一切东西对于自我而言都已被设定。</strong></p><p>这里讨论的自我是原始的自我，那个有着无限倾向的活动。注意到此处拆掉了前一节建立起来的脚手架，这是为了之后在演绎中重新建立起来。之前是为了演绎出这一绝对综合，现在要更进一步的演绎出综合的中间环节了。</p><p>60</p><p>这个原初自我是产生出一切的条件，是未被限制的，因而本身没有达到意识。</p><blockquote><p>疑惑：达到意识究竟是意味着一种进入还是一种成为？</p></blockquote><p>它既不可以叫随意的，也不可以叫非随意的，或者说是任意的和不由自主的。因为无论是任意的还是不由自主的，都是一种规定。它既可以是任意的，也可以是不由自主的，有这样两种潜能，现在还不知道。但这种一切行动的开端，因为没有什么别的依据，它必然是自由的：自由就是由于自身，一切活动都产生于自身。</p><p>到这里至少可以看出，<strong>自由不是任意，也不是不由自主，它是一种统摄两方的更高的概念</strong>。而绝对自由又是绝对必然性，因为我们无法设想，如果自我本质以内没有一种不可置疑的必然性，那么一切行动又是如何可能发生的？简单来说，一切的发生都是一种暴力，因为偶然的发生它不具有充分的力量，就是不讲道理。正如我诞生于世上，感受着一切存在，而不是没有我，也没有存在。</p><p>而这个原始活动的自我，其真实性在于哪里？哲学家凭什么设想有这个东西？这里说是经过推理而得知的，因为我时时感受到这一活动的产物，时刻感受到自身思维的活动，因而这原初活动的自我是唯一的一个原因。</p><p>同时又推论出自我意识的客观世界，不过是客观的东西原初就融入自我意识的综合，因而我只待自我意识的展开，以便再认识到这些客观的东西。</p><p>一个相对形象的解释就是，这个世界从一开始就已经是完成了的，一切的时间性、空间性以及其他杂多都像一个没有点开的程序一样。但是世界还为自己制作了一个解释器，也就是意识。通过意识的展开，世界回忆着它自己。</p><p>61</p><p>进一步，既然这种原始活动存在，那么其内容又如何可知？哲学家的方法是对这个活动进行自由模仿，我的理解是一种再现、重演的过程，但不是原地进行的过程，因为原初活动是无法被限制的。再简而言之，就是启动调试器进行单步调试。此处又产生了一个新问题，原初活动是超于时间的限制的，而模仿却是建立于相继活动被打断的时间性基础之上的，我们凭什么说这种模仿是一致的呢？</p><p>回答是简明的，在时间彼岸的原初活动的自我和在时间序列之中的自我，归根结底是统一的。</p><p>将这种思考方式一般化，一切哲学的构造，都仅仅在于对原始自我的构造的模仿。哲学就在于将这种模仿做得十全十美。</p>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有限无限：辩证法的一个粗浅的例子</title>
      <link href="/20250306-dialetic/"/>
      <url>/20250306-dialetic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今日再看，已然有错。不要参考。  2025.3.10</p></blockquote><p>仅仅作为把握辩证法的精神的第一步。</p><p>当我们在设想“无限”这一概念的时候，我们往往是在设想“非有限”，也就是从客观世界当中抽象出一个有限的概念，然后对其进行否定。就是说，一个无限的某物，它不过是一切有限之物以外的某物。</p><p>然而这种对立的发展是不彻底的。这种对立只是将有限与无限作为地位平等的两部分作为互相的反对。而辩证法是对立统一的，我们还要从这种对立当中找到贯穿两方面的一个中介，使得这种对立能够被扬弃。</p><p>无限，也就是无限制的，无条件的，应当是二者之中原初的。有限则是在无限的基础上，施加了规定性而产生的。无限与有限本是对立的，不可结合于同一事物上的。然而这样的结合却在我们自身之内存在着（自我意识既是无限的也是有限的活动）。因而需要一个第三者中介来进行同一化，这个第三者不是别的，而就是一种无限的活动。因为有限的活动只能提供有限的同一性，无法一以贯之地维持自我意识的同一的存在。</p><p>因而无限是有限与无限的合题。这表明，无限不是与有限平等的对立的。无限除了无限以外，还统摄着有限。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>忠实于自己的文字</title>
      <link href="/20250306-writing/"/>
      <url>/20250306-writing/</url>
      
        <content type="html"><![CDATA[<p>晚间群友在讨论关于博客的事。正巧最近也在自觉地进行转向，因而有很多可说的感想。</p><p>博客首先并不是博客。就其内容而言，只是随手产出的一组文字，只不过有这样一种公开的载体。随着这种载体而来的则是隐私的问题；或者说信息并没有什么绝对保密的载体。就算我把自己关在家里用纸笔写了一些东西，也难保家人走来走去时候看到一两个字，虽然他们本来也对这些东西并不感兴趣就是了。</p><p>写了博客之后，我的胆子反倒变大了。因为我发现这些东西就算在这里摊开了，除了自己以外也没什么人会读。自己写的东西多少还是有一些认知的，特别是读到一两年前写的东西的时候，多少会有种“这是傻瓜吗？”的感觉。审视自己的这些文字，会发现它们达到了可读性、趣味性、实用性的三无状态，试问这些文字到底能吸引什么样的人来读。</p><p>粗略地考察了自己写作时的一些惯性，或者我认为或多或少是一些人的共性，在此略作讨论。</p><p><strong>自己认为值得写的事情往往写得好；自己认为不值得写或者羞于提起的事情往往写得差。</strong>这是一条很经验的规律，然而原因也是值得推敲的。写作本身就是一种自我表达的事，当然有一种报喜不报忧的倾向。如果说这种倾向有什么问题的话，那就是对于写作的另一个目的——自我回顾，有一种阻碍的作用。就算自己知道有些文字不会发表，不会受到他人的审视，只要意识到这其中的内容是很糟糕的，就会不由自主地调整用词、春秋笔法。如果有意识地修正这一点，那看起来就更加糟糕了：整个写作过程就会犹犹豫豫，难以落笔。</p><p>在我写到这里的时候，我突然又意识到，这样一种在犹豫中写作的过程实际上是对“自我回顾”功能的一个更好实现。这种判断并不是从写作活动的产物，即文本而来的；而是就写作的过程，亦即写作活动本身而言的。如果能够进入一种自动化的写作状态，并捕捉到其中的犹豫，写作中的人就可以<strong>凭借对于写作过程的审视，发现自身的态度在某处存在的矛盾状态</strong>。这也许就是保持对文字忠实的全部意义。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（二）</title>
      <link href="/20250305-idealism/"/>
      <url>/20250305-idealism/</url>
      
        <content type="html"><![CDATA[<p>55</p><p>当我们确定了自我之内的两种活动后，它们每一个都就不能单独地被称为自我了，因为</p><p>56</p><p>a) 做限制的活动无法变成客体，是纯粹的主体的活动，</p><p>b) 被限制的活动是变为对象的、单纯客观的活动，</p><p>而自我意识是主客统一的，既是主体又是客体，自我自为地达到自我意识，自我“for itself”地成为&#x2F;产生了自我意识，这是两个环节单独作用所不能完成的，必须经由一个中介性的环节，一个否定，一个扬弃，扬弃就是抛弃并同时保存下来的环节，达到一种合题，即是贯穿了两个阶段的对立统一，成为了第三种活动。</p><p>第三种活动被如此描述，它是摆动于被限制活动和作限制活动之间的，无非是自我意识本身的自我：因为自我的创造活动与自我的存在是一个东西，因此自我本身是一种复合的东西，是一种综合的东西。</p><p>说得更明白些，自我就是在两种活动相互斗争发展的结果。</p><p>接下来对这种斗争进行规定。</p><p>a) 斗争是对立活动之间的斗争，对立也是由自我起源的。到这里辩证法的三个阶段就彻底浮出水面了，当然这要看那个统一的环节是否彻底贯穿了所有环节，如果不彻底一些，就还是形而上学的。</p><p>回到最初我们认为自我是无限活动，它具有创造无限物的倾向，这一方向是离心的，然而，如果没有一种向内回归于自我这个中心的活动，则方向是不可判别的。就其本性来说无限活动的，是自我之内的客观的东西（它在后一种活动内被限制）。后一种回归于自我的活动则无非是在那种无限性中直观自身的意向。如此自我的内在的东西与外在的东西分离开，产生了一种对抗，它只能归于自我意识的必然性，也即自我意识的产生原因是自明的，对立的产生原因也是自明的。</p><p>57</p><p>自我确然到它自身，是将这样的对抗确定而保存下来（这里有一点再生的想象力的感觉）。为什么能够保存下来？对立总是彼此消灭，从而最终无法持续下去，回到静止。然而自我是一种保持同一性的活动，只有持续不断的矛盾，才能使其进行活动。要么矛盾被消灭，不然就只有通过真正的努力保存或思考矛盾，才可以持续下去。这种努力，就是贯穿了矛盾双方的统一的第三者，诞生在了矛盾当中。</p><p>只要是我未被扬弃，则原初的矛盾不被扬弃。矛盾的存在有一种必然性，使得其内部产生维持自身存在的活动，即给这种矛盾提供同一性的活动。</p><p>推论。在自我意识中表现出来的同一性并非原初就有的，而是一种被创造出来的，经过中介的同一性。斗争是原初的，同一是由此产生的。</p><p>于是，最初意识到的最高的，主体与客体的同一性并不是自在存在的，自在在这里是in itself，一种存在在于它自身。此处同一性的存在并不在于它的自身，而在于第三者的中介，这中介活动是摆动于对立对立方向之间的一种活动。</p><blockquote><p>所以再看，道生一，一生二，二生三，三生万物。是否有新感受</p></blockquote><p>58</p><p>b) 自我意识无规定性，因而自我意识之前的活动是无限的，斗争是无限的，因而提供同一性的中介活动也是无限的，是无限多的行动系列。这里隐约感觉到旧矛盾消亡与新矛盾不断产生的无限活动。</p><p>接下来解释这无限的行动聚合在一个绝对的行动之中何以可能。对立的主体与客体有无限的消除（扬弃）对方的倾向，却不能这样做，因为自身也是由这对立所确定的<del>什么相爱相杀</del>，二者必须合为一体，却又不能共存。因此斗争不(仅)是两个因素的斗争，而且是两个方面的斗争：一方面，两个无限的对立的东西不可能合为一体；另一方面，为了维持自我意识的同一性，又必须合为一体。绝对的对立，迫使自我在一个无限序列的行动中调解对立，带来的是一种绝对的，进行到底的，必然的，不由自主的合为一体的活动。</p>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验唯心论体系句读（一）</title>
      <link href="/20250304-idealism/"/>
      <url>/20250304-idealism/</url>
      
        <content type="html"><![CDATA[<blockquote><p>谢林的先验唯心论体系的确构建了一个精巧的知识学框架。前两章如醍醐灌顶，然而从第三章开始，便变得相当繁琐难读了，并且没有什么补充材料可以使我理解此处的结构，主要是贯穿于整个意识活动中的辩证法的运用（在这里是一种套用）。因此决定做一次句读的尝试，实时梳理思路，力图以此冲破第一个环节的演绎（第53到116页）。并且我这就滚去读精神现象学。</p></blockquote><blockquote><p>采用版本为商务印书馆的梁志学&amp;石泉译本</p></blockquote><p>53</p><p>这一章的标题是：以先验唯心论为原则的理论哲学体系。这意味着必然是从先验唯心论出发——或者说是唯心实在论。现在我们要创建的是理论知识体系，它与实践知识体系是先验唯心论中互为前提的两部分，它是考察观念的活动的哲学，可以理解为一种“主体发生学”。</p><p>首先来看提要。自我意识是唯一的绝对活动，它是无条件成为了我们理论的公设而存在的，并且自我意识绝对地不受到任何限制或规定。其他规定性都是由此而派生的，其他活动也是由此活动而确立的。因而第一要务是阐释它。阐释它，即剖析它，说明自我意识从头到尾不过是怎么一回事，可以分成几阶段，最后再统一起来。完成了之后，将是“绝对综合的中介环节”。绝对综合的，就代表一种无条件的将主观的与客观的综合起来的，这就是说自我意识被分成各环节</p><p>下面是一个总的章程。</p><p>自我意识由一观念的与一现实的活动组成，两边是相向而行的，因而将什么东西确立为观念的与确立为现实的，这两件事有一种彻底的同一性。也就是说，完全就是一回事，只不过是同一运动中自己分裂出的两个阶段。接下来具体阐释这是如何可能的。</p><p>54 </p><p>我们从主客统一体的自我概念出发，“对作哲学思考的人来说”，是一种特殊的，这种特殊性在于哲学的思考要考察的是思维本身。这个思维对于我而言是客体化了的，于是某种东西被“那种活动”，即自我意识的绝对活动设定在了客体自我也即实在活动中。从这个角度看，主体的自我中还并没有它，就是说实在活动并未被观念活动所限定。在此刻，两活动还仍未会合。我们的目的就是探讨这种会合的活动。以上，即为整个讨论的出发状态。整章则为构造一个合理的会合过程，或是运动，使其符合辩证法的正反合的流程。因而，谢林的这种阐释依然是一种形式主义的。</p><p>讨论分为两节，一是推演自我意识的绝对综合，二是将其环节化</p><p>I. 自我意识活动内所包含的绝对综合的演绎</p><p>从“限制必须既是观念的同时，又是现实的”出发。“既然主观与客观的原始结合，只有在绝对活动内才可被讨论”。这是为什么？绝对活动，就是有规定-无规定-变化，一种自身分裂并在最终扬弃了这种对立的过程。只有这样的活动才可能同时容纳二者。这样一种活动只有自我意识，因而限制首先由自我意识确定，至于之后也可以从其他地方产生出来，但自我肯定是第一个源头。因为，</p><p>a) 自我意识的原始活动，既是观念的，又是现实的。</p><p>55</p><p>b) 限制仅仅是由自我意识作出的。</p><p>自我有两种活动，一种是被限制的，限制不依赖于此活动; 一种是做限制的，它则是本身不可被限制的。</p><p>在以上两部分，对于整个自我的彼岸或者外侧，自我作为实在活动，只具有单纯的客观性，它是没有真正的自我的，我只是对象。有了自我的观念活动，才有主观性。</p><p>作限制的观念活动与被限制的客观性的实在活动是对立着的，因而前者自身不能成为客体。</p><p>达到意识和受到限制是同一回事。“达到意识”，即为作表象的、观念活动的意识所感知、识别到。而纯粹的存在，即纯有，无限的有，它是不可思议的。因为这一个“有”还没有说它是怎么样的有，没有任何规定的有。纯有就等于纯无。只有有限的有，具体的有，有规定性的有，才能够被意识把握到。好比一块木头，在使用刻刀对这块木头作“规定”之前，它不能作为一件雕刻被把握到。</p><p>我虽然有一个作限制的观念活动，但它自身不受限制。因而我限制不了它，这种“活动”无法到达我的意识。所以我“决不能看到确立这种状态（被限制状态）的界限的（观念）活动”。</p>]]></content>
      
      
      <categories>
          
          <category> 谢林 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>康德的问题（一）</title>
      <link href="/20250302-kant/"/>
      <url>/20250302-kant/</url>
      
        <content type="html"><![CDATA[<p>范畴就是先天知性概念。我们所有的事物就都可以归纳到范畴里面。比如面前的桌子是“实体性”，抛硬币的结果具有“偶然性”。</p><p>康德将先验图型作为范畴运用到经验性直观的一种“判断模式”。这种图型类似于直观的一种“样态”。对于因果性范畴的运用可以产生“A导致了B”的假言的判断。那么什么“样态”的直观能够适合于因果性的范畴来运用呢？康德说这个图型长成这样，它描绘了直观中那些杂多之间的相继状态，而这相继状态还要服从某种规则。我们把整个时空看做连续的空间平面向前发展的一个“四维时空”，判断力的图型法就可以被描绘为，我在这个时空里按照范畴的先天要求进行框定。就如同交通摄像头判断闯红灯：只要拍到三张照片，一张是红灯时车辆越过停止线，一张是红灯时车辆驶过停止线，还有一张车辆继续行驶。那么这车辆的行为就符合了“闯红灯”的时空图型。我们就可以把闯红灯的概念联结到这辆车上，然后就可以开罚单了。</p><p>不过闯红灯毕竟是一个经验性的概念，这样的图型也是经验性的。对于一般的判断力而言，我们要把直观和作为先天知性概念的范畴联结起来，这是一种先验的运用。作为体现了范畴的先天的规定性的图型也必须是先验的。这种先验就强调了客观有效性——它必须是放之四海而皆准的。如同因果性的图型，它必须保证原因和结果之间的联系是一种客观的、经得起考验的、一贯的关系，而并非一种偶然的关系：这一次A引发了B，而下一次A却不能引发了。那么它就失效了。</p><p>问题就出在这种图型它并不能很好地规定这种客观的有效性。先验图型是作为一种先天知识而直接地在我们之中的，在人类的认识能力之中的。然而人类对于因果关系的认识还是常常有例外：譬如这次刮风之后下雨了，得到了刮风会导致下雨的结论；下次又没有下雨，于是再对气象作考察。从中即诞生了气象学，研究各种复杂条件下的天气变化。我们逐渐掌握了越来越复杂的因果关系，但也不断地认识到额外的影响因素，最后发展到混沌系统。我们认识到的因果关系经常只是相对有效的。</p><p>对因果关系的认识发生了错误。而先验图形又是客观有效的。因而只剩下一种可能性，即错误的判断是由于对这种图型法的错误运用，或者是相对正确的运用。然而认识总是要上升的，这表明虽然人的知性能力客观有效，但是人对它的运用却至多只能够“相对正确”。如果“先验图形”所表达的判断力追着认识活动跑的话，它就不再是一种先天知识了，因而这种先验的运用就变成了非法的。</p><p>因而康德在这里并没有能够完全肃清休谟的怀疑论的那种疑虑，而只是做了两件事：</p><ul><li>说明了人对因果关系的认识是可能而非不可能的</li><li>说明了知性就其本身而言在把握因果关系上是客观有效的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我听见斧头</title>
      <link href="/20250302-celan/"/>
      <url>/20250302-celan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我听见斧头已经开花，<br>我听见那地方的名字说不出来，</p><p>我听见那块望着他的面包<br>治好了那个被绞死的人，<br>那块他妻子为他烤的面包，</p><p>我听见他们把生命称作<br>我们唯一的庇护所。</p></blockquote><p>我以前从不读外文诗歌——翻译让音乐性消失，文化差异让理解消失。如果不是外国语学院，或者文学院的学生，应该还是很难主动接触这种东西。不过策兰是目前为止的唯一一个例外，只是因为偶然刷到朗读诗的视频，冲动入手了同一本选集。拿到手之后，基本也读不明白，但是想到听诗时候的感觉，产生了“不如自己也来出声地念一念”的想法。</p><p>这些诗翻译得并不拗口，只要按照原有的断句去朗读就很通顺。我目前还没有什么办法去解读诗的内容，不过这种体验也算是独特：大脑空空，慢慢地三五个字，或十几个字从嘴里一蹦，然后喘一口气，再念下一句。由于对感情完全吃不准，所以从头平静到尾，或是整体下行。从来没有什么昂扬的，也没法夹杂着轻快的感觉。每首诗让人一念完只想要闭嘴，以至于一时不能再开启下一首。</p><p>引用的这首，我是借助注释来理解的。译者对于注释谨慎到了吝啬的程度，一方面觉得苦恼，一方面感谢译者对于读者理解自由的权利的保护，也许自由发挥、不求甚解才是对的。回到这一首，面包的治愈在于它恢复了一种微小的常态，生命是这些微小的常态连续相加而所以可能。这让我想到小说作品里常见的死亡Flag——在完成一件大事之前，约定好完成之后要继续生活中的一件小事。但角色往往就这样带着遗憾牺牲，而知道有这种约定的人，也许会执着地借着逝去人物的一个象征来完成约定的仪式：在墓前聊天、喝酒；整理遗物；为不在场的人物准备其应有的一份物品。诸如此类。可以被治愈的当然已经不是逝者，而是活着的人。</p><p>打算就这样自由散漫地读一遍；然后束之高阁，有缘再见。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>胫骨髓内钉内固定术后8周负重策略考察</title>
      <link href="/20250226-strategy/"/>
      <url>/20250226-strategy/</url>
      
        <content type="html"><![CDATA[<p>我在小红书上看到了很多骨折的朋友，胫腓骨折不在少数，他们都分享了自己的恢复过程。但是我敢说决没有人系统性地梳理了自己各时期的医学影像、主观感受和恢复策略的组合。以至于很多问题在后来人的心中仍然是未解之谜。因而只能求助于文献。</p><p>个人背景：胫骨髓内钉固定后第9周复查，医学影像表现为骨痂生长不明显，断端对位可。医嘱患侧负重10%以应力刺激骨痂生长。个人采取的负重策略较为激进。在第10周时，尝试单侧40~50%负重。在第12周时，尝试患侧 (50%, 90%) 负重并且尝试使用单拐。骨折端未有痛感。</p><p>需要注意的是，激进的负重策略需要相对严格良好的手术效果支撑，即术前断端对位好，内固定稳定。同时在实践的策略上也是循序渐进的。并不是一下子踩到多重，而是要在严格安全的环境稳定地进行定量的加重，如遇到痛感及时停止。毕竟这种策略的目标仍然是恢复功能、感知恢复情况、促进骨骼生长而并非一蹴而就。</p><p>以下是部分文献的观点。</p><p>[1] 胫骨骨折髓内钉内固定患者术后早期与晚期负重的对比研究. 卢红信 , 陈笑天 , 叶龙飞 , 王晓盼 , 吴敏 , 代秀松 , 肖玉周. 中华解剖与临床杂志,2022, 27 (08): 563-567.</p><blockquote><p><strong>目的</strong></p><p>对比分析胫骨骨折患者髓内钉内固定术后早期负重与晚期负重的临床疗效。</p><p><strong>方法</strong></p><p>回顾性研究。纳入2017年1月—2020年12月蚌埠医学院第一附属医院骨科胫骨骨折患者107例，其中男75例、女32例，年龄18～77（39.9±10.9）岁，均接受髓内钉内固定术治疗。按照术后患肢负重开始时间的不同将患者分为2组：术后4周内患肢开始负重者25例为早期负重组，术后4周内患肢完全不负重者82例为晚期负重组。对比2组患者基线资料、手术时间、置入髓内钉的直径、术后植入材料的失败率、术后3个月膝关节功能Lysholm评分、术后6个月和1年的骨折愈合情况。</p><p><strong>结果</strong></p><p>2组患者的年龄、体质量指数（BMI）、胫骨骨折部位、骨折AO分型及Gustilo分型、美国麻醉医师协会（ASA）分级、损伤机制、是否开放性骨折、有无腓骨骨折、有无外固定架等一般资料比较，以及手术时间和髓内钉直径比较，差异均无统计学意义（<em>P</em>值均&gt;0.05）。早期负重组与晚期负重组患者术后植入材料失败率分别为0和1.21％（1&#x2F;82），术后6个月延迟愈合率分别为16.0％（4&#x2F;25）和29.3％（24&#x2F;82），术后1年骨不连分别为4.0％（1&#x2F;25）和11.0％（9&#x2F;82），差异均无统计学意义（<em>P</em>值均*&gt;<em>0.05）。早期负重组患者术后3个月膝关节功能评分（88.0±2.4）分，高于晚期负重组的（74.5±4.6）分，差异有统计学意义（</em>t*&#x3D;19.32，<em>P</em>&lt;0.001）。</p><p><strong>结论</strong></p><p>与晚期负重相比，胫骨骨折患者髓内钉内固定术后早期（≤4周）负重能够提升患肢膝关节功能，临床疗效较好，建议临床推广。</p></blockquote><p>[2] Beebe, M. J., Morwood, M., Serrano, R., Quade, J. H., Auston, D. A., Watson, D. T., Sanders, R. W., &amp; Mir, H. R. (2019). Extreme Nailing: Is It Safe to Allow Immediate Weightbearing After Intramedullary Nail Fixation of Extra-articular Distal Tibial Fractures (OTA&#x2F;AO 43-A)?. <em>Journal of orthopaedic trauma</em>, <em>33</em>(8), 392–396. <a href="https://doi.org/10.1097/BOT.0000000000001484">https://doi.org/10.1097/BOT.0000000000001484</a></p><blockquote><p>目的：探讨胫骨远端关节外骨折（OTA&#x2F;AO 43-A）髓内固定（IM）后即刻负重是否会导致骨折愈合前对线的改变。<br>设计：回顾性研究。<br>单位：创伤中心一级。<br>干预：胫骨远端骨折的IM钉治疗。<br>患者&#x2F;参与者：53例54处骨折，均能承受术后耐受的体重。18例为OTA&#x2F;AO 43-A1、20例为OTA&#x2F;ao43-A2、16例为OTA&#x2F;ao43-A3，20例为开放性骨折。<br>主要观察指标：骨折对线改变或位置丢失。<br>结果：术后平均外翻角度为0.52±1.49度，伸直角度为0.48±3.14度。最终对中优14例，可接受28例，差12例；2例骨折由可接受的初始对中转为差的最终对中；2例骨折由优对中转为可接受的对中。随着时间的推移，7处骨折的对位有了改善。2例骨折需要游离皮瓣覆盖，4例因骨丢失需要分期移植。10例骨折意外返回手术室，5例感染性骨不连需换植体，3例感染性骨不连需清创，2例无菌骨不连）。没有一个病人因植入失败而进行了翻修。<br>结论：胫骨远端关节外骨折（OTA&#x2F;AO 43-A）经IM内固定后即刻负重，可使骨折的对线发生微小改变，对大多数患者来说是安全的。并发症与以前非负重队列的报道一致。</p></blockquote><p>部分医生观点</p><p>丁香园-<a href="https://www.dxy.cn/bbs/newweb/pc/post/50017467">下肢髓内钉术后多久负重？</a></p><blockquote><p><a href="https://www.dxy.cn/bbs/newweb/pc/profile/8891951">七叶皂</a>: 髓内钉做的少，但我个人理解只要软组织两三周愈合后就可以开始部分负重锻炼了。</p></blockquote><blockquote><p><a href="https://www.dxy.cn/bbs/newweb/pc/profile/11361240">zzf1056(骨科版版主)</a>: 髓内钉确实是可以负重相对早一点，我做的基本是8周全负重，横断型可以更早一点，书上貌似写的是2-4周从30kg开始，具体我再翻翻书</p></blockquote><blockquote><p><a href="https://www.dxy.cn/bbs/newweb/pc/profile/232095">shinedge</a>: 我也有时碰到这样的，术中偷懒，术后提心吊胆</p></blockquote><p>以下是个人观点（非医学专业个人，不构成医疗建议，请咨询正规的医院或康复机构）</p><p>对于很多已达到临床愈合标准的患者，在进行脱拐负重锻炼时可能仍然疼痛、肿胀，但医生仍然建议锻炼行走；反之对于未愈合的患者也可能有良好的主观感受。理论上来讲，越是恢复，感受到的疼痛是越少的。很多时候骨科的大夫给予的建议是较为保守的；而运动康复科的建议是激进的。</p><p>骨痂生长状况并非良好情况下的恢复锻炼需要充分照顾到体感，发力尽量以平稳渐进为主，并辅以正常走路体态的模拟。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>言语的方舟-节选</title>
      <link href="/20250221-listening/"/>
      <url>/20250221-listening/</url>
      
        <content type="html"><![CDATA[<blockquote><p>邀您共同参与南京大学现象学研究所读书会（关注微信公众号）</p></blockquote><blockquote><p>Chretien 1998 <em>The Ark of Speech</em></p></blockquote><p>因为实际上，黑格尔写道：“言语仅仅通过事物的意义来说话，它给予事物一个名字，并将这个名字表达为对象的存在。这是什么？我们回答说：这是头狮子，是一头驴，等等；它就是，换句话说，它根本不是具有黄色、四肢等等的东西，一个独立的、特有的存在，而是一个名字，一个我声音的音响，完全不同于直观中的事物，这才是它的真实存在（……）。因此，通过名字，作为存在的对象诞生于我之中。这就是精神行使的第一种创造性能力。亚当为所有事物命名：这就是至高无上的权利，是对整个自然的第一次占有，或者说是从精神中创造这一自然的行为（……）。人对事物说话，就像是对属于自身的东西说话一样。”黑格尔描述了言语的否定性维度，在这一维度中，精神表现出一种比单纯的接受性更高的行动。如今我们有了，如果用克劳德尔的话来说，一些永不凋谢的花朵——言语之花，但是，为了这一切的实现，凋谢的花朵必须完全凋谢，而且这凋谢的花多带给我们的困扰也必须被超克。</p><p>……</p><p>哪里存在倾听之完美，假设有这种完美的话？如果完美的倾听是一种如此透彻的、如此充满理解的倾听，以至于它在某种程度上用清晰的预见包裹住我的言语，以至于它不待我细说就能完全听懂我——无论是我说了的还是没说的——，以至于它总能预见到我语句的运动而从不因此感到惊讶，那么这种倾听反而会趋向于消解我的言语，甚至消解自身之为倾听。这种倾听，远非一种完满的实现，反而会导致毁灭与暴力。在某些意义上，完美的倾听会反转为全然的暴力与控制。我们不想向那些事先已对一切了如指掌的人言说，我们不想要他人代我们完成未说完的句子，我们言说并不是为了放弃自己的存在之位置。诠释亦有其暴力，甚至，有可能，永远都是某种暴力在奠基和引发阐释。如果倾听理解得太多（而人们或许总是理解得太多），它便会变成那穿透我的——而非在言语之炉火旁迎接我的——观看、剖析、洞察。在许多文化传统中，人们都把这种一眼便看穿他人，甚至在别人口未开便洞穿其内心的能力当作天赋归于哲学家或通灵者，但我们要问的是，这所谓天赋是否真的是一种天赋？如果它从他人那里剥夺了他去言说这一责任，换言之，如果它剥夺了他人作为人的不可让渡的重担，那么，它所给予的便还不如夺走的多。</p><p>……</p><p>与他人一同用心去倾听那未被听闻者，这完全不意味着我是在像一位心理学家或解释学家那样捕捉他言语中的未被说出者，也不意味着我是在占据一个突出的、主导性的高位。这里涉及到的是完全不同的东西。倾听他人所说出的未被听闻者，乃是一种耐心而艰难的探索，这条通向事件（事件要求着言语）之独特性的探索之路，有时会迷失方向，有时需重新开始，且充满着关注行为中的即兴发挥和爱抚之举。只有从这里开始，从这种始终处于开端状态的、由须被说出之事奠定其基调的兄弟情谊出发，他人的言语才会变得可被听见，亦即受到尊重。这些言语的口吃、笨拙、不相即、矛盾不再构成障碍，它们因而也不再是主权性言语眼中的缺失或不足；它们本身就是有意义的。但这种意义，与我以所谓专家的方式在我自身中解读出的症状之意义毫无共同处。它见证着言语的对抗性维度，它表明：任何的言语行为都是一场与沉默的肉搏、与那不能被说出却又将会被说出者的肉搏。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>战地中盘实况报道</title>
      <link href="/20250216-mujica/"/>
      <url>/20250216-mujica/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：东风谷氨酸</p><p>来源：bgm.tv</p></blockquote><blockquote><p>Tilnel 评论：个人对mujica的剧情已经没有正面的期待，目前只是不得不接着赤完整坨。因而除了文末期待剧情向上以外，其余观点基本同意。</p><img src="image-20250216203907465.png" alt="发现ep7-13剧透预言成功#7之后的反应" style="zoom:33%;"></blockquote><p>先说立场：本人从第一集开始集集准时看并关注一些场外内容，对部分情况的概述可能有失偏颇</p><p>ep1-ep3</p><p>观众期待保持高位，情节没有明显问题，热度不减当年</p><p>各种假药大行其道，而且都很有讨论空间，因为当前的剧情确实还保留在一种“可以严肃讨论”的框架之内</p><p>部分质疑设定合理性的声音开始出现</p><p>ep4</p><p>转折点</p><p>目前来看，这集后半段的争议主要集中在“剧情速度过快”和“角色ooc为了炸团而炸团”上，但是整体声音没有转向，因为有大莫老师吃瘪和mujica解散的乐子，观众的注意力被吸引了。</p><p>我个人觉得假药势头最不对的一集，核心原因也许就是剧情问题，大家依然愿意相信剧本水平并且尝试自圆其说，于是有了很多在我看来并不合理但是大家都很热衷的说法，但是大家忽略了另一种可能：这剧本不行</p><p>ep5</p><p>好的，慢下来了，这是很多观众的体验。虽然此时出现了很多失望的声音，但是整体还没有完全崩掉。</p><p>此时，我认为mujica现状的根源来了：大篇幅引入mygo角色</p><p>事实上，整体的剧情走向，如果把现实主义先放一放，还是可以接受的嘛。但是把mygo的角色放进来，很多时候剧情就不能由着编剧了。前几集讨论区最大的节奏就是sakiko的行为到底如何评价。当你把几个和sakiko同样人气的角色引入之后，如果写的不好甚至一般，那争议的指数级扩大是可以预见的。</p><p>这是一步险棋，从舆论环境看险棋中的险棋，但是还有走好的可能。</p><p>当然了，编剧也许根本不关心cn的情况。</p><p>ep6-ep7</p><p>至暗时刻（目前）。</p><p>第五集是缓冲，我相信很多人和我想法一样，但是之后的内容和前四集疑似完全脱钩了，这是我主观上感受到的第一个严重不适。</p><p>你的卖点不是黑深残吗？然后就在缓冲之后几乎抛开不谈了？</p><p>其次，对ano的处理真的是灾难性的。我说的灾难性不是说剧情方面。不是爱厨的我的不适感并没有其他观众那么激烈，但是要先看清楚一件事情：</p><p>mygo是同时卖剧情和角色，只是剧情很好让人以为角色不是重中之重，但是邦邦的本质是卖角色和团体，而非剧情。</p><p>但官方为了炒作把mujica的剧情称为最大的爆点，然后没有满足观众需求；这个时候你处理角色就要谨慎了！因为这是企划最后的救命稻草了！</p><p>结果编剧把mygo人气最高的角色的粉丝惹毛了。</p><p>再看sakiko已然是…</p><p>你又没有剧情的硬实力，又没能好好卖角色，就剩下动画本身，结果你的live还…</p><p>回顾和展望</p><p>mujica会遭受重大挫折，tomori没递出去的笔记本会有后续，taki的深入塑造，飞鸟山之战的回旋镖一定会飞回来…</p><p>这些也许都是观众曾经期待过的，这些坑好像都补上了？但是效果呢？</p><p>mujica的失败，舆论胜过剧情。如果你是一个一周只能看完一集而且不动脑子的普通观众，这番也许是可以接受的。但是mujica面对的是什么人，是有史以来最混沌的观众群体之一。你可以把crychic的救赎当成暗线，让mygo来上临门一脚，但是从第五集编剧疑似将mygo视作剧情支柱之后，舆论管理就是必须要考虑的因素了。尤其是官方下场炒作，把热度带起来之后，这就是重中之重了。</p><p>很多人觉得“这剧情没问题啊”，因为他们对整体的路径规划就是我上面说的这些节点，但是怎么把它们串起来，就有屠宰和手术的区别了。</p><p>这玩意早就做完了。我上面的想法都无形中把它视为实时制作放送。</p><p>后续看看mujica要如何重组，我希望还有缓和观众矛盾的可能，我希望剧情还能有所突破（向上）。</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不要幻想绝对真理</title>
      <link href="/20250211-verity/"/>
      <url>/20250211-verity/</url>
      
        <content type="html"><![CDATA[<p>最高信仰；无条件者；绝对真理。Anyway，只是同一件事情的不同说法，对于此类概念的追求刻在了人类基因里。人已经习惯了凡事问个为什么，眼前的事情全都探明了，A的条件是B，B的条件是C，C……</p><p>人类是一种能够认识到“无穷”的生物。这样的追问也被察觉到，可以无穷地进行下去。</p><p>所以世界应是这样吗？人类只能“以有涯随无涯”，玩一个永远不会终结的游戏，最终陷入一种徒劳，先人认为不是这样的。</p><p>接下来要明确第一个命题，就是自我作为人类个体，一切认识和思考的出发点都是从<strong>人</strong>能够接受的知识开始的。这些知识是关于世界的知识，然而却不是仅属于世界的知识。无论其来源，当知识为人所意识的时候，就已经打上了深深的人的烙印。我们可以管这种东西叫做主体性，一个通俗的比喻是，世界的一切如同二进制的数据，主体性是一套系统软件，而知识则是高度封装的抽象对象。至于这个对象呈现的性质，则很大程度上受到软件如何处理数据的影响。世界被人所认识的过程，实则是在人的观念中刻下世界的一个“投影”。我们从最根本的天性上，只能站在人的角度和立场上来考虑世界的一切。</p><p>启蒙运动就是在这样的思考中，打开了有关“人的权利”的追求。作为人，思考的出发点是人，其目的依然要归于人类，不再允许人屈从于其他的神圣力量。可以说这是一种“人类优先”的思考方式，当然也可以讲得非常朴素：我们只有相信人类自身的理性能力，因为舍此以外别无其他的智慧。</p><p>如果一个人终其一生，处于对于理性能力的不信任而不承认任何一个命题，他一生都只能够在偶然性的泥潭中打转，人的知识就无从增长。人或多或少会持有一些信念，也许是“人是铁饭是钢”，what not。类似的信念实则是长期以来由经验归纳与分析推导出的真命题。在当下它是一种真理，然而也并不见得一直会是真理，假如某天机械飞升的话。</p><p>我们常讲一句话叫，真理只在大炮的射程之内，这话是俾斯麦的。可见如果在大炮射程不及的地方你的真理就不是真理了。一时一地的真理是由大炮这种属于人类的力量守护的。也许有人觉得可笑，认为真理自在人心，真理从世界诞生之时就存在了，不需要你人来守护。但果真如此吗？不妨认为这种不需要守护的东西叫做绝对真理，它飘在宇宙中，揭示着万事万物的演化之法。那么人在这里无需任何行动，因为不论如何行动，事情的结果总是由这个“绝对真理”决定，那么人的自我意识，或者说人与这个世界交互的“操作面板”，都变成不必要的了。人类将如草芥般被支配着，沦为世界的人偶。如果这样是你所满意的，那么大可回到启蒙运动之前的世界去过活。</p><p>崇尚自由的人则充当着真理到现实之间的中介，真理通过人的意识与能动活动实现在这世界上，成为受时间空间限制的相对真理。在此意义上绝对真理反倒是我们开炮的对象，因为对它的幻想阻碍了人的现实行动。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>骨折后那些没人告诉你的事</title>
      <link href="/20250209-fracture/"/>
      <url>/20250209-fracture/</url>
      
        <content type="html"><![CDATA[<p>我是右腿胫腓骨骨折。本文仅讨论下肢骨折，骨盆、上肢、肋骨骨折及脊椎病患者不适合参考。</p><p>做手术前医生大概会问要不要镇痛泵，就是自动给你定时止痛药的装置。理论上是可选，但其实必选，尤其怕痛体质。医生没说，要主动问医生，如果医院里没有那算你倒霉。主要做完手术有疼痛会影响休息。博主相对耐痛，也还是用了，术后几天都没任何痛感。</p><p>初期卧床的阶段，吃饭时吃饭后上半身能抬高尽量抬高。平时时不时也要起身，可以不太久。老是躺着会便秘，别说吃乳果糖，你吃华莱士都不管用。便盆是废物一个，谁用谁知道。</p><p>也不要想着不方便就憋。大肠把水一重吸收，就更难排了。</p><p>做牵引、安排牵引床也许是件好事。你会拥有结实的钢架子和拉手用于起身，甚至上半身可以直立，对排遗很有用。没牵引没这装备。</p><p>关节活动要趁早，医生不说你要问。术后一天，有条件并经医生批准，要努力进行屈膝，足背屈（勾脚），跖屈（绷脚）的练习，谨防筋膜粘连，关节硬化。屈膝一开始有点疼，需要慢慢地增加角度。一个月内，大小腿完全折叠为佳。我隔壁床做前十字韧带重建，第二天康复师进来照着腿就是掰，屈膝过90度为止，疼得龇牙咧嘴。</p><p>早练早活动。晚了，关节硬了，你就糟老罪了。</p><p>早期可能伸膝有点受限属正常。</p><p>手术后局部血管未重建，腿部淤血，大片深红摸着稍微有点疼，属正常。等待血管重新生长后会慢慢消解，此时血供也恢复好了。</p><p>有条件者，上厕所坐马桶。能坐马桶了，心态会变好。能安全地独自做什么事了，都要尝试去做。</p><p>在家这担心那担心，一定记得把平时小问题记下来，复查问医生。省得看了医生又忘掉了。</p><p>大约两个月的时候记得问医生脚能否触地，以及占体重比例，省得脚下没轻没重影响恢复，或者应力刺激不够恢复速度慢。</p><p>胫腓骨骨折，对于腓骨断点在骨干的，可能只做胫骨不管腓骨，这是较为普遍的临床实践，到积水潭医院那也是这么做。有时近端更是不管，因为神经密集。腓骨愈合慢不太影响整体恢复。但腓骨远端到外踝这里的骨折，由于可能影响踝关节活动，一般会干预。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ave Mujica 的未来 - 第五话后评</title>
      <link href="/20250206-mujica/"/>
      <url>/20250206-mujica/</url>
      
        <content type="html"><![CDATA[<p>第五话的问题究竟在哪？单拎一话其实它的观感是不差的，但评分骤降到8.8（事实上B站的大手已经锁分了）表明了一种看空。</p><p>前四话在不断的爆发中揭露了许多队内矛盾，第五话的任务是在前四话紧锣密鼓高信息密度的轰炸之后放缓节奏，承上启下。在炸团已经确定的情况下，对于团队成员的状态以穿插的方式进行叙述。当然要明确目前的主要矛盾在于 Ave Mujica 重组的必然结果和当下团队成员动机不足、责任心不足的矛盾。因而刻画方向应当在于，老成员们不得不回归的理由，以及回归后拥有让队伍发展向好的能力。</p><p>目前第五话对人物积极面刻画不足。大众视角看祥子的人物形象已经跌落谷底。当然也有处理好的部分，比如沉默整集的祥子唯一一句话轻声破防中展现的人物弧光。但更多的信息是负面的——若叶睦闭门不出，祥子不关心睦，也不回初华的消息，正照应 MyGO!!!!! 第13话 Ave Mujica 的短剧中，Doloris 被抛弃而 Mortis 不被爱着。她们都被 Oblivionis 所遗忘。</p><p>B站动漫区头部的相对悲观情绪是在说，剩下的8话篇幅不够，无法以优美的方式和适当的节奏展开对 Ave Mujica 五人的救赎可能产生两种问题，一是节奏急迫，忽视观感；二是逻辑不严谨，强行推进。由此，也可以说第五话的问题就在于它是一季13话而不是16话、20话。祥子作为队魂，是开启 Ave Mujica 复活之路的最关键人物，在这样的重要节点，人物形象依旧在总体下滑。</p><p>也有乐观派，观点大约有几点：1、没完结不要着急下定论 2、人物塑造在进行 3、角色不是圣人，她不闹我看什么？</p><p>两方实际的不同是对待作品立场不同。Ave Mujica 是要成为一个剧情流畅、处处合理、大众的理解度高的故事？还是要成为一个小众解读、卖爆点的故事？</p><p>用一个比喻即可阐明：Ave Mujica 的发展如同棋局。</p><p>再聪明的棋手，在行棋过程中也有可能打出漏勺。你最终可能会赢，也许这个漏勺将棋局推向了较为激烈精彩的局势，但漏勺就是漏勺，棋谱会记得，胜率会下降，你在那个地方总是有一个更好的选择。Ave Mujica 就是这样一盘棋：漏勺已经打了；精彩也的确精彩。获得了讨论度，也有乐子和高光，但精彩的故事大纲和部分人物闪光之外，也有演出发挥失常和逻辑断裂。</p><p>Ave Mujica 的漏洞包括：</p><p>1、来自经纪公司的现实的重压只在炸团后出现。摘面具不担责，日常工作不见人辅助，赔款的时候人来了。</p><p>2、所有的吵架戏通通给人一种感觉：“怎么突然开始说这个了？”团队立身之本的争论犹如儿戏。</p><p>3、高高抬起，轻轻落下。结尾形势紧张，下一话告诉你危机平稳度过，怎么解决的不给你看。第四话炸团结尾尤甚，整个团队在起爆之后瞬间达成开幕即解散的共识。观众是信你按下不表呢？还是应该认为你没能力圆上这个情节呢？</p><p>4、在团队起爆之前，没有为成员归队准备台阶&#x2F;伏笔。那么势必在后续剧情交代，这搞不好就会变成追加设定，强行解释，以及机械降神。</p><p>所以不怪现在有假药。总是说假药看多了，擅自期待，擅自破防。大伙为什么都这么好奇剧情，因为是真的想不到怎么圆。诸多分析向假药都在试图圆上剧情逻辑，是一种无奈之举。</p><p>当厨师端给你一道看上去像宫保鸡丁的菜的时候，你吃了一口顿感味道不对，是否厨师也应该告诉你，“你不要擅自期待这道菜的味道然后擅自破防”？</p>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>骨折的上下文（pw为某组群号）</title>
      <link href="/20241224-fracture/"/>
      <url>/20241224-fracture/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4012b9bc11f9908a3eaa983fbda97ecf8ca45297bfd23a09a0d7dacba066e2fb">9c591e5321f2e0cfd2bc84047a64292d4fd097cfed96ff968510140273b9aca90c61af8978dc61ca95dd7ff9d5d51bc284cf480af003ac183ebc3c8e6691c96762572263e04afe5836602528fecc296438f6e92cd095e59fbe26b197be0eae32b28a5a850b9d5eee6f7e0432f2a0df87a951a67b0af9699bad7832542af187a36a71fb936e4d31624e31e29beb260a5bf1e6aac6e4b3b76350085bd13b23239fc0f3bbda4ab0af57fac7a7707d4a73f1afc401f7811cfc61e78684d58027786d339a4f618cc20509e2e13c84d50d84d4e404e22258becb884b02001b3977e42891f177d7db479ee4c51ad29e62a662970e8a0c4dd18855e8b0eb232d413cc87c71e38132c93755af04b913c916f2d15912676a5152b11d706ca1236d1b427bdf76fdd66579786eb58bb5cfbec8dfc8ee7dca9864f048009119eb8e3c6709232d4f70abed55f6afe380c4967f7c5d6bdd491bb92cc810cebe72f81417c9051570a29efb9ca22f19fff49cfcb7780cf3844fc92b69b4c323620d6b4f244f39b3ee84e67c00651e4d2ed100d548eb2b8cd0f913d17eece2b35698cf9da9d154a5fbf2203f62c7f48879b4d35614e18e149a4a5b9a5370941955e2bea6b998e19cd1ba57474407849eae7c7f4561097ac6beb61ed33540272883bd9adeb639f73539fc25dc3c731e6e5457333253a376897540f8576c71d140979a8d53435a542c031fc45bb4de8f62a0100a27a27c6e491db5dd9d40c598ce8041a6938d6e15a22667c4eebdceff493457fd4025a6964a4f64a1887adbe33194d72edba6c7ab5bdcf02b5085c8757aa5d2964b30880504a3f69d34f78a733a576507f5a951629b2fd6ca88b2bc0b8dae2e8c921fab044ed713b6ae1972c88e2b182e4a27a055d47f0cefdd4d96c51a32f7e65c0e3fb1b99e50ed3ce6f22cfde5fcb8af76cd2b52ae3a37a71392ecc4662464ff1cae675d66b2478a8d43d3133f2c6d49347a96d6da2a5acba905ded08f8bf730f84f6c7194d26da21cd9dc241863156863e53d3c7641b5ff4785048f23636b08d96eac23039b7c9b927c366b7f585a8161ef89f6cf55f5dfaaf3b922e37a8502988a2e437d41b0031b23d42728b9465adf204b01b9862e05517a3d40cfcb3902e30081eca68aa02489a749e6314b9ad93bff08d90ad4e98207e0d08b2b2fb85618357fdfd02dad5d52612ea7b7882cdd1850a85c756987f2d068d642700325063ca8b22cb0b1c84628c8cc0748ab5a9d134a8f1621aa7f3eebefef33a2e2e66482f9a59d7039fb12aa091061d33a80d28372111c3a44263ed67a753859fdaf1d7f085c812d830c0d5902e7b75b8dda36051b2be7f2cf039e4d2d25c20672f30683628c53bbd7c551b1985416c21d993de2aa4ed51dd57e538b687f86c0275ae30511c1f29d70ccf9e2163b959f59740d3612e092bdc71670894245405cce327555caa7627d7dae5ab49b84d81fc465556ffd9f20d2d00d89bb288903a1d20e92b69d0e04d97ea4d631a528dc07f7225218eee1af05ffcc1f0ca513a07376f15e2df3913283aa16b17cb6ea985d89cbfd9b0adc3e31e64381b12017f827141e1f6767ecf047c46eefc480f33b0fffc24c7eba346ece0ca3d2da0800e1778bd43ba7336596bf515c183a9d62e786e0388a9c651f29e6b22f6ded571c7ecffd9ce28adfe8c340be922ba9f353117533eae95955793e82f0e267f174b3149d0f7573aa28894354293afbe039fef0dac380776004d020adec9631080069875e12336900349f09dcbc96d5df6cf88b206e602cc6ed993fcbdc355465d118b099d74525245a89183caa4c46e5ed564a6119868f153fb5f2c257417111dcaae81a47d478f221222b0402a1dd1fc65ac5578e78c87e900e53545aa0a3c585b997de4f2d18c80a96c09ab52a5711a26e741d3bdeac43d915f9777fbe65dbe91787e9d5508c2ac00eec817bb4a0bd928e9c9534d40c4fea432216b02fe598ddd8a3862afede2b8f00bb554deb6d9f4750d6fda83005b9fd630af827927c3e68b91a09ec02d48d278034e131645830c3525853f77f7b99ecaeb350676b231edf4b939d0b1459e4f0bcc94c4caebe936f76c2b4f7638cfa27f3265d8639634d0d570db9c41d5a0c662db5f034f28b03be0d2861ad1bb7a01ee3eec412c5a1dbed410b4e5303fabac03e0f79d6921e8946bde79b7b885e3ba9c2726307c3f21c6120dfc69c9fd56647657e37c1f35d8d201d45e775c75e0920618518c7bea9b09045c9b3fa80e7250a0d66b01050d490f3b607709dc1aed27eacd75d4d99cea03276d08a0bce85414eb9b647c414bf3e81661527254833a253d05b4518941b373270df0fafab384a3db8dc9253a5bd80ee137ec24ab497f30720d5cbb7fdf2df81a69dbf312cdb2ca1d1290d6da083574bd8c8adc56fd87476f66382db08b0512547a247efde59c04f6f54e6eb5692100db45140497f1b1e83ef8bbed39cd0b1e2f7df7dad8a554538e1265a7fb63461ce7b04887882248873611d3f6ea21c727870ebd4a5fb5a0c4af110e2188e39af5df8414c375da137856b699a18acadef734f5a9d02657f882f48e73dd766c9b381e55a0498b2c04ce28e42a5a972460ce922e1f885a565d283b0f13cca3f6741bdbc0e6bf1e74a22b1b822fa8873625e7ac94280b791e7c02de99862080a971104b803f03f82fd2ba57414ac78c979964eebf67909e6c128decb1cbd1e5020cb712128d6e3d1d650ef48ef01836af7467c75264f50f8a53338eb7ef9629ef3c97470a8742d6acaf32e502bad5bc5a381e7ba11754aad04eb53e48c463eb3dcbd28efa3fb7d69329af4f8b8a093b64f2bbd572d71d95843d52ed5f83f2fa4f08600f5429534695654648c8db5eb17f2e61c67baafe3f49549484e28a457c9906ca723d251803c992a803532ba47965fc225ce899ff0075178ca05bf1f4d4b6e5a951a9f90f405ddc038fdf41ba2a5ad730c011a5dbe6373fb0cf99cc5e51789a1b2aaf99283d0336da5a0a1488c56c8e0477e4988630c09ef13c3701b4da113cd978739ee8ccd49251d6ee9ca8a33f125790a985686206deeeb9f413636e74ee455295e490ad67843edc4f623082787a19fe0793bf052f6ac36e247ee0af34d824b7483af6cc0eaf3a80a23cc7df9ce87a53dab78057193204faaa916793d13e3ea2c2ce7467a9767b92faad691fe8b6e224ee63303b9a95c6a6d8e4f176ecd1fe24bd83b43f922de4e0f0fd87017525c03d847bea9e37ef9637122daa4b01d77de91b5bd81f62101aa087e225555e36f931cc9b70c83f54d5708997340e80c0f3121e39e5b11793381e30e91d2a49e204586612d6ba572b857d91520ab565c136dd85a40125ca1ed756b6b4a063930471da147f3f4ee8f58a84d3af27faf57c264b426491da881702a3e5102aef0360021eb41e922d6cebfc82236c5ba6974dcee0aee024013d7f32db5fb90942af76b80f94f917872d656d508c50d56dc488a65ceb17496cf4133a01e8a7a6ef428e3a17b08174297fc3c9c9eb07c918c6d0ab426a7abcd6c3e0424c51ba8e541f622800f9d4eab3fa04cd4b7abc0f35342c4549618f41a49f2e6e0f52f7d389ff161e45a4a18572fc980ae79eaa03919a4061e70d136d8420619cdfc4c62b38ed6bc089ef465b475b08b94edbe75276815ba795b35a9a3c6aa182009d38061e1c4051d77cccbad8f13d71639a4ed175fe06071efaa8ca25c68d18afd2c7d3a4da2d3008ed226b76d118e51572fc7889c29e33ad6671c0988cab8816fa52a7797c0c1bfa6e7ebf700cbc98533452955c950695768f6d2fe1500caf5924dc716c142851e81dd7c40a7d2391b56f79ae1ff6046617a1e53866df3e81f7f5742e883a936c3365efc0116a25a1bed8886f46ffc96649609c12fb584048be02966198897eea00806f24f0524290a67ca96cf2f46f5e2fde96bdd1474f9078f0c63a45cfac4d4a0eadbd8b8be3baf90e1ca8a476da1cac49bbd1d585edc5a180ca441caa02bf767b1284a855a2d7575a6fcc3f6d24ab65b9cd8c1885eb980c29c77732cc2a2bf2a0be1fa293f4dd3b96aead45b65c0118b939197ac40da13d90823fc14e8bdd57ca2bab0992fe31fb2c66ccd1eb1edc07b845fe5ab4127bcf027c3f27170515bfd6673494a8e9e32178a3fdbce0cecaf804c143f97f19cd63c38c6d6fd3d266d9196e71fe31c7ee7218ff60e2d1c7c471e4545a91e596f2e896c466bed233bf3eb154db8df39e34a4492241080f2c262da581f204481dae83743cca7fe66eb2147f1bbf554cd24eb513969aa9a082ba1660bc696604c80424e741fd034c9e694dac8dcee8b12b53a37d5dd6df4e4997cfa69ecbb56c3978d06dffc7333825b22094a4eff71d41350955b3a0afc9bb4d310b3d65469f7dd61447a78d41b826c8290a61db1494d4ee7ee827ce268eca5b1f2928a28bffcd1230310880801076019bc62b63fac5c43a69a43d8534e9bc95e893957bd371a139b44ab362fceb6fd23f34ff71e702f9171d3abe72ab0b1e5ad9256d9809a5b85b180f37c431677e19c022851852dfb32a1bd263462121ba8953ddd45d99119a353344fde27712892b0eed32788b16d76dd3065861332f3ec2d20a28c6967ba8746293ae1d729de3497749c20c6d956863bd14df0d21d20dac63c8a426ce0ea1d10d482bb7fe95826ec161463ffd5fab96e642dd07a2f38c03407384ce85b398edb33cca6adc18f50ab864dcb64cd6761047a9aa6f08571976ac2db25e0e641975a37e61073d759436d4126bade42cfdf59f624b122d78b6b9a380ff091b1b6002cadcea4bb017a06e73034c77efd5addf546fb926fb0615f84ebc57ff379799c53008cd70b0c1fb0aaaa89c093224d4bc8b174a7da46f310784ddc07fdf6ff40bf11d1495f9df783f46ac3d3fe6a78b36d898d97c33eb3ebf33fbdc53ee6d37e1850a9e685b75ea3b1ec016488e7a0b1b64034993e88459dbf1771c95b0d786afa4b5e705acd5cc28aaa5692964c7bd450d1f1e8899b33074e13fbdcd459ce9bb588a0ef1f8b6849a233e6e3137c9dfc373c000a6635a84e2231434dd4855cdaf465a702e8611dfbfa00c387a16606fe484351f0a1e40bd0ec290d39afb9aad8a514490e3fac4ad2d28a629f30503d7019b34e779ccbb9a4c9d1c8e034aff2a788f2a978b684795b718f4ad2df117c96dda6a13001023f045b753b7a36936585ea6fdf318e26e6f6ec24c95cad9de841a57a7de2a1cc51110b53062beaa9ae96690807f7a689e771f2221e95cfd4231c0f4cad1c6c5ce1017ad3331d9ff068f582f2d8f3c24ab4be144ede2e67d6893fdf7f775bfd5bb65b41c278df053df2dbddf448b46e9ba2dede3dbb7c615b48d2884a2c23cf9abb98548c9c18bc3cece19198bfad51857f1005d7ee47859b3080e21389437feea2fb9fe40fad8620244dba554732f8a2c3cca87cb6ccb18e45eb4e0c4588c3014f7f16ef68544391c38f9ae6e722435d5eed35bc89be9dc1dd7bce5143b893644c0b5c97761bdb91088b3df67e841641952b3bdf3970e415c66068353a87434a3d0075dde7471ca451b0a7466c892b9c32ec6f250f660b13c2f4071d0ecba09b2766aa402493b0a5514956cbd8759da85738232795c6435bb097b190769b8c33e459f132f21c9c4218ffee27f080ebb4b1b0170c0cbed5a5d82cff83f082dc64cf529a13a67fb6cb0a131be065c516a0ff1937ff354f312a3537a72fefdb48705b5a42193d958aa9d79097f817a38082493da369233eed88214a407ee7b07d70a51b5e1fdf8a390f6e9ade1fd406de3579f8ffc3aa1cb06fa281b6cd17eb2c6497439d02926d8209483341f688beab13a1fa91a76fd9abfb6df1b02af04b08dcdd863456e5ae9525637e920cdd0c552186dddb270d962ad32723597f077bc6ceb62a82f3a3851fd908465c396b516b7e55bb2b2bb0ecaaf493774f9e1952c048814fad64757b4443b8c5823ac5c15b3b9dd2499d94f45b013df1cc71154e734e2a12fab233c2293c9054d41f192ace16c59e6ebf9a5980547a6538c016c7aaf8170c0cfcad7884a6f833771e9f4cde06b9684d7640c3eae00639c0557b3a7280a68afef4faecef75353ba51ce025a8f74ecf52f647f2485a50a6734f7d8c5cad4a2333f54285bffaf89e11e58c2e986cffef0f5c4848556bebc2bd4835f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哪来那么多长期主义</title>
      <link href="/20241128-longtermism/"/>
      <url>/20241128-longtermism/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1kABYYeE19">最近哪来的那么多长期主义开箱</a></p><blockquote><p> 我们能否在购买之前就意识到这是一件“长期主义单品”，并在之后的日子里坚持一开始的认知？</p></blockquote><p>个人现役服装中服役时间最久的是一件商场买的肯宁顿风衣（但是1k6且聚酯），品牌也是已经从中国退市一年的SELECTED(听起来是很没品的名字)。但是它可以说是建立了我对风衣这种商品形态的认知，那就是——几乎怎么穿也不应该看到明显起皱的长外套。当然从此我和嘎巴甸（华达呢）这种面料就无缘了。那么最喜欢做这种面料的其实是—-Burberry。到底是谁在喜欢这么难打理的面料？并且一般支数还会比较高，这样容易反光，起皱就更明显了。</p><p>到今年满打满算买到手已经4年了。但是我今年穿这件衣服应该比我前3年加起来都要多。我也不知道为什么把它放在衣柜里躺尸，主要的原因还是以前自己在穿衣这方面克扣自己太多了，几乎没怎么买过衣服——因此我其实没有其他的衣服来搭它。这就很要命。</p><p>当然另一个原因是我以前觉得这样穿太奇怪了。似乎当时还是 cityboy 版本——没事，现在也是。为什么能把这件衣服想起来也要赖它。大概是说ex给我推了几家淘宝店，都是这种风格。后来分手了，连带着这种风格一起不喜欢了。</p><p>以上只是戏言。正经地说，我还是觉得 cityboy 太典了。虽然我自己也买了一两件这种风格的 teeshirt。这种风格差不多就是满大街的底特律517这种，初看觉得这个穿得挺好的。然后看到所有人都在穿像个NPC，就绷不住了。</p><p>当然以我调酒师的身份，最容易走的路线其实还是轻熟，几乎是顺理成章的，不容置疑的。跑题了。</p><blockquote><p>当初觉得帅的东西穿久了或者见识广了也就那回事，反而是随手买的成为了美好的误会。实际上不能长期又能怎么样呢？我当下这一刻的满足是真实的。它短时间内依然能带给我足够的价值。我并不认为我的购物没能长期就失败了。</p></blockquote><blockquote><p>只有拥有了自己的风格，才有所谓的长期主义。时尚一直是来来回回的。</p></blockquote><p>OOTD：大逆不道的西服内穿塞进裤子并外穿开衫毛衣，再把驳头翻到外面。最后把衬衫领翻到驳头外面。（？？？）</p><p>南极人卖的内搭德绒Tee比平圆方中的纯棉款舒适度上好几个层次。虽然不见得是粘纤的原教旨德绒就是了。</p><p>——这样我就可以假装自己在9度的天只穿了3件而且还不觉得冷。主要是领口多了一层，整个保温最薄弱的一环解决了。</p>]]></content>
      
      
      <categories>
          
          <category> 时尚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【自用】杂项</title>
      <link href="/20241127-misc/"/>
      <url>/20241127-misc/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3a846b429e2c41302ce90a4bbfa1690b07f85a82343e66f404b7a6a9c6059e6e">680953028ddd47d9bc33f1e3c96e3f1f5e5c7e34231229e943681291ffab92c8749268f0964a83468d040c412125fa6d384e49db682778d75d02e70c614d5aa016d305904f5cbec93baa5d0dca7b9c570729e2510e59ba26ea54324ae433cab84c317a347544adffd220edecab3eba88dbbe6fd8da059a8a09f406028fdb000b0d611d5cdcfe5bcc063bbdcfda35b8b6b56cfc8ad58acb88c9023955c386f2aec6dffad1a0e5f6b1a1f06c09764496444f5b2c89eb89e9a4a272e3842512fbb14281b9db77b8c1917ebcfcea637e400cda77c4befda04271a90c80bc253393a83cdedb96adcfcd3dbe8e1ce8572d30eae14afaeb4127388b7bb253445198f3965a0cbc7b6c557fd22936615ff315d7b4075a6a015936bdd37730ae7b58cf9826341c130b0b154eb546c5492dd0312042bcb173648a144bde822282a44871cf187ab0a25b2c9190be18b0c6df73bccc6b7e2ecddae3ffa1bd4a521aa3d1fb17ed900dd0f98f2dccd9b1bfbabc4ec48380fee624da1addb429c7a4f22555900f4d30d73e31893d7a70853d315a9c021ba720bfaa892c1ad31f37a47b87a45508c743148f29ff29a2ee59c5f38921de34da123392b7b4b81932e116181039b045d37c5e247a3fd77d6497ebf6fc68a01cbb75692c713b838483a8a6cb332720042ac45bd480f121810a564dd25f2eabc054645f7ffae849f5c508a51f4f8286f9ce9ecc1e0136df0ee5c7bb377764d50f467c90e8c60573c5e0a05a999944539989</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>都 2024 年了你的穿搭还能反映你自己吗</title>
      <link href="/20241127-wtfyouwear/"/>
      <url>/20241127-wtfyouwear/</url>
      
        <content type="html"><![CDATA[<p>刷了一个非常好玩的 <a href="https://www.bilibili.com/video/BV1oLUkYkEWn">B 站视频</a></p><p>顺手贴一下最近其他比较喜欢的视频列表</p><p><a href="https://www.bilibili.com/video/BV1kABYYeE19">最近哪来的那么多长期主义开箱</a></p><p><a href="https://www.bilibili.com/video/BV16ZU2Y8E5R">小伙连着穿了一周的Rick Owens Kiss Boots，这是他精神发生的变化</a></p><p><a href="https://www.bilibili.com/video/BV14z4y1T7qo">2023十大潮流烂活！｜老钱风、美拉德穿搭、cleanfit、芭蕾风…令人满头问号的时尚？</a></p><p><a href="https://www.bilibili.com/video/BV1WE411n71Y">Lemaire 2020FW</a></p><p>跑个题：<a href="https://www.bilibili.com/video/BV1vEDeYxEU1">齐泽克的简单友谊测试 原作者：Julian Cinema &amp; Philosophy</a></p><p><img src="image-20241127142033289.png" alt="image-20241127142033289"></p><blockquote><p>Working out is modern couture (高定). No outfit is going to make you look or feel as good as having a fit body. Buy less clothing and go to the gym instead. –Rick Owens</p></blockquote><p><img src="image-20241127142716116.png" alt="image-20241127142716116"></p><p><img src="image-20241127142730449.png" alt="image-20241127142730449"></p><blockquote><p>如今，有什么是不能从海鲜市场轻易淘来的呢？</p></blockquote><p><img src="image-20241127142808959.png" alt="image-20241127142808959"></p><p><a href="https://www.bilibili.com/video/BV1ArU7YSEiC">Loewe 2025SS</a></p><p>诡异的 BGM</p><p>大量裙撑（甚至风衣），宽大袖口，各种斗篷、各种印制、各种半透明，大量印花</p><p>少量未来主义</p><p>又见羽毛印花T恤</p><p><img src="image-20241127160615791.png" alt="image-20241127160615791"></p>]]></content>
      
      
      <categories>
          
          <category> 时尚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作随记</title>
      <link href="/20241125-working/"/>
      <url>/20241125-working/</url>
      
        <content type="html"><![CDATA[<p>首先来看一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_stack</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">void</span> *buffer[BT_BUF_SIZE];</span><br><span class="line">  <span class="type">int</span> nptrs = backtrace(buffer, BT_BUF_SIZE);</span><br><span class="line">  <span class="type">char</span> **strings = backtrace_symbols(buffer, nptrs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!strings) &#123;</span><br><span class="line">    perror(<span class="string">&quot;backtrace_symbols&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; nptrs; j++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strings[j]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="image-20241125195032520.png" alt="效果" style="zoom: 67%;"><p>打不出调用栈当中的大多数函数名。这主要是因为编译时没有添加 -rdynamic 参数。</p><img src="image-20241125195158300.png" alt="效果2" style="zoom:67%;"><p>添加之后，就可以有了。这样搞我们就可以省得用 gdb 去调试调试器了。</p><p>打算在项目里引用一些 Log4j 之类的库。想做日志分级。日志里面细的东西实在是太细了。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Crazy Saturday</title>
      <link href="/20241125-record/"/>
      <url>/20241125-record/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在周五夜里唱唱是我这周末做的最错误的决定。 ——typoverflow</p></blockquote><p>周五晚上，大家都叫着要唱，于是这局真成了。这次唱到4点51，吃了和上一次同一家的早餐，搭乘地铁2号线的第二班车回到仙林校区。随后有一分队在824打雀魂直到早上8点多，才各奔东南西北。</p><p>一觉醒来是7点多，本来打算问问吃什么的，说是重庆面馆。但这时候第二场来问了。于是在没有吃饭的情况下前往酒吧。</p><p>我居然能在一个小时里完成洗澡夹头发再画一个白开水的操作，果然人的潜能都是被逼出来的。</p><p>喝两点去唱，唱到四点半打道回府。感觉周一就算起得来也绝非人类了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不抽烟了</title>
      <link href="/20241116-nosmoking/"/>
      <url>/20241116-nosmoking/</url>
      
        <content type="html"><![CDATA[<p>走来计科楼的路上，我想着最近大概足够幸福了，可以不抽烟了。这是一个自我实现的预言。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作随记</title>
      <link href="/20241116-working/"/>
      <url>/20241116-working/</url>
      
        <content type="html"><![CDATA[<p>先来看一段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span>(<span class="string">&quot;movq $-1, %rax\n&quot;</span><span class="string">&quot;syscall\n&quot;</span>); <span class="comment">/* won&#x27;t set errno */</span></span><br><span class="line">  <span class="comment">/* syscall(-1); */</span></span><br><span class="line">  <span class="type">void</span> *handle = dlopen(<span class="literal">NULL</span>, RTLD_LAZY);</span><br><span class="line">  <span class="type">long</span> *errno_position = dlsym(handle, <span class="string">&quot;errno&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!errno_position)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Not found&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(*errno_position));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syscall()</code> 事实上还是 glibc 的 wrapper。errno 并不能够被 raw 的系统调用获得，只有 glibc 的 wrapper 能干这件事。我用内联汇编写 syscall 指令，errno 立马就不管用了。</p><p>问题在于 glibc 是怎么知道 syscall 出了什么问题的，感觉有点头秃。</p><p>OK syscalls(2):</p><blockquote><p>Note: system calls indicate a failure by returning a negative error number to the caller on architectures without a separate error register&#x2F;flag, as noted in syscall(2); when this happens, the wrapper function negates the returned error number (to make it positive), copies it to errno, and returns -1 to the caller of the wrapper.</p></blockquote><p>看到这里，我情不自禁地想问，既然 errno 对 kernel 不可见，那么对于 <code>ptrace(PTRACE_PEEKDATA)</code> 这种调用，它就算在成功的情况下也有可能返回 -38(ENOSYS) 这种东西。我怎么知道这个系统调用是成功了还是失败了？</p><p>答案是 ptrace(2):</p><blockquote><p>C library&#x2F;kernel differences: At the system call level, the PTRACE_PEEKTEXT, PTRACE_PEEKDATA, and PTRACE_PEEKUSER operations have a different API: they store the result at the address specified by the <u>data</u> parameter, and the return value is the error flag. The glibc wrapper function provides the API given in DESCRIPTION above, with the result being returned via the function return value.</p></blockquote><p>其实我觉得这样 wrap 一下真的很干。平白无故给我的理解上了一点强度。譬如在 strace 中</p><p><img src="image-20241116132923596.png" alt=""></p><p>我分明就是用内联汇编调用的。然后你告诉我这里无中生有返回了一个 -1。我觉得不行。</p><img src="image-20241116133145608.png" alt="image-20241116133145608" style="zoom:50%;"><p>对于我来说，我就想看到最 raw 的系统调用结果。</p><p>不过对于我们的 tracer 而言，这些都是小问题。现在我们知道如何设置 errno 了：因为 ptrace 获得的永远都是 raw 的 rval，所以只要改 rval(%rax) 就行了。</p><hr><p>关于线程退出状态的问题，可以看一看这个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">foo</span><span class="params">(<span class="type">void</span> *_)</span> &#123;</span><br><span class="line">  <span class="comment">/* syscall(SYS_exit, EXIT_FAILURE); */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pthread_t</span> thrd;</span><br><span class="line">  pthread_create(&amp;thrd, <span class="literal">NULL</span>, foo, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">void</span> *exited;</span><br><span class="line">  pthread_join(thrd, &amp;exited);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;foo exited with %ld\n&quot;</span>, (<span class="type">long</span>)exited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接 exit，则会打印 foo exited with 0。但用 return 的就能打出 1 了。说明 pthread 在 foo return 之后果然是使用了一些同步的操作把返回值写进。如果没有这个操作，返回值就彻底丢掉了。</p><p>为什么是 0，其实是 join 的时候 pthread 干的。</p><img src="image-20241116135339801.png" alt="image-20241116135339801" style="zoom:50%;"><hr><p>对于 thread 的认知可能需要更新一下。</p><p>首先一个进程默认会有一个初始线程。进程是一个资源单位，而线程是一个调度单位。一个进程可以有很多个线程，包括初始的线程。这些线程之间都是平等的，在操作系统视角来说，没有高低，主次之分。任何线程都可以悄悄地似掉，如果没有其他的同步机制的话，那就真的死掉了。</p><p>新创建的线程，只是和创建它的进程同属一个线程组，可以说它是这个进程的子线程，而不能说是之前的线程的子线程。子线程创建新线程，它们依然是平级的。</p><img src="image-20241116141014668.png" alt="image-20241116141014668" style="zoom:50%;"><p>实验的结果</p><hr><p>想要恢复线程，也就是在dump的时候，先研究一下线程之间的关系。然后把cpu上下文装到线程里就行了。</p><p>while clone() 是会返回一些 tid 的。理想状况下，应该控制 tid 和之前一样，但是我该怎么做（？）</p><hr><p>明日任务：rewrite socket syscall</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作随记</title>
      <link href="/20241113-working/"/>
      <url>/20241113-working/</url>
      
        <content type="html"><![CDATA[<p>先来做一个数独吧。然后就做了一小时。</p><hr><p>主要就来写一些关于 ptrace 的发现吧。从这样一个小程序说起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    raise(SIGSTOP);</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// tracer</span></span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ptrace(PTRACE_SEIZE, pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACESYSGOOD); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%*c&quot;</span>);</span><br><span class="line">      ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">ptrace_syscall_info</span> <span class="title">info</span>;</span></span><br><span class="line">      <span class="type">int</span> result = ptrace(PTRACE_GET_SYSCALL_INFO, pid, <span class="keyword">sizeof</span>(info), &amp;info);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptrace error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (info.op) &#123;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_ENTRY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;syscall entry: ID = %lld\n&quot;</span>, info.entry.nr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_EXIT:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;syscall exit : ID = %lld\n&quot;</span>, info.entry.nr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_NONE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;None\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PTRACE_SYSCALL_INFO_SECCOMP:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Seccomp\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unknown\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 line 11 的注释。在注释掉这一行前，syscall_info 是可以获得相关信息的。但是注释之后，每次都只能获得到 NONE。Man ptrace(2) 理由是，”In case of system call entry or exit stop…limited to type ..NONE unless ..TRACESYSGOOD option is set”。</p><p>我们现在来控制它走几步。</p><img src="image-20241113174529054.png" alt="image-20241113174529054" style="zoom:50%;"><p>依此就是 execve()， NONE， 还有 brk()。</p><p>根据 strace，&#x2F;bin&#x2F;ls 的第一个调用就是 brk()，挺合理的。</p><p><img src="image-20241113174636851.png" alt="image-20241113174636851"></p><p>这里甚至看到 execve() 有返回值（？？）</p><p>那么，其实想要揪出这个 NONE 到底是什么。</p><img src="image-20241113181716326.png" alt="image-20241113181716326" style="zoom:50%;"><p>根本不懂。</p><hr><p>我是呆逼。</p><img src="image-20241113181807456.png" alt="image-20241113181807456" style="zoom:50%;"><p>意思是 <code>SIGTRAP|0x80</code> 是一般的正常的系统调用 invoke&#x2F;return 产生的。而那个 5 应该是有问题的。</p><hr><p>逆天。</p><img src="image-20241113184302150.png" alt="image-20241113184302150" style="zoom: 67%;"><p>这个特性挺能藏。</p><hr><p>接下来，我们将会来观察，在 clone 发生的时候，ptrace 要怎么跟踪</p><hr><p>首先随便讲一下线程这个东西。</p><p>作为 clone() 创建的 linux 原生线程呢，刚创建完后被控制的第一下，就是执行线程入口函数的第一个系统调用。这为我们简化了很多。但是在函数执行完之后，线程就会悄悄地死掉，然后什么也不告诉主线程。</p><p>事实上，thread 自行退出是通过 SYS_exit 系统调用（60号）。它做的仅仅是终结这个执行流；那么就少了一个可以调度到 CPU 上被执行的东西。不太明白这个系统调用对于资源的释放有没有，似乎没有，毕竟 clone() 之前就要准备好线程要使用的资源了，应该是调用者释放。</p><p>在任意一个线程，甚至是主线程，调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall(SYS_exit, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>都可以使当前执行流停止，并且其他的线程继续运行，整个进程基本上没啥大问题。资源应该都是进程层级的东西。</p><p>如果子线程退出，你会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-process</span><br></pre></td></tr></table></figure><p>如果主线程退出，会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-process-&#123;process&#125;</span><br></pre></td></tr></table></figure><p>是的，主线程死了，但是主进程还活着。</p><img src="image-20241113202635648.png" alt="image-20241113202635648" style="zoom:50%;"><p>当然其实 <code>ps -aux</code> 还是可以看到它的状态的。非常地合理。</p><hr><p>作为 tracer，在看到线程 syscall(60) 的时候，只要在 entry 处 detach 一下就好了。当然如果要砍掉一个线程，那只要罚它做一个 SYS_exit 然后 detach。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新功能：显示我是否在工位干活</title>
      <link href="/20241112-activity/"/>
      <url>/20241112-activity/</url>
      
        <content type="html"><![CDATA[<p>已实装在 <a href="https://tilnel.github.io/about">about | Tilnel’s Blog</a></p><p>给静态页面加这种东西，疑似有点闲。</p><p>实现分为三步：</p><p>1、判断我是否在工位 - 采取的标准是检测右手边主机是否锁屏</p><p>2、动态更新</p><p>3、将其显示在静态页面上。毕竟 github.io 仓库太慢了</p><h1><a href="#pan-duan" class="header-anchor">#</a><span id="pan-duan">判断</span></h1><p>修改 Windows 组策略使得锁定(4800)解锁(4801)事件被记录。写一个cpp获取最后一个事件，挂在后台。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckLockUnlockEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hEventLog = <span class="built_in">OpenEventLog</span>(<span class="literal">NULL</span>, <span class="string">&quot;Security&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hEventLog == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open event log.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD bytesRead = <span class="number">0</span>, minBytesNeeded = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="function">std::vector&lt;BYTE&gt; <span class="title">buffer</span><span class="params">(bufferSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ReadEventLog</span>(hEventLog, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,</span><br><span class="line">                      <span class="number">0</span>, buffer.<span class="built_in">data</span>(), bufferSize, &amp;bytesRead, &amp;minBytesNeeded)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to read event log.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">CloseEventLog</span>(hEventLog);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* pRecord = <span class="built_in">reinterpret_cast</span>&lt;EVENTLOGRECORD*&gt;(buffer.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((BYTE*)pRecord &lt; buffer.<span class="built_in">data</span>() + bytesRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRecord-&gt;EventID == EVENT_LOCK || pRecord-&gt;EventID == EVENT_UNLOCK) &#123;</span><br><span class="line">            std::string eventType = (pRecord-&gt;EventID == EVENT_LOCK) ? <span class="string">&quot;Lock&quot;</span> : <span class="string">&quot;Unlock&quot;</span>;</span><br><span class="line">            std::string message = <span class="string">&quot;Event: &quot;</span> + eventType + <span class="string">&quot;, Time: &quot;</span> + std::<span class="built_in">to_string</span>(pRecord-&gt;TimeGenerated);</span><br><span class="line">            std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">SendUDPMessage</span>(message);  <span class="comment">// 发送事件到目标主机</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 每次检测只发送最新的一个事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        pRecord = (EVENTLOGRECORD*)((BYTE*)pRecord + pRecord-&gt;Length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseEventLog</span>(hEventLog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a href="#geng-xin" class="header-anchor">#</a><span id="geng-xin">更新</span></h1><p>把事件信息发到 Linux 主机上。启动一个守护进程，监听消息并生成一个 &#x2F;tmp&#x2F;activity 文件，内容为需要在网站上显示的 html 标签。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#ff0000&#x27;</span> <span class="attr">已经离开了</span>&lt;/<span class="attr">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 nginx</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /activity &#123;</span><br><span class="line">  <span class="attribute">default_type</span> text/html;</span><br><span class="line">  <span class="attribute">alias</span> /tmp/activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a href="#xian-shi" class="header-anchor">#</a><span id="xian-shi">显示</span></h1><p>塞一个 JavaScript 到主题的 js 文件夹里，fetch 这个 html 标签并塞到另一个 html 标签里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123; <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span> &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! Status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;html-container&#x27;</span>).<span class="property">innerHTML</span> =</span><br><span class="line">          html;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to fetch HTML:&#x27;</span>, error);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;html-container&#x27;</span>).<span class="property">innerText</span> =</span><br><span class="line">          <span class="string">&#x27;Failed to load content.&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，为了从 github.io 上跨域访问，需要设置 nginx 的 Head</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /activity &#123;</span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;Content-Type, Authorization&#x27;</span>;</span><br><span class="line">  <span class="attribute">default_type</span> text/html;</span><br><span class="line">  <span class="attribute">alias</span> /tmp/activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把需要的元素装在 About 的 markdown 里面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;html-container&quot;</span>&gt;</span>校园网访问可加载当前状态<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/active.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><div id="html-container">校园网访问可加载当前状态</div><script type="text/javascript" src="/js/active.js"></script>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作随记</title>
      <link href="/20241112-working/"/>
      <url>/20241112-working/</url>
      
        <content type="html"><![CDATA[<p>今日目标是把之前的代码改完，并且至少支持 C&#x2F;S 类型的程序。</p><p> 第一步是重新梳理一下，auto 模式和 manual 模式分别到底发生了什么，进而能够在代码中对两种写法进行分开&#x2F;耦合。</p><p>事实上，auto 模式可以视为一种机器提供操作的 manual 模式。因而可以优先分析 Manual。</p><p>手动模式下，大致是这样的流程：</p><ul><li>启动 tracee，推进到初始状态后停下</li><li>等待用户输入，首先是切换“焦点”。进而是“执行一步”。</li></ul><p>此时，running 为全局第一个 state。</p><p>“执行一步”都做了什么？</p><ul><li>首先，作为手动模式，一般来说是顺着往下走，一般来说无须进行自动的状态恢复。</li><li>在某一位置触发了 Choose。此种情况并不需要进行 ckpt，因而只需要停下来，并询问 Choose 应当产生的结果。</li><li>一步执行结束。需要进行 ckpt。如果用户并未指定切换焦点，则下一步仍然在当前的焦点上进行。</li><li>当然，delete last_running; last_running &#x3D; running;</li></ul><p>ckpt 到底做了什么？</p><ul><li>将当前的状态放到 running 中。并且序列化然后写盘</li><li>也许写盘的操作可以在内存压力不大的情况下省去。用正经一点的话来说，就是“改变存储引擎为磁盘&#x2F;内存”<ul><li>但是这个好像并不是瓶颈，不首先考虑。</li></ul></li></ul><p>一个小问题。</p><p>在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="built_in">dwarf_init</span>();</span><br></pre></td></tr></table></figure><p>中，写 <code>std::unordered_map::operator[]</code> 会产生一个 floating point exception。推测 .init 早于了 STL 的实例化。</p><p>一天结束了。记一下我做到哪里了。</p><p>首先我在 Monitor 模块。其次我正在写 configure 的读取。接下来我要改写初始化状态的部分。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重读 eXplode 知道的事情</title>
      <link href="/20241111-eXplode/"/>
      <url>/20241111-eXplode/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The reader should keep in mind that conceptually what EXPLODE does is very simple. If we assume infinite resources and ignore some details, the following would approximate its implementation: 1. Create a clean initial state (§3.3) and invoke the client’s mutate on it. 2. At every choose(N) call, fork N children. 3. Onclient request, generate all crash disks and run the client check method on them. 4. When mutate returns, re-invoke it</p></blockquote><p>这个简化是非常不讲道理的。作为不需要复现这种技术的人来说，当然可以假设你在每一个分支的地方都去作 Fork，但是。。。这始终不是很对。</p><p>对于想要模仿这种做法的人来说，完全找不到任何方法可以忽略过度使用 fork() 带来的进程数量爆炸。问题不光处在系统性能资源上。甚至可以说，连进程数量上限都能摸到</p><p>当然作者的说法是很狡猾的，“你们大可以把这件事情看成是这样”。这句话隐含的意思就是实际情况和他所说的相去甚远。</p><p>当然，作者还是有所补充的：</p><blockquote><p>As a result, EX PLODE unsurprisingly looks like a primitive operating system: it has a queue of saved processes, a scheduler that picks which of these jobs to run, and time slices</p></blockquote><p>所以总的来说，做法还是状态存取和调度器。</p><img src="image-20241111174219924.png" alt="image-20241111174219924" style="zoom:50%;"><p>接下来有点费解。</p><blockquote><p>exhaust all possible combinations of choices within a single mutate call before doing another.</p></blockquote><p>也就是原地把所有的可能性都走一步，再往下走。有一种广搜的感觉，而不是：我尝试这个分支，然后从这里继续往后探索。</p><p>eXplode 的 ckpt 方法是确定性回放。也就是 stateless。</p><blockquote><p>EXPLODE uses computation rather than copying to recreate states.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重力</title>
      <link href="/20241110-gravity/"/>
      <url>/20241110-gravity/</url>
      
        <content type="html"><![CDATA[<p>桌游组的重力系数也许太高了。可怕。是不是大家身上的负担都太重了？</p><p>虽然这个群可能本身就是这样，群友进来说两句抑郁的话，然后消失，然后过一阵子再来抑郁一下。这些抑郁却又说不出个实在的理由。每种情绪一定有引起它的原因，但是有人似乎是不愿意将这种原因附着于某种俗物，以便为它起一个浮华亮丽的名字。这样还可以敝帚自珍一下。</p><p>也许人都是有远多于自己想象的自尊的。譬如不愿意接受竟然是这么俗套、这么没意思的理由造成了自己的抑郁。于是就需要给原初的创伤套皮，如同河蚌分泌出物质来包裹沙石形成珍珠一样。于是伤口首先变得漂亮；其次变得看起来没有什么破坏力。分析卡在这一层也就没有什么实际的效用了。 </p><p>大概现在还是需要努力有意识地在聊天的时候断断句。但是文字形式的断句效果是很差的，因为文字经过自己的反思的概率是更高的，不一定能够逮到无意识的尾巴。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客、Hexo、Valine评论头像 备忘</title>
      <link href="/20241110-blog/"/>
      <url>/20241110-blog/</url>
      
        <content type="html"><![CDATA[<p>Valine 评论区在移动设备上可能刷不出来。应该是浏览器的问题。</p><p>Valine 评论是可以设置头像的，前提是留下一个邮箱，并且这个邮箱注册了 <a href="https://gravatar.com/">Gravatar</a> 然后设置了头像。一次注册到处使用。</p><img src="image-20241110171001041.png" alt="头像" style="zoom: 67%;"><p>砍掉了博客的文章摘要。改成了 Archive 的页面。</p><p>砍掉了文章列表分页，力求原始简单。</p><p>砍掉了回到顶部按钮，总共也不会多长。</p><p>终于启用了 jQuery 站内搜索，现在可以搜索关键字了。</p><p>更新了 About 的内容。省略了很多网络社交不需要的东西。</p><p>更新了几个友链，虽然我们并没有交换，就当是博主推荐了。</p><p>启用了访问统计(busuanzi)。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Highway to Hell</title>
      <link href="/20241108-trip/"/>
      <url>/20241108-trip/</url>
      
        <content type="html"><![CDATA[<p>Preface</p><p>11月7日，骑了很远的路。游记参考祁念的记录。似乎我也没有什么实际的情节需要补充。</p><p>为什么会做这样看起来疯狂且没头脑的事情，我已经忘记了很久——并非。</p><p>如果没有可以互动的对象，那么回家&#x2F;宿舍&#x2F;工位将会是一件非常乏味的事。看起来工作室的各位都不是十分愿意离开人群。与人在一起这件事本身包含了一种力量，似乎是“收到反馈”的权力。人做任何事、说任何话的背后都隐藏着一种期待，或是说一种欲望，即将这些话语和行为的意义进行锚定，以防止这些内容在产生意义之前就散失了。呃说人话：一种“回应”是人们所期待的，回应这件事使得自我的主动表达得到了ACK。于是就可以对行为的意义进行自己的判断。这一判断就是依据回应生成的。</p><p>可能这样说并不精准。回应并不是“判断”的内容的充分依据，它充其量是一种直接原因。因为回应到了，我们搜索自己的意识，产生新的行为以应对那个回应。</p><p>“≥3”是一个并不充分的条件。大多数情况下，3个人的活动可以产生足够多的plot以供所有人咀嚼，产生回应，引发一种“消息风暴”。2个人的活动就会大打折扣了。</p><p>我在说<strong>二人关系是乏味的</strong>，听起来有点危险。</p><hr><p>其实应该写游记的，但是祁老师已经写了主要情节，我就偷个懒搬来好了（）</p><blockquote><p>据说这个游记其实有五篇。但是跳票3篇。《自行车篇》《厕所篇》《消费篇》《旅途见闻篇》《尾声》</p></blockquote><p>一切的起因都要从一顿饭吃完回来已经过了十二点开始。</p><p>@祁念←半夜不好意思敲醒阿姨回宿舍的人<br>@茶栗←有人建议就会很乐意夜骑&#x2F;唱唱的人<br>@洗先生（Tilnel）←一件随机刷新的活动有≥3（含自己）就容易参与的人<br>三人成组，踏上行程准备，在玄武湖和晓庄中间选择了更近的目的地。</p><p>《自行车篇》<br>洗杯子先生记起来自己其实还有一辆被自己遗忘在宿舍门前数月的公路自行车，作为没有哈啰月卡又没办法骑电动车出校的人，选择回去看看公路车是否可用——结果当然是不可用的，从车山车海中把车举起来放出来的下一秒，车的瘪后胎就说明了自己不堪大用。于是选择了（看上去）更适合当天行程的价值8.6元的哈啰七天卡，此处是一个伏笔。</p><p>在出门的过程中，洗杯子先生认为自己的车需要重买，于是以五十块把车当场抛售给了乐得如此的cj——至于cj要花多少个五十块才能修好这辆车，此乃后话。</p><p>骑至金鹰附近借洗手间休整后，洗杯子先生突然发现，七天卡的权益不同于高贵的两小时无限次的月卡，单次最长时间其实只有30min——发现这件事的时候，已经37min后了，于是支出+1元。</p><p>此后订了闹钟，每半小时休整一次更新哈啰时间，最终在数次导航cj的偏航之后抵达了目的地——某不知名的夜不落食物街道。尽管当时已经近凌晨四点，街边小摊和相当多的临街店铺还在营业。随机选择了一家幸运早餐店作为补给。虽然选择了这家店的cj并没有吃，价格算得上低廉，味道也不差。</p><p>吃饱喝足之后再次上路，弹出的消息却是“您的哈啰权益已过期”，经过仔细确认和休整次数的回忆，三人惊喜的发现没有麻麻的哈啰的七天卡，是七天五次，反复开关最终提前刷爆了额度——不过其实还有三次助力车，但是南京压根没有助力车。于是洗杯子先生进入了今日第不知道几绷并表达了对哈啰的亲切问候。</p><p>尽管如此，限于有人骑自己的车来，还是没办法打车，又“骑都骑了”，最终继续选择哈啰上路。“这次要不你就全程开得了别开卡了？”“开了，因为我发现续卡只要4.1元。”——这 绝 对 是 消 费 陷 阱。</p><p>返程途中还是继续保持三十分钟一停的规律……吗？在某个三十分钟后试图休整的洗杯子先生遇到了全新的滑铁卢，哈啰单车颇为别出心裁将运营区挖了个洞——尽管来时我们走过相同的路，但是来时恰巧避开了这里休整。此处我们位于洞中，最近的回运营区重置时长的方式是倒车，但显然，倒车对于这种骑行还是太残忍了，最终骑到了路线经过的下一个运营区，换句话说，支出+1元。</p><p>总之最终先到了KFC吃cj的早餐，又到了金鹰711与起得早得过头的kakaa会合进行了一波消费。消费过后，尽管kakaa的后座仍可以坐人，但是一方面，“既然追求骑行，不如贯彻到底”，cj和洗杯子先生还是选择骑行；另一方面“自己的不爽固然令人难受，但同行人的舒适更加令人揪心”，被cj和洗杯子先生否决了“骑一辆更舒适的车这样自己可以顺势坐kakaa后座”的提议的祁念同学终究继续骑行。</p><p>最终四人从西门进校，进校后的第一件事是更换至自己具有高贵的电动车小蓝月卡的座驾，并放言“现在有两个人舒服了”。</p><p>舒服挺好，如果剩下的六次助力车次数能在七天内用完就更好了（笑）</p><blockquote><p>祁念: 其实返程cj提过从南京站走从钟山南侧回来，被两个人同时否了</p><p>洗先生: *绝对会死的*</p><p>祁念: *绝对会死的*</p></blockquote><hr><p>《厕所篇》<br>不知道为什么当天在厕所处的笑点如此之多，大概人类还是需要厕所。</p><p>在去查看洗杯子先生的公路车近况之前，cj提过一次用教学楼洗手间，可能是公路车的现况太过好笑且震撼，也可能是被冷风把脑壳吹不清醒了，三人直接出门前往晓庄了。</p><p>鉴于出门前校内711恐怖长队现状，祁念提出可去金鹰711逛一圈看看情况，于是稍微变更了一下路线经由金鹰前往目的地。抵达711并购入水补给之后，询问711店员附近的洗手间，店员答曰海底捞，于是出门前往海底捞借用厕所。</p><p>洗杯子先生认为金鹰有一家营业的酒店，上次的23：00左右他仍然有走过南侧的某条路。而具有丰富的阴间时间金鹰海底捞经验的cj认为不然，曾经有幸体验阴间时间海底捞的祁念也认为不然。于是前往金鹰北侧，提车后，洗杯子先生于此时发现哈啰七天卡权益打骨折，祁念同学正在看热闹。</p><p>一抬头cj已然消失，然而东北侧门实则已锁，并不熟悉夜半金鹰的二人确认了半天此路不通，跟着一般通过的路人，找到了略靠西北侧的可用门，并在电梯间遇到了已经用过厕所下楼的cj。什么叫做经验丰富啊[战术后仰.jpg]总之略等了一手之后，三人继续踏上行程。</p><p>在中途的某次停车休整时，路旁十字路口拐角有一间装修十分厕所的建筑，但是它的气味不足又弥补了这一部分。适逢cj正在查询消费记录和地图，好奇心绕行半圈以后发现，这确实是公共厕所，并且门前还有貌似已经收摊的夜市。[如果一间建筑长得像厕所，位置像厕所，那它就是厕所.jpg]</p><p>时间一路快进到抵达大成名店的KFC吃完早餐之后，cj惊喜发现此间KFC的厕所是坏的。在KFC店员和大成名店内部员工的指路下找到了大成名店一楼的厕所——尽管在数米开外，奇妙的气味已经让人有了敬而远之的想法。于是祁念和洗杯子同学一同在外等候cj，而cj在出来以后分享了自己与鼠鼠（rat而非mouse版）在厕所相见的趣闻。</p><p>还好没去。</p><hr><p>鉴于剩下的几篇跳票太久了，作者自己记性不太好。所以还是试图自己写了。</p><p>TODO：车载音响</p><hr><p>《消费篇》</p><p>说起来，本次夜骑正是从一场未遂的711开始的。在吃完上一顿后，打车回来的三人准备看一眼校内711的营业情况。洗杯子先生认为，应该没有那么多人无聊&#x2F;精力旺盛到半夜起来去排队给711刷业绩。但是真的在一点多的时候看到校内711的盛况之后傻眼了，本来打算捡个漏的，没想到我校学生还是太有精神了。鉴于三人都不想排队于是离开，就在这路上，三人草率地决定要夜骑——去往cj记忆中的某一个夜市。</p><p>离开学校不久，三人打算去瞧一瞧金鹰的711是否有活动，于是提前进行了一个拐弯。当711出现在眼前的时候，三人惊喜地发现：不但有活动，而且还没人排队（果然大学生是这个世界上最有精神的群体）。三人决定在711进行一些液体补给，并在黎明时分返回到这里进行一波抢购。</p><p>转眼目的地已然到达，夜市一条街除了两边的商铺开着，马路中间也各种流动摊贩，还有在路中间支起了帐篷的临时馆子，繁华程度让在南京生活了快24年的洗杯子先生表示活久见——毕竟是完全没有夜生活的城市。三人略犹豫一会儿后，决定去吃一家早餐店，此时大约是三四点的样子。</p><p>令人疑惑的是，祁念点了两碗粥——记忆中是赤豆元宵和皮蛋瘦肉粥。问及缘由的时候，说是喜欢又喝甜的又喝咸的。这也是从来没见过的操作。另外要吐槽的是，这家店的锅贴出奇地小。虽然看到价格是6块钱8个的时候就觉得份量应该不太大，但是这个实际大小很难让洗杯子先生将其与他认知中的锅贴联系在一起。当然，总的来说这家店是很便宜的，不仅感叹这居然是2024年的物价。cj什么也没有吃，表示他只是想来到这里，就满意了。</p><p>返程路上三人先经过了大成名店的KFC，cj在此作早餐补给，三人修整后与kakaa一道去了金鹰的711。6点时候的711已经人比较多了。在进门的时候，所有人都以为这里一共有两个711会员，所以应该会有4张117-60的券……吧？然而并没有：祁念似乎没有领券。洗杯子先生和kakaa买了一篮子，而祁念和cj拿了两篮子，到了结账的时候发现没券，不得不使用kakaa的另一张。cj得知充满了零食的那一篮无法结账后悲痛欲绝：您这是把大头给省掉了啊。在回校之后，发现似乎太多的同学都经历了挑选半天商品最后结账时发现没有券的惨剧，这下非常庆幸了——kakaa在那时候恰好醒了，并且恰好能够被call来，kakaa简直就是三人的救世主。</p><hr><p>首先复盘一下路线</p><p>走仙林大道</p><p><img src="image-20241118183037258.png" alt="image-20241118183037258"></p><p>在仙林中心站看到罗森未开门，补给失败决定右拐到金鹰711</p><p><img src="image-20241118183148372.png" alt="image-20241118183148372"></p><p>在金鹰湖滨天地左拐进入文苑路，一直到久客宾馆</p><p><img src="image-20241118183226843.png" alt="image-20241118183226843"></p><p>走仙隐北路向西北方向出了仙林街道</p><p><img src="image-20241118183330230.png" alt="image-20241118183330230"></p><p>经过仙尧路。路过车管所以及垃圾宁芜铁路</p><p><img src="image-20241118184523720.png" alt="image-20241118184523720"></p><p>接下来我认到了这个。因而我们一定走了尧新大道。</p><p><img src="image-20241118184615526.png" alt="image-20241118184615526"></p><img src="image-20241118185512486.png" alt="image-20241118185512486" style="zoom:33%;"><img src="image-20241118185700686.png" alt="image-20241118185700686" style="zoom: 33%;"><p>然后在煤炭地质局附近看到了一家KTV。我问有没有唱唱（）。此处左拐</p><p><img src="image-20241118185813078.png" alt="image-20241118185813078"></p><img src="image-20241118190043362.png" alt="image-20241118190043362" style="zoom:50%;"><p>去程燕尧路是一个下坡。有路牌指马鞍山，但是我也没找到附近有任何马鞍形状的山。</p><p><img src="image-20241118190143976.png" alt="image-20241118190143976"></p><p>可以看到街景这里的照片比较新，有这个外市非机动车禁止通行。再往前走点的老街景是没有的。</p><p><img src="image-20241118190308257.png" alt="image-20241118190308257"></p><p>此处对面就是G36宁洛高速入口了。</p><p><img src="image-20241118190523192.png" alt="image-20241118190523192"></p><p>总之向西南进入华银路。路过了丁家庄夜市，还有妇幼保健院。厕所篇亦有记载。</p><p><img src="image-20241118190945710.png" alt="image-20241118190945710"></p><p>之后是路过了兴卫村站。感叹道这是活在语音报站里的118路底站。在这里下坡一路狂奔，但是走错路了，在前面折返。返回来看到有遛狗的了都。</p><p><img src="image-20241118191203034.png" alt="image-20241118191203034"></p><p>嗯这条路就长这样。</p><p><img src="image-20241118191239926.png" alt="image-20241118191239926"></p><p>兴卫村站。以及左边疑似是碰到遛狗人的地方。</p><p><img src="image-20241118191355287.png" alt="image-20241118191355287"></p><p><img src="image-20241118191414464.png" alt="image-20241118191414464"></p><p>折返的路口</p><p><img src="image-20241118191511702.png" alt="image-20241118191511702"></p><p>回退，然后向西北（左拐）</p><p><img src="image-20241118191550281.png" alt="image-20241118191550281"></p><p>走寅春路。应该有经过瑞福大街</p><p><img src="image-20241118191724080.png" alt="image-20241118191724080"></p><p>只有向北一条路了。</p><p>![image-20241118183005612](20241108-trip.assets&#x2F;image-20241118183005612.png</p><p><img src="image-20241118184232297.png" alt="image-20241118184232297"></p><p>终点：寻苏味粥铺（万寿商业街）。在北边存在一个万寿购物中心的全天营业茶百道</p><p>南京大学仙林校区-仙林大道-学海路-文苑路-仙隐北路-仙尧路-尧新大道-燕尧路-华银路-华电北路(在兴兴路口前折返)-寅春路-万寿商业街</p><p><img src="image-20241118193851922.png" alt="image-20241118193851922"></p><p>万恶之源</p><p><img src="image-20241118193144552.png" alt="image-20241118193144552"></p><p>此地使我DNA动了，因为我就是在这里上的范如本的物理化学课。</p><p><img src="image-20241118193247303.png" alt="image-20241118193247303"></p><p>看到这个感觉无疑了。如果再蹦出两家吃过的店来那就完全正确了。</p><p><img src="image-20241118193345671.png" alt="image-20241118193345671"></p><p>我肯定吃过这个肯德基。我记得这家装修很特殊，比很多店都要精致一点。</p><p><img src="image-20241118193529084.png" alt="image-20241118193529084"></p><p>我每天好像就是在这个附近等车回家。</p><p><img src="image-20241118193605198.png" alt="image-20241118193605198"></p><p>这个上坡街景也对得上。</p><p><img src="image-20241118193646820.png" alt="image-20241118193646820"></p><p>就是这里。当时可以坐311到长途东站。</p><hr><blockquote><p>南京大学仙林校区-仙林大道-学海路-文苑路-仙隐北路-仙尧路-尧新大道-燕尧路-华银路-华电北路(在兴兴路口前折返)-寅春路-万寿商业街</p></blockquote><p>《旅途见闻篇》</p><p>出发后不久，仍在仙林街道地界内的时候，经过了一个路口。此时cj触发了某种开关，停车下去开始拍照：眼前是一家名叫“久客宾馆”的店。笔者已经忘记这里有什么渊源，但是“久客”的发音类似于joker，大约如此。此处三人进行了一次没素质的闯红灯行为。</p><p>骑行的路线是一路向西出仙林街道，穿过尧化街道到达迈皋桥街道的万寿商业街。实际上一开始说是去晓庄，但其实原本的目标就是去那条商业街。</p><p>到了仙隐北路的尽头。此时洗杯子先生说，好像想起来这地方了。路口的右手边是题了“仙林”大字的界碑。再往前就是见过很多次的白金汉爵酒店。此处是很多南京考驾照的人都会路过的地方，因为再往前面走走就是车管所和尧新考场了。仙尧路横跨了多条铁路线，其中就有臭名昭著的，多年来不断影响南京市地铁线建设的，计划搬迁却迟迟没有开工的宁芜铁路。当然春夏之间，这铁路线上的风景还是很不错的。</p><p>仙尧路的后半段穿过了一片公园。一个十字路口的四边都是丛丛的森林，难免产生一种深邃神秘的感觉。</p><p>过了尧新大道，迎来的是燕尧路一段巨大的下坡。三人都默不作声，在这里尽情利用地形加速。到了尽头，看到路牌上写着大大的“马鞍山”，令人费解。</p><p>左拐就是华银路了。此路名祁念非常熟悉，因此留影。这条路也非常有节目效果。一是在《厕所篇》中提到的长得像厕所的厕所以及夜市；一是被洗杯子先生去程和回程都捕捉到的红绿灯同时亮的红绿灯。</p><p>顺着路的方向进入华电北路，又是一段强劲的下坡，三人享受着下坡一时爽，直到cj意识到好像走错路了。在与兴兴路交会的路口停下车，一阵理智的查找之后决定：原路回退！回去可就是上坡了……</p><p>上坡路上碰到了半夜的遛狗人，因为是大型犬，所以并没有允许祁念凑近。笔者忘记是什么狗了。</p><p>左拐走寅春路，直到一个尽头，在那里，路的两边都是开着的饭店，我们意识到这就是cj提到的夜市了，新世界正在三人面前。</p><p>返程。笔者唯一记得的就是金鹰的未命名湖泊上飘着的水雾。</p><hr><p>《尾声》</p><p>四人回到了他们忠实的412。cj使用工作室的睡觉装备进行休息；祁念有培训暂时不能休息；洗杯子先生决定回宿舍睡觉；而kakaa已经睡了一夜不需要休息。大家各奔东南西北。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>性别意识-理性 allegro</title>
      <link href="/20241104-relationship/"/>
      <url>/20241104-relationship/</url>
      
        <content type="html"><![CDATA[<p>正是在对于差异的认知当中——此处的差异指的是对具体交际当中的人而非一种概念上的认识的差异——人才在交往中寻见一种乐趣。因为其中包含了一种事物发展方向的潜能。</p><p>而其中最乐见的恐怕是性别差异。古往今来有不少女扮男装并在长久的相处之后对性别进行重新发现的故事。例如梁祝；例如木兰辞。谜底揭晓的一刻，新的可能性，或者说得更加物化一点，新的选项就出现了。</p><p>其中所暗喻的是什么？长久相处这个环节只是故事当中使用的夸张手段，以凸显出那个性别意识的到来的震惊。事实上性别意识是无处不在涌现的。我想这些故事中都包含了这样一层意思：如果直白地告诉你有一个女性在你的面前，然后你意识到那是一个女性，这样稀松平常的事情并不会引发你对“性别意识”这件事的反思；那好，我就先告诉你她是个男的，再给出真相。这样性别意识涌现的瞬间就被放大了，人的态度会在一瞬间发生变化。</p><p>如果看到这里您应激了，想说自己根本不会有任何波澜，自己对男性女性是一视同仁的，那么您一定是完全未经性化的主体，也就不会成为这篇文章的读者。反过来说，您非常害怕自己被人指出无法对男女性别一视同仁，只能通过反驳的方式自我标榜一下。</p><p>写这段也是终于意识到我有一小撮读者了，会考虑读者对我有期待，而我对读者也有预期，预期读者会是尚未进化掉动物性的 Homo Sapiens Sapiens (现代人类)。为什么动物性如此重要？我临时想到一个简单的二分法，但是刀法不是很精湛：社会化的部分是工具理性，是世界机器运转的关节；未社会化的剩余（欲望）是驱动力，是根本的目的。</p><p>不过这听起来很掉价。不是想说人根本就是为了生物冲动才活在这世界上，我始终认为意识是物质世界将其自身溶化为一种理智的中介，人一定会追求理性当中的无条件者，即一切观念存在的原因。这不仅是一项崇高的事业，也是人的生物本能的一种高阶的表现。理性就这样从“看似的”非理性当中孕育出来。</p><p>更进一步，Willingness 当然是一种理性。婴儿哭哭啼啼需要人哄，也是理性的作用。类比的话，我们无法在非图灵完备的机器上实现一种图灵完备的语言。从非理性上能长出理性来吗？人能够产生理性，只能说明生物冲动虽然看起来是非理性的，但其中含有完整的“理性的潜能”。简单的晶体管几乎什么都不能做，但它们堆起来并且输入程序，仿佛就能思考。</p><p>我缝完了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11月4日纸质稿遗失的②。密码是88888888</title>
      <link href="/20241104-disappeared/"/>
      <url>/20241104-disappeared/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d294e764122956503f89c311d2568bd54be370c97d5ffbd262052ac5580c2e4">346518f25371ed5bd356f6b975c718b10b447f069f24e3eb1dff358858fbb02e6132f4398a81a590a39cf23c0e7e477e5a10f54bce3d5ba6675fd96e8932c25c9ab0440beb9bfe3e5b2fe134c00fa1f0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摸</title>
      <link href="/20241104-slacking/"/>
      <url>/20241104-slacking/</url>
      
        <content type="html"><![CDATA[<p>科研处于一种停滞的状态。我就说真不应该读这个研究生。接下来一段时间要有实质性的进展，但这真的可能吗，在得了痴呆症的情况下？</p><p>我也不知道我的心思到底在哪里，总之飘着。可能是怕手头这点东西到最后并不会有好的成效，也可能是怕不能按照预期的方式工作。但总而言之我不想做这个。我并不想处理这类复杂的要高强度动脑的知识。可能只想唱唱歌，做做数独——甚至有的时候做数独都会感觉累；养养花，看点好看的，吃点好吃的，体验很多不一样的事情。比待在实验室里撸代码更有成就感。</p><p>大概是哪怕平时感到微不足道的成就也大于在科研上做出了什么，毕竟与人交互的反馈是大于与物质世界交互的反馈的。</p><p>我认为我心理上是健康的，但是一提到工作就不太健康了，这是我的困境。反过来说如果我希望工作有所进展的话，是不是就需要自觉放弃一点心理健康程度？</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于穿衣这件事情，有一些不成熟的想法</title>
      <link href="/20241024-night/"/>
      <url>/20241024-night/</url>
      
        <content type="html"><![CDATA[<p>自从看了 JOJO 时尚考之后，我就再也停不下来关注这些时装品牌了。虽然现在还很不容易看出一场show的主题，也说不出每个look到底有哪些设计元素，但总之能够看到服装，尤其是男装，并不是以前所想的那么沉闷的主体。当然到了这里也应当说，也许女装当中的设计随便抖一抖撒到男装上，都能做出许多新鲜的东西了。</p><p>第一推荐的时尚博主是 <a href="https://space.bilibili.com/353368172">AHALOLO-Bilibili</a>。也许是在中文互联网上最容易接触到的最前沿的，并且是解读过的时装咨询。两位主持人自身无论是知识素养还是外形条件都足够打了。</p><p>当然作为学生党肯定是买不起奢侈品的。但是也有不少方法可以借鉴，而不会停留在观看</p><ul><li><p>挑选认为好看，有意思的单品，并去找平替</p></li><li><p>一些小细节&#x2F;装饰可以从基础款手动改出来</p></li><li><p>看一场秀&#x2F;一件单品的思路，然后在自己搭配时反复强调</p></li></ul><p>有的时候也许重要的不是喜欢什么风格，喜欢什么单品。而是“我”如何让这件单品在我身上变得更合理。从衣服装饰人变成人去配合衣服，听起来不可思议，但对于卖衣服的人来说，在他们拿到成衣设计的时候，这是一个基本思路。</p><p>买衣服一定要挑模特。首先没有模特效果图的衣服要慎买。但是为什么对于消费者来说，选择好的模特比选择看起来不那么专业的模特，也是合理的？如果模特本身的素质很牛逼，套个麻袋都好看，是不是容易让自己造成误判？</p><p>我的思路是这样的：对于同一家店，选模特与摄影的审美（能力）与其服装设计的审美（能力）几乎是匹配的。这意味着如果模特图的效果就很差，那么一定是在某个审美的环节除了问题。这样你还能够相信他们的衣服吗？假如衣服确是设计得精良，那么设计者一定不会允许在最终呈现效果上打了折扣。</p><p>对于时装品牌，除了衣服本身的素质以外，秀场也会非常在乎 styling。现代的模特们已经几乎不走台步了，然而谁也都能感受到，每一场每一场之间，随着主题的不同，模特们的步伐，神态etc都是贴着场景的需要走的。</p><p>穿衣这件事情，其目的本身就是去呈现一种感觉。服装设计是固定的，因而最大的变量还是人本身。</p><p>「观察」是掌握美的第一能力。</p>]]></content>
      
      
      <categories>
          
          <category> 时尚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二版置顶</title>
      <link href="/20241023-top/"/>
      <url>/20241023-top/</url>
      
        <content type="html"><![CDATA[<p>最近来看的人变多了，正好随手调整一下内容。</p><p>人无法对他写下的文字完全忠实。事实上我最近在录入以前的手写稿时，也有大量删改。19-22的册子看起来写了不少，但最终进入到这里的只有寥寥几篇：写的时候完全不讲究，事后自己去读的时候只有捂脸。这也算我本人这一时期的特色了。然而我还是希望“尽量忠实”，尤其是最近一年我觉得我在这方面做得不错。23年8月-24年7月的手写部分，除了一些涉及他人隐私的地方我不得不使用代号以外我几乎是原封不动地录入了。有可能是因为距离现在的我并不遥远所以我对这些文字大体上满意。</p><p>随手浏览一下文章列表，偶然会有几个月的沉寂期。19年以前的部分在考虑补，高中写的东西的确不少；20春-22春夏我的个人生活几乎是停滞的，因为那段时间包含了我状态最差的时候，最繁忙的时候，以及最无所事事的时候，所以就连纸质日记也没有几篇。仔细想来，爆发期其实就是22年秋冬的一段dramatic的感情，之后几乎每个月都有思考和记录。</p><p>介绍完博客的概况，该介绍一下自己了。如你所见这里有很多计算机相关的内容，偶尔也谈点哲学。然而相比于理性世界，我更在乎感性直观的冲击：视觉、味觉、嗅觉、听觉。所以正在努力成为味觉与嗅觉的美学家，从一个调酒师开始，探索饮品的各种可能。其他的成分只要再略读一两篇文字就明了了。</p><p>那么，如果您看到喜欢的文字并且愿意，可以在社交媒体上联系我（评论区并不会及时通知到我个人），这些反馈都会对我有很大帮助。</p><p>Tilnel 2024-10-23 06:42:15</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>和 Blue 的聊天记录</title>
      <link href="/20241023-chat/"/>
      <url>/20241023-chat/</url>
      
        <content type="html"><![CDATA[<p>Blue 0:07:47 我好喜欢半夜在外面乱转啊 完全不想上楼回家</p><p>Tilnel 0:08:18 无数次夜游玄武湖了 回家&#x2F;回宿舍好无聊</p><p>Blue 0:11:05 昨天&#x2F;前天去了四种宗教的宗教场所（门口）</p><p>Blue 0:16:19</p><blockquote><p>Boss 0:09:11 哎 我真的活着吗</p></blockquote><p>连我都活着 您可比我热爱生活多了</p><p>Blue 0:16:49 我想 如果能被人感知到的话 大概是确实活在世上的</p><p>Blue 0:17:44 比如要是我说话没人理的话 我的存在就弱一分</p><p>Blushed 0:18:01 我配热爱生活吗</p><p>Blue 0:18:12 您在做对世界产生变化的事</p><p>Blue 0:18:28 说明您激烈地欲继续生活</p><p>Boss 0:18:59 我现在不想变化了</p><p>Blushed 0:19:03 也许只是激烈地想证明自己活着，或者一些其他事情</p><p>Blue 0:20:15 您还在关注世界</p><p>Blue 0:21:02 说明您大概还想深入生活的更多可能性</p><p>Blue 0:22:00 （天哪 不躺着的半夜真是有魔力吧 我这辈子讲过这么积极的话吗</p><p>Blushed 0:22:16</p><blockquote><p>Blue 0:21:02 说明您大概还想深入生活的更多可能性</p></blockquote><p>我不关注这个世界，也不胆敢深入什么可能性。我只是由于感到一些责任或者牵绊，还不能就此放手。</p><p>Blue 0:23:11 我此刻竟觉得 如果我在过去的某些时候能说这些话 或许我的生命能有翻天覆地的变化呢</p><p>Tilnel 0:24:40 每个人的生命是有自己的节奏的</p><p>Tilnel 0:25:11 有些事情就是会迟到，您可能会因此觉得有点委屈</p><p>Blue 0:25:29</p><blockquote><p>我不关注这个世界，也不胆敢深入什么可能性。我只是由于感到一些责任或者牵绊，还不能就此放手。</p></blockquote><p>我很多时候想着 我要爱这些牵绊 这样我就暂时没有必要惶恐 仅仅一刻也好 我只是想要顺从他们 让他们把我安全地缚在这地上</p><p>Tilnel 0:26:55 这样是对的</p><hr><p>Blue 0:27:57 我有点开心了</p><p>Blue 0:28:12 去便利店看看有什么啤酒</p><p>Tilnel 0:29:20 我们来到这里都是为了寻找更多的羁绊。我们享受这种受迫而不得不做某些事的感觉，因为我们自己是从来没有什么必须要做的事的</p><p>Blushed 0:30:10 为什么开心的时候要饮用酒精呢</p><p>Blushed 0:30:23 为什么难过的时候要饮用酒精呢</p><p>Blue 0:31:18 不知道</p><p>Blue 0:31:30 但是喝啥呢</p><p>Tilnel 0:31:32 为了去见邪恶的酒神！</p><p>Blue 0:31:38<br><img src="image-20241023044758338.png" alt="image-20241023044758338" style="zoom:50%;"></p><p>Tilnel 0:31:39 喝Asahi</p><p>Blue 0:32:24 我记得21年夏天我在摇联的活动上喝asahi</p><p>Blue 0:32:55 有个老哥叫我别一个人喝闷酒</p><p>Blue 0:33:47 然后我就混入了他们其中</p><p>Blue 0:33:58 开始乱叫乱跳</p><p>Blue 0:34:46 现在想想感觉就像那个一夜情</p><p>Blue 0:35:03 后来我也从来没有认识过他们其中的任何人</p><p>Blushed 0:36:10 人生也许就是这样子的</p><p>Blushed 0:36:26 会在某段时间和一些人聚在一起做某些事情</p><p>Blushed 0:36:48 后来再也没有认识甚至见过他们其中的任何人了</p><p>Blushed 0:37:21 最后认识的人也会不认识，见过的人也不会再见</p><p>Blue 0:37:32 有什么不好呢</p><hr><p>Blushed 0:38:42 我为什么戒酒呢？</p><p>Tilnel 0:39:27 不想度过一个荒唐的夜晚</p><p>Tilnel 0:39:44 但其实不喝酒的每天也都是很荒唐的</p><p>Blue 0:40:16 我手里这罐asahi是500ml的</p><p>Blue 0:40:33 我记得那年我喝的是1500的</p><p>Blue 0:40:45 别人都倒出来分着喝的</p><p>Blue 0:40:58 但是我对嘴了</p><p>Blue 0:41:11 而且也没有和我分酒喝的人</p><p>Blushed 0:41:22 因为如果我主动找酒喝且酒足够的话，我一定会喝醉。因为那就是我想要的。但是失去意识的时候并不会停止讲话或者做事。</p><p>Blushed 0:41:44 我难以承受这些无意识行为带来的后果</p><p>Tilnel 0:43:10 没被朋友拍成大型纪录片就不错了（</p><p>Blushed 0:43:12 我可以有意识地去做荒唐的事情，那是我选择的；但我害怕无意识地去做荒唐的事情，因为我没有经历过程，却不得不接受后果</p><p>Blushed 0:43:27 也许已经被拍成大型纪录片了</p><p>Blue 0:43:44 真的不得不接受后果吗</p><p>Tilnel 0:44:08 我认为无意识地表达点什么也挺好的</p><p>Tilnel 0:44:27 如果有所记录的话你还可以用来解读自己</p><p>Blue 0:44:50 我其实挺期待看到无意识的自己的</p><p>Blushed 0:44:56 但是我并不是自言自语</p><p>Blushed 0:45:05 我是在和别人说话</p><p>Blue 0:45:32 听我爸妈说我睡着了之后就像是死了 不会动当然也不会说话</p><p>Blue 0:45:41 我觉得挺没意思的</p><hr><p>Blushed 0:46:27 当我输出一些给自己看的文本的时候，我发现充满了情绪垃圾</p><p>Blushed 0:47:10 我曾经向某人展示过我的精神废料，后来人家就再也没有理我了</p><p>Blue 0:48:09 我常常觉得我不知道什么是我</p><p>Blushed 0:48:15 与其说我的写作能力在下降，毋宁说大学以来我作为人的能力就在退化</p><p>Tilnel 0:48:18 写blog吧（</p><p>Tilnel 0:48:39 被动地展示精神废料</p><p>Blue 0:48:45 我想如果把理智剥离的话 我或许能知道什么是我吧</p><p>Blushed 0:48:47 说实话，我并不知道技术上怎么去维护blog</p><p>Blushed 0:49:02 我不知道如何搭建个人主页</p><p>Tilnel 0:49:07 开个博客园，etc</p><p>Tilnel 0:49:51 然后在一些角落里若无其事地挂个链接</p><p>Blue 0:50:16 我没啥写作能力</p><p>Blue 0:50:37 积了很多很多500字的东西</p><p>Blue 0:50:51 最多也就能连续写2000</p><p>Blushed 0:50:53 好久没有写作了</p><p>Tilnel 0:51:05 我的博客大多都是笔在纸上滑到哪里算哪里，然后照着敲进电脑</p><p>Tilnel 0:51:15 大多都是零散的</p><p>Tilnel 0:51:34 重要的不是连续的文字生成</p><p>Blue 0:51:43 而且我还喜欢讲事情之前前摇</p><p>Tilnel 0:51:43 而是你写文字当中的犹豫和沉默</p><p>Blue 0:52:02 所以基本还没摇完就不想写了</p><p>Blue 0:52:15 我感觉我比较适合发微博</p><p>Blue 0:52:26 一句话暴论</p><p>Blue 0:52:45 妈的 想把手机扔进河里</p><p>Tilnel 0:53:10 我也常有一些暴力冲动（</p><p>Tilnel 0:53:20 比如躺床上就会想着把床板拍烂</p><p>Blushed 0:53:31 也许确实可以考虑搭建一个个人主页了</p><p>Blushed 0:53:46 有一些protocol还没有系统地整理</p><p>Blushed 0:54:10 一直没有动力去做这件事情</p><p>Blue 0:54:12 我躺床上的时候总想被钉在床上</p><p>Blushed 0:54:19 常常感觉自己是个废物</p><p>Blue 0:54:40 很简单的</p><p>Blue 0:55:43 github.io</p><p>Tilnel 0:56:43 写一些markdown放在github里我觉得都够了（</p><p>Tilnel 0:57:10 讲究一个形式</p><p>Tilnel 0:57:49 甚至可以提issue评论</p><p>Blue 1:00:51</p><blockquote><p>Blue 1:00:51 我躺床上的时候总想被钉在床上</p></blockquote><p>想象被什么长兵贯穿心脏钉住</p><p>Tilnel 1:02:34</p><blockquote><p>Blue 1:00:51 想象被什么长兵贯穿心脏钉住 </p></blockquote><p>想保持对生活的热情可能真的需要自觉地去当一个剧情发动机</p><p>Blue 1:02:53 啊 月亮露出来了</p><p>Blue 1:03:10 云层上的风看起来很大</p><p>Tilnel 1:03:51 生活需要一点dramatic</p><p>Blue 1:04:15 唉 走路有点晃了 上楼喝吧</p><p>Tilnel 1:04:22 陪一杯（</p><p>Tilnel 1:06:27 我躺在床上会被恶灵附身</p><p>Blue 1:06:31 家里只有酸奶</p><p>Blue 1:06:31 啊 在电梯里喝没了</p><p>Boss 1:06:35 我在玉玉什么</p><p>Boss 1:06:36 我不知道</p><p>Tilnel 1:06:52 你在嫉妒</p><p>Tilnel 1:07:06 你在委屈</p><p>Tilnel 1:07:08 你在。。。</p><hr><p>Blue 1:09:48 我中学的时候晚上回家 我妈都会让我快吃饭 但是我从来就更喜欢用睡觉来抵抗饥饿</p><p>Blue 1:10:02 或者我其实根本感觉不到饥饿吧</p><p>Tilnel 1:10:10 我就不行，因为白天耗能太高了</p><p>Tilnel 1:10:15 中学的时候</p><p>Tilnel 1:10:30 我们中学的食堂又是一坨</p><p>Tilnel 1:10:39 经常夜里回家狼吞虎咽</p><p>Blue 1:11:12 哈哈 我中学食堂也</p><p>Tilnel 1:11:15 现在想想还是很神奇，也许高中才是人最脆弱的时候</p><p>Blue 1:11:21 甚至小学食堂也</p><p>Tilnel 1:11:37 我会因为被早饭粥烫到了就大哭（</p><p>Blue 1:11:47 所以我大概中午也不怎么吃</p><p>Blue 1:12:02 后来我妈退休了 他就天天中午给我送饭</p><p>Tilnel 1:12:57 真好，我得自带</p><p>Tilnel 1:13:55 高中只是强度大，但是现在事情实在变得复杂</p><p>Blue 1:14:12 唉</p><p>Tilnel 1:14:17 我真希望不带脑子生活</p><p>Blue 1:14:26 我大概是不配聊高中的</p><p>Blue 1:14:46 闭麦了</p><p>Tilnel 1:15:02 怎么寸止了</p><p>Tilnel 1:15:21 那就不聊高中！</p><p>Qin 1:15:28 大概是觉得保送生有点开</p><p>Twist 1:15:43 sbw的名字终于有我喝过的了</p><p>Tilnel 1:15:58 有喝过我做的这款吗</p><p>Blue 1:16:11 我也喝过</p><p>Tilnel 1:16:12 大言不惭，但是全南京第一</p><p>Blue 1:16:18 群友调的</p><p>Tilnel 1:17:01 所以为什么要摆摊呢</p><p>Qin 1:17:13 不是好玩吗</p><p>Tilnel 1:17:17 大概是我想主动当一个剧情发动机了</p><p>Blue 1:21:51 唉 躺下之后就不想说话了</p><p>Tilnel 1:22:01 您躺下之后会想什么</p><p>Blue 1:22:08 感觉我是个不称职的社畜</p><p>Tilnel 1:22:33 称不称职不是自己该考虑的（</p><p>Tilnel 1:22:44 老板觉得你好就是好</p><p>Blue 1:23:03 嗯</p><p>Blue 1:23:32 社畜一般都啥时候睡觉呢</p><p>Tilnel 1:23:52 这个点，或者两三点</p><p>Tilnel 1:24:04 要不问问吉良</p><p>Blue 1:24:06 五六点睡吧</p><p>Tilnel 1:24:14 吉良11点</p><p>Blue 1:25:31 上半年的时候 我在南京睡不好觉吃不下饭 在上海还行</p><p>Blue 1:25:44 现在在上海也不太行了</p><p>Blue 1:26:09 之前吃了一罐褪黑素软糖</p><p>Blue 1:26:14 真好吃啊</p><p>Tilnel 1:26:19 我感觉褪黑素这玩意</p><p>Blue 1:26:21 所以不敢吃了</p><p>Tilnel 1:26:27 让我睡醒之后也没精神</p><p>Tilnel 1:26:36 所以用了一次之后就再也没用过了</p><p>Tilnel 1:26:59 主要还是连吃两粒也没睡着</p><p>Blue 1:27:03</p><blockquote><p>Blue 1:26:14 真好吃啊</p></blockquote><p>“您真的没overdose吗？”</p><p>Blue 1:27:10 哈哈</p><p>Tilnel 1:27:15 不要碰od</p><p>Blue 1:27:19 我连着吃6粒</p><p>Tilnel 1:27:57 我买的是汤臣那个</p><p>Blue 1:28:04 但是旺仔qq糖真没他好吃</p><p>Tilnel 1:28:04 应该是没什么味道</p><p>Tilnel 1:28:32</p><blockquote><p>Tilnel 1:27:15 不要碰od</p></blockquote><p>算了我也不好说</p><p>Tilnel 1:28:38 我这是不是一种酒精od</p><p>Blue 1:29:07 唉 感觉我现在可能有点癫 所以说这些话</p><p>Tilnel 1:29:15 癫好</p><p>Tilnel 1:29:47 如果我能保持100g酒精的微醺状态并且不用开车，我觉得我身边的人都会幸福一点（</p><p>Tilnel 1:30:13 小嘴嘎嘎能讲</p><p>Qin 1:31:21 作为不喝酒精神状态就已经不太正常的选手</p><p>Blue 1:31:37 我不喝酒的时候精神状态很正常吗</p><p>Qin 1:31:43 我觉得还是不要再用酒精挑战我的精神状态下限</p><p>Blue 1:32:06 我想有些群友大概一直都能发现我不太正常</p><p>Blue 1:32:21 说到底 什么是正常呢</p><p>Tilnel 1:32:23 什么是正常</p><p>Qin 1:32:29 什么是正常呢</p><p>Tilnel 1:33:15 自己觉得好的状态就是好的</p><hr><p>Qin 1:34:29 一点半把宿管喊醒编个ID</p><p>Tilnel 1:34:50 其实真实ID也不会怎样</p><p>Otaku 1:35:35 哦对 您可以去计科楼824</p><p>Tilnel 1:35:54 824－9有一张可以躺的椅子（</p><p>Otaku 1:36:00 还有纸质读物</p><p>Qin 1:36:17</p><blockquote><p>Otaku 1:36:00 还有纸质读物</p></blockquote><p> 这下想去了</p><p>Tilnel 1:37:39 我恭维的纸质读物大多已经被我录进博客了</p><p>Tilnel 1:37:44 工位*</p><p>Qin 1:38:07 不对吧，中间有一段blog断更说是记笔记了</p><p>Tilnel 1:38:21 噢对</p><p>Qin 1:38:25 不会首字母缩写连连看确实缺乏一些乐趣（</p><p>Tilnel 1:38:27 也在工位上</p><p>Tilnel 1:38:41 您要盒谁我可以直接告诉您（</p><p>Qin 1:38:50 太诚实了以至于完全就是诱饵</p><p>Tilnel 1:39:09 诚实吗</p><p>Tilnel 1:39:23 我觉得还差一点</p><p>Qin 1:39:43 真有人能对自己的文字完全诚实吗</p><p>Tilnel 1:39:55 说出来的和想的事情之间有一道无法逾越的鸿沟</p><p>Tilnel 1:40:05 更别提发布版了</p><p>Tilnel 1:40:12 但我在尽量诚实</p><p>Qin 1:40:18 我不写这种东西的原因就是我对自己的文字大概不诚实</p><p>Tilnel 1:41:12 其实写作的最终的玩法就是咀嚼自己写作过程中犹豫不决的，避而不谈的部分</p><p>Tilnel 1:41:32 当然阅读的最终玩法也是这样（</p><p>Qin 1:42:13</p><blockquote><p>Tilnel 1:41:12 其实写作的最终的玩法就是咀嚼自己写作过程中犹豫不决的，避而不谈的部分</p></blockquote><p>问题是自己都没办法把真正犹豫不决的东西付诸纸上（</p><p>Tilnel 1:42:13 “你为什么没说，必定有诈！”</p><p>Tilnel 1:43:26</p><blockquote><p>Qin 1:42:13 问题是自己都没办法把真正犹豫不决的东西付诸纸上（</p></blockquote><p>只是走这样一个过程而已。那些平时没意识到但是写的时候犹豫不决的东西会在自己的心里留下痕迹</p><p>Tilnel 1:43:36 一种自我诊断法</p><p>Tilnel 1:43:55 真正有用的从来不是静态的文字</p><p>Tilnel 1:45:09 看到一道裂谷的时候，第一个想的会是裂谷是如何形成的，而不是周边的平原</p><p>Tilnel 1:47:06 因为人天生知道，这道惊为天人的奇观底下才蕴含着地球内部活动的最大动力</p><hr><p>Blue 1:47:34 谢谢大家 给我发了6年钥匙扣</p><p>Tilnel 1:48:07 唉 zijingbt</p><p>Tilnel 1:48:19 今天还在品鉴紫荆的遗产</p><p>Blue 1:51:51 这么多年了 还没真的看完girl’s guide</p><p>Tilnel 1:52:07 有这个，可惜用不上</p><p>Tilnel 1:52:16 因为不是 girl</p><p>Tilnel 1:53:09 当时紫荆预告关服，然后我匆忙地下载了很多资源，填满了所有的机械硬盘</p><p>Tilnel 1:54:04 可能信息量最大的还是一堆kindle的电子书合集</p><p>Tilnel 1:54:42 你说，我手里掌握了一辈子都读不完的精神文明，但是却觉得自己依然精神匮乏</p><p>Tilnel 1:54:51 是怎么回事呢</p><p>Qin 1:55:42</p><blockquote><p>Tilnel 1:54:42 你说，我手里掌握了一辈子都读不完的精神文明，但是却觉得自己依然精神匮乏</p></blockquote><p>应聘图书馆管理员能让自己变得精神富足吗</p><p>Tilnel 1:55:54 对啊，这是怎么回事呢（</p><p>Tilnel 1:57:56 关站的时候我还传了一份白色相簿2的游戏然后被拒了（</p><p>Blue 2:00:23 即使都读了 很多时候也只是六经注我 只能读到我能懂的东西</p><p>Tilnel 2:00:40 那我觉得没什么问题</p><p>Tilnel 2:00:53 很多东西就是单纯的没读</p><p>Tilnel 2:01:07 我借图书馆的书已经超期了</p><p>Blue 2:01:15 我也不知道 人从什么时候开始就接受不了新的思想了呢</p><p>Tilnel 2:01:16 9天</p><p>Blue 2:02:15 如果这个世界上所有尚未属于我的事物都已经不再能被我所认识 那我就觉得确实起离死不远了</p><p>Tilnel 2:03:32</p><blockquote><p>Blue 2:02:15<br>如果这个世界上所有尚未属于我的事物都已经不再能被我所认识 那我就觉得确实起离死不远了</p></blockquote><p>我现在已经改变目标了</p><p>Tilnel 2:03:41 我想要各种 好看的东西</p><p>Tilnel 2:04:08 胜过某种新奇的认识</p><p>Blue 2:04:46 我其实觉得新奇的认识是精神自虐</p><p>Tilnel 2:04:50 也许应该学服装设计</p><p>Blue 2:04:53 我大概喜欢这个</p><p>Tilnel 2:04:58 计科只是planB</p><p>Blue 2:05:21 喜欢把自己置于一个痛苦的位置上</p><p>Tilnel 2:05:44 明白。。。</p><p>Blue 2:05:55 然后对自己说 这都是你活该 思想配得上苦难</p><p>Tilnel 2:05:59 认识到新的东西是有阵痛的</p><p>Tilnel 2:06:22 很多曾经笃信的东西都打碎了重新考量</p><p>Tilnel 2:06:37 然后不接受退缩的自己，也不接受新的</p><p>Blue 2:07:02 我确实有许多没来由的信条</p><p>Tilnel 2:07:05 所以，《彷徨》</p><p>Blue 2:07:17 但是大部分时间我还是</p><p>Blue 2:07:30 痛于自己失去了信仰的能力</p><p>Blue 2:08:53 如果能甘愿顺从于一种神圣力量的话 大概能生活地更简单吧</p><p>Tilnel 2:08:58 现在处于一种，悬置的状态</p><p>Blue 2:09:09 甚至能感觉到被爱呢</p><p>Tilnel 2:09:11 没法判断任何东西</p><p>Tilnel 2:09:52 相应地，对于很多事情的接受度也虚假地提高了</p><p>Blue 2:10:03 我中学附近的基督新教教堂的匾上就写着类似于爱与信仰的事情</p><p>Blue 2:10:15 唉</p><p>Blue 2:10:40 论爱欲也没看完 pending一个多月了</p><p>Blue 2:10:51 我天天都在干什么</p><p>Tilnel 2:11:53 您可千万别</p><p>Tilnel 2:12:04 算了，我希望你不要</p><p>Blue 2:12:27 没事</p><p>Blue 2:12:38 我大概现在并不知道我在说啥</p><p>Tilnel 2:12:40 至少我希望我不要</p><p>Tilnel 2:13:11 总之我希望自己有一种信仰的能力，但是不要信仰任何东西</p><p>Tilnel 2:13:30 这样能保留一种潜能</p><hr><p>Blue 2:13:46 应该就是没在思考了 只是在把自己想过的事情读出来而已</p><p>Tilnel 2:14:05 我也是啊</p><p>Tilnel 2:14:27 还坐在阳台上喝呢</p><p>Tilnel 2:14:58 我可能已经复读这些东西一两年了</p><p>Blue 2:15:12 嗯</p><p>Blue 2:15:15 我也是吧</p><p>Blue 2:15:29 我不相信我这些话是没说过的</p><p>Tilnel 2:16:00 但总之我还相信一件事</p><p>Tilnel 2:16:20 就是这些话背后的原因可能就是非常简单的一件事</p><p>Tilnel 2:16:29 对于这些课题大概微不足道</p><p>Tilnel 2:17:10 那也许“幸福”就是微不足道的</p><hr><p>Blue 2:17:17</p><blockquote><p>Blue 2:15:29 我不相信我这些话是没说过的</p></blockquote><p>但是我挺好奇的 我在什么时候什么地点说什么话能得到谁的回应呢</p><p>Blue 2:17:48 毕竟大部分时候 是没有回应的</p><p>Tilnel 2:18:57 我会暗自期望一种没有回应的分支</p><p>Tilnel 2:19:25 任何形式上的回应可能都会触发一种短路</p><p>Tilnel 2:19:52 于是此处的答案就不是我自己的了</p><p>Tilnel 2:20:04 或者说，此处我就没有思考的机会了</p><p>Blue 2:20:15</p><blockquote><p>Tilnel 2:18:57 我会暗自期望一种没有回应的分支</p></blockquote><p>我也</p><p>Qin 2:20:21 那您期待的是自己说着说着想明白了吗</p><p>Blue 2:20:31 我想我说话的结局一定是不再说话</p><p>Tilnel 2:20:32 yep</p><p>Blue 2:20:44 但是我比较懦弱</p><p>Blue 2:21:21 我会想 如果是有强制力命令我不再说话就好了</p><p>Tilnel 2:21:33 我有一个暴论</p><p>Tilnel 2:21:47 就是人其实是畏惧自由的</p><p>Blue 2:21:48 这样我就可以把自己摆在受害者的位置上</p><p>Tilnel 2:21:59 因为自由代表自甘风险</p><p>Tilnel 2:22:08</p><blockquote><p>Blue 2:21:48 这样我就可以把自己摆在受害者的位置上</p></blockquote><p>和你这句差不多</p><p>Tilnel 2:22:50 如果遵从某种命令，那么错误就可以归咎于某种异己的力量</p><p>Tilnel 2:23:09 完全的自由就是另一回事</p><p>Blue 2:23:10</p><blockquote><p>Blue 2024&#x2F;8&#x2F;8 22:39:49 我就是想要得到一个貌似权威的、先验正确的规范 然后他全然地战胜了我 我就能轻松地放弃思考 屈服于他 并把不思考的罪孽和逃避的责任推给他…</p></blockquote><p>。</p><hr><p>Tilnel 2:23:25 唉</p><p>Tilnel 2:23:31 所以我是M（</p><p>Tilnel 2:23:41 而且这世界上M多S少</p><p>Blue 2:23:48 我是m吗</p><p>Blue 2:23:51 我不知道</p><p>Blue 2:24:02 也有群友说过我是s</p><p>Blue 2:24:22 还有群友说过什么别的</p><p>Tilnel 2:26:47 S其实是世界的M</p><p>Tilnel 2:27:05 祂是世界施虐的代行者</p><p>Tilnel 2:27:34 所有人都是M罢了（</p><p>Blue 2:27:46 唉</p><p>Tilnel 2:27:49 感觉说得有点多了</p><p>Tilnel 2:28:06 喝得也有点多了</p><p>Blue 2:28:15 想起昨天早上 明明起得很早</p><p>Qin 2:28:34</p><blockquote><p>Tilnel 2:27:34 所有人都是M罢了（</p></blockquote><p>前两天和朋友聊过，我觉得这种逻辑推完了所有人都是M，反过来讲所有人都不是M</p><p>Blue 2:28:42 还是把自己按在床上做了20min清明梦</p><p>Tilnel 2:28:56</p><blockquote><p>Qin 2:28:34 前两天和朋友聊过，我觉得这种逻辑推完了所有人都是M，反过来讲所有人都不是M</p></blockquote><p>完全可以这么说</p><p>Blue 2:29:05 上班的路上整个人都还是恍惚的</p><p>Tilnel 2:29:46 所以是“逻辑”自身有问题</p><hr><p>Blue 2:29:57</p><blockquote><p>Blue 2:28:42 还是把自己按在床上做了20min清明梦</p></blockquote><p>虽然这很亵渎但是 我实在喜欢做神的感觉</p><p>Tilnel 2:29:58 我在说什么</p><p>Blue 2:30:25 但是又觉得作为人是不能贪恋这个的</p><p>Blue 2:30:29 这是危险的</p><p>Tilnel 2:30:34 好</p><p>Qin 2:30:37 没事，你有一半的意思是酒精代驾的</p><p>Qin 2:30:54 适合文艺创作的状态</p><p>Qin 2:31:01</p><blockquote><p>Qin 2:30:37 没事，你有一半的意思是酒精代驾的</p></blockquote><p>意识*</p><p>Tilnel 2:31:06 酒精可能不是代驾</p><p>Tilnel 2:31:22 我才是代驾（</p><p>Blue 2:31:29</p><blockquote><p>Blue 2:29:57 虽然这很亵渎但是 我实在喜欢做神的感觉</p></blockquote><p>我太自大了</p><p>Tilnel 2:31:35 是我替世界说</p><p>Tilnel 2:31:52 感觉好糟糕啊</p><hr><p>Qin 2:32:13 自大的人会说自己自大吗</p><p>Tilnel 2:32:18</p><blockquote><p>Blue 2:31:29 我太自大了</p></blockquote><p>我倒挺羡慕的？</p><p>Blue 2:33:01 我有一个信念吧</p><p>Blue 2:33:12 唯有矛盾的才是真实的</p><p>Blue 2:33:36 所以因为我是自卑的所以我是自大的</p><p>Qin 2:34:03 我认可自卑自大二象性</p><p>Blue 2:34:06 因为我的自我意识过强 所以我欲抹掉我的存在</p><p>Blue 2:34:35 他们只能同时为真 虽然看上去是矛盾的</p><p>Tilnel 2:35:00 抹平是不符合能量最低原则的（</p><p>Blue 2:35:07 唉 我觉得我并不是酒精代驾</p><p>Blue 2:35:25 我和不少人平时说话估计就这样</p><p>Tilnel 2:35:59 有一个差异蹦出来才是最自然的</p><p>Tilnel 2:36:29 你已经完成一种循环了</p><p>Sakuran 2:37:14</p><blockquote><p>Qin 2:32:13 自大的人会说自己自大吗</p></blockquote><p>或许会的</p><p>Sakuran 2:37:25 自大的人不一定认识不自己自大</p><p>Sakuran 2:37:52 有的时候会意识到自己的自大，但在无意识间又会让自己的自大气氛弥散出来</p><p>Tilnel 2:38:01 但是一个自大的人只认识得到自己的自大这件事是不可能的</p><p>Tilnel 2:38:13 因为认识到自己的自大的同时就已经蕴含了自卑了（</p><p>Blue 2:38:26 唉</p><p>Tilnel 2:38:30 就是，我在这里装什么呢</p><p>Tilnel 2:38:36 这种感觉</p><p>Blue 2:38:46 好想今天早上也做清明梦</p><p>Tilnel 2:38:57 他同时认识到的是自己是一只纸老虎</p><p>Sakuran 2:40:28</p><blockquote><p>Tilnel 2:38:30 就是，我在这里装什么呢</p></blockquote><p>太对了</p><p>Tilnel 2:40:53 恰如此时此刻（</p><p>Blue 2:40:56 我刚把钟补回来 迟到还得补</p><p>Blue 2:41:32</p><blockquote><p>Tilnel 2:38:57<br>他同时认识到的是自己是一只纸老虎</p></blockquote><p>怎么说呢</p><p>Tilnel 2:41:39</p><blockquote><p>Blue 2:40:56 我刚把钟补回来 迟到还得补</p></blockquote><p>我觉得就算放您沉默了您还得再想几个钟头</p><p>Tilnel 2:41:43 所以干脆继续聊</p><p>Blue 2:41:49 世界上谁不是纸老虎呢</p><p>Tilnel 2:42:15</p><blockquote><p>Blue 2:41:49 世界上谁不是纸老虎呢</p></blockquote><p>我也会这样想</p><p>Blue 2:42:16 唉</p><p>Blue 2:42:30 我想展示一下我的输入法</p><p>Tilnel 2:42:45 但是人与人直接相对的时候就很容易被击倒（</p><p>Blue 2:43:03 有神秘的联想词</p><p><img src="image-20241023051500751.png" alt="image-20241023051500751" style="zoom:25%;"><img src="image-20241023051513574.png" alt="image-20241023051513574" style="zoom:25%;"></p><p>Tilnel 2:43:42 哈哈哈哈</p><p>Sakuran 2:43:42</p><blockquote><p>Tilnel 2:42:45 但是人与人直接相对的时候就很容易被击倒（</p></blockquote><p>而我常常是被击倒的</p><p>Sakuran 2:44:03 我应该少讲点b话显然</p><p>Tilnel 2:44:06</p><blockquote><p>Sakuran 2:43:42 而我常常是被击倒的</p></blockquote><p>也许是双方都被击倒</p><p>Tilnel 2:44:20 我偶尔觉得您的态度挺好的</p><p>Tilnel 2:44:34 就是一种能一直说下去的感觉</p><p>Tilnel 2:44:54 不管不顾</p><p>Blue 2:44:57 我挺嫉妒Sakuran桑的 我猜</p><p>Tilnel 2:45:02 我要是这样会有多开朗</p><p>Tilnel 2:45:08 不敢相信</p><p>Tilnel 2:45:26 哪怕冷场</p><p>Tilnel 2:45:48</p><blockquote><p>Tilnel 2:44:20 我偶尔觉得您的态度挺好的</p></blockquote><p>不是偶尔，是骤然</p><p>Sakuran 2:46:26 我发觉这是我在线上的社交在进了大学后奇迹般地搬运到了线下</p><p>Blue 2:46:32 我猜我对各位群友的任何负面情绪其实都是酸 而已</p><p>Tilnel 2:46:40</p><blockquote><p>Blue 2:46:32 我猜我对各位群友的任何负面情绪其实都是酸 而已</p></blockquote><p>我觉得没问题</p><p>Tilnel 2:46:44 我一直认为</p><p>Sakuran 2:46:53 因为我在高中时线下呈现出这样的状态是难以置信的</p><p>Tilnel 2:46:54 嫉妒，是我活下去的第一推动力（</p><p>Blue 2:46:58 但是我其实生活得客观上很幸福了</p><p>Blue 2:47:09 所以我好像也没资格酸</p><p>Sakuran 2:47:25 我不知道我的动力是啥，或许是享乐吧</p><hr><p>Tilnel 2:47:55</p><blockquote><p>Blue 2:46:58 但是我其实生活得客观上很幸福了</p></blockquote><p>你们难道都是完全的唯物主义者吗</p><p>Blue 2:48:11 您觉得我难道是吗？</p><p>Tilnel 2:48:13 至少我感觉我是主观唯心的</p><p>Tilnel 2:48:30</p><blockquote><p>Blue 2:48:11<br>您觉得我难道是吗？</p></blockquote><p>大概不是</p><p>Tilnel 2:48:59 所以提出一个客观视角的判断有点难以接受</p><p>Tilnel 2:49:48 然而在一个客观视角上看我其实也有点窘迫</p><p>Tilnel 2:51:06 所以我可能希望身边的所有我喜欢的人都尽量能逃离窘境</p><p>Tilnel 2:51:33 也就是尽力支援一下</p><p>Qin 2:52:50</p><blockquote><p>Tilnel 2:49:48 然而在一个客观视角上看我其实也有点窘迫</p></blockquote><p>怎么个客观法</p><p>Blue 2:52:56 我觉得我没有陷入过窘境</p><p>Blue 2:53:08 或者说我宁愿这样认为</p><p>Tilnel 2:53:20</p><blockquote><p>Qin 2:52:50 怎么个客观法</p></blockquote><p>纯主观的客观法（</p><p>Tilnel 2:53:33 自己评判自己</p><p>Blue 2:53:41 可是然后我依然是忧虑的</p><p>Blue 2:54:13 唉</p><p>Sakuran 2:54:57 我没有真的陷入过较大程度上（何为较大程度？）的窘境，但却常常会幻想自己在近未来即将落入这样的窘境</p><p>Sakuran 2:55:16 但我又不真的有动力去为避免之做出努力</p><p>Tilnel 2:55:23 我觉得很小的危机也是一种危机</p><p>Blue 2:55:27 我丝毫没有行动能力</p><p>Sakuran 2:55:35 焦虑与懒惰的伴生是致命的</p><p>Tilnel 2:55:36 就是一个细节可能对别人毫无影响</p><p>Tilnel 2:55:43 但是对自己就至关重要</p><p>Sakuran 2:55:49 是可以杀死人的，或许</p><p>Blue 2:56:07 所以我的一部分会以看戏的心态坐等我的毁灭</p><p>Sakuran 2:56:09 单独的焦虑和单独的懒惰杀伤力尚不足惧</p><p>Blue 2:56:26 但是一直以来 最后都无事发生</p><p>Tilnel 2:56:28 每个人希望能达到自己心中所想的那个状态</p><p>Tilnel 2:56:35 但是可能总是差一点</p><p>Sakuran 2:56:49 丧了 可那并不奇怪</p><p>Tilnel 2:56:51 所以要是能补上那一点也就好了</p><p>Sakuran 2:57:11 这是一种贪婪吗</p><p>Tilnel 2:57:13 但是换一个角度来说，差的那一点正好是一个人发展的动力</p><p>Tilnel 2:57:18</p><blockquote><p>Sakuran 2:57:11 这是一种贪婪吗</p></blockquote><p>不是</p><p>Blue 2:57:28</p><blockquote><p>Blue 2:56:26 但是一直以来 最后都无事发生</p></blockquote><p>所以只剩下可悲的嬉笑而已</p><p>Tilnel 2:58:12</p><blockquote><p>Sakuran 2:57:11 这是一种贪婪吗</p></blockquote><p>也许是世界给你植入的思想钢印</p><hr><p>Sakuran 2:58:30 像是窗外总有阴霾</p><p>Sakuran 2:58:42 嘲笑 可笑的 oh my</p><p>Blue 2:58:43 我不知我是否看起来很焦虑</p><p>Tilnel 2:58:44 <em>不完美</em></p><p>Tilnel 2:58:50 您看起来很焦虑</p><p>Sakuran 2:58:53 心有不甘</p><p>Sakuran 2:59:01 力所不逮</p><p>Qin 2:59:02 感觉晚上的这聊天可以拿去写术力口歌词</p><p>Sakuran 2:59:16 无怪</p><p>Tilnel 2:59:20 非要术力口吗</p><p>Sakuran 2:59:22 世界照常运转</p><p>Sakuran 2:59:31 没有惊喜</p><p>Blue 2:59:32 我妈说我看起来很焦虑 所以他们早就不敢碰我了</p><p>Sakuran 2:59:33 没有意外</p><p>Sakuran 2:59:41 渺小</p><p>Sakuran 2:59:48 那是一种常态</p><p>Sakuran 2:59:58 多么（忘了）</p><p>Blue 3:00:06 我不知道各位看见我的时候我是表现成什么样子</p><p>Tilnel 3:00:24 我觉得我喝酒之后也许是最佳状态</p><p>Sakuran 3:00:27 不用再去奋勇地失败</p><p>Blue 3:00:31 我不知道是否还有机会让各位看见我</p><p>Tilnel 3:00:41 这可能是饮酒的根源</p><p>Sakuran 3:00:48 酒精混搭烟草 爱与梦全部点燃</p><p>Tilnel 3:00:54 草</p><p>Tilnel 3:01:00 开始作词</p><p>Sakuran 3:01:06 我在烟雾中寻找期待</p><p>Tilnel 3:01:20 您这歌不是给赛博丁真唱的吧</p><p>Blue 3:01:24 开始唱唱了</p><p>Sakuran 3:01:29 手心紧握哪怕只是一片虚幻</p><p>Blue 3:01:39 这是背歌词呢</p><p>Tilnel 3:01:48 我狂笑了</p><p>Tilnel 3:01:59 还是在阳台上</p><p>Tilnel 3:03:02 这种时候大笑一声真中断思路了</p><p>Qin 3:03:33 酷</p><p>Tilnel 3:03:43 cool</p><p>Sakuran 3:03:57 所以，我想要说的，前人全都说过了</p><p>Tilnel 3:04:09 前人之述备矣</p><p>Sakuran 3:04:15 我想要做的</p><p>Sakuran 3:04:20 有钱人都做过了</p><p>Qin 3:04:23</p><blockquote><p>Qin 2:59:02 感觉晚上的这聊天可以拿去写术力口歌词</p></blockquote><p>但是bw的某几句真的很适合写歌词（</p><p>Blue 3:04:48 如果我不去看前人的工作</p><p>Tilnel 3:05:12 哪几句</p><p>Blue 3:05:12 我觉得我还可以装作我的思考是有意义的</p><p>Tilnel 3:05:15 没有意识到</p><p>Tilnel 3:05:25</p><blockquote><p>Blue 3:05:12 我觉得我还可以装作我的思考是有意义的</p></blockquote><p>不用装作</p><p>Tilnel 3:05:30 就是有</p><p>Tilnel 3:06:07 他人的思想被你思想了，那就是有意义的</p><hr><p>Tilnel 3:07:03</p><blockquote><p>Blue 3:00:31 我不知道是否还有机会让各位看见我</p></blockquote><p>我也想再见见</p><p>Tilnel 3:07:24 大概只见过一次？</p><p>Tilnel 3:08:12 见过的那一次甚至是有点悲伤的日子</p><p>Blue 3:08:37 没事 我大概一直都这样</p><p>Tilnel 3:09:00 我这样可不容易</p><p>Blue 3:11:09 唉 虽然我住哪里大伙都知道</p><p>Blue 3:11:21 但是最好还是和我打个招呼</p><p>Blue 3:11:44 我有点怕见人的 真的</p><p>Tilnel 3:11:51 您需要的话可以call</p><p>Tilnel 3:12:07 虽然我知道您的性格很难主动call人</p><p>Tilnel 3:13:27 其实我也无所谓</p><p>Tilnel 3:13:44 我甚至希望有人能突然闯上门</p><p>Tilnel 3:14:25 谁突然到12栋门口说要喝点啥我也不会有意见的（</p><p>Tilnel 3:14:40 我可能特别喜欢不确定性</p><p>Tilnel 3:15:16 因为会有非常丰富的心理活动发生</p><p>Tilnel 3:15:39 比如今天我说不会在工作室待很久</p><p>Tilnel 3:15:50 转头开了三集电视剧</p><p>Blue 3:17:29</p><blockquote><p>Tilnel 3:12:07 虽然我知道您的性格很难主动call人</p></blockquote><p>我什么性格呢</p><p>Blue 3:17:39 有些事情我很惊讶</p><p>Blue 3:18:06 比如 并不是每个人都能发现我是内向的人</p><p>Tilnel 3:18:15 比如上次我说您别说怪话之后直接自己禁言了</p><p>Tilnel 3:18:21</p><blockquote><p>Blue 3:18:06 比如 并不是每个人都能发现我是内向的人</p></blockquote><p>这还挺明显（</p><p>Blue 3:18:40 甚至有不少人在我如此声称之后还一直表示不信</p><p>Blue 3:18:56 我觉得这甚至不需要“发现”吧</p><p>Tilnel 3:19:40 的确</p><p>Tilnel 3:20:35</p><blockquote><p>Tilnel 2:16:29 对于这些课题大概微不足道</p></blockquote><p>我没喝酒的时候的脑回路就是这样</p><p>Tilnel 3:21:01 一些“微不足道”的郁闷就该直接说出来</p><p>Tilnel 3:21:37 就算输了也认了（</p><p>Blue 3:22:29</p><blockquote><p>Tilnel 3:18:15 比如上次我说您别说怪话之后直接自己禁言了</p></blockquote><p>我不知道</p><p>Blue 3:22:53 或许我不记得了 或许这是您的误解</p><p>Tilnel 3:23:42</p><blockquote><p>Blue 3:22:53 或许我不记得了 或许这是您的误解</p></blockquote><p>我记得您回答说认为并不是怪话，但是认为有人说看不懂是好的</p><p>Blue 3:24:40 我转的我的那几句话是我想时时告诫自己的</p><p>Blue 3:25:06 然后现实一点的原因是…</p><p>Blue 3:26:39 我与群友不共享生活 我观察生活有点看烦了</p><p>Blue 3:27:58 我就想起“不调查就没有发言权”的事</p><p>Blue 3:28:45 然后我就是觉得我早就应该（甚至主动地）fade away</p><p>Tilnel 3:29:32</p><blockquote><p>Blue 3:28:45 然后我就是觉得我早就应该（甚至主动地）fade away</p></blockquote><p>希望您能不fade away</p><p>Tilnel 3:29:53 我真的觉得应该想说就说</p><p>Tilnel 3:29:57 虽然我也这样（</p><p>Blue 3:30:09 原来我没被群友们屏蔽 或者说没被所有群友屏蔽吧</p><p>Tilnel 3:30:18 但我也很不喜欢看人脸色说话</p><p>Blue 3:30:49 我不知道 我觉得我其实和群友没什么话可说</p><p>Tilnel 3:31:11 前文亦有记载 我羡慕一个人能够自大</p><p>Blue 3:32:03 而且我其实是不敢说话的</p><p>Blue 3:32:12 尤其是打字</p><p>Blue 3:32:33 会永远被人翻出来的</p><p>Blue 3:32:43 我怎么可能敢说话呢？</p><p>Tilnel 3:33:09 instant message害的</p><p>Tilnel 3:33:34 我以前会有点想回到只能寻呼机的时代</p><p>Blue 3:35:02 所以我只有想着“也不会有人看到吧” 甚至是“别扯了 他人根本就是不存在的”才敢打点字呢</p><p>Tilnel 3:35:17 那我觉得这是真的</p><p>Qin 3:35:36 被完全地忘记是一件大概不太好的事情</p><p>Blue 3:35:44 why</p><p>Qin 3:35:53 所以被惦记大概有助于多一点和这个世界的联系</p><p>Blue 3:36:04 我也不止听您这样讲</p><p>Qin 3:36:05</p><blockquote><p>Blue 3:35:44 why</p></blockquote><p>因为我朴素地觉得活着更好</p><p>Tilnel 3:36:08 说明你活了一世但是完全没有影响力（</p><p>Qin 3:36:22 被忘记不太利于活着</p><p>Tilnel 3:36:25 我总觉得应该留下点什么</p><p>Blue 3:36:55 但是我并不信仰着这种朴素的认识</p><hr><p>Tilnel 3:37:01 影响力也是演化的一环</p><p>Tilnel 3:38:01 曾经是基因，现在可能是思想和知识</p><p>Tilnel 3:39:12 可能总会有一种奢望，就是人类应该往何处去</p><p>Blue 3:40:35 我自我意识过强了 竟觉得世界会因为我的行为改变 我害怕世界变化的责任担在我的肩上 从而想着最好不要行动了</p><p>Blue 3:42:31 我又是自卑的 所以想要磨灭我的存在</p><p>Blue 3:43:55 唉 感觉都是陈词滥调</p><p>Tilnel 3:44:07 那也有可能你感受到的目的就是这样</p><p>Tilnel 3:44:15 我也就不多说什么了</p><p>Tilnel 3:44:29 虽然有点神棍</p><p>Tilnel 3:44:57 但是我总认为世界是会降临它的意志到人的头上的</p><p>Tilnel 3:45:33 你去履行它也不构成任何问题</p><p>Blue 3:46:12</p><blockquote><p>Tilnel 3:44:57 但是我总认为世界是会降临它的意志到人的头上的</p></blockquote><p>即使我是祂的先知 我也是无力的</p><p>Tilnel 3:46:49 最后就是一个平凡的论点，每个人的目标都是不同的</p><p>Tilnel 3:47:26 所以只能等待你感受到祂</p><p>Blue 3:47:34</p><blockquote><p>Tilnel 2:38:31 就是，我在这里装什么呢</p></blockquote><p>唉 我感觉我也是这个</p><p>Tilnel 3:47:47 然后做出你所希望的变化</p><p>Tilnel 3:47:56 或者确实就这样了</p><p>Tilnel 3:48:26 但是我不会觉得你的做法有任何问题</p><p>Tilnel 3:48:57 如果你坚信世界需要自己做这一件事</p><p>Tilnel 3:49:00 那就去做</p><p>Blue 3:49:28 好像也没有</p><p>Tilnel 3:49:38 我是whatever肯定bot</p><p>Blue 3:49:56 在我的生命里发生更多的是… 我做与不做都一样</p><p>Blue 3:50:11 甚至我故意不做 他还是降临了</p><p>Blue 3:50:41 我不明白哪里来的这种恩赐</p><p>Tilnel 3:51:06 换言之你只需要实行自己的想法</p><p>Blue 3:51:13 或者说其实这是陷阱？是我太愚钝了看不出来？</p><p>Tilnel 3:51:34 可能说决定论是比较悲观的</p><p>Tilnel 3:52:08 只能诉诸荒木飞吕彦了</p><p>Tilnel 3:52:46 即使知晓命运，也会去反抗的勇气</p><p>Tilnel 3:53:02 不一定是反抗，也可能是代行</p><p>Blue 3:54:05 然后为了让我自己不那么惶恐 我就猜想 我的生活其实没那么幸运 只是我降低了期待而已</p><p>Blue 3:54:30 但我这样想 又怕自己不知满足</p><p>Tilnel 3:54:52 一个行为造成的结果，其影响是回溯性地论断的</p><p>Tilnel 3:55:37 没有未来就没有一个历史事件的论断</p><hr><p>Tilnel 3:57:48</p><blockquote><p>Blue 3:54:30 但我这样想 又怕自己不知满足</p></blockquote><p>我恐怕没有足够的精力去评判这个微观的事件</p><p>Tilnel 3:58:14 一来是喝多了</p><p>Blue 3:58:23 也不能说是微观的吧 唉</p><p>Tilnel 3:59:10 但是你总是立足于宏观的影响去判断自己的生活</p><p>Tilnel 3:59:56 似乎世界的意志是否被满足才决定了你的幸福</p><p>Blue 4:00:14 嗯… 确实</p><p>Tilnel 4:00:25 这早就是一种宗教信仰了</p><p>Blue 4:00:42 其实只不过是我不知道什么是幸福</p><p>Blue 4:01:11 所以我才会说“客观上的幸福”</p><p>Tilnel 4:01:33 那不妨再主观一点</p><p>Tilnel 4:02:49 但我也做不到</p><hr><p>Blue 4:03:03 唉</p><p>Blue 4:03:13 想起群友说</p><p>Blue 4:03:19 “需要性解放”</p><p>Blue 4:03:42 或许想了半天最后也还是这个</p><p>Blue 4:04:21 但是我其实挺怀疑的</p><p>Tilnel 4:04:38 解放的状态大概是全部人类顷其生命周期才能完成（消灭）的</p><p>Tilnel 4:05:45 用极限的逼近去形容有点庸俗，但也就是这样</p><p>Tilnel 4:06:18 毕竟完美这个词并不归属于人类</p><p>Blue 4:06:49 是的</p><p>Tilnel 4:10:59 假如你还心有不甘</p><p>Tilnel 4:11:08 请务必不被消灭</p><p>Blue 4:11:36 谢谢</p><hr><p>Tilnel 4:11:51 唉，都是复读</p><p>Blue 4:12:05 其实 当然毕竟是世俗的人</p><p>Tilnel 4:12:08 我说的你100%都想过</p><p>Tilnel 4:13:29 有一个被我复读过114514次的论调，就是嫉妒使人活着（</p><p>Blue 4:15:03 我也不知道 是应该去喜欢听自己听得懂（早已在自己之中）的话呢？ 还是要去努力听自己没想过或者避免去想所以听不懂的话呢</p><p>Blue 4:15:21</p><blockquote><p>Tilnel 4:13:29 有一个被我复读过114514次的论调，就是嫉妒使人活着（</p></blockquote><p>谢谢</p><p>Blue 4:15:49 看来我说的话看上去是陷入存在主义危机了</p><p>Blue 4:16:16 我肯定是会活着的 大可放心</p><p>Tilnel 4:16:27</p><blockquote><p>Blue 4:15:03 我也不知道 是应该去喜欢听自己听得懂（早已在自己之中）的话呢？ 还是要去努力听自己没想过或者避免去想所以听不懂的话呢</p></blockquote><p>感觉没有”应该”</p><p>Blue 4:16:58 因为我认为生死并非是凡人应该决定的</p><p>Tilnel 4:17:31 AB二选一的最优解永远是选C</p><p>Tilnel 4:18:41</p><blockquote><p>Blue 4:16:58 因为我认为生死并非是凡人应该决定的</p></blockquote><p>那我觉得是保留这一选择的能力</p><p>Tilnel 4:19:45 谁让你生，谁又让你死</p><p>Tilnel 4:20:04 通通干掉</p><p>Tilnel 4:20:12 滚！</p>]]></content>
      
      
      <categories>
          
          <category> 喜剧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中期考核</title>
      <link href="/20241018-mid/"/>
      <url>/20241018-mid/</url>
      
        <content type="html"><![CDATA[<p>  在拖延了半个月之后，我终于开工了。也没什么别的原因，主要是因为时间只剩下8个小时了。</p><p><strong>个人陈述（学术创新类）</strong></p><p><strong>（一）</strong> <strong>科研选题的前沿性和独创性</strong>（结合科技前沿和学科领域发展动态，论述选题的研究意义、拟解决的关键科学问题；附相应参考文献）</p><p>科研选题：针对分布式系统实际代码实现的模型检测方法。</p><p>分布式系统运行的过程中往往会出现大量不确定性的因素。在多个节点上运行的进程协同工作，会产生通信、调度上的偶然变化，构造分布式系统的时候往往无法穷举这些情况，程序的异常处理不完善导致系统潜在的崩溃可能。并且在错误发生之后，引发问题的执行路径通常难以还原，导致最终定位不到问题所在。</p><p>面对分布式系统的验证问题，通常的做法是模型检测。模型检测是一种形式化的自动化验证技术，用于验证系统模型是否满足要求。通过将系统的行为建模为一系列状态转换，检查系统的所有可能状态，以确保系统在任何可能状态下都满足特定的属性或规范。如果某个状态违反了规范，模型检测将报错，并提供有关不符合规范的状态的信息，帮助系统设计人员识别和解决问题。</p><p>传统的模型检测是使用 TLA+ 等形式化验证工具对分布式算法进行建模。然而，面对真实而复杂的系统实现，强行使用形式化的方法进行建模则面临着困难的约简：约简过多，则与实际系统偏差越远；约简越少，则状态转换的分支越多，容易出现“状态爆炸”的问题。</p><p>然而，为真实代码构建模型是非常困难的。传统的模型检测通常假设系统设计是在较高层次完成的，并抽象掉了实际实现的许多细节。要验证实际代码需要从代码中重建这些抽象描述，这一过程涉及大量的手工操作，阻碍了模型检测在实际系统中的应用。此外，人为在手动抽象过程中犯的错误可能会导致误报或漏报。这些错误可能发生在模型构建阶段，也可能在系统演变过程中发生。</p><p>为了规避传统模型检测中的模型“漂移”问题，前人也提出了各类方法。CMC 是一个 stateful 的模型检测工具，能够对 C 代码直接进行模型检测，被用于检测网络协议和文件系统（FiSC）。但是 CMC 的检测需要侵入式地修改源程序代码，以使得被测程序运行在 CMC 的地址空间内。同时，它要求被测系统具有明显的事件驱动的特征，并不能适应更广泛的实际系统实现的需求。</p><p>MaceMC 使用深度优先搜索和随机行走来检测网络协议实现中的 liveness 问题，但是被测系统限定于使用 Mace 语言生成的 C&#x2F;C++ 实现。Yabandeh 等人基于 MaceMC 提出的 CrystalBall 中增加了 Steering Execution，在运行的过程中分析未来的错误状态，并通过控制执行来避免走入错误状态。</p><p>Junfeng Yang 等人提出了 eXplode 对文件系统进行穷举式的测试。后提出了一个在 Windows 上对实现级的分布式系统进行透明的模型检验的 MoDist 框架。但是由于商业原因，并未开源其实现。</p><p>为了弥补这些方法的不足，我的科研选题是提出一种通过系统调用截停的方式，不侵入性地修改代码而操纵实际实现的分布式系统执行，以达到对分布式系统的实际代码实现进行模型检测的方法。由于直接从系统调用层面进行操作，因而不需要进行代码插桩操作，并且对于被测系统的要求较为宽松，适应面更广。</p><p><strong>（二）</strong> <strong>代表性成果的理论、方法或技术创新亮点</strong>（重点阐述研究生个人取得的代表性成果的创新性、引用和评价情况、国内外获奖情况等）</p><p>对于选题“针对分布式系统实际代码实现的模型检测方法”，个人已经开发了一套测试框架，代码量约 4000 行。目前应用于 Raft 共识协议的 C 语言实现的验证上，已经证明了其有效性。</p><p>1、工作简介</p><p>计算机中的一个进程所作的事情无非是两件事情，一部分是图灵机一样的确定性的计算，另一部分是通过系统调用与外部世界进行交互。系统调用是单一进程的全部不确定性的来源。对于分布式系统而言，我们将其由于进程间执行的先后顺序造成的执行结果差异称为调度不确定性；将进程受系统调用结果变化造成的差异称为环境不确定性。由此，我们只需要控制好分布式系统运行中的每一个不确定性，并且对于状态做相应的管理，就可以任意地探索分布式系统执行的状态空间。</p><p>因而，为了实现这样的框架，我们必须解决的问题有：</p><ul><li>如何完整地保存进程状态，并且在需要的时候将保存下来的状态恢复成运行中的进程？进而实现整个分布式系统的状态快照保存恢复。</li><li>如何自由地控制分布式系统中的各个不确定性，以实现对执行路径的完全操控？</li><li>如何从分布式系统的实际实现中提取其需要的不确定性，如由随机数&#x2F;时钟超时决定的不同操作？</li><li>如何对分布式系统的状态合法性进行检查？</li></ul><p>2、技术路线</p><p>Linux 中的 ptrace 系统调用提供了对于进程的观察以及控制执行的能力。</p><p>对于测试框架，我的最终实现形式类似于 gdb。一个控制进程（下称 tracer）和多个被控进程（下称 tracee）组成。tracee 为设定好的被测程序，由 tracer 创建新进程并启动被测程序，根据分布式系统的需要，传递节点信息等各自不同的参数。通过 ptrace 系统调用对多个 tracee 进程施加控制，统一运行到有意义的用户代码之前， 作为分布式系统的初始状态。</p><p>此时，每一个进程都停止在一个系统调用之前。由 tracer 将所有进程的状态储存下来，包括每个进程的：1、内存地址映射；2、可读写的内存地址空间（堆、栈、数据段等） 3、文件描述符表。并保存所有的环境状态，包括每个进程占用的文件和网络中滞留的数据包等。</p><p>以此作为初始状态，分别对每一个 tracee，通过 ptrace 控制其执行一个系统调用后保存新的状态，并恢复旧的状态，最后将初始状态标记为“已遍历”并存盘。对新产生的状态继续执行上述操作。如此即可搜索分布式系统运行中产生的所有可能状态。</p><p>新的状态产生后，通过 dwarf 调试信息，提取其进程地址空间中与分布式系统状态相关的变量的值，验证分布式系统的状态断言是否满足，并报告给测试人员。</p><p>3、验证分析</p><p>框架最初成型时，我将测试框架应用于 Bakery 锁算法的经典错误写法，能检测出其中错误，验证了技术路线的可行性。经过完善后，将其用于某开源的 C 语言 Raft 共识协议实现，复现了已有工作检测到的多项 bug，证明这项技术对于实际生产应用中的系统是具有检测能力的。</p><p><strong>（三）</strong> <strong>其它研究成果</strong>（除上述学术创新成果外，简要阐述研究生个人在面向国家需求的自主原创系统研发，或产生实际经济社会效益的应用转化方面作出的贡献，如无可不填）</p><p>研究生期间，本人持续对 C 语言程序设计课程的在线评测系统进行开发与维护，支撑了 2023 与 2024 级技术科学实验班与软件学院新生的教学工作（每级约800人）。同时保障了 2024 年软件学院保研夏令营、2024年南京大学计算机学科体验专题营的机试系统正常运行。</p><h3 id="1-2-ptrace-简介"><a href="#1-2-ptrace-简介" class="headerlink" title="1.2 ptrace 简介"></a>1.2 ptrace 简介</h3><p>ptrace 是 Linux 内核提供的进程跟踪的系统调用，它允许父进程检查和替换子进程的内核镜像（包括寄存器）的值。</p><p>子进程调用 ptrace(PTRACE_TRACEME) 且父进程调用 ptrace(PTRACE_SEIZE) 后，父进程即可对子进程的执行进行控制：在子进程进行系统调用前或系统调用返回后停止；获取子进程系统调用信息；读写子进程内存和寄存器的值；模拟系统调用执行等。通过几种基本操作，能够实现程序的确定性执行。</p><h2 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2 系统设计"></a>2 系统设计</h2><p>单线程程序从一个特定的状态出发，其状态转换分为两类。一是进行系统调用，对操作系统对象进行创建、删除、读写；二是系统调用以外的运算逻辑。对于第二类而言，其代表的状态转换是确定性的，即给定进程状态和代码，执行代码达到的目标状态是唯一确定的；对于第一类而言，则状态转换还要取决于操作系统对象的状态。比如同样执行 read() 系统调用，如果文件的内容正同时被其他进程改变，则产生的结果不确定。</p><p>在多线程程序以及分布式系统中，由于其由多个独立执行的程序组成，因而其执行路径还受到各执行流之间的调度的影响。 </p><p>因此，为了对分布式系统进行模型检验，首先需要穷尽系统调用的可能结果；同时穷尽系统所有节点的各操作执行的先后顺序。</p><h3 id="2-1-整体框架"><a href="#2-1-整体框架" class="headerlink" title="2.1 整体框架"></a>2.1 整体框架</h3><p>对于 n 个节点的分布式系统，我们用 n + 1 个进程进行整个系统的操控执行：</p><ul><li>一个 tracer 进程，用以控制所有的进程</li><li>n 个 tracee 节点进程，即受控运行的分布式系统</li></ul><p>以 3 个节点为例，对于一个运行中的分布式系统，其状态为 $S&#x3D; &lt;Env, Node1, Node2, Node3&gt;$，其中：</p><p>$Node$N$ 代表节点的状态，包括节点的堆、栈、寄存器。</p><p>$Env$ 代表节点之外的环境，包括被节点使用的操作系统对象的状态，如网络消息，系统时间，打开的文件等。</p><p>在分布式系统执行的过程中，能够引发状态不确定性的分歧操作包括：消息的先后顺序，消息是否到达，以及消息等待是否超时。</p><p>tracer 进程每次从一个状态 $S$ 开始控制其中一个节点，运行到下一个分歧操作前，即：消息发送前，消息接受前，以及请求系统时间之前。之后对于每一个节点，都由 Choose() 函数根据运行时的上下文决定下一个分歧操作可能的状态转换集合$Transfer$，且对于每一种可能性 $t \in Transfer$，生成如下的“转换边”：  $(Node$N.t(), &lt;Env, Node1, Node2, Node3)&gt;)$ </p><p>它表示，状态的下一次转换从状态四元组出发，通过 $Node$N$ 执行 $p()$ 所代表的转换可达到下一个状态：</p><p>$(Node$1.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’, Node1’, Node2, Node3)&gt;$ </p><p>$(Node$2.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’, Node1, Node2’, Node3)&gt;$ </p><p>$(Node$3.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’’, Node1, Node2, Node3’)&gt;$ </p><p>总的工作流程是：设置一个状态转换边的队列；每一次从中取出一条边并执行达到新的状态，在新的状态的基础上，生成新的转换边并入队。</p><p>对于 DMCK 的实现有两种，一种是 stateful，即通过保存和恢复节点的内存、寄存器等信息来重现状态；一种是 stateless，通过重放记录的执行路径来重现状态。我们的工作主要是 stateful 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S = &lt;Env, Node1, Node2, Node3&gt;</span><br><span class="line"></span><br><span class="line">q.add(Edge(skip, S))</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">    edge = q.deque()</span><br><span class="line">    S&#x27; = edge.transfer()</span><br><span class="line">    forall (node in Nodes) &#123;</span><br><span class="line">        // 只根据 node 的状态就可以算出当前执行上下文了</span><br><span class="line">    Transfers = Choose(node)    </span><br><span class="line">    forall (t in Transfers) &#123;</span><br><span class="line">    q.add(Edge(t, S&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def transfer(edge) &#123;</span><br><span class="line">S = edge.getState()</span><br><span class="line">t = edge.getTransfer()</span><br><span class="line">node = t.getNode()</span><br><span class="line">nodeState = S.getNodeState(node)</span><br><span class="line">nodeState.t()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- </p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应该忘记什么</title>
      <link href="/20241018-wasureta/"/>
      <url>/20241018-wasureta/</url>
      
        <content type="html"><![CDATA[<p>我记得的东西太多了。负担太多了。也许应该忘记一些事情。</p><p>曾经我认为，往事就算想忘记也是无法忘记的，说忘记只是自欺欺人。因而并不需要做这样的努力，只要不去想就好了。就像一个伤口你告诉自己不要去摸但是最后还是经常去摸一样。</p><p>这样度过了很久很久。我以为这就是万全的方法。</p><p>现在，似乎应该去做一点“蒸馏”。虽然我觉得很多事情就是会记一辈子，客观上记这些东西只会害了我。但是似乎还是有办法能淡忘。大概就是决定去忘记。。。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么时候才能长大呢</title>
      <link href="/20241017-shiriai/"/>
      <url>/20241017-shiriai/</url>
      
        <content type="html"><![CDATA[<p>熬夜的原因找到了。一躺上床就只有负面的心情，所以不愿意躺上床，就会拖；好不容易躺下了，脑子里面就是那些事翻过来倒过去。</p><p>晚上聊天有一个说得很好。高中给那个还是傻小子的我带来的确实是快乐。但是想明白了很多事情之后再回味，其实并不是什么好地方，也并没有发生什么好事，只会觉得各种不是滋味。</p><p>获得的教训是千万不要没事翻旧相识的朋友圈。那都是比起我而言更配得上幸福的人，为什么非要自讨苦吃呢。。。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不要承认那个名字</title>
      <link href="/20241009-cite/"/>
      <url>/20241009-cite/</url>
      
        <content type="html"><![CDATA[<p>本文内容采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名 - 非商业性使用 - 相同方式共享 4.0 国际许可协议</a> 进行许可。</p><blockquote><p>整理的时候发现忘了是从哪里手抄的了，应该是今年上半年抄的。总之原文写得很好，拿来用用</p></blockquote><blockquote><p>谁规定人不能畏怯敏锐，不能沉郁昂扬？那正是我的疾病，也是我的天赋；是我的宝藏，也是我的残缺。</p></blockquote><p>fine，我承认，用一种有名有姓的病症来定义生活十分诱人——它可以解释我的一切疑虑：嘴角上扬，是躁狂症发作；眼泪决堤，则是抑郁作祟。如果做错事情，那千万不会是我的问题——看嘛，那些行为可是清清白白地写在医学论文里。</p><p>这诱人的定义将现代医学移情为一种神学意识形态：化验单便是赎罪券，同无力改变的人们一起，求助于圣母、耶稣、佛祖、科学……什么都好，什么都不重要，因为错误已经被忏悔，可以心安理得地原谅自己。</p><p>福柯在《疯癫与文明》里讲，正常与不正常，本就是被话语与文化界定，是一种社会建构的概念，是社会空间中的一个知觉对象。况且，现代医学本身也还没搞明白双相的成因——只是狡猾地用「十分可能」「也许」来假定一种缺陷遗传基因或脑部病变。</p><p>&lt;后面或许有，但是我只抄到了这里&gt;</p><p>update: 我找到原文了</p><p><a href="https://coink.wang/bipolar-disorder.html">疯癫絮语 | Coink DO BOOM!</a></p><p>我不想把药物治疗当作阿鼻地狱里唯一的那根蛛丝。诺洛西汀、碳酸锂的确能够帮助患者社会意义上地「恢复正常」。但，病毒可以由刻意转录的药剂杀灭，心境稳定剂只是堪堪钝化人的感官。我知道它有效，只是我现在用不着。</p><p>谁规定人不能畏怯敏锐，不能沉郁昂扬？</p><p>「那正是我的疾病也是我的天赋，是我的宝藏也是我的残缺」(蒙马特遗书)</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>这下看懂了</title>
      <link href="/20241002-yarareta/"/>
      <url>/20241002-yarareta/</url>
      
        <content type="html"><![CDATA[<p>早上起来随手翻了翻斯嘉丽的小号，很多当时没看懂的东西现在看懂了。总之足以说明她在这方面并不算纯粹，或者说“朴素的善良”。可能我以前真的疏于了解吧。</p><p>卧床不起的心情一定不是很好；下来走走，然后稍微收拾一下就是另一种精神面貌。所谓的总结研究并没有开始进行，因为好累。我怕累，所以一直在这里写着，这是一种延宕。</p><p>其实写这些就是为了拖拖时间罢了，我自己也知道。不想立刻投身到新的节奏当中去。也许是那种「野草」式的自恋。</p><p>“感觉”这种事真是捉摸不定，但我也没有任何必要、任何义务对其进行预判。或者说那是一件纯粹存活于当下的物质——物质所创建出的一种临时性。</p><p>我也许需要适当地发一点精神病。只要对碎碎念这种事情脱敏，也就会对那种“精神病”式地发言脱敏。那才是我能无障碍地言说的时刻。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间大步向前走</title>
      <link href="/20240923-yarareta/"/>
      <url>/20240923-yarareta/</url>
      
        <content type="html"><![CDATA[<p>好不容易迈出这一步，决定放弃。至于为什么？我只想说，我简短的人生经验告诉我，如果保持这份偏执不放，一定会被标记为究极傻逼。哪有人相信这么荒唐的东西，愚蠢也得有个度。</p><p>总之必须忘记，不得不忘记。要彻底地转变态度，不要心存幻想。如果以后有机会再说话的话，一定要好好告别。</p><p>我也不是想不到各种可能性，只是我无法判断是该相信还是该质疑。写到这里我又忘记刚才的思路了。总之她应该也没必要对我使个坏，而只是为了恶心我一下。</p><p>人要做一件事，或是产生某种反应必然有其原因，而不是无缘无故的。如果我承认她比我要强，那么大概率她能够做到她想要做的事情。也就是说，当前的局面就是她所希望达到的效果。</p><p>效果&#x3D;目的。这也说明最初她其实就在劝退我，或是表达过不感兴趣。但我并没有捕捉到这一点，两个月没有回消息其实已经是一个明显的讯号。之后才有了“旧林羁鸟”之说。</p><p>也许是为了避免麻烦或对于“体面”的执念，对方并未直言相阻，而是引入一个更深的套路再予以重击。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>秋分日</title>
      <link href="/20240922-yarareta/"/>
      <url>/20240922-yarareta/</url>
      
        <content type="html"><![CDATA[<p>我是一个极容易动摇的人，偏偏这点从来就没有学好。</p><p>緒方理奈和赤名リカ其实是一个模子里刻出来的人物，我对她们两位都非常喜欢。不止是因为她们敢于表达爱，更是因为她们“有进退”。</p><p>对，不是“知进退”，谁知道离开是不是最好的决定？谁也不能说得上来，事情到底会怎样发展。但是她们可以坚决地离开，创造自己的新的生活。</p><p>也许回去之后仍然会偷偷抹眼泪，即便如此在转身的时候也毫不动摇。</p><p>所以，「恋爱世纪」虽然是 Happy Ending，却是平庸的，是大多数故事的结局；而「东京爱情故事」是 Normal Ending，但是其中展现出的人物选择却有着科幻片一样的觉悟。</p><p>所以，动画的 White Album 1 是科幻片，而 WA2 是写实的。</p><p>即使写到这里，我的态度依旧存疑。</p><p>至于斯嘉丽是怎么想的，已经不怎么重要了。曾经有个人，如果与她聊天，就可以稳定地获得一种安心的感觉。而现在情况为之一变，我自己会动摇起来。</p><p> Thank you. Good-bye!</p><p>当然我还是不明白，为什么偏执与动摇会出现在同一个人身上共存得如此不和谐。</p><p>我偏执的可能是，希望就算离开，也尽可能留下一个帅气的背影。</p><p> 当你想说任何话做任何事的时候，发现这些对于对方来说其实根本就无从谈起。这简直像在静止的时间里有人向你丢来数十把飞刀一样恐怖。</p><p>来即招之，去即挥之，此乃树的本分。</p><p>我不一定在乎别人的感受，但是一定在乎别人是不是喜欢我。所以也许很自私。</p><p>总之，不脆弱，但是动摇；不会倒下，但是很容易受到影响。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当我在学赤名リカ的时候，我到底在学什么</title>
      <link href="/20240921-yarareta/"/>
      <url>/20240921-yarareta/</url>
      
        <content type="html"><![CDATA[<p>夜里姑且还是问了一下对方的态度，结果是什么“说来话长”的一眼就像是在糊弄人的说法。我也很难相信。姑且认为她其实是保持礼貌并且赶我走。不过，何至于此。</p><p>对于一个志虑忠纯的人来说，怀疑是不是最恶劣的侮辱？所以我轻易不去表达对一个人的怀疑。所以她是这样的人吗？</p><p>只要不进入对方的节奏，我可能也是正常的。或许我做不到真正的冷漠。我又没有在人际关系这方面的聪明才智。也许是这样，我才被淘汰了。其实也没什么。</p><p>每次死心也都能活过来，猫有九条命，人只要肉身不死就可以无限重来。</p><p>我到底学赤名リカ学到哪里去了？希望自己能像女主那样，处处学她，却处处学不像。</p><p>天啊我不想再微笑了。每到痛苦的时候，嘴角都会自发地上扬，这是不是一种苦笑？我是没法接着当作无事发生了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>擅作主张的不安</title>
      <link href="/20240920-upset/"/>
      <url>/20240920-upset/</url>
      
        <content type="html"><![CDATA[<p>人类是一种傲娇生物吗？我不太确定。</p><p>但是至少人是一种极其需要承认的生物。不管是正面的承认，还是反面的不承认也好，总归是确立了他作为一个能动的主体，进而有能力得到这个世界的反馈。</p><p>人与人之间相交往，到底有什么难度呢？接下来我所提出的说法是有一个天生的漏洞的，但是我先提出来好了，然后再来考虑这个漏洞应当怎么解释。</p><p>如果一个人喃喃自语，喋喋不休，那么他大概会被认为是疯子；事实上，这样的人最吊诡的地方是他不需要收到反馈就可以持续地进行这样的活动。对于一般人而言，如果说了很多话都没有得到回应的话，他便也不再说。</p><p>话与话之间的沉默是一片充满焦急的区域。那里是一些由于焦虑得不到回应而自动产生的擅作主张的不安。没有人能在交际中将这些不安一股脑地倒出来。  </p><p>就是这样。 </p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>何尝不是一种 Rick Roll</title>
      <link href="/20240920-yarareta/"/>
      <url>/20240920-yarareta/</url>
      
        <content type="html"><![CDATA[<p> 看电影也有点耽误我想事情了。本来想边看边写的。</p><p>很久没有静下心来像这样写两个字。</p><p>我的特点，是我的优点，也是我的缺点。我的生命力是顽强的，心态是健壮的。我虽然有一点见识，但并不明白人心。我并不聪明，并不敏感&#x2F;敏锐，甚至有一种刻意而为之的执拗&#x2F;迟钝。</p><p>“人在火炉旁是很难感受不到温暖的。”</p><p>主观意愿与客观效果是一对辩证统一。如果你受到冷落，其实这很难是由于一种无意之举。就算不说是刻意的，也一定是因为有必然的不方便的原因，从而不符合对方自身的意志。</p><p>因而，不仅不得不放弃，更加不得不体谅，不得不反省。自己提出了也许是无理取闹的要求，而对方假如不是出于天性或恶意欺骗，也可以说是出于有适于体面的礼貌。</p><p>留给我的只有用于冷静的时间。只能摇摇头了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>务虚</title>
      <link href="/20240729-briefing/"/>
      <url>/20240729-briefing/</url>
      
        <content type="html"><![CDATA[<p>其实状态还是没有调整好。心态不对，态度不对，行动上看，几乎可以说是完蛋。轻松不自如，有千钧重负。</p><p>也可以说是泰山崩于前而死性不改。一方面我是真的没有什么冲劲了。</p><p>想一想也是无所依靠，没有寄托。每天可以不说一句话，不同一个人来往，这无疑是危险的</p><p>没有什么特别在意的人，在意的人也不懂如何与她若无其事地说两三句话。松懈了也就松懈了，除了不能好好向老板交代以外，也就没有了。</p><p>这不是食粮的事。不是任何作品能够扭转的状况。出问题的不是思想观念，而是生活本身。</p><p>Too hard to change.</p><p>榜样的力量其实是很薄弱的。无需赘言。追比圣贤作为一种理想，并不是能够长久地坚持下去的动力。很多时候，只是望洋兴叹，能人背后有能人。</p><p>尽管没有解决的办法，但该裱糊的，表面工作还得做。</p><p>我最近似乎有点开窍，似乎也没有。偶然思念谁，偶然又幻想碰见谁。如今是没有任何意义的。我在人类这个领域可能只有这点天分，与非人类打交道是一般的擅长，与人交往的表现可以说是灾难性的。</p><p>晚上来了。白天睡过去的时间就用通宵来解决。</p><p>完全没征兆的摆烂。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>干沉默了</title>
      <link href="/20240729-work/"/>
      <url>/20240729-work/</url>
      
        <content type="html"><![CDATA[<p> 不确定，再看看</p><p>把小桌板拿到桌上架起来，刚好够上显示器的底部高度。现在可以站着办公了。</p><p>不过我说，这周我没少做事，但是又根本没干正事。周五老板给我发消息，下周开小会。结果我这周都干了什么呢：睡觉，翻译视频，调一个没头脑的 netdata bug；玩 PXE，网络启动；调 dotoj 的 bug；写新的 profiler。劲都没使在正事上。</p><p>这一周的作息也基本上处于一个完犊子的状态。本来想往前调，结果每天在宿舍起床之后吃个晚饭回来，晚上准备早点睡。然后就开始折腾各种玩意，最后都是拖到早上，7点，9点。周六我寻思干脆这晚上在工位通宵算了，结果好家伙，又写了一个没什么大用的东西之后，开始猛刷视频。本来想着直接一波熬到晚上，这样还能调正过来。没想到吃完午饭回宿舍还是累了，睡了一觉，又是晚上到工位。</p><p>。。。</p><p>其实这种状态真的挺好的，只要我不用干活不用上班，那就是绝妙。可惜事情还是得做的。</p><p>虽然也没少想心思，但是已经比以前好多了。身边也没那么多事，况且前面去了一次 BSK 之后直接给我了一点小小的震撼，一段时间里可能都会处于比较佛系的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>制作视频汉化字幕</title>
      <link href="/20240722-script/"/>
      <url>/20240722-script/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近想搬两个视频到 B 站。所以学习一下如何制作汉化字幕。</p><p><a href="https://www.bilibili.com/read/cv35618868/">经验总结：汉化字幕的生产流程简介 - 哔哩哔哩 </a></p></blockquote><p>请注意，此文大部分是个人经验，每个字幕组的工作流程和具体内容都不大一样，仅供大家参考，可能不具有代表性。</p><p> 我自己做的字幕比较多的是：动画片、各类创作者访谈、电影幕后视频，有时候会自己一个人从头到尾做完一个视频，有时候也跟组里的伙伴们一起合作，所以啥的都会搞一点。就按照我做的这几个工种结合字幕制作流程中的顺序来说：</p><p>一、片源</p><p>首先是片源获取，这个分情况，大家都知道做字幕这个灰色地带，如果影视剧的话，第一时间肯定是到各大论坛、种子站或者DC++源之类的地方找资源，也有一些字幕组的片源帝是直接自购（流媒体or碟）然后扒出来的，总之这是个各显神通的环节。扒下来的片源往往被称作“生肉”，相对于做好字幕的片子“熟肉”，字幕组就是一个厨房团队。</p><p>接下来工作到了这里就有分别，最重要的一点是，片源有没有自带字幕，带的是什么语。</p><p>二、需不需要听写？听译？</p><p>如果没有自带字幕，就需要听写+翻译或者听译了（看组里翻译的能力水准，需要听写+翻译合作，还是一个人可以完成听译），我以前一个人翻那些YouTube上面扒下来的访谈视频就是靠硬听硬翻的，有时候一句没听懂，翻来覆去听，为了翻译一句话能搞一天。主要还是需求听的人对这个片源的常用语言、文化环境里的各类梗、说话人的口音等等有很详细的了解。</p><p>不过现在听译的需求越来越少了，有各类AI语音识别软件，连时间轴都帮你打好了，原片的语言如果没有特别重的口音，基本上AI都能识别出来，像YouTube甚至有自带的语音识别转字幕功能，轴都帮你打好了，虽然有时候打轴的断句有点奇怪。</p><p>如果片源有自带字幕，那就轻松很多，不用听写，而且轴打得都比较标准，可以直接进到翻译阶段。</p><p>三、打时间轴</p><p>上面说的“打轴”，啥意思呢，就是给这个字幕做上时间轴，这个时候我一般会先用最基础的字母格式：srt格式的文件（听写软件和YouTube自动生成的字幕一般也会导出这种格式）。srt不含任何字幕格式（字体大小、颜色、位置甚至更高级的特效等等），只有单纯的两个信息：1、某一段字幕在视频哪个时间点出现，又在哪个时间点消失；2、这段字幕的文字内容。</p><p>打轴是一个挺枯燥的活儿，你需要精确到毫秒，保证字幕和语音能完全对上。早年的软件不大好用，后来我发现了大家都在用的神器aegisub，这个软件能把音频波形、视频画面和字幕放在同一个窗口下，同步播放，并且可以用可视化的UI直接划取某一段音频波形打轴，工作效率高了很多。</p><p><img src="https://i0.hdslb.com/bfs/article/fbb33a979a1461f4890b3db4212a2752572604.png" alt="aegisub的界面示例，这是我翻译IGN《未来蝙蝠侠》幕后纪录片的截图"></p><p>四、翻译</p><p>翻译这个阶段，也是比较复杂的一个阶段，得分几个小点讲讲。</p><p>弄懂原文当然还是基础，视频翻译中可能更会容易出现俚语、俗语、典故、时代性表达等等，翻译虽然也是再创作，但是理解原文的基础上译者才能进行自己的发挥，这点对于所有类型的翻译都是一样的要求。</p><p>字幕翻译和书面翻译不同，其实更接近口译一点，字幕展示时间是被片中人说话的速度所固定的，观众并不像书的读者那样有反复回读的时间，所以对于译文更会要求短、准确、易于理解。一行中文字幕一般来说在15个字是观众能够兼顾看画面+读字幕的极限了，如果能在10个字以内更好了——当然这和这句话出现在屏幕上的时间也有关系，如果说得慢、时间长，那也可以适当放宽。这就反过来涉及到和上面打轴流程之间的冲突，不同语言之间的信息量不同，一句话长短可能区别很大，所以翻译的时候再次调整断句和时间轴是再常见不过的事情了。</p><p>还有和其他翻译形式共通的一个点，就是说话人的语气、用词等等，在时间允许的情况下，多多琢磨，如何用中文更好地把原文中特殊格式、隐含的意思表达出来。这些东西我有详细在经验总结：美漫汉化时要注意什么？这里说过。</p><p>四、注释</p><p>这是一个比较特殊的点，正式影视引进的字幕里，按照工作标准，是没有注释的，有带注释的都是我们这类民间字幕组。特别是我们翻译美漫采访、动画这类，典故、梗比较多的东西，有些东西就会想注释下，方便刚入坑的萌新更好理解，也是一个去对接多元宇宙里其他作品的跳板。在其他情况下也会有注释的情况，比如历史类、科技类、文化类等等纪录片、传记片之类的，很可能要出现注释一些背景知识的情况。但是一定要注意的是，注释时候不要过于自我陶醉了，克制一点，简短一点，观众是来看这个片子本身的~</p><p>五、校对</p><p>校对不一定每个字幕组的流程里都有，但是其实是必不可少的一个步骤，最基本是检查翻译好的字幕里有没有错别字等等低级错误，然后就是有没有翻译错误，例如对原文理解失误、中文表达不顺畅、或者有没有更好的表达等等之类的。校对需要比较熟练、对背景有深度了解、比较有责任心的人来做，一般都是字幕组里的老人。</p><p>六、格式、特效</p><p>这时候，格式一般就从srt转成ass了（不是屁股），ass格式中不光包括了时间轴信息和字幕内容，还有字幕的字体、位置、字号、颜色，甚至淡入淡出、在屏幕上移动、变大变小、卡拉OK特效等等。</p><p>格式上有一些我个人的习惯，可供大家参考：</p><p>如果你要做中英双语字幕，英文的字号要比中文小一点，和中文一样大的英文字母会显得非常臃肿。</p><p>中文字幕上的标点，可以有感叹号、问号、逗号等等，但是省略句号会比较美观，因为放了句号会显得原本居中的字幕向左偏了。</p><p>尽量用易读清晰的字体，适中的大小，颜色我喜欢选最常规的白色或者稍微低饱和度一点的黄色。高饱和度的颜色会让字幕显得非常廉价——当然如果你要突出复古迪斯科舞厅的感觉，某些特定的偶尔也能用个五彩斑斓的颜色点缀点缀，就是别从头到尾都闪瞎人眼就行。</p><p>为了增强字幕的易读性，描边、阴影、半透明背景、阴刻&#x2F;阳刻效果等等这些做法至少要选择一项，否则字幕常常会出现和视频背景颜色混杂导致看不清的情况。同样也是为了易读，不要选择太细的字体。</p><p>字幕的位置不要太高太低，更要注意不要挡住视频的重要部分，调节位置的时候一定要细心一点。</p><p>有些特效能手还会在ass的基础上用AE等等其他软件字幕做更进一步的特效，这就是更加各显神通的地方，也看各组的审美了。</p><p>七、压制</p><p>完成格式特效之后，又有两条路可走：直接发布外挂字幕，让观众自己把外挂字幕加载到生肉里面观看。或者直接把字幕压制到生肉中，做成熟肉。</p><p>以前的视频编码、格式比较混乱，有人用rmvb，有人用avi，还有人直接用mkv封装的，近些年来大家似乎慢慢都比较统一压成mp4了。压制也比以前简单了很多，不用再写代码，有许多傻瓜式的软件，把生肉和字幕拖进去，不到一会儿它就压好了。</p><p>八、发布</p><p>发布也有区别，可以线上平台直接让人观看，如果有版权因素容易被和谐，不过是当下懒人观众越来越多的情况下，线上还是最容易能被人看到的方式。还有还是发资源链接给人下载，以前大家搞BT、磁力、电驴，后来各类网盘野蛮生长的时候下载最方便，不过随着版权净网的增强和网盘限速越来越多，也稍难了一点，不过这两年貌似又有一些新的网盘开始野蛮生长了，不知道这些新的网盘还能野蛮多久。</p><p>还有一种比较尴尬的“发布”，就是字幕组做好的字幕，被某些盗版在线网站拿去，压进一些什么澳门赌场之类的诈骗广告，再发到自己的网站上让人在线看，很多字幕组对于这种事情都很无奈，但是本身又是个灰色地带，很少有维权的办法。</p><p>其实到了这个时代，字幕组越来越少了，有一点是因为中文市场越来越大，很多影视剧上流媒体的时候，都会自带翻译好的中文字幕，这时候只需要压制一下就成了熟肉了。当然某个内容的深度爱好者还是会觉得官方字幕不够精确，会自己再出精校版、注释版等等。还有一点是AI越来越发达了，许多比较简单口语的内容AI能够完成听译一条龙，不过目前对于语言类的AI还是英语方面做得最好，到翻译成中文还是经常有那么些纰漏和不像人话的地方，碰到英语之外的语言就更孱弱了。等到AI进化成完全体的那一天，也许字幕组才会真正退出历史舞台吧。 </p>]]></content>
      
      
      <categories>
          
          <category> 搬运 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网关吃了我的 dnsmasq REPLY</title>
      <link href="/20240721-dnsmasq/"/>
      <url>/20240721-dnsmasq/</url>
      
        <content type="html"><![CDATA[<p>这次只能说，好好品一下了。</p><p>先说一下网络配置：</p><p>网关 - 路由器 - dhcp 服务器1： 192.168.3.1 Huawei AX3 Pro</p><p>dhcp 服务器2，PXE 服务器：192.168.3.21(dnsmasq)</p><p>上 dnsmasq 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/etc/dnsmasq.conf</span><br><span class="line">--------------------------</span><br><span class="line">port=0</span><br><span class="line"># dhcp-option-force=209,archiso_pxe.cfg</span><br><span class="line"># dhcp-option-force=210,</span><br><span class="line">dhcp-boot=/boot/syslinux/lpxelinux.0</span><br><span class="line">enable-tftp</span><br><span class="line">tftp-root=/srv/tftp</span><br><span class="line">log-dhcp</span><br><span class="line">dhcp-range=192.168.3.0,proxy,255.255.255.0</span><br><span class="line"># dhcp-vendorclass=set:bios,PXEClient:Arch:00000</span><br><span class="line">pxe-service=x86PC,&#x27;Network Boot&#x27;,/boot/syslinux/lpxelinux</span><br></pre></td></tr></table></figure><p>PXE 客户端：VirtualBox BIOS</p><p>两边抓包：</p><p>服务端：<img src="image-20240721151300600.png" alt="我肯定回复里是有信息的"></p><p>客户端：</p><p>不好意思，Wireshark 抓包结果没存。但是没有发现来自 c0a80315 的 DHCP 协议消息。RNM</p><p>我关掉了路由器的 DHCP，使用 Linux 上的 isc-dhcp-server，</p><p><img src="image-20240721203959046.png" alt="image-20240721203959046"></p><p>都没有 OFFER 了。如何验证是不是被路由器吞了？我们直接把两台电脑接起来</p><p><img src="image-20240721204222334.png" alt="image-20240721204222334"></p><p>瞬间啥都有了</p><p><img src="image-20240721204302756.png" alt="image-20240721204302756"></p><p>问题在于，我把 pxelinux.0 一送过去它就停下来了。不管是 VBox 还是物理 BIOS 都是这个 B 样。我懒得弄了，爬</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在没有DHCP的情况下使用PXE-网络启动服务器设置</title>
      <link href="/20240720-ipxe/"/>
      <url>/20240720-ipxe/</url>
      
        <content type="html"><![CDATA[<p>PXE, Preboot eXecution Environment，发音一般为 pixie，是从网卡启动的环境。我的了解并不深刻，但是总归，这种启动方式是和硬盘启动、USB 启动并列的一种方式。它做的事情无非是：</p><ul><li>从当前网络环境中找到一个 DHCP 服务器</li><li>DHCP 服务器告诉本机，TFTP 服务器的位置</li><li>本机从 TFTP 服务器上下载一个引导程序。可能是 lpxelinux，总之是个程序</li><li>可能还下载一些配置文件，告诉引导程序应该做什么</li><li>然后将控制权移交给引导程序</li></ul><p>这样的启动方式，还可以直接启动 grub。间接地，可以启动任何的操作系统。只要引导程序后续向远程请求 vmlinuz 和 initramfs，就可以启动 linux 内核。这也是无盘机的原理。</p><p>但是，pxe 的不便之处就在于，必须要一个 DHCP 服务器来给出这些配置。这对于广域网上的用户，并不是很友好。比如我在南京大学，想要连接中科大的网络启动服务，这就很困难。如果我想要我自己搭建的网络启动服务在校内都可用，我还需要和 ITSC (信息服务中心) 做可能的协商（并且大概率不会成功！除非以组织的名义来做，比如 LUG 和高性能计算中心一起来）。</p><p>造成这一切的主要原因是，网卡自带的 pxe ROM 并没有很复杂的功能。于是 iPXE 呼之欲出。</p><h2 id="配置-iPXE"><a href="#配置-iPXE" class="headerlink" title="配置 iPXE"></a>配置 iPXE</h2><p><a href="https://ipxe.org/">iPXE</a></p><p>可以选择烧到网卡上（！）或是烧到其他的启动介质上。</p><p>如果烧到网卡上，等于是仅对于我现在能够控制的机器有用。对于未来可能的机器，比如我要装个系统，我还要先烧一个 iPXE。这就麻烦了。烧到其他的启动介质上？我不如直接烧一个 Windows.iso 进去。</p><p>当然因为是做一个小玩具。并且我们并不确定会不会雀实存在有的电脑上采用了 iPXE。（并且我们不想用 U 盘）。因此在这里我们选择<a href="https://ipxe.org/howto/romburning/intel">烧网卡</a>。注意根据自己的网卡型号去看 ipxe 官网上不同的指引。</p><p>然而根据指引，我们还是要烧 U 盘。你妈</p><p>我居然真的没有 U 盘</p><h2 id="放弃-iPXE"><a href="#放弃-iPXE" class="headerlink" title="放弃 iPXE"></a>放弃 iPXE</h2><p>使用 DHCP 服务器吧。</p><p>使用打包好的 <a href="https://netboot.xyz/">netboot.xyz</a> 的 docker image。</p><h2 id="放弃-netboot"><a href="#放弃-netboot" class="headerlink" title="放弃 netboot"></a>放弃 netboot</h2><p>docker 要加 proxy 才能运行。dashboard 完全加载不了。</p><h2 id="跟着-ArchWiki-来做"><a href="#跟着-ArchWiki-来做" class="headerlink" title="跟着 ArchWiki 来做"></a>跟着 ArchWiki 来做</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人生是一场巨大的寸止</title>
      <link href="/20240720-bsk/"/>
      <url>/20240720-bsk/</url>
      
        <content type="html"><![CDATA[<p>人生就是在一场寸止之后，永远地提上裤子  —-我</p><p>周日（7.15）晚上和小智去了一趟 Boomshake，我大受震撼。去之前其实有点怕自己被卡颜直接卡出去，之后才明白，我擦，联系他的其实是酒吧销售。谁会跟钱过不去啊。</p><p>去之后现实冷清地等上人。在社恐当中开始了游戏。我艹，完全玩不明白，就是学着别人怎么玩我也怎么玩，没有什么交流，音乐声巨大也没办法语言交流。</p><p>越玩越没兴趣，多次想遁走，去卫生间外的休息室抽烟，全是俊男靓女。只能说没有好好预习，游戏咔咔输。</p><p>等到第二次逃到卫生间，头昏脑胀地坐了一会儿后，小智也来了，他走进去，10分钟都不带反应的。我只能进去看看他，好家伙，直接干趴了。我俩直接受不了了，准备打车跑路。</p><p>技术总结：看起来没什么技术含量的娱乐方式仍然是有门槛的。如果不懂里面的规矩，那就只能当个局外人。当然也没什么丢人了，毕竟素不相识。但也忍不住觉得自己也没开心，又可能让别人觉得莫名其妙，又有点挫败。也许是一件幸运的事，毕竟直接关上了这扇窗，对我的身体反而好一点。</p><p>这里的年轻人们出了门后也许就是寻常模样。有些是来玩的，有些是以此为生。雇佣方式有可能是销售摇人，私下结清。很难想象如果出了门，这些历史记录是否就消除地一干二净。</p><p>当然我并不在意别人的过去，难道为自己的笨拙找个理由开脱是什么罪吗？</p><p>有心无力，应该去到哪里才能使自己被容得下？那岂不是要改变自己的意志。</p><p>一个强到能够改变自己的意志的人，也是强到能够不移其志的人。总而言之–他是自由的。这两种做法需要的品格明明同源同种。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从源码更新 sshd</title>
      <link href="/20240718-sshd/"/>
      <url>/20240718-sshd/</url>
      
        <content type="html"><![CDATA[<p> 之前爆出 Linux 上的 sshd 可能有一个 race condition 导致的 RCE。建议更新到 openssh 9.8。于是火速 clone 源码之后直接 make install 了。</p><p>但是今天在断电之后想扫一下办公室网络发现主机，觉得更新的人应该不多，随手就</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV ip/24 -p 22</span><br></pre></td></tr></table></figure><p>期待出一个 openssh 9.8，结果出来了一个别人的主机，自己的是没有。当然后来验证了其实是我的机器没有开，但我到了座位上之后，也是闲的蛋疼想看看 nmap 一下自己的设备到底能出些什么玩意。结果大为震撼，<code>openssh-9.6p1</code> 。。。</p><p>到底是谁发明的 <code>ssh -V</code> 验证版本更新成功法？这里面有另外？个变量：</p><ul><li>openssh 的安装目录</li><li>systemd 的配置</li><li>ssh 的编译参数</li></ul><p>openssh 现在居然默认安装在 <code>/usr/local</code>。。。但是 systemd 当然只认 <code>/usr/</code>。</p><p>ssh 编译时如果不指定和当前版本一致的 config 目录，就。。不知道会是哪里。最后会导致 fingerprint changed &amp; man in the middle attack。</p><p><img src="image-20240718215331548.png" alt="image-20240718215331548"></p><blockquote><p>配置文件目录变了之后，就不会用原来的 pubkey 作为 fingerprint 了</p></blockquote><p>所以我们根据 <a href="https://www.linuxfromscratch.org/blfs/view/systemd/postlfs/openssh.html">OpenSSH-9.8p1 (linuxfromscratch.org)</a> 的指导，重新编译了 openssh，并且小改 Makefile 进行了安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr                            \</span><br><span class="line">            --sysconfdir=/etc/ssh                    \</span><br><span class="line">            --with-privsep-path=/var/lib/sshd        \</span><br><span class="line">            --with-default-path=/usr/bin             \</span><br><span class="line">            --with-superuser-path=/usr/sbin:/usr/bin \</span><br><span class="line">            --with-pid-dir=/run                      &amp;&amp;</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>更新：这样做会使得在 ssh client（ssh-session）中，PATH 没有 &#x2F;usr&#x2F;local&#x2F;bin。导致自己编译安装的 vim 没办法直接启动。</p><p>解决办法：<code>--with-default-path</code> 和 <code>--with-superuser-path</code> 加一加。</p><p>更新：2FA 和登录邮件提醒消失了</p><p>解决：添加 <code>--with-pam</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux wakeonlan 无法正常开启</title>
      <link href="/20240718-linuxwol/"/>
      <url>/20240718-linuxwol/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nettool -s enp34s0 wol g</span><br></pre></td></tr></table></figure><p>g 就是 granted，d 就是 denied</p><p>这样设置网卡允许wol是一次性的。重启之后，又自动变成禁止。尝试用 update-rc.d 开机自动执行脚本，不知道为什么不行。</p><p>所以按照 ArchWiki 的方式，设置成 systemd 管理的</p><p><a href="https://wiki.archlinux.org/title/Wake-on-LAN">Wake-on-LAN - ArchWiki (archlinux.org)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/systemd/network/50-wired.link</span><br><span class="line">---</span><br><span class="line">[Match]</span><br><span class="line">MACAddress=aa:bb:cc:dd:ee:ff</span><br><span class="line"></span><br><span class="line">[Link]</span><br><span class="line">NamePolicy=kernel database onboard slot path</span><br><span class="line">MACAddressPolicy=persistent</span><br><span class="line">WakeOnLan=magic</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 快速启动无法被 wol 唤醒</title>
      <link href="/20240718-wol/"/>
      <url>/20240718-wol/</url>
      
        <content type="html"><![CDATA[<p>Windows 官方文档《 <a href="https://go.smzdm.com/3ecd4f1e758f18ee/ca_aa_yc_163_amx025p4_16293_2621_1641_0">System Power States</a> 》中讲述到，<strong>Windows 系统自身（抛开 BIOS 不谈）是不支持“快速启动”和“关机”状态下的网络唤醒，只支持“睡眠”、“休眠”状态下的网络唤醒</strong>：</p><ul><li><p>睡眠（Sleep），属于 S3 电源状态；</p></li><li><p>快速启动（Fast Startup），属于 S4 电源状态；</p></li><li><p>休眠（Hibernate），属于 S4 电源状态；</p></li><li><p>关机（Soft off），属于 S5 电源状态</p></li><li><p>对于<strong>“快速启动（fast startup, S4）”：</strong>从 Windows 8.1 开始到 Windows 11，“快速启动”作为系统默认的“<strong>关机”方式</strong>，是不支持网络唤醒的，<strong>这也是为什么在 WOL 的教程中会让你关闭“快速启动”</strong>：</p></li></ul><blockquote><p>“快速启动”：快速启动是一种关机类型，它使用休眠文件来加快后续的启动速度，在这种关机状态下，Windows 系统不支持网络唤醒。“快速启动”与“休眠”同属于  S4 电源状态。</p></blockquote><p><img src="619f939c2356a9109.png_e1080.jpg" alt="WOL 网络唤醒避坑指南：常见问题的分析与内容补充"></p><p>“快速启动”属于“<strong>hybrid shutdown（混合关机）</strong>”，是关机的一种类型：</p><p><img src="619fb314b625f7326.png_e1080.jpg" alt="《System Power States》"></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统无法正常 suspend （睡眠）</title>
      <link href="/20240718-suspend/"/>
      <url>/20240718-suspend/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p>仔细翻看 journal：</p><p><img src="image-20240718185134192.png" alt="image-20240718185134192"></p><p> 但其实我们并没有 nvidia 驱动，甚至是 headless 的。查看 service 的依赖</p><p><img src="image-20240718185214952.png" alt="image-20240718185214952"></p><p>全删掉，然后 <code>daemon-reload</code> 就好了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>看看Redis 2.8源码</title>
      <link href="/20240715-redis/"/>
      <url>/20240715-redis/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20240715140825253.png" alt="image-20240715140825253"></p><p>唯一用到多线程的地方是一个看起来很 trivial 的优化，震撼我妈</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图形绘制技术-光学相机</title>
      <link href="/20240708-optical/"/>
      <url>/20240708-optical/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20240708144504816.png" alt="image-20240708144504816"></p><p>参考文献：现代光学镜头设计方法与实例</p><p><img src="image-20240710155552561.png" alt="image-20240710155552561"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知识领域</title>
      <link href="/20240706-fields/"/>
      <url>/20240706-fields/</url>
      
        <content type="html"><![CDATA[<p>之前总结过一次研究生阶段需要关注的领域。不过那张纸丢失了，这样也好，我可以调整一下重心。</p><p>健美&#x2F;力量举&#x2F;举重</p><p>营养学&#x2F;烹饪</p><p>斯诺克&#x2F;台球</p><p>赛车&#x2F;F1&#x2F;摩托车&#x2F;汽车</p><p>生理学&#x2F;运动科学&#x2F;医学</p><p>心理学</p><p>哲学&#x2F;精神分析&#x2F;现象学</p><p>文学&#x2F;历史&#x2F;神话</p><p>植物学&#x2F;动物学&#x2F;微生物学</p><p>化学</p><p>声乐&#x2F;器乐&#x2F;古典&#x2F;歌剧   吉他</p><p>电视剧&#x2F;电影</p><p>书法</p><p>行政&#x2F;政治学&#x2F;国际政治</p><p>经济学&#x2F;金融</p><p>管理学</p><p>调酒&#x2F;果茶&#x2F;奶茶&#x2F;茶&#x2F;咖啡</p><p>园艺&#x2F;插花</p><p>立直麻将&#x2F;国际象棋</p><p>社交技巧&#x2F;人际关系</p><p>军事&#x2F;军用装备</p><p>日语&#x2F;法语</p><p>电脑维修</p><p>手工&#x2F;木工&#x2F;设计&#x2F;机械</p><p>写作&#x2F;表达&#x2F;喷人</p><p>电子产品</p><p>机器学习</p><p>营销学</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK 设计</title>
      <link href="/20240701-dmck/"/>
      <url>/20240701-dmck/</url>
      
        <content type="html"><![CDATA[<p>我也不知道怎么回事，在后台有一个随机读写lock的程序忘了kill的情况下，测试程序一直能打出长度一样、顺序一样、甚至内容也一样的log，企图骗我这就是执行路径。CS套路深，我要回农村</p><p>假设我获得了系统调用的顺序和所有系统调用之后的进程状态。</p><p><img src="image-20240702214113221.png" alt="image-20240702214113221"></p><p>显然是B。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssite_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> buf[.count], <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>注意 buf 是 <code>const</code> 意思是写之前和写之后是同一个状态。但是 $\mathbb{A}$ 状态下，write 的参数未必准备好了。只有到系统调用的前一刻，其所有的参数才被准备好。想要从 $\mathbb{B} $ 之前获取参数并不是什么问题，关键在于「向前多少」</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>了结</title>
      <link href="/20240630-ending/"/>
      <url>/20240630-ending/</url>
      
        <content type="html"><![CDATA[<p>这几天实在狠狠地玩大了。本来应该用来干活的时间都浪费掉了。睡觉睡不醒，看不完的剧，打不完的麻将。我也不知道我这是怎么了，很久很久没有拿得出手的成就，也没有什么东西值得去拼。这个目标不一定要多么高尚，甚至于千万不能高尚，而仅仅在于一个“有”。有一个很矬、很蛇皮的目标，却能使人行高尚之实。</p><p>第一件事就是为接下来的工作安排一个章程。</p><p>什么时候休息？真正疲劳的时候，完全疲劳的时候。只要脑力仍能运转，就不安排休息；甚至是一段时间后清醒了又可以继续。这几天就略微放任一下作息，到个人最自然的节律即可。</p><p>然后把心事都了解一下。首先是关于 Z女士。上周日外出喝酒，真心话环节她问，是否会接受一夜情，是否接受炮友。我当然是都接受的，也正面回答了。这问题倒是并不恼人，毕竟我从来不打算掩饰，但是提出问题的原因无法探究，也许就是好奇一下？反而我就不能问回去，毕竟对方的对象在场，有的话毕竟不该说。另外令人在意的是，提及本科阶段都喜欢过哪些人的时候，总之我不在其列。我在妄想什么？不过这些都是無駄のこと！真的假的都不能说出来。</p><p>周三还是周四晚上，我在计科楼东南角抽烟。满耳的蝉鸣让我感觉身在乡下，于是发了条动态。结果过了十几分钟，她居然和她男朋友到原地来逮捕我。也不能说是碰巧，也就是赌我在那里坐了几十分钟。</p><p>于是后来也没有见到。戏剧已经落幕。</p><p>会有人掉两滴眼泪吗？她离开的是这一切，理所当然；而我离开的只是她，所以我不会。</p><p>写完这些的确是很丧气的。这位断断续续地在我生命中走了两三年，这期间我不是过于冲动和情绪化，就是过于谨慎。事到如今我也不知道我有没有成熟一点，我们之间的关系是简单呢？还是复杂呢？谁知道。</p><p>我们一起喝酒，一起抽烟。最后留下的身影也是那样。她坐着 Z先生 的车，叫我好好珍惜她。</p><p>谁知道该怎么珍惜呢？懂事的孩子是不应该多说什么的。</p><p>莫欺少年穷；而少年却不可以此自恃，隐而不发。赢得所谓的最终胜利？如今也不知道是不是有这样的胜利存在。总之一切都不可信，自从隐瞒的心思重了之后，就发现一件事：想要人不知，即使外界用尽手段去探知，也有可能无功而返。只要讲故事的功夫到位，叙述诡计可以骗过所有人的眼睛。他人的谜团是永远都解不开的。</p><p>当然放在自己身上还是要谨慎一点，因为这是一个悖论：自己不希望别人知道的事情一定会被人知道。</p><p>思路有点中断，依我看确实应该休息了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内心快板一则</title>
      <link href="/20240630-allegro/"/>
      <url>/20240630-allegro/</url>
      
        <content type="html"><![CDATA[<p>客人：这差使您办好了，不负众望。</p><p>先生：鬼知道我吃了多少苦头。</p><p>客人：这些磨难让您更加成熟老练，以后世上的人听到您的姓名，无人不知无人不晓这一位铁骨头的硬汉子。</p><p>先生：我本不想收受它的这些好处。这难事落到谁的头上，本来就是一笔糊涂账！有人可以得过且过，有人就要苦尽甘来， 甚至于这甘也并不来。</p><p>人本没有必要平衡心态，无非是对比多了自觉“失衡”。但我只劝想要“平衡”的，那高高在上的为什么用不着自己平衡，反而让落在下面的自己去找？</p><p>子女较多的家里，经常有被要求懂事的那几个，和被溺爱的那几个。那要懂事的，往往受到的恩惠是较少的。因为是”懂事的”，所以他们并不能为少受恩惠而大呼小叫。于是发展出的那种苦闷是二阶性的： 其怀疑的是【必须自己想出将这一切合理化的说辞说服自身】这件事。</p><p>简单来说，这个气我受了，但是要我跟谁也不能说，打碎了牙往肚子里咽，哪有这么霸道的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024春季 蒋炎岩《操作系统》期末回忆</title>
      <link href="/20240630-OS/"/>
      <url>/20240630-OS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>By <a href="https://space.bilibili.com/8002700">Fradow</a></p></blockquote><h2 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一 基本概念"></a>一 基本概念</h2><p>均用10-20字描述即可。</p><ol><li>什么是内核（kernel），什么是外壳（shell）？</li><li>写出系统调用（<code>syscall</code>、<code>ecall</code> 等）的功能。</li><li>什么是数据竞争？为什么C代码中要避免数据竞争？</li><li>很多操作系统都没有关机指令，那么它是如何实现关闭计算机的？</li><li>为什么磁盘等存储设备要设计成按块读取？</li></ol><h2 id="二-进程、线程与地址空间"><a href="#二-进程、线程与地址空间" class="headerlink" title="二 进程、线程与地址空间"></a>二 进程、线程与地址空间</h2><p>现在你想在Linux上实现 <code>pidof</code> 指令，可通过命令行参数传入进程名，打印拥有该进程名的所有进程号。</p><ol><li><code>pidof</code> 的 <code>main</code> 函数有 <code>argc</code>、<code>argv</code> 两个参数，写出其函数原型，解释它们都代表什么含义。</li><li>命令行参数传给进程后存放在什么位置？</li><li>10-20字描述如何实现 <code>pidof</code>。</li><li>操作系统中的进程可以随时开始、中止。这对的实现有何影响？如果想让 <code>pidof</code> 显示（近期）历史上某个瞬间的进程列表，需要如何实现？</li></ol><h2 id="三-编译、链接和加载"><a href="#三-编译、链接和加载" class="headerlink" title="三 编译、链接和加载"></a>三 编译、链接和加载</h2><p>以下是执行 <code>./a.out</code> 后其进程对应的一段 <code>pmap</code> 输出。<em>（回忆时编的，重点是最后一列）</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0000000000400000</span>    <span class="number">132</span>K r-x-- a.out</span><br><span class="line"><span class="attribute">0000000000602000</span>      <span class="number">4</span>K r---- a.out</span><br><span class="line"><span class="attribute">0000000000603000</span>      <span class="number">4</span>K r---- a.out</span><br><span class="line"><span class="attribute">0000000000604000</span>      <span class="number">4</span>K rw--- a.out</span><br><span class="line"><span class="attribute">00007f8b1c000000</span>    <span class="number">128</span>K rw---<span class="meta"> [anon]</span></span><br><span class="line"><span class="attribute">00007f8b1c020000</span>    <span class="number">256</span>K rw---<span class="meta"> [anon]</span></span><br><span class="line"><span class="attribute">00007f8b1c040000</span>    <span class="number">132</span>K rw---<span class="meta"> [stack]</span></span><br><span class="line"><span class="attribute">00007fffedcfed00</span>      <span class="number">4</span>K r-x--<span class="meta"> [vvar]</span></span><br><span class="line"><span class="attribute">00007fffedcff000</span>      <span class="number">4</span>K r----<span class="meta"> [vdso]</span></span><br></pre></td></tr></table></figure><ol><li>解释静态链接和动态链接的区别。</li><li>在输出中的每一行地址空间后写出其表示的含义。<code>./a.out</code> 是通过静态链接还是动态链接得到的？</li><li>若实现一个调试器，支持用一个进程调试另一个进程，需要在操作系统上做什么设计（在系统对象和系统调用上）？</li></ol><h2 id="四-并发编程"><a href="#四-并发编程" class="headerlink" title="四 并发编程"></a>四 并发编程</h2><p>现有n个线程（线程号为1, 2, 3, …, n）玩石头剪刀布，每个线程创建后均执行一次 <code>play_one_round</code>。其中调用 <code>play</code> 得到每个线程的胜负结果，若平局则结果均为 <code>TIE</code>。请写出完整的 <code>play</code> 函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">play_one_round</span><span class="params">(<span class="type">int</span> pid, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">  assert(type == ROCK || type == SCISSORS || type == PAPER);</span><br><span class="line">  <span class="type">int</span> result = play(pid, type);</span><br><span class="line">  <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">    <span class="keyword">case</span> WIN: <span class="built_in">printf</span>(<span class="string">&quot;I (%d) win!\n&quot;</span>, pid); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOSE: <span class="built_in">printf</span>(<span class="string">&quot;I (%d) win!\n&quot;</span>, pid); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为可以使用的线程库函数。假设互斥锁初始状态为解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mutex_lock</span><span class="params">(<span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mutex_unlock</span><span class="params">(<span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">sem_t</span> semaphore = SEM_INIT(<span class="type">int</span> value); <span class="comment">// initialize semaphore</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> sem, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> sem, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cond_wait</span><span class="params">(<span class="type">cond_t</span> *cond, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cond_signal</span><span class="params">(<span class="type">cond_t</span> *cond, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cond_broadcast</span><span class="params">(<span class="type">cond_t</span> *cond, <span class="type">mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><h2 id="五-文件系统"><a href="#五-文件系统" class="headerlink" title="五 文件系统"></a>五 文件系统</h2><ol><li>Everything is a file. 目录是文件吗？</li><li>什么是文件描述符？写出3个返回文件描述符的系统调用名称。</li><li>解释操作系统如何区分一个文件是普通文件、流还是设备。</li><li>RAID相比使用单个或多个可靠磁盘有何优点？</li><li>假如有一款内存得到普及，其容量和性能与DRAM相当，断电后数据不消失（但正在写入的内容可能会消失），这会对文件系统有何影响？可以适当展开分析。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>镜头光晕 分析</title>
      <link href="/20240627-lensflare/"/>
      <url>/20240627-lensflare/</url>
      
        <content type="html"><![CDATA[<p>直观上来看：</p><ol><li>图片上的圆形和光斑是由于光线在镜头和光圈之间“来回反射”（反射）造成的。 </li><li>特定方向上的光线尖峰很可能是由于光线在相机传感器（数字相机上是网格状的）和&#x2F;或光圈光阑上的衍射造成的。 </li><li>光源周围的光晕（我这里不是说任何大气效应）是由于强光在镜头的玻璃材料中的散射造成的。</li></ol><p>为了实现1和3，需要扩展现实相机模型。我们必须考虑一些在镜头上反射的光线，除了那些仅通过它们折射的光线。</p><p>控制两种不同材料之间界面处光重新分配的物理方程是菲涅耳方程。它们可以从麦克斯韦方程中推导出来，麦克斯韦方程更普遍地控制电磁波在材料中的传播。</p><p>菲涅耳方程给出了在界面处反射的光的百分比 R，具体取决于斯涅尔角 θi 和 θt 以及两种材料的折射率 n1 和 n2。有两个方程，取决于入射光是否在垂直于该平面的入射平面上偏振。对于非偏振光 - 我们假设摄影师在这里没有使用任何偏振滤光片 - R 只是两个项 Rs 和 Rp 的平均值。</p><p>让我们看一下 R 的值取决于参数。正如我们所看到的，反射系数 R 增加得更快——当光从折射率较大的材料变为折射率较小的材料时，对于长角度（全内反射）等于 1。</p><p>在我们的例子中，这意味着镜头外部的反射比镜头内部的反射更频繁——这有点违反直觉。</p><p>下面可以看到光线在通过相机时被反射 4 次的示例：</p><p>我实现这一点的方式是概率的：在每个接口上，我计算反射系数 R。然后，我根据这个值随机决定光线是反射还是折射。这相当于实际拆分每个界面处的每条射线，并用 R 或 （1-R） 对它们进行加权，但以这种方式更容易实现。</p><p>下面是在随机选择的界面上分割的射线示例。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AML复习</title>
      <link href="/20240618-aml/"/>
      <url>/20240618-aml/</url>
      
        <content type="html"><![CDATA[<p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkU5ZXBZQjN5YlYzY1hNeXNhaXRMVHliSlZqaEdJQ1BDU0QtQ2lpSmlNeVJtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkpYVGNGWm1nTzludDg5ejJaQUgzSUpRdXVGY0dJZVBDaUQtQ2lqdGxNeVJtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkNiUFlnU09oVUlGdExDY1YzQzAwUFNFbFZwUEdNcnNDaUQtQ2lqQjU5S1JtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRlBscGxpMVdVWnJqYzJ3UThMakdURkNQcWtCVkdJWENDQ0QtQ2lqVm50cVJtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkFLYzV5SktBV2lSV0hrb05pNV9QcEppYTM2NEdPdVJEU0QtQ2lqUHBOT1JtdUtHQTFDQXV5OA" alt=" "></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算模型导引复习</title>
      <link href="/20240616-computTH/"/>
      <url>/20240616-computTH/</url>
      
        <content type="html"><![CDATA[<p>题型分析</p><p>基础概念 1，2-图灵机（16，17）3-一般、原始、部分递归函数，Lambda演算的CR性质（18）4-配对函数组，停机问题（19）5-（20） Lambda不动点算子（21）6-（22） 7-通用图灵机（22） 8-（23）9-Turing。。。算法可以达到的绝对极限（23）</p><p>函数 1，3，5，7，9，11，13-判定数论函数类（16，17，18，19，20，21，22）2-构造函数（16）4-构造函数（17）6，12-一元递归函数性质证明（18，21） 8-证明初等函数（19） 10-构造什么什么定义数论全函数 14，16-函数和Godel编码（22，23）15-一元递归函数性质，函数周期性等（23）</p><p>Lambda演算 1，2，3，4，5，6，7，8-添加公理的证明（16，17，18，19，20，21，22，23）</p><p>图灵机 1-求输出（16） 2，7，8，9，10，11-构造图灵机计算函数（16，19，20，21，22，23）3，5-从输入输出构造函数（17，18）4，6-停机问题证明（17，18） </p><p>其他：1，3，4，8，9-证明sinh&#x2F;其他函数的第n位 f(n) 为Turing可计算（23），进而证明是初等函数。（18，19，20，22）  2-可判定的证明（19） 5-证明Turing可计算函数为一般递归函数（20）  6-看不懂（21.6） 7-证明不动点结合子（21.7） 8-算中国剩余定理（23）</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为赋新词</title>
      <link href="/20240611-shortcircuit/"/>
      <url>/20240611-shortcircuit/</url>
      
        <content type="html"><![CDATA[<p>如今看年轻人为赋新词而说的愁，不免感到有点可笑。我倒不是在说他们的困境并非真实的，而是这种姿态显得不够强大。最近在很多场合，我都下了这样的定论：如果你觉得的内心足够强大，你尽可以随心意去做事；但如果一个人的内心容易受到伤害而不能很快地恢复，那对他来说采取保守的防备姿态也是一件相当正常的事情。</p><p>如何让自己相信自己的内心是强大的，我想这只能借助于一种自负，即那种在任何情况下否认自己受到了伤害，自己坚信不疑。（录者语：我现在改变看法了）这可能有很大一部分是天生的，有一小部分是长久以来的习惯。这样的习惯是很难刹得住车的。让人从一种信念而转向另一种看起来简直是蛮不讲理的信念。</p><p>这种蛮不讲理，仅仅是因为其不符合社会从一开始就赋予所有人的一种“短路”。可以想到只要解开这一短路。但这需要一个人在其经历中的反复思考，以及一种作“哥白尼式的革命”的勇气。</p><p>经验上看来，对于短路的路径作一系列追问将使人沉默。此时不应给予任何答案，不引入新的短路，而叫人获得一个自己选择的机会，深刻地在考虑自身的欲望之后进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Isolated</title>
      <link href="/20240611-lone/"/>
      <url>/20240611-lone/</url>
      
        <content type="html"><![CDATA[<p>越是到夏天这时候，在床上就越是难以入眠，特别是有一个喜欢关了空调睡觉的舍友。好在这光景也就只是持续一周。躺在床上翻来覆去，其实并没有什么可思考的。只是在那里把遗书的事情在脑子里安排了一遍。醒来之后倒也没觉得这种想法很可笑，只是觉得可以按住暂时不去实行，毕竟没到非死不可的境地。</p><p>去412坐了一晚，那是一个相当亲切又热情的地方，就像加州旅馆一样。之后一冲动就想着入社了。那里确实有很多朋友，就算我并不是社员，偶尔去玩一趟也不是什么不可以的事情，但毕竟还是希望名正言顺，希望没人会有意见。仿佛经过这一年的事情之后，我变得有点畏首畏尾的，昨晚还想着是不是应该行善积德，重新建立一下自我。这段时间我应该多一个人待着。特别忙碌的时候，人的进步就停止了。需要一段完整的时间对自己施加肉眼可见的改变。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夕拾 第三周</title>
      <link href="/20240609-week3/"/>
      <url>/20240609-week3/</url>
      
        <content type="html"><![CDATA[<p>上周除了电视剧以外基本没看什么。明天补一点吧。</p><p>我找到一本书。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z:/ZijingBT/kindle电子书资源/kindle人的资源打包/自制21-40/ZZ21-22/数码摄影构图与用光.pdf</span><br></pre></td></tr></table></figure><p>本周来把它看掉。</p><p>看雍正王朝（已过半）</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 夕拾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人民的名义</title>
      <link href="/20240603-intheNameofPeople/"/>
      <url>/20240603-intheNameofPeople/</url>
      
        <content type="html"><![CDATA[<p>这是一部很长的剧，有55集之多。最后是用两周时间去看完的。</p><p>里面值得学习的细节很多，需要解读的内容也很多。当然有很多人去做了“中译中”，而我在看的时候的确就思考不了那么多，语言的艺术这些东西都显得有点虚了。</p><p>我只提几点：</p><p>一是守住底线。做任何事都要把原则性放在第一位。</p><p>二是谨慎交友。不结交卑鄙小人，不得罪道不同不相为谋的人；保持真正的革命友谊，既是最务实的，也是最打动人心的。</p><p>三是学会以退为进。适当的时候放弃眼前的，看到下一步应该怎么做。</p><p>四是学习上不能放松。特别是用严谨的思维分析情势的能力要加强。</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夕拾 第二周</title>
      <link href="/20240603-week2/"/>
      <url>/20240603-week2/</url>
      
        <content type="html"><![CDATA[<p>上周剩下一个没看完的：</p><p><img src="image-20240527150622100.png"></p><p>当然是因为上周最后把所有的时间都用来刷完了人民的名义，读性心理学这些。本周还是可以照常安排。</p><p>剧：</p><p><img src="image-20240603174946953.png" alt="image-20240603174946953"></p><p>电影：</p><p><img src="image-20240603175029995.png" alt="image-20240603175029995"></p><p><img src="image-20240603175126800.png" alt="image-20240603175126800"></p><p>学习材料</p><p><img src="image-20240603180310929.png" alt="image-20240603180310929"></p><p>纪录片</p><p><img src="image-20240603180358644.png" alt="image-20240603180358644"></p><p>​</p><p>我突然觉得摄影还是要比较系统地学。多练眼睛和构图的巧思</p>]]></content>
      
      
      <categories>
          
          <category> 夕拾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The.Scent.of.Yvonne.1994</title>
      <link href="/20240601-yvonne/"/>
      <url>/20240601-yvonne/</url>
      
        <content type="html"><![CDATA[<blockquote><p>吐个槽，紫荆站上的老电影真的是不能随便点开，你根本不知道什么时候会突然露个点给你看。</p></blockquote><p>背景大概是1940年左右，在法国。一个有点普通的爱情故事。但是最后的发展很奇怪。当然，在讲述往事的时候，穿插了十几年以后两位男主的故事。</p><p>为什么男主提出去美国之后，女主就和本地乡绅好上了？</p><p>为什么男二被打成同性恋者？完全没有交代。</p><p>为什么男二最后倒车再冲下山崖在男主面前自杀了？</p><p>真是一部一言难尽的电影。</p><p>从豆瓣摘了一点。看来我还是不懂一点浪漫。</p><blockquote><p>假如你见到了一个能满足你各种幻想的女人，你会有另一个脑子去相信她又懒又放荡又薄情吗？电影的关键点，就是伊冯娜的叔叔跟维克多私下交谈的内容，在她叔叔嘴里，完全是真实的伊冯娜。男女都是视觉动物，以貌取人，爱上的，都是这个人带给你的一种感觉，而感觉里有一半都是脑补出来的幻想。人的外表，和内在不见得是一致的，它代表一部分内在，但也隐藏了一部分内在。漂亮女人，让人贪爱的同时，很难想到她漂亮的外表下，可能是另一颗并不美丽的心。甚至，即使你知道她并不美丽的另一面，你也依然不觉得不美，甚至你还会去理解她。</p><p>这就是美丽外表的力量！</p><p>就像是香水，掩盖住了不堪的体味儿，却让你久久不能遗忘。漂亮，是一种资本，它可以让人沉迷于对猎物获取的快感之中，又能享受从不同猎物身上获取的价值。因此，有的漂亮的动物，就像是鸟儿一样，不会总落在同一个枝头。这就是更了解伊冯娜的勒内说的，你不要让她离开你的视线，她只属于那一刻。</p><p>而维克多，并没有理解这一番话的意思。香水带给人的感觉是挥之不去的，久久停留在人的记忆中，即使是失去，即使是知道不堪，你也忘不掉它带给你的感觉。</p></blockquote><blockquote><p>勒孔特搞突然死亡，无非是要解释人物对无聊生活、机械人生的厌倦，企望用死来获得超脱，用死来挽留正在流逝的美好时光，“证明我活过，我爱你，我爱你们，爱的那么纯粹”。</p></blockquote><blockquote><p>她叔叔说，她是个麻烦，她只活在那一刻。他砸烂那个每小时敲12下报时的老钟，那一刻，他是希望她能停下在那一刻的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>未记录时间的记录</title>
      <link href="/20240601-whattime/"/>
      <url>/20240601-whattime/</url>
      
        <content type="html"><![CDATA[<p>理工科人的文笔，从统计的角度上来讲，可能的确是比较差。</p><p>但这并不是理工科本身的错，逻辑链条要比这长得多。</p><p>这更主要地是因为—理工科是对爱幻灭的遗族们为自己的子女选择的避难所。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高级机器学习：二分类</title>
      <link href="/20240530-aml/"/>
      <url>/20240530-aml/</url>
      
        <content type="html"><![CDATA[<p>任务：</p><ul><li>读描述，下载数据集</li></ul><p>数据集：客户id，名字，信用点，位置，性别，年龄，年限，存款，产品数量，有信用卡，活跃，月薪</p><p>预测：客户是不是跑路了</p><p>实现：任何算法，任何语言。</p><p><strong>网络设计</strong>：根据问题的具体需求设计神经网络的结构。对于简单的二分类问题，一个两到三个隐藏层的小型 MLP 通常就足够。</p><p><strong>激活函数</strong>：对于隐藏层可以使用 ReLU 激活函数，因为它有助于解决梯度消失问题，并且计算上比较高效。输出层因为是二分类问题，所以建议使用 sigmoid 激活函数。</p><p><strong>损失函数</strong>：使用交叉熵损失函数（binary cross-entropy），这是处理二分类问题的标准选择。</p><p><strong>优化器</strong>：可以使用 Adam 或 SGD（带动量），这些优化器能帮助快速收敛且通常表现良好。</p><p><strong>正则化</strong>：为了避免过拟合，可以在训练过程中加入 Dropout 层或使用 L2 权重正则化。</p><p>**可以作一些仔细的分析。</p><p>输出：$yourId.txt，1000 lines，没有文件头的结果。</p><ul><li>实现算法，输出预测</li><li>写报告</li></ul><p>1）你的理解和分析</p><p>2）算法的动机，介绍算法的背景</p><p>3）算法的技术细节，特别是要包括伪代码</p><p>4）描述或分析算法的表现</p><p>5）总结和（可选的）讨论</p><p>使用 LaTeX 模板撰写含有英文摘要的中文报告。命名为 report.pdf</p><ul><li>提交</li></ul><p>1）$yourId.txt</p><p>2）report.pdf</p><p>3）源代码</p><p>打包zip，命名为 $Id_v$version.zip。e.g. 1912xxx_v1.zip</p><p>使用南大表格提交</p><p>Baselines:</p><p>经典算法包括随机森林，逻辑回归，XGBoost GBST，SVM，MLP，GBDT 等等。可以参考这些算法的表现。</p><table><thead><tr><th>alg</th><th>f1</th></tr></thead><tbody><tr><td>RF</td><td>0.583</td></tr><tr><td>LR</td><td>0.487</td></tr><tr><td>SVM</td><td>0.568</td></tr><tr><td>MLP</td><td>0.586</td></tr><tr><td>GBDT</td><td>0.603</td></tr><tr><td>RFE (n&#x3D;9)</td><td>0.609</td></tr></tbody></table><p>算法选择</p><p>CatBoost 是一种流行的梯度提升决策树（Gradient Boosting Decision Tree, GBDT）算法，由 Yandex 开发。它是专门为处理分类特征而优化的机器学习算法，同时也适用于回归问题。CatBoost 有几个显著的优点：</p><ol><li><strong>对分类特征的原生支持</strong>：CatBoost 可以直接处理分类特征，无需进行预处理（如独热编码）。这简化了数据预处理步骤，并通常能提高模型的性能。</li><li><strong>避免过拟合</strong>：CatBoost 实现了几种机制来减少过拟合的风险，例如具有有序提升的默认树学习策略。这种技术在训练每棵树时使用不同的数据子集，从而提高了模型的泛化能力。</li></ol><table><thead><tr><th>性能</th><th>baseline</th><th>smoothing + binning</th><th></th></tr></thead><tbody><tr><td>f1</td><td>0.598446</td><td>0.630029</td><td></td></tr><tr><td>acc</td><td>0.827778</td><td>0.846667</td><td></td></tr><tr><td>recall</td><td>0.641667</td><td>0.652778</td><td></td></tr><tr><td>precision</td><td>0.560680</td><td>0.608808</td><td></td></tr><tr><td>auprc</td><td>0.691654</td><td>0.693995</td><td></td></tr><tr><td>auc</td><td>0.856181</td><td>0.862392</td><td></td></tr><tr><td>macro f1</td><td>0.744414</td><td>0.766660</td><td></td></tr></tbody></table><p>数据预处理</p><p>观察训练集上属性值的数量可知，Surname 是 High-catdinality categorial variables. 做 polynomial smoothing</p><p>提高泛化能力，对Balance和Salary 做等频分箱</p><p>调参</p><p>depth, score_function,list of cat features</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>性心理学</title>
      <link href="/20240529-sexpsychology/"/>
      <url>/20240529-sexpsychology/</url>
      
        <content type="html"><![CDATA[<p>作者：霭理士</p><p>快快地读，做纸质的笔记，然后在归纳的时候录入到这里。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>天水围的夜与雾.Night.and.Fog.2009</title>
      <link href="/20240528-nightandfog/"/>
      <url>/20240528-nightandfog/</url>
      
        <content type="html"><![CDATA[<p>Night and Fog</p><p>以家庭暴力为题材的电影。镜头和布置平淡但真实，90年代的风格又使人仿佛要窒息。</p><p>看前半段的时候，总是觉得故事叙述节奏太慢。后半段则穿插李森和玲相识的往事，与问询知情人的片段，最后停止在案发当场。</p><p>这是在说什么呢？看起来美好的开局，和习以为常的平静生活，仍然酝酿出一桩惨案。</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>污垢.Filth.2013</title>
      <link href="/20240529-filth/"/>
      <url>/20240529-filth/</url>
      
        <content type="html"><![CDATA[<p>过了两天才来写。</p><p>说实话里面有很多内容我看不明白，比如说，男主的那个妻子到底是否是幻想？还是真实的？我倾向于认为那个是男主的幻想。更进一步，是一个内化了的大他者：用诱惑的方式要求男主晋升，并且允诺一种持续的激情。男主对于这个幻想可以说是唯命是从，以至于他不遗余力地通过女装的方式成为那个幻想中的。既然“她”能允诺我拥有极度的幸福和激情，那么她本身是必然有享乐的能力的。</p><p>男主在升职这件事情的做法上很有意思：通过栽赃同事靠性上位、是男同、说领导坏话，而这些都是男主自身。包括后来把朋友陷害入狱，其罪行也是男主自己犯下的；男主所办的案子，自己也是目击证人。将自己的缺陷都附加到他人的身上。</p><p>然而男主是什么样的人呢？一个抑郁症患者，一个警探；一个吸食毒品的人；疑似同性恋者，但一直都和很多女性保持关系。一个自大狂，但也是一个自卑的人：在游戏中用复印机复印自己的阳具，却偷用放大功能。加上前面的行为，不得不说他充满了焦虑，他对于自己的缺点太过于敏感，而且在众人面前一直都做好了伪装。</p><p>男主的自卑是有原因的：在年幼的时候，男主的表现一直没有弟弟出色。在推推搡搡中，弟弟不小心摔下煤山，但是并没有能够施以援手。于是他成为了一个永远差一点的孩子，并且自认为是把弟弟害死了。</p><p>于是，男主最后留下的一番话实在是有意思</p><blockquote><p>你把你那厚瓶底一样的眼镜摘了吧，配一副隐形眼镜，或者是去做激光手术。知道吗，戴着眼镜是没有人会真诚对待你的。你太软了，其实所有人都和你一样害怕这个世界。试着变得强硬一点，她还是会很爱你的。</p></blockquote><p>何尝不是男主对自己说的话。在撂下了这番话之后，男主自杀了。</p><p>最后，还有疑点：他几次梦境中的老男人是否是兄弟的父亲？还有，“规则照旧”这个反复，到底是什么意思？</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有样学样</title>
      <link href="/20240528-review/"/>
      <url>/20240528-review/</url>
      
        <content type="html"><![CDATA[<p>回顾历史，我从来都比较谨慎，甚至是比较怕事。主要对于情绪问题，无论是对方的还是自身的，都有点照顾不到。这里的补全就是要多观察。所以第一个任务就呼之欲出。</p><p>1、观察其他的亲密关系是如何发展的。具体而言，从机遇、动机以及后续行为方面去看，主要是客观地描述，以材料为主。最后是总结与练习方面的指导。</p><p>第二个任务就是培养心态。</p><p>2、读一读书，读一读哲学。说到底是自身的定力。</p><p>第三方面是识人。察言观色，认清形势，怎么能知道一个人在思考什么，目的是什么，底线是什么，是否是同路人。老实说这最后一点并不很重要，只要判断到双方是否合得来就可以了。</p><p>3、见人，不一定是现实里的人，也可以是经典的影视作品。读心理学，以及文学作品。</p><p>still 锻炼聊天技巧，多掌握一些话题，是长期的事。先碎片化后系统化。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异性交往中的心理学 - 陈昌凯</title>
      <link href="/20240528-psycoInOpposSexComm/"/>
      <url>/20240528-psycoInOpposSexComm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结：浅显但做不到的大道理。一个词概括，就是“降格”</p></blockquote><p>1&#x2F;2000 一个男人在茫茫人海中喜欢上一个女人并鼓起勇气约会她的概率。</p><p>1&#x2F;4 这个女人和男人约会4次后，喜欢上他的概率。</p><p>1&#x2F;2 男人坚持约会同一个女人4次的概率。</p><p>1&#x2F;3 相爱的两个人最后结婚的概率。</p><p>1&#x2F;20 离婚率</p><p>谈恋爱是一件理性的事情吗？真的会做一些傻事。不是一个理性的过程。</p><p>情商是人类最重要的生存能力。（但其实我从来都有点不屑）</p><ul><li><p>认识自身情绪的能力：感情表达有障碍的人，对别人的感情也比较冷漠。</p></li><li><p>妥善管理情绪的能力：在适当的时候，对适当的人，适度地发脾气。</p></li><li><p>自我激励的能力：延迟满足和抑制冲动</p><ul><li><p>一开始提出较低的要求，逐渐成长</p></li><li><blockquote><p>延迟满足是一种能力而不是技巧</p></blockquote></li></ul></li><li><p>认识他人情绪的能力：顺畅沟通的基础</p><ul><li>不要启动应激模式，那是没有用的。</li></ul></li><li><p>人际关系的管理能力：领导和管理能力</p><ul><li>“你生气了？”“你为什么生气？”解释</li><li>“没有。”“我不知道。”“自己去想啊。”直接做能让对方开心的事情</li></ul></li></ul><p>男女差异</p><ul><li>女性喜爱分享，男性崇尚效率</li><li>女性需要倾诉，男性向往独立</li><li>女性强调当下，男性注重长远</li></ul><p>《男人来自火星》</p><p>QA</p><p>Q：一直是女生主动怎么办？</p><p>A：没什么怎么办。这是很好的一件事。当然还要考虑是否适合。女生不要再暗示啦，明示一下更容易上钩。</p><p>Q：人为什么会作？为什么有的人会装傻而不是面对？</p><p>A：测试是否是真心喜欢。容忍就是真心的喜欢。适度对于自己的安全感是有好处的。但是过度了就会让人觉得很累。也有可能是行为模式或性格习惯，人是自我中心的，可能无意地侵犯到对方。</p><p>遇到问题不知所措，遇到威胁的时候，第一反应是呆着，第二反应才是逃跑。有的时候不是装傻。另一方面也有可以装傻的，但底层也是不知道应该怎么做。</p><p>Q：为什么男孩子更愿意向男生倾诉而不是女朋友？</p><p>A：也愿意向女生倾诉，但可能不是女朋友。主要是求得一种认同和帮助。男女之间的关注点不一样。（吃药的时候看到一则新闻.txt）因为他觉得这是一个烦恼，向女朋友倾诉不能解决问题还会平添你的烦恼。</p><p>Q：是不是一定会吵架？怎么避免？</p><p>A：无法避免。这是呈现双方需求的一种方式。当然也不是完全没有办法：情商高一点。句式换一换：我怎么怎么样……避免激起对方的防御心理，用正向的方式而不是否定的。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>德意志意识形态 - 摘录</title>
      <link href="/20240527-germanideology/"/>
      <url>/20240527-germanideology/</url>
      
        <content type="html"><![CDATA[<p>圣xxx的各种东西我都没看了。看人驳斥这种东西确实没有什么意思，况且写得太抽象了。只要把前面关于费尔巴哈的部分，也是写作最困难的部分看完就好。</p><p>[TOC]</p><h1 id="关于费尔巴哈的提纲"><a href="#关于费尔巴哈的提纲" class="headerlink" title="关于费尔巴哈的提纲"></a>关于费尔巴哈的提纲</h1><p>从前的一切唯物主义—— 包括费尔巴哈的唯物主义—— 的主要缺点是：对事物、现实、感性，只是从客体的或者直观的形式去理解，而不是把它们当作人的感性活动，当作实践去理解，不是从主观方面去理解。所以，结果竟是这样，和唯物主义相反，能动的方面却被唯心主义发展了，但只是抽象地发展了，因为唯心主义当然是不知道真正现实的、感性的活动的。</p><p>（六）<br>费尔巴哈把宗教的本质归结于人的本质。但是，人的本质并不是单个人所固有的抽象物，实际上，它是一切社会关系的总和。<br>费尔巴哈不是对这种现实的本质进行批判，所以他不得不：<br>（１）撇开历史的进程，孤立地观察宗教感情，并假定出一种抽象的—— 孤立的—— 人类个体；<br>（２）所以，他只能把人的本质理解为“类”，理解为一种内在的、无声的、把许多个人纯粹自然地联系起来的共同性。</p><p>所以，费尔巴哈没有看到，“宗教感情”本身是社会的产物，而他所分析的抽象的个人，实际上是属于一定的社会形式的。</p><h1 id="德意志意识形态"><a href="#德意志意识形态" class="headerlink" title="德意志意识形态"></a>德意志意识形态</h1><h6 id="对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判"><a href="#对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判" class="headerlink" title="对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判"></a>对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判</h6><h2 id="第一卷-对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判"><a href="#第一卷-对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判" class="headerlink" title="第一卷 对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判"></a>第一卷 对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判</h2><blockquote><p>对应三个人的观点</p></blockquote><p>一个人说，只要我们教会他们如何用符合人的本质的思想来代替这些幻想，另一个人说，只要我们教会他们如何批判地对待这些幻想，还有个人说，只要我们教会他们如何从头脑里抛掉这些幻想，这样……当前的现实就会崩溃。</p><p>这些天真的幼稚的空想构成现代青年黑格尔哲学的核心。在德国不仅是公众怀着畏惧和虔敬的心情来接受这种哲学，就是哲学英雄们自己在捧出它的时候也洋洋自得地感到它有震撼世界的危险性和大逆不道的残酷性。</p><h3 id="一-费尔巴哈-唯物主义观点和唯心主义观点的对立"><a href="#一-费尔巴哈-唯物主义观点和唯心主义观点的对立" class="headerlink" title="一 费尔巴哈 唯物主义观点和唯心主义观点的对立"></a>一 费尔巴哈 唯物主义观点和唯心主义观点的对立</h3><blockquote><p>背景</p></blockquote><p>正如德国的思想家们所宣告的，德国在最近几年里经历了一次空前的变革。从施特劳斯开始的黑格尔体系的解体过程变成了一种席卷一切“过去的力量”的世界性骚动。在普遍的混乱中，一些强大的国家产生了，但是立刻又消逝了，瞬息之间出现了许多英雄，但是马上又因为出现了更勇敢更强悍的对手而销声匿迹。这是一次革命，法国革命同它比起来只不过是儿戏；这是一次世界斗争，在它面前狄亚多希的斗争简直微不足道。在瞬息间一些原则为另一些原则所代替，一些思想勇士为另一些思想勇士所歼灭。在１８４２年至１８４５年这三年中间，在德国所进行的清洗比过去三个世纪都要彻底得多。<br>据说这一切都是在纯粹思想的领域中发生的。</p><p>然而，不管怎么样，我们碰到的是一个有意义的事件：绝对精神的瓦解过程。</p><blockquote><p>利用民族感情的哲学叫卖，青年黑格尔派的局限性。</p></blockquote><h4 id="A-一般意识形态-德意志意识形态"><a href="#A-一般意识形态-德意志意识形态" class="headerlink" title="A. 一般意识形态 德意志意识形态"></a>A. 一般意识形态 德意志意识形态</h4><p>他们和黑格尔的论战以及互相之间的论战，只局限于他们当中的每一个人都抓住黑格尔体系中的某一方面来反对他的整个体系，或反对别人所抓住的那些方面。起初他们还是抓住纯粹的、未加伪造的黑格尔的范畴，如实体和自我意识，但是后来却亵渎了这些范畴，用一些世俗的名称称呼它们，如“类”、“唯一者”、“人”，等等。</p><p>从施特劳斯到施蒂纳的整个德国哲学批判都局限于对宗教观念的批判。</p><p>老年黑格尔派认为，任何东西只要归入某种黑格尔的逻辑范畴，就明白易懂了。青年黑格尔派则批判一切，到处用宗教的观念来代替一切，或者宣布一切都是神学上的东西。青年黑格尔派同意老年黑格尔派的这样一个信念，即认为宗教、观念、普遍的东西统治着现存世界。不过一派认为这种统治是篡夺而加以反对，而另一派则认为它是合法的而加以赞扬。</p><p>既然青年黑格尔派认为观念、思想、概念，即被他们变为某种独立东西的意识的一切产物，是人们的真正枷锁，就像老年黑格尔派把它们看作是人类社会的真正羁绊一样，所以不言而喻，青年黑格尔派只要同意识的这些幻想进行斗争就行了。</p><p>他们之中最年轻的人确切地表达了他们的活动，说他们仅仅是为反对“词句”而斗争。</p><blockquote><p>没有反对现实的现存的世界。最终只能从宗教史上对基督教作一些片面的说明。</p></blockquote><p>这些哲学家没有一个想到要提出关于德国哲学和德国现实之间的联系问题，关于他们所作的批判和他们自身的物质环境之间的联系问题。</p><p>可以根据意识、宗教或随便别的什么来区别人和动物。一当人们自己开始生产他们所必需的生活资料的时候（这一步是由他们的肉体组织所决定的），他们就开始把自己和动物区别开来。人们生产他们所必需的生活资料，同时也就间接地生产着他们的物质生活本身。</p><blockquote><p>You are what you produce.  所谓人是什么样，就是说他的生产怎么样。</p></blockquote><p>这种生产方式不仅应当从它是个人肉体存在的再生产这方面来加以考察。它在更大程度上是这些个人的一定的活动方式、表现他们生活的一定形式、他们的一定的生活方式。个人怎样表现自己的生活，他们自己也就怎样。因此，他们是什么样的，这同他们的生产是一致的—— 既和他们生产什么一致，又和他们怎样生产一致。因而，个人是什么样的，这取决于他们进行生产的物质条件。</p><p>这种生产第一次是随着人口的增长而开始的。而生产本身又是以个人之间的交往为前提的。这种交往的形式又是由生产决定的。</p><p>各民族之间的相互关系取决于每一个民族的生产力、分工和内部交往的发展程度。这个原理是公认的。然而不仅一个民族与其他民族的关系，而且一个民族本身的整个内部结构都取决于它的生产以及内部和外部的交往的发展程度。一个民族的生产力发展的水平，最明显地表现在该民族分工的发展程度上。任何新的生产力都会引起分工的进一步发展，因为它不仅仅是现有生产力的量的增加（例如开垦新的土地）</p><blockquote><p>民族间，民族内社会关系，都取决于生产力和分工。</p></blockquote><p>某一民族内部的分工，首先引起工商业劳动和农业劳动的分离，从而也引起城乡的分离和城乡利益的对立。分工的进一步发展导致商业劳动和工业劳动的分离。同时，由于这些不同部门内部的分工，在某一劳动部门共同劳动的个人之间的分工也愈来愈细致了。</p><p>分工发展的各个不同阶段，同时也就是所有制的各种不同形式。这就是说，分工的每一个阶段还根据个人与劳动的材料、工具和产品的关系决定他们相互之间的关系。</p><blockquote><p>分工的发展就是所有制的发展。</p></blockquote><ul><li><p>部落所有制，分工还很不发达，仅限于家庭中现有的自然产生的分工的进一步扩大。因此，社会结构只局限于家庭的扩大。</p></li><li><p>古代公社所有制和国家所有制，几个部落通过契约或征服联合为一个城市。仍然保存着奴隶制。除公社所有制以外，动产的私有制以及后来不动产的私有制已经开始发展起来。分工已经比较发达。城乡之间的对立已经产生，国家之间的对立也相继出现。这些国家当中有一些代表城市利益，另一些则代表乡村利益。在城市内部存在着工业和海外贸易之间的对立。公民和奴隶之间的阶级关系已经充分发展。</p></li><li><p>封建的或等级的所有制，古代的起点是城市及其狭小的领地。而中世纪的起点则是乡村。这种所有制与部落所有制和公社所有制一样，也是以某种共同体为基础的。但是作为直接进行生产的阶级而与这种共同体对立的，已经不是古代世界的奴隶，而是小农奴。土地占有的等级结构以及与之有关的武装扈从制度使贵族掌握了支配农奴的权力。这种封建结构同古代的公社所有制一样，是一种联合，其目的在于对付被统治的生产阶级，只是联合的形式和对于直接生产者的关系有所不同，因为出现了不同的生产条件。</p><p>在城市中和这种封建的土地占有结构相适应的是行会所有制，即手工业的封建组织。个别手工业者逐渐积蓄起来的少量资本及其与不断增长的人口比较起来是固定的人数，使得帮工和学徒制度发展起来了，而这种制度在城市里产生了一种和农村等级制相似的等级制。</p></li></ul><p>这样，封建时代的所有制的主要形式，一方面是地产和束缚于地产上的农奴劳动，另一方面是拥有少量资本并支配着帮工劳动的自身劳动。</p><p>比较广大的地区联合为封建王国，无论对于土地贵族或城市说来，都是一种需要。因此领导统治阶级组织即贵族组织的到处都是君主。</p><p>由此可见，事情是这样的：以一定的方式进行生产活动的一定的个人，发生一定的社会关系和政治关系。</p><p>社会结构和国家经常是从一定个人的生活过程中产生的。但这里所说的个人不是他们自己或别人想像中的那种个人，而是现实中的个人，也就是说，这些个人是从事活动的，进行物质生产的，因而是在一定的物质的、不受他们任意支配的界限、前提和条件下能动地表现自己的。</p><p>意识在任何时候都只能是被意识到了的存在，而人们的存在就是他们的实际生活过程。</p><p>德国哲学从天上降到地上；和它完全相反，这里我们是从地上升到天上，就是说，我们不是从人们所说的、所想像的、所设想的东西出发，也不是从只存在于口头上所说的、思考出来的、想像出来的、设想出来的人出发，去理解真正的人。我们的出发点是从事实际活动的人，而且从他们的现实生活过程中我们还可以揭示出这一生活过程在意识形态上的反射和回声的发展。</p><p>因此，道德、宗教、形而上学和其他意识形态，以及与它们相适应的意识形式便失去独立性的外观。它们没有历史，没有发展；那些发展着自己的物质生产和物质交往的人们，在改变自己的这个现实的同时也改变着自己的思维和思维的产物。不是意识决定生活，而是生活决定意识。前一种观察方法从意识出发，把意识看作是有生命的个人。符合实际生活的第二种观察方法则是从现实的、有生命的个人本身出发，把意识仅仅看作是他们的意识。</p><blockquote><p>一句话：物质决定意识.</p></blockquote><p>对现实的描述会使独立的哲学失去生存环境，能够取而代之的充其量不过是从对人类历史发展的观察中抽象出来的最一般的结果的综合。</p><blockquote><p>我们所提出的不过是一些“抽象”。这些抽象，不同于哲学，是不提供适用于各个历史时代的药方或公式的。在整理资料的时候，困难就开始出现，解决困难的前提只能从对每个时代的个人实际生活和活动的研究中得到。</p><p>具体时代的生活，具体分析。</p></blockquote><blockquote><p>下面是一些同德意志意识形态，那种空中楼阁式的历史观，所相对的“抽象”</p></blockquote><h5 id="【1】历史"><a href="#【1】历史" class="headerlink" title="【1】历史"></a>【1】历史</h5><p>一切人类生存的第一个前提也就是一切历史的第一个前提，这个前提就是：人们为了能够“创造历史”，必须能够生活。</p><p>但是为了生活，首先就需要衣、食、住以及其他东西。因此第一个历史活动就是生产满足这些需要的资料，即生产物质生活本身。</p><blockquote><p>生产物质生活是一切历史的基本条件。</p></blockquote><p>德国人从来没有这样做过，所以他们从来没有为历史提供世俗基础，因而也从来没有过一个历史学家。法国人和英国人尽管对这一事实同所谓的历史的联系了解得非常片面（特别因为他们受政治思想的束缚），但毕竟作了一些给历史编纂学提供唯物主义基础的初步尝试，首次写出了市民社会史、商业史和工业史。</p><p>已经得到满足的第一个需要本身、满足需要的活动和已经获得的为满足需要用的工具又引起新的需要。这种新的需要的产生是第一个历史活动。</p><p>德国人认为凡是在他们缺乏实证材料的地方，凡是在神学、政治和文学的缪论不能立足的地方，就没有任何历史，那里只有“史前时期”……他们的历史思辨所以特别热衷于这个“史前历史”，是因为他们认为在这里他们不会受到“粗暴事实”的干预，而且还可以让他们的思辨欲望得到充分的自由，创立和推翻成千成万的假说。</p><p>一开始就纳入历史发展过程的第三种关系就是：每日都在重新生产自己生活的人们开始生产另外一些人，即增殖。这就是夫妻之间的关系，父母和子女之间的关系，也就是家庭。这个家庭起初是唯一的社会关系，后来，当需要的增长产生了新的社会关系，而人口的增多又产生了新的需要的时候，家庭便成为（德国除外）从属的关系了。</p><p>但是人并非一开始就具有“纯粹的”意识。“精神”从一开始就很倒霉，法定要受物质的“纠缠”，物质在这里表现为震动着的空气层、声音，简言之，即语言。语言和意识具有同样长久的历史；语言是一种实践的、既为别人存在并仅仅因此也为我自己存在的、现实的意识。语言也和意识一样，只是由于需要，由于和他人交往的迫切需要才产生的②。凡是有某种关系存在的地方，这种关系都是为我而存在的；动物不对什么东西发生“关系”，而且根本没有“关系”；对于动物说来，它对他物的关系不是作为关系存在的。</p><p>因而，意识一开始就是社会的产物，而且只要人们还存在着，它就仍然是这种产物。</p><p>但是，另一方面，意识到必须和周围的人们来往，也就是开始意识到人一般地是生活在社会中的。这个开始和这个阶段上的社会生活本身一样，带有同样的动物性质；这是纯粹畜群的意识，这里人和绵羊不同的地方只是在于：意识代替了他的本能，或者说他的本能是被意识到了的本能。</p><p>分工起初只是性交方面的分工，后来是由于天赋（例如体力）、需要、偶然性等等而自发地或“自然地产生的”分工。分工只是从物质劳动和精神劳动分离的时候起才开始成为真实的分工①。</p><p>从这时候起意识才能真实地这样想像：它是同对现存实践的意识不同的某种其他的东西；它不想像某种真实的东西而能够真实地想像某种东西。从这时候起，意识才能摆脱世界而去构造“纯粹的”理论、神学、哲学、道德等等。但是，如果这种理论、神学、哲学、道德等等和现存的关系发生矛盾，那末，这仅仅是因为现存的社会关系和现存的生产力发生了矛盾。</p><p>我们从这一大堆赘述中只能得出一个结论，那就是，上述三个因素—— 生产力、社会状况和意识—— 彼此之间可能而且一定会发生矛盾，因为分工不仅使物质活动和精神活动、享受和劳动、生产和消费由各种不同的人来分担这种情况成为可能，而且成为现实。要使这三个因素彼此不发生矛盾，只有消灭分工。</p><p>与这种分工同时出现的还有分配，而且是劳动及其产品的不平等的分配（无论在数量上或质量上）；因而也产生了所有制，它的萌芽和原始形态在家庭中已经出现，在那里妻子和孩子是丈夫的奴隶。</p><p>……即所有制是对他人劳动力的支配。其实，分工和私有制是两个同义语，讲的是同一件事情，一个是就活动而言，另一个是就活动的产品而言。</p><blockquote><p>下面这段隐隐地引出了异化的话题。</p></blockquote><p>最后，分工还给我们提供了第一个例证，说明只要人们还处在自发地形成的社会中，也就是说，只要私人利益和公共利益之间还有分裂，也就是说，只要分工还不是出于自愿，而是自发的，那末人本身的活动对人说来就成为一种异己的、与他对立的力量，这种力量驱使着人，而不是人驾驭着这种力量。原来，当分工一出现之后，每个人就有了自己一定的特殊的活动范围，这个范围是强加于他的，他不能超出这个范围：他是一个猎人、渔夫或牧人，或者是一个批判的批判者，只要他不想失去生活资料，他就始终应该是这样的人。而在共产主义社会里，任何人都没有特定的活动范围，每个人都可以在任何部门内发展，社会调节着整个生产，因而使我有可能随我自己的心愿今天干这事，明天干那事，上午打猎，下午捕鱼，傍晚从事畜牧，晚饭后从事批判，但并不因此就使我成为一个猎人、渔夫、牧人或批判者。社会活动的这种固定化，我们本身的产物聚合为一种统治我们的、不受我们控制的、与我们愿望背道而驰的并抹煞我们的打算的物质力量，这是过去历史发展的主要因素之一。</p><blockquote><p>国家是一个妥协的结果</p></blockquote><p>正是由于私人利益和公共利益之间的这种矛盾，公共利益才以国家的姿态而采取一种和实际利益（不论是单个的还是共同的）脱离的独立形式，也就是说采取一种虚幻的共同体的形式。</p><blockquote><p>而又有现实的支持的土壤</p></blockquote><p>然而这始终是在每一个家庭或部落集团中现有的骨肉联系、语言联系、较大规模的分工联系以及其他利害关系的现实基础上，特别是在我们以后将要证明的各阶级利益的基础上发生的。</p><p>由此可见，国家内部的一切斗争—— 民主政体、贵族政体和君主政体相互之间的斗争，争取选举权的斗争等等，不过是一些虚幻的形式，在这些形式下进行着各个不同阶级间的真正的斗争。</p><p>从这里还可以看出，每一个力图取得统治的阶级，如果它的统治就像无产阶级的统治那样，预定要消灭整个旧的社会形态和一切统治，都必须首先夺取政权，以便把自己的利益说成是普遍的利益，而这是它在初期不得不如此做的。</p><blockquote><p>个人追求的是特殊利益，并以真正地反对共同利益和虚幻的共同利益进行实际斗争，国家则以虚幻的“普遍”利益对特殊利益进行实际的干涉。</p></blockquote><blockquote><p>缩句：生产力不是不同个人自身的联合力量，而是异己的权力，并支配了人们的意志和行为。</p></blockquote><p>受分工制约的不同个人的共同活动产生了一种社会力量，即扩大了的生产力。由于共同活动本身不是自愿地而是自发地形成的，因此这种社会力量在这些个人看来就不是他们自身的联合力量，而是某种异己的、在他们之外的权力。关于这种权力的起源和发展趋向，他们一点也不了解；因而他们就不再能驾驭这种力量，相反地，这种力量现在却经历着一系列独特的、不仅不以人们的意志和行为为转移的，反而支配着人们的意志和行为的发展阶段。</p><blockquote><p>生产力作为一种社会力量，拥有的这样的表现，就叫做异化。</p></blockquote><p>要使这种异化成为一种“不堪忍受的”力量，即成为革命所要反对的力量，就必须</p><ul><li>让它把人类的大多数变成完全“没有财产的”人</li><li>同时这些人又和现存的有钱的有教养的世界相对立</li></ul><p>而这两个条件都是以生产力的巨大增长和高度发展为前提的。</p><p>另一方面，生产力的这种发展（随着这种发展，人们的世界历史性的而不是狭隘地域性的存在已经是经验的存在了）之所以是绝对必需的实际前提，还因为如果没有这种发展，那就只会有贫穷的普遍化；而在极端贫困的情况下，就必须重新开始争取必需品的斗争，也就是说，全部陈腐的东西又要死灰复燃。其次，这种发展之所以是必需的前提，还因为：只有随着生产力的这种普遍发展，人们之间的普遍交往才能建立起来；由于普遍的交往，一方面，可以发现在一切民族中同时都存在着“没有财产的”群众这一事实（普遍竞争），而其中每一民族同其他民族的变革都有依存关系；最后，狭隘地域性的个人为世界历史性的、真正普遍的个人所代替。</p><blockquote><p>人作为一种经验的“世界的历史性的存在”的重要性。</p></blockquote><p>不这样，</p><p>（１）共产主义就只能作为某种地域性的东西而存在；</p><p>（２）交往的力量本身就不可能发展成为一种普遍的因而是不堪忍受的力量：它们会依然处于家庭的、笼罩着迷信气氛的“境地”；</p><p>（３）交往的任何扩大都会消灭地域性的共产主义。共产主义只有作为占统治地位的各民族“立即”同时发生的行动才可能是经验的，而这是以生产力的普遍发展和与此有关的世界交往的普遍发展为前提的。</p><p>共产主义对我们说来不是应当确立的状况，不是现实应当与之相适应的理想。我们所称为共产主义的是那种消灭现存状况的现实的运动。</p><p>在过去一切历史阶段上受生产力所制约、同时也制约生产力的交往形式，就是市民社会。这个社会（从前面已经可以这样判定）是以简单的家庭和复杂的家庭，即所谓部落生活作为自己的前提和基础的。</p><p>从这里已经可以看出，这个市民社会是全部历史的真正发源地和舞台，可以看出过去那种轻视现实关系而只看到元首和国家的丰功伟绩的历史观何等荒谬。</p><p>市民社会包括各个个人在生产力发展的一定阶段上的一切物质交往。它包括该阶段上的整个商业生活和工业生活，因此它超出了国家和民族的范围，尽管另一方面它对外仍然需要以民族的姿态出现，对内仍然需要组成国家的形式。“市民社会”这一用语是在１８世纪产生的，当时财产关系已经摆脱了古代的和中世纪的共同体。真正的资产阶级社会只是随同资产阶级发展起来的；但是这一名称②始终标志着直接从生产和交往中发展起来的社会组织，这种社会组织在一切时代都构成国家的基础以及任何其他的观念的上层建筑的基础。</p><h5 id="【2】关于意识的生产"><a href="#【2】关于意识的生产" class="headerlink" title="【2】关于意识的生产"></a>【2】关于意识的生产</h5><p>单独的个人随着他们的活动扩大为世界历史性的活动，愈来愈受到异己力量的支配（他们把这种压迫想像为所谓宇宙精神等等的圈套），受到日益扩大的、归根到底表现为世界市场的力量的支配；这种情况在过去的历史中也绝对是经验的事实。</p><p>各个个人的全面的依存关系、他们的这种自发形成的世界历史性的共同活动的形式，由于共产主义革命而转化为对那些异己力量的控制和自觉的驾驭，这些力量本来是由人们的相互作用所产生的，但是对他们说来却一直是一种异己的、统治着他们的力量。</p><blockquote><p>主要就是注意“作为主体的社会”，一种社会意识成为异己的力量对人进行了统治。</p></blockquote><p>这种观点仍然可以被思辨地、唯心地、即幻想地解释为“类的自我产生”（“作为主体的社会”），把所有前后相继、彼此相联的个人设想为从事自我产生这种神秘活动的唯一的个人。这里很明显，尽管人们在肉体上和精神上互相创造着，但是他们并不像圣布鲁诺胡说的那样，或者像“唯一者”、“被创造的”人那样创造自己本身。</p><blockquote><p>还并没有发展到神棍的地步。</p></blockquote><p>由此可见，这种历史观就在于：从直接生活的物质生产出发来考察现实的生产过程，并把与该生产方式相联系的、它所产生的交往形式，即各个不同阶段上的市民社会，理解为整个历史的基础；然后必须在国家生活的范围内描述市民社会的活动，同时从市民社会出发来阐明各种不同的理论产物和意识形式，如宗教、哲学、道德等等，并在这个基础上追溯它们产生的过程。这样做当然就能够完整地描述全部过程（因而也就能够描述这个过程的各个不同方面之间的相互作用）了。</p><p>这种历史观和唯心主义历史观不同，它不是在每个时代中寻找某种范畴，而是始终站在现实历史的基础上，不是从观念出发来解释实践，而是从物质实践出发来解释观念的东西。</p><p>……而只有实际地推翻这一切唯心主义谬论所由产生的现实的社会关系，才能把它们消灭；历史的动力以及宗教、哲学和任何其他理论的动力是革命，而不是批判。</p><p>印度人和埃及人借以实现分工的原始形态在这些民族的国家和宗教中产生了等级制度，所以历史家便认为似乎等级制度是产生这种原始社会形态的力量。法国人和英国人至少抱着一种毕竟是同现实最接近的政治幻想，而德国人却在“纯粹精神”的领域中兜圈子，把宗教幻想推崇为历史的动力。在德国历史编纂学看来，问题完全不在于现实的利益，甚至不在于政治的利益，而在于纯粹的思想。</p><p>正如上面所说的，要真正地、实际地消灭这些词句，要从人们的意识中消除这些观念，只有靠改变条件，而不是靠理论上的演绎。对于人民大众、即无产阶级来说，这些理论观念是不存在的，因而也就用不着去消灭它们。如果这些群众在某个时候有过某些理论观念，如宗教，那末这些观念也早已被环境所消灭了。</p><p>这也是费尔巴哈和我们的敌人的共同之点。费尔巴哈在这些地方证明：某物或某人的存在同时也就是某物或某人的本质；一个动物或一个人的一定生存条件、生活方式和活动，就是使这个动物或人的“本质”感到满足的东西。任何例外在这里都被肯定地看作是不幸事件，是不能改变的反常现象。</p><p>这样说来，如果千百万无产者根本不满足于他们的生活条件，如果他们的“存在”同他们的……相矛盾……</p><p>在对感性世界的直观中，他不可避免地碰到与他的意识和感觉相矛盾的东西，这些东西破坏着他所假定的感性世界一切部分的和谐，特别是人与自然界的和谐②。为了消灭这个障碍，他不得不求助于某种二重性的直观，这种直观介于仅仅看到“眼前”的东西的普通直观和看出事物的“真正本质”的高级的哲学直观之间。</p><p>他没有看到，他周围的感性世界决不是某种开天辟地以来就已存在的、始终如一的东西，而是工业和社会状况的产物，是历史的产物，是世世代代活动的结果，其中每一代都在前一代所达到的基础上继续发展前一代的工业和交往方式，并随着需要的改变而改变它的社会制度。甚至连最简单的“可靠的感性”的对象也只是由于社会发展、由于工业和商业往来才提供给他的。</p><p>大家知道，樱桃树和几乎所有的果树一样，只是在数世纪以前依靠商业的结果才在我们这个地区出现。由此可见，樱桃树只是依靠一定的社会在一定时期的这种活动才为费尔巴哈的“可靠的感性”所感知。</p><p>诚然，费尔巴哈比“纯粹的”唯物主义者有巨大的优越性：他也承认人是“感性的对象”。但是，毋庸讳言，他把人只看作是“感性的对象”，而不是“感性的活动”，因为他在这里也仍然停留在理论的领域内，而没有从人们现有的社会联系，从那些使人们成为现在这种样子的周围生活条件来观察人们。</p><blockquote><p>只停留在抽象的人。仅仅限于在感情范围内承认“现实的、单独的、肉体的人”。没有发现其他的“人的关系”。</p></blockquote><p>然而，事情被思辨地颠倒成这样：好像后一个时期历史乃是前一个时期历史的目的，例如，好像美洲的发现的根本目的就是要引起法国革命。因此，历史便具有其特殊的目的并成为某个与“其他人物并列的人物”（如像“自我意识”、“批判”、“唯一者”等等）。其实，以往历史的“使命”、“目的”、“萌芽”、“观念”等词所表明的东西，无非是从后来历史中得出的抽象，无非是从先前历史对后来历史发生的积极影响中得出的抽象。</p><p>……历史就在愈来愈大的程度上成为全世界的历史。例如，如果在英国发明了一种机器，它夺走了印度和中国的千千万万工人的饭碗，并引起这些国家的整个生存形式的改变，那末，这个发明便成为一个世界历史性的事实。</p><p>例如，在某一国家里，某个时期王权、贵族和资产阶级争夺统治，因而，在那里统治是分享的，那里占统治地位的思想就会是关于分权的学说，人们把分权当作“永恒的规律”来谈论。</p><p>如果完全不考虑这些思想的基础—— 个人和历史环境，那就可以这样说：例如，在贵族统治时期占统治地位的是忠诚信义等等概念，而在资产阶级统治时期占统治地位的则是自由平等等等概念。总之，统治阶级自己为自己编造出诸如此类的幻想。所有历史学家（主要是１８世纪以来的）所固有的这种历史观必然会碰到这样一种现象：占统治地位的将是愈来愈抽象的思想，即愈来愈具有普遍性形式的思想。</p><p>事情是这样的，每一个企图代替旧统治阶级的地位的新阶级，就是为了达到自己的目的而不得不把自己的利益说成是社会全体成员的共同利益，抽象地讲，就是赋予自己的思想以普遍性的形式，把它们描绘成唯一合理的、有普遍意义的思想。</p><p>由此可见，每一个新阶级赖以建立自己统治的基础，比它以前的统治阶级所依赖的基础要宽广一些；可是后来，非统治阶级和取得统治的阶级之间的对立也发展得更尖锐和更深刻。</p><p>黑格尔本人在“历史哲学”１４的结尾承认，“他所考察的仅仅是概念的前进运动”，他在历史方面描述了“真正的神正论”（第４４６页）。在这之后，又可以重新回复到“概念”的生产者，回复到理论家、思想家和哲学家，并做出结论说：哲学家、思想家自古以来就是在历史上占统治地位的。这个结论，如我们所看到的，早就由黑格尔表述过了。</p><p>这样，根据历史材料来证明精神的最高些治（施蒂纳的教阶制）的全部戏法，可以归结为以下三个手段：</p><p>第一，必须把统治的个人—— 而且是由于种种经验的根据、在经验条件下和作为物质的个人进行统治的个人—— 的思想同这些统治的个人本身分割开来，从而承认思想和幻想在历史上的统治。</p><p>第二，必须使这种思想统治具有某种秩序，必须证明，在一个承继着另一个的统治思想之间存在着某种神秘的联系。达到这一点 的办法是：把这些思想看作是“概念的自我规定”（所以能这样做，是因为这些思想由于它们都有经验的基础而彼此确实是联系在一起的，还因为它们既被仅仅当作思想来看待，因而就变成自我区别，变成由思维产生的区别）。<br>第三，为了消除这种“自我规定着的概念”的神秘的外观，便把它变成某种人物——“自我意识”；或者，为了表明自己是真正的唯物主义者，又把它变成在历史上代表着“概念”的许多人物——“思维着的人”、“哲学家”、思想家，而这些人又被规定为历史的创造者、“监护人会议”、统治者①。这样一来，就把一切唯物主义的因素从历史上消除了，于是就可以放心地解开缰绳，让自己的思辨之马自由奔驰了。</p><h4 id="B-意识形态的现实基础"><a href="#B-意识形态的现实基础" class="headerlink" title="B. 意识形态的现实基础"></a>B. 意识形态的现实基础</h4><h5 id="【1】交往和生产力"><a href="#【1】交往和生产力" class="headerlink" title="【1】交往和生产力"></a>【1】交往和生产力</h5><p>物质劳动和精神劳动的最大的一次分工，就是城市和乡村的分离。城乡之间的对立是随着野蛮向文明的过渡、部落制度向国家的过渡、地方局限性向民族的过渡而开始的，它贯穿着全部文明的历史并一直延续到现在。</p><p>随着城市的出现也就需要有行政机关、警察、赋税等等，一句话，就是需要有公共的政治机构，也就是说需要一般政治。在这里居民第一次划分为两大阶级，这种划分直接以分工和生产工具为基础。城市本身表明了人口、生产工具、资本、享乐和需求的集中；而在乡村里所看到的却是完全相反的情况：孤立和分散。</p><p>城市和乡村的分离还可以看作是资本和地产的分离，看作是资本不依赖于地产而存在和发展的开始，也就是仅仅以劳动和交换为基础的所有制的开始。</p><blockquote><p>行会 师傅 帮工 日工（平民） 农奴逃入城市</p></blockquote><p>分工的进一步扩大表现为商业和生产的分离，表现为特殊的商人阶级的形成。…….这样就产生了同附近地区以外的地区建立贸易联系的可能，这种可能之变为现实，取决于现有的交通工具的情况，取决于由政治关系所决定的沿途社会治安状况（大家知道，整个中世纪，商人都是结成武装商队行动的）以及取决于交往所及地区内由相应的文明程度所决定的需求的发展程度。</p><p>城市彼此发生了联系，新的劳动工具从一个城市运往另一个城市，生产和商业间的分工随即引起了各城市间在生产上的新的分工，在每一个城市中都有自己的特殊的工业部门占着优势。最初的地域局限性开始逐渐消失</p><blockquote><p>市民保卫生活，反对农村贵族；商业和交通带来城市间交往，捍卫同样的利益而缓慢地产生出市民阶级。</p></blockquote><p>市民创造了这些条件，因为他们脱离了封建联系；同时他们又是由这些条件所创造的，因为他们是由自己同既存封建主义的对立所制约的。随着各城市间的联系的产生，这些对他们来说都是共同的条件发展为阶级条件。</p><p>同样的条件、同样的对立、同样的利益，一般说来也就应当在一切地方产生同样的风俗习惯。</p><p>资产阶级本身只是逐渐地、随同自己的生存条件一起发展起来的，同时它又由于分工关系重新分裂为各种不同的集团，最后随着一切现有财产被变为工业资本或商业资本，它吞并了在它以前存在过的一切有产阶级（同时资产阶级把原先没有财产的阶级的大部分和原先有财产的阶级的一部分变为新的阶级——无产阶级）。单独的个人所以组成阶级只是因为他们必须进行共同的斗争来反对某一另外的阶级；在其他方面，他们本身就是相互敌对的竞争者。另一方面，阶级对各个人来说又是独立的，因此各个人可以看到自己的生活条件是早已确定了的：阶级决定他们的生活状况，同时也决定他们的个人命运，使他们受它支配。这和个人屈从于分工是同类的现象，这种现象只有通过消灭私有制和消灭劳动本身才能消除。</p><blockquote><p>“消灭劳动”（Aufhebung der Arbeit）这种说法在这里是什么意思，请参看</p></blockquote><blockquote><p>织布的手工业工场是第一个产生的。它与行会的束缚是对立的。资本开始积聚。</p></blockquote><p>随着摆脱了行会束缚的工场手工业的出现，所有制关系也立即发生了变化。离开自然形成的等级资本向前走的第一步是受商人的出现所制约的，商人的资本一开始就是活动的，是现代意义上的资本。向前走的第二步是工场手工业的出现，工场手工业又动员了大量自然形成的资本，并且同自然形成的资本的数量比较起来，一般是增加了活动资本的数量。</p><p>随着工场手工业的出现，工人和雇主的关系也发生了变化。在行会中，帮工和师傅之间存在着一种宗法关系，而在工场手工业中，这种关系由工人和资本家之间的金钱关系代替了。</p><p>商业和工场手工业产生了大资产阶级，而集中在行会里的是小资产阶级，现在它和过去不同，在城市里已经不占统治地位了，而且还必须屈从于大商人和手工工场主的统治①。由此可见，行会一跟工场手工业接触，就衰落下去了。</p><p>对工场手工业经常采用种种的保护办法：在国内市场上实行保护关税，在殖民地市场上实行垄断，而在国外市场上则实行差别关税。……只要在稍微有利的条件下，工场手工业就可以很容易地在某个国家建立起来，正因为这样，它也很容易被破坏。此外，它的经营方法，特别是１８世纪在乡村里的经营方法，使它和广大群众的生活方式结合在一起，以致没有一个国家敢于不顾工场手工业的生存而允许自由竞争。因而工场手工业，在它能够输出自己的产品的时候，是完全依赖于贸易的扩展或收缩的，而它对贸易的反作用却是比较微小的。</p><p>大工业通过普遍的竞争迫使所有人的全部精力极度紧张起来。只要可能，它就消灭意识形态、宗教、道德等等，而当它不能做到这一点时，它就把它们变成赤裸裸的谎言。</p><p>它使自然科学从属于资本，并使分工丧失了自然性质的最后一点痕迹。它把自然形成的关系一概消灭掉（只要这一点在劳动范围内可能做到的话）；它把这些关系变成金钱的关系。</p><p>大工业到处造成了社会各阶级间大致相同的关系，从而消灭了各民族的特殊性。最后，当每一民族的资产阶级还保持着它的特殊的民族利益的时候，大工业却创造了这样一个阶级，这个阶级在所有的民族中都具有同样的利益，在它那里民族独特性已经消灭，这是一个真正同整个旧世界脱离并与之对立的阶级。大工业不仅使工人与资本家的关系，而且使劳动本身都成为工人所不堪忍受的东西。</p><p>当然，在一个国家里，大工业不是在一切地方都达到了同样的发展水平。但这并不能阻碍无产阶级的阶级运动：大工业所产生的那个无产者阶层走在这个运动的前面，并引导着所有其余的群众，而没有卷入大工业的工人，则由于大工业的过错而处于比在大工业中做工的工人更糟的生活境遇中。同样，大工业发达的国家也〔或多或少〕影响着非工业国家，因为非工业国家由于世界贸易而被卷入普遍竞争的斗争中①。</p><h5 id="【2】国家和法同所有制的关系"><a href="#【2】国家和法同所有制的关系" class="headerlink" title="【2】国家和法同所有制的关系"></a>【2】国家和法同所有制的关系</h5><p>起源于中世纪的民族那里，部落所有制先经过了几个不同的阶段—— 封建地产，同业公会的动产，工场手工业资本—— 然后才变为由大工业和普遍竞争所产生的现代资本，即变成抛弃了共同体的一切外观并消除了国家对财产发展的任何影响的纯粹私有制。</p><p>现代国家是与这种现代私有制相适应的。现代国家由于捐税逐渐被私有者所操纵，并由于借国债而完全为他们所控制；这种国家的命运既受到交易所中国家债券行市涨落的调节，所以它完全取决于私有者即资产者提供给它的商业信贷。由于资产阶级已经不再是一个等级，而是一个阶级了，因此它必须在全国范围内而不是在一个地区内组织起来，并且必须使自己通常的利益具有一种普遍的形式。</p><p>由于私有制摆脱了共同体，国家获得了和市民社会并列的并且在市民社会之外的独立存在；实际上国家不外是资产者为了在国内外相互保障自己的财产和利益所必然要采取的一种组织形式。</p><p>在私法中，现存的所有制关系表现为普遍意志的结果。仅仅ｊｕｓ ｕｔｅｎｄｉ ｅｔ ａｂｕｔｅｎｄｉ〔使用和滥用的权利〕②就一方面表明私有制已经完全不依赖于共同体，另一方面表明了一个幻想，仿佛私有制本身仅仅是以个人意志，即以对物的任意支配为基础的。</p><p>每当工业和商业的发展创造出新的交往形式，例如保险公司等等的时候，法便不得不承认它们是获得财产的新方式。</p><h5 id="【3】自然产生的和由文明创造的生产工具与所有制形式"><a href="#【3】自然产生的和由文明创造的生产工具与所有制形式" class="headerlink" title="【3】自然产生的和由文明创造的生产工具与所有制形式"></a>【3】自然产生的和由文明创造的生产工具与所有制形式</h5><p>因而这里出现了自然产生的生产工具和由文明创造的生产工具之间的差异。耕地（水等等）可以看作是自然产生的生产工具。在前一种情况下，即在自然产生的生产工具的情况下，各个个人受自然界的支配，在后一种情况下，他们则受劳动产品的支配。在前一种情况下，财产（地产）也表现为直接的、自然产生的统治，而在后一种情况下，则表现为劳动的统治，特别是积累起来的劳动即资本的统治。</p><blockquote><p>货币作为一种统治手段</p></blockquote><p>在前一种情况下，所有者可以依靠个人关系，依靠这种或那种形式的共同体来统治非所有者；在后一种情况下这种统治必须采取物的形式，通过某种第三者，即通过<strong>货币</strong>。</p><p>在大工业中，生产工具和私有制之间的矛盾才第一次作为大工业所产生的结果表现出来；这种矛盾只有在大工业高度发达的情况下才会产生。因此，只有在大工业的条件下才有可能消灭私有制。</p><p>因此，这里显露出两个事实①。第一，生产力表现为一种完全不依赖于各个个人并与他们分离的东西，……他们同生产力和自身存在还保持着的唯一联系，即劳动，在他们那里已经失去了任何自主活动的假象，它只是用摧残生命的东西来维持他们的生命。而在过去，<strong>自主活动</strong>和<strong>物质生活的生产</strong>是分开的，这是因为它们是不同人的命运，同时物质生活的生产，由于个人本身的局限性，还被认为是自主活动的次要形式，—— 现在它们互相分离竟达到这般地步，……</p><p>……占有就必须带有适应生产力和交往的普遍性质。</p><blockquote><p>所有制所具有的性质与生产力和交往的现实相适应</p></blockquote><p>对这些力量的占有本身不外是同物质生产工具相适应的个人才能的发挥。仅仅因为这个缘故，对生产工具的一定总和的占有，也就是个人本身的才能的一定总和的发挥。</p><p>其次，占有还受实现占有所必须采取的方式的制约。占有只有通过联合才能得到实现，由于无产阶级所固有的本性，这种联合只能是普遍性的，而且占有也只有通过革命才能得到实现。</p><p>只有在这个阶段上，自主活动才同物质生活一致起来，而这点又是同个人向完整的个人的发展以及一切自发性的消除相适应的。同样，劳动转化为自主活动，同过去的被迫交往转化为所有个人作为真正个人参加的交往，也是相互适应的。</p><blockquote><p>大工业生产促成了联合起来的个人，创造了联合起来的个人对全部生产力总和的占有，消灭私有制。意指过去的生产组织形式并没有带来革命的土壤。在下面也有批评。</p></blockquote><p>哲学家们在已经不再屈从于分工的个人身上看见了他们名之为“人”的那种理想，他们把我们所描绘的整个发展过程看作是“人”的发展过程，而且他们用这个“人”来代替过去每一历史时代中所存在的个人，并把他描绘成历史的动力。这样，整个历史过程被看成是“人”的自我异化过程，实际上这是因为，他们总是用后来阶段的普通人来代替过去阶段的人并赋予过去的个人以后来的意识。由于这种本末倒置的做法，<strong>即由于公然舍弃实际条件</strong>，于是就可以把整个历史变成意识发展的过程了。</p><blockquote><p>革命与自我革命</p></blockquote><p>无论为了使这种共产主义意识普遍地产生还是为了达到目的本身，都必须使人们普遍地发生变化，这种变化只有在实际运动中，在革命中才有可能实现；因此革命之所以必需，不仅是因为没有任何其他的办法能推翻统治阶级，而且还因为推翻统治阶级的那个阶级，只有在革命中才能抛掉自己身上的一切陈旧的肮脏东西，才能建立社会的新基础③。</p><h4 id="C-共产主义。——交往形式本身的生产"><a href="#C-共产主义。——交往形式本身的生产" class="headerlink" title="C. 共产主义。——交往形式本身的生产"></a>C. 共产主义。——交往形式本身的生产</h4><blockquote><p>这似乎是对共产主义在下一个定义。</p></blockquote><p>…….上述矛盾产生以前，个人之间进行交往的条件是与他们的个性相适应的条件，这些条件对于他们说来不是什么外部的东西；它们是这样一些条件，在这些条件下，生存于一定关系中的一定的个人只能生产自己的物质生活以及与这种物质生活有关的东西，因而它们是个人自主活动的条件，而且是由这种自主活动创造出来的①。……人们进行生产的一定条件是同他们的现实的局限状态和他们的片面存在相适应的，这种存在的片面性只是在矛盾产生时才表现出来，因而只是对于后代才存在的。这时人们才觉得这些条件是偶然的桎梏，并且把这种视上述条件为桎梏的观点也强加给过去的时代。</p><blockquote><p>省流：交往的条件与现实的状态相适应。交往的条件是自主活动的条件，并被自主活动创造出来。</p></blockquote><p>已成为桎梏的旧的交往形式被适应于比较发达的生产力，因而也适应于更进步的个人自主活动类型的新的交往形式所代替。</p><p>而且较早时期的利益，在与之相适应的交往形式已经为适应于较晚时期的利益的交往形式所排挤之后，仍然在长时间内拥有一种表现为与个人隔离的虚幻共同体（国家、法）的传统权力，这种权力归根结底只有通过革命才能打倒。</p><p>这也就说明了：为什么在某些带有较大的概括性的问题上，意识有时似乎超过了当代的经验关系，因此人们在后来某个时代的斗争中可以指靠先前时代理论家的威望。</p><p>最后，无论什么地方，占领很快就面临结束之日，那时已经没有东西可供占领了，需要转向生产。从这种很快到来的生产的必要性中可以做出如下结论：定居下来的征服者所采纳的社会制度形式，应当适应于他们面临的生产力发展水平，如果起初没有这种适应，那末社会制度形式就应当按照生产力而发生变化。这也就说明了民族大迁移后的时期中到处都可见到的一件事实，即奴隶成了主人，征服者很快就学会了被征服民族的语言，接受了他们的教育和风俗。</p><p>一切历史冲突都根源于生产力和交往形式之间的矛盾。此外，对于其一国家内冲突的发生来说，完全没有必要等这种矛盾在这个国家本身中发展到极端的地步。由于同工业比较发达的国家进行广泛的国际交往所引起的竞争，就足以使工业比较不发达的国家内产生类似的矛盾（例如，英国工业的竞争使德国潜在的无产阶级显露出来了）。</p><p>过去的联合只是一种（决不像“社会契约”中所描绘的那样是任意的，而是必然的）关于这样一些条件的协定（参阅例如北美合众国和南美诸共和国的形成），在这些条件下，个人然后有可能利用偶然性为自己服务。这种在一定条件下无阻碍地享用偶然性的权利，迄今一直称为个人自由。而这些生存条件当然只是现存的生产力和交往形式。</p><blockquote><p>我称，过去的个人作为阶级的成员，他们的根本利益是分散的，是互有矛盾的，而那种联合仅仅是一种”协定“。而革命无产者的联合，是将根本利益的条件把握在自己的控制当中。</p></blockquote><p>注意。不要忘记，单是维持农奴存在的必要性和大经济的不可能性（它要求把ａｌｌｏｔｍｅｎｔｓ〔小块土地〕分给农奴），很快就使农奴对封建主的赋役降低到中等水平的代役租和徭役地租，这样就使农奴有可能积累一些动产，便于从他的领主那里里逃跑出来，并使他有可能去当市民，同时还引起了农奴的分化。可见逃亡农奴已经是半资产者了。由此也可以清楚地看到，掌握了某种手艺的农奴获得动产的可能性最大。</p><h2 id="第二卷-对各式各样先知所代表的德国社会主义的批判"><a href="#第二卷-对各式各样先知所代表的德国社会主义的批判" class="headerlink" title="第二卷 对各式各样先知所代表的德国社会主义的批判"></a>第二卷 对各式各样先知所代表的德国社会主义的批判</h2><h3 id="“真正的社会主义”"><a href="#“真正的社会主义”" class="headerlink" title="“真正的社会主义”"></a>“真正的社会主义”</h3><h3 id="一-“莱茵年鉴”或“真正的社会主义的哲学"><a href="#一-“莱茵年鉴”或“真正的社会主义的哲学" class="headerlink" title="一 “莱茵年鉴”或“真正的社会主义的哲学"></a>一 “莱茵年鉴”或“真正的社会主义的哲学</h3><h4 id="A-“共产主义、社会主义、人道主义”"><a href="#A-“共产主义、社会主义、人道主义”" class="headerlink" title="A. “共产主义、社会主义、人道主义”"></a>A. “共产主义、社会主义、人道主义”</h4><p>我们从这篇文章开始谈起，因为在这篇文章中十分自觉地、而且以强烈的自尊感表露出“真正的社会主义” 的德国民族性质。</p><blockquote><p>共产主义是法国的现象，社会主义是德国的现象；法国人的幸福在于，他们具有这样一种幸福的社会本能，他们用这种本能在任何一个时候都可以代替科学工作。这个结果是在两个民族的发展进程中预先确定了的。法国人通过政治走向共产主义〈当然，现在我们已经知道，法国人民是怎样走向共产主义的〉；德国人通过最后变成人类学的形而上学走向社会主义〈即走向“真正的社会主义”〉。共产主义和社会主义归根到底都消融在人道主义中了。</p></blockquote><p>把共产主义和社会主义变成了两种抽象的理论、两种原则以后，再给这两个对立面杜撰任何一种黑格尔式的统一，随便安上一个名称，当然是非常容易的事。这样做就不仅有可能洞悉“两个民族的发展进程”，而且有可能光辉地显示出一个醉心于思辨妙想的个人比法国人和德国人高明的地方。</p><p>这些“真正的社会主义者”对于法国人的一切责难就在于：法国人没有以费尔巴哈的哲学作为自己的整个运动的最高原则。我们的这位作者是以关于劳动和享乐之间的分裂这一现成的命题为依据的。但他不是从这个命题开始谈起，而是在思想上把问题倒转过来，一开始就说什么人没有意识，并由此作出了关于“对粗暴的物质的依赖”的推论，接着就强使这种依赖在“劳动和享乐之间的分裂”中得到实现。</p><p>外国人思考和行动是为了自己所处的时代，而德国人思考和行动却是为了永恒。我们这位“真正的社会主义者”把这种意见阐述如下：</p><blockquote><p> “共产主义在其标志着反对竞争的那个名称上就已经暴露出自己的片面性；虽然这种狭隘的见解作为党的称号现在也许还有意义，但是，难道它会永恒地继续下去吗？”</p></blockquote><p>我们这位作者在根本消灭了共产主义以后，就转而谈到它的对立面—— 社会主义。</p><blockquote><p>“社会主义实行无政府制度，这个制度是人类和宇宙的本质上独特的特性”（第１７０页），正因为如此，这个制度过去对“人类”说来是没有存在过的。</p></blockquote><p>自由竞争太 “粗暴” 了，所以我们这位 “真正的社会主义者” 没有宣布它是“无政府制度”</p><p>因此，这里所得出的因果关系可归结如下。无产者生存着并像机器一样地工作着：这是我们所看见的事实。但是，为什么无产者要“像机器一样地工作” 呢？因为食利者“让自己的固有本质腐化”。为什么食利者让自己的固有本质腐化呢？因为“现在我们这个社会如此野蛮化了”。而为什么它如此野蛮化了呢？请你们去问上帝。</p><p>他说，自由活动就是“不决定于我们之外的物”的活动；这就是说，自由活动是ａｃｔｕｓ ｐｕｒｕｓ，纯粹的抽象的活动， 只不过是活动的那种活动，而且，归根到底，它又被归结为“纯粹思维”的幻想。既然这种纯粹的活动有了物质的基质和物质的结果，那末这种活动当然是完全被玷污的了；“真正的社会主义 者”只是迫不得已才从事这种被玷污了的活动，所以他轻视这种活动的产物，称它不是“结果”，而 “只不过是人的糟粕”（第１６９ 页 ）。</p><p>我们的作者这样驳倒了共产主义和社会主义之后，就给我们揭示出两者的最高统一——人道主义。从这时起，我们进入了 “人”的境地，从此我们这个“真正的社会主义”的全部真正的历史就只在德国展开了。</p><p>我们很清楚，一小撮德国空谈家是断送不了共产主义运动的。但是，在像德国这样的国家里，许多世纪 以来哲学词句都占有一定的势力，这里没有其他民族所有的那种尖锐的阶级对立，而这种情况本来就削弱着共产主义意识的尖锐性和坚定性，在这样的国家中毕竟应当反对一切能够更加冲淡和削弱对于共产主义同现存秩序的充分对立性的认识的词句。</p><p>后面零星摘一点</p><blockquote><p>“人和自然界的斗争是以两极的对立、以 我 的 特 殊 生 命 和 自然界的普遍 生命的相互作用为基础的。当这一斗争表现为自觉活动的时候，就叫作劳 动。”（第１６４ 页 ）</p></blockquote><p>相反，如果说“两极的对立”的观念是以对人和自然界的斗争的观察为基础的，不是更正确吗 ？ 先从事实得出一个抽象概念，然后宣称这个事实是以这个抽象概念为基础的。这是给自己装上一副德国人的深思的和思辨的姿态的一种最便宜的方法。</p><p>在手稿中，没有“德意志意识形态”第二卷的第二章和第三章。 在遗留给我们的手稿中，有些地方已经受到了“老鼠的牙齿的批判”。这些根据句子的完整部分所恢复起来的地方，都用方括弧括起来了。</p><p>在恩格斯的“共产主义原理”（１８４７）中指出，无产阶级革命只有在一切先进的资本主义国家同时发动时才可能胜利，因而不可能在一个国家内胜利，这个结论对于垄断前的资本主义时代来说是正确的。在新的历史条件下，在垄断资本主义时期，列宁根据他所发现的帝国主义时代资本主义的经济政治发展不平衡的规律，做出了新的结论：社会主义革命可能首先在几个或者甚至在单独一个国家内获得胜利，不可能同时在一切国家或大多数国家内获得胜利。这个新的结论是在列宁“论欧洲联邦口号”（１９１５） 这篇论文中第一次提出来的。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夕拾 第一周</title>
      <link href="/20240527-month/"/>
      <url>/20240527-month/</url>
      
        <content type="html"><![CDATA[<p>夕拾，用来管理除了学术以外的学习生活。</p><p>第一月 （1-4 周）</p><ol><li>恢复训练。能做15个引体向上，140kg 深蹲，170kg 硬拉。做新的计划，走3个月。</li><li>读小逻辑。</li><li>从头开始学习计算模型。</li><li>见纸质材料</li></ol><p>第一周 5.27-6.2</p><p><img src="image-20240527145945379.png" alt="image-20240527145945379"></p><p><img src="image-20240527150012060.png" alt="image-20240527150012060"></p><p><img src="image-20240527150036874.png" alt="image-20240527150036874"></p><p><img src="image-20240527150622100.png" alt="image-20240527150622100"></p><p>雁过留痕。</p><p>这样管理结构还是很乱。我需要学一些管理学的方法**。</p>]]></content>
      
      
      <categories>
          
          <category> 夕拾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图形绘制技术Lab2</title>
      <link href="/20240520-MoerLab2/"/>
      <url>/20240520-MoerLab2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形绘制技术-Lab2"><a href="#图形绘制技术-Lab2" class="headerlink" title="图形绘制技术 Lab2"></a><center>图形绘制技术 Lab2</center></h1><h5 id="纹理的采样、映射以及生成"><a href="#纹理的采样、映射以及生成" class="headerlink" title="纹理的采样、映射以及生成"></a><center>纹理的采样、映射以及生成</center></h5><center>502023330051 孙博文</center><h2 id="光线微分"><a href="#光线微分" class="headerlink" title="光线微分"></a>光线微分</h2><p>根据 $p_i - p_0 &#x3D; \Delta u \dfrac{\partial p}{\partial u} + \Delta v \dfrac{\partial p}{\partial v}$</p><p>将其分成3个维度计算，以 $u$ 为例，$p(w, u, v)$ 是点坐标，$t(u, v)$ 是纹理坐标，而我们先前假设，$\dfrac{\partial p}{\partial u}$ 和 $\dfrac{\partial p}{\partial v}$ 都是常数：</p><p>$p_1.u - p_0.u &#x3D; \Delta t_1.u \dfrac{\partial p.u}{\partial t.u} + \Delta t_1.v \dfrac{\partial p.u}{\partial t.v}$</p><p>$p_2.u - p_0.u &#x3D; \Delta t_2.u \dfrac{\partial p.u}{\partial t.u} + \Delta t_2.v \dfrac{\partial p.u}{\partial t.v}$</p><p>故可以写成：</p><div>$$\begin{bmatrix}p_1.u - p_0.u\\\\p_2.u - p_0.u \end{bmatrix}=\begin{bmatrix}\Delta t_1.u &\Delta t_1.v\\\\\Delta t_2.u &\Delta t2.v\end{bmatrix}\begin{bmatrix}\dfrac{\partial p.u}{\partial t.u}\\\\\dfrac{\partial p.u}{\partial t.v}\end{bmatrix}$$</div><p>2阶方阵中 $\Delta t_1.u$ 可以通过计算 $t_1, t_0$ 的 $u$ 方向差值得到，其余同理；</p><p>左边可以计算三角形点坐标差得到。</p><p>进而调用 <code>solveLinearSystem2x2</code> 可求得 $\dfrac{\partial p.u}{\partial t.u}$ 和 $\dfrac{\partial p.u}{\partial t.v}$，即$\dfrac{\partial p}{\partial u}$ 和 $\dfrac{\partial p}{\partial v}$ 在 $u$ 方向上的分量。</p><p>$v, w$ 方向同理。</p><p>求解代码如下：</p><img src="image-20240520185709226.png" alt="image-20240520185709226" style="zoom: 67%;"><p>双线性滤波结果：</p><img src="image-20240520185915426.png" alt="image-20240520185915426" style="zoom:50%;"><p>光线微分结果：</p><img src="image-20240520185829080.png" alt="image-20240520185829080" style="zoom:50%;"><h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><p>球面映射：计算出方位角后，修正到 [0, 1]</p><p>用于修正的fix函数：</p><img src="image-20240520202122018.png" alt="image-20240520202122018" style="zoom: 67%;"><p>圆柱体：v 取归一化的 z 坐标</p><p>平面：直接取 x，y 坐标</p><img src="image-20240520202219930.png" alt="image-20240520202219930" style="zoom:67%;"><p><img src="image-20240520194408285.png" alt="image-20240520194408285"></p><p><img src="image-20240520195042337.png" alt="image-20240520195042337"></p><p><img src="image-20240520202023233.png" alt="image-20240520202023233"></p><h2 id="木纹"><a href="#木纹" class="headerlink" title="木纹"></a>木纹</h2><p>在构造函数中读取木纹的属性并生成随机的单位向量</p><img src="image-20240520212215999.png" alt="image-20240520212215999" style="zoom:67%;"><p>在 <code>evaluate</code> 中，根据坐标，使用 Berlin 噪声和双线性插值计算颜色，与讲义一致</p><img src="image-20240520215052001.png" alt="image-20240520215052001" style="zoom: 50%;"><p><img src="image-20240520214932641.png" alt="image-20240520214932641"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>强装镇定</title>
      <link href="/20240519-composure/"/>
      <url>/20240519-composure/</url>
      
        <content type="html"><![CDATA[<p>前阵的闹剧以完美解决的方式，连事带人一起滚出了我的生活。这好吗？这不一定好。至少今晚就因为它，我被工学椅硬控了两个小时，既没在工作，也没在娱乐。这说明我是真的需要休息。</p><p>不过我有点被迫弹出的感觉，是说真正开心的事情发生之后，我还是不算知情。但也没事，就算后面只能眼睁睁看着事情发展，那也正常，本该如此。</p><p>我已经不知道上次以单一纯粹的心态面对这种事是什么时候了。越多考虑，真心就越难辨。所以我主张的是“以个人自己的主张而非分析”为准。简而言之，就是他敢于说出的东西就是真的。</p><p>跑题了。左顾右盼、左右逢源的日子也要结束了。</p><p>先谈另一件事。事件本身依然有值得观察的地方。作为只抓大学的尾巴，这样一场恋爱能持续多久？面对这种新人，某人是否还能守住？敬请期待。。。我想要的很多答案，就会出现在这一绝佳的样本上。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.26 酒单-最终版</title>
      <link href="/20240518-list/"/>
      <url>/20240518-list/</url>
      
        <content type="html"><![CDATA[<p>中心思想：颜色好看</p><h3><a href="#jiu" class="header-anchor">#</a><span id="jiu">酒</span></h3><p>金汤力 - 添加利金酒45ml，青柠汁8ml，托马斯亨利汤力水补满（约120-150ml），蝶豆花，青柠片装饰   蓝紫色</p><ul><li>清爽，草本，酸甜微苦</li></ul><p>椰林飘香 - 哈瓦那3年朗姆45ml，马利宝15ml，椰奶45ml，菠萝汁45ml，红色花瓣装饰   奶白色</p><ul><li>热带风味，甜</li></ul><p>自由古巴 - 哈瓦那3年朗姆45ml，青柠汁8ml，可乐补满，青柠角装饰   深褐色</p><ul><li>清爽，甜</li></ul><h3><a href="#wu-jiu-jing-te-yin" class="header-anchor">#</a><span id="wu-jiu-jing-te-yin">无酒精特饮</span></h3><p>蓝色夏威夷 - 莫林蓝柑糖浆20ml，柠檬汁20ml，象牌苏打水补满  黄柠檬片装饰  蓝色</p><ul><li>酸甜，橙味</li></ul><p>斯嘉丽 - 优鲜沛蔓越莓汁60ml，象牌苏打水补满，柠檬皮装饰  红色</p><ul><li>酸甜，蔓越莓风味</li></ul><p>菠萝冰茶 - 菠萝汁45ml，橙汁30ml，柠檬汁15ml，糖浆15ml，茉莉绿D茶补满   橙色</p><ul><li>菠萝风味</li></ul><h2><a href="#cheng-ben" class="header-anchor">#</a><span id="cheng-ben">成本</span></h2><p>以最终出品约50杯为前提，估计各物料用量如下表：</p><table><thead><tr><th>品种</th><th>数量</th><th>单价</th><th>总价</th></tr></thead><tbody><tr><td>添加利金酒700ml</td><td>1</td><td>85.5 + 3</td><td>88.5</td></tr><tr><td>哈瓦那3年朗姆700ml</td><td>2</td><td>74 + 3</td><td>154</td></tr><tr><td>托马斯亨利汤力水 200ml</td><td>8</td><td>65 &#x2F; 6</td><td>86.6</td></tr><tr><td>青柠檬</td><td>5</td><td>11</td><td>55</td></tr><tr><td>黄柠檬</td><td>5</td><td>6</td><td>30</td></tr><tr><td>马利宝椰子味朗姆酒 700ml</td><td>1</td><td>78</td><td>78</td></tr><tr><td>菲诺厚椰乳 1L</td><td>1</td><td>15.8</td><td>15.8</td></tr><tr><td>意文菠萝汁 1L</td><td>2</td><td>10.9</td><td>21.8</td></tr><tr><td>可口可乐330ml</td><td>6</td><td>3.0</td><td>18</td></tr><tr><td>必得利蓝柑糖浆</td><td>1</td><td>41.5 + 3</td><td>44.5</td></tr><tr><td>象牌苏打水325ml x 6</td><td>1</td><td>17.9</td><td>17.9</td></tr><tr><td>优鲜沛蔓越莓汁 2L</td><td>1</td><td>20.9</td><td>20.9</td></tr><tr><td>意文橙汁 1L</td><td>1</td><td>10.9</td><td>10.9</td></tr><tr><td>蝶豆花 40g</td><td>1</td><td>13.9</td><td>13.9</td></tr><tr><td>小计</td><td></td><td></td><td>742.4</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 酒 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本周剩余工作盘点</title>
      <link href="/20240515-workleft/"/>
      <url>/20240515-workleft/</url>
      
        <content type="html"><![CDATA[<p>周四 批作业 1 <strong>定酒单</strong> 1，并且汇报好；买烟 1</p><p>周五~ 摆摊 1</p><p>周六 准备定完酒单的材料 0；扫除 1</p><p>周日 图形绘制技术作业；排练</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝色</title>
      <link href="/20240514-idk/"/>
      <url>/20240514-idk/</url>
      
        <content type="html"><![CDATA[<p>染了个蓝色头发。感觉自己萌萌哒</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组会大纲</title>
      <link href="/20240513-dmck/"/>
      <url>/20240513-dmck/</url>
      
        <content type="html"><![CDATA[<p>做了什么：</p><p>用 willemt&#x2F;raft，做了一个基于 UDP 通信的被测程序</p><p>对 tracer，实现了 emu_socket, emu_sendto, emu_recvfrom 等多个网络相关函数，完全模拟 SOCK_DGRAM </p><p>care:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_sendto</span><br><span class="line">SYS_recvfrom</span><br><span class="line">SYS_write</span><br><span class="line">SYS_read</span><br><span class="line">SYS_clock_nanosleep</span><br></pre></td></tr></table></figure><p>1、对socket、connect、listen、send、recv等的拦截</p><ul><li>拦截与模拟 <font color="gree">OK</font></li><li>tracer 与 tracee 之间的数据拷贝 <font color="gree">yes</font></li></ul><p>2、对数据报的管理 - 数据结构 <font color="gree">OK</font></p><p>3、用 raft 写简易被测程序，研究其性质</p><p>4、手动操控模式，随机模式 —- 一条线走下去</p><p>5、稍作划分；还是强耦合</p><ul><li>tracer: 调度、控制</li><li>state: 状态（结构体、序列和反序列化）</li><li>guest: tracer 与 tracee 交互</li><li>network: 网络行为的模拟</li></ul><p><img src="image-20240513082647413.png" alt="image-20240513082647413"></p><p>实际设计上，消息队列归属于节点状态了。相当于为每一个节点添加了一个 recvbuffer</p><p>不需要choose：</p><ul><li>超时。通过调度的枚举即可。在 sleep 处打上点即可。<ul><li>譬如，先 send_applyentries 再退出 sleep；或反之 sleep 后先判是否收到心跳，再 send_applyentries。</li></ul></li></ul><p>对于 willemt&#x2F;raft，要求周期性 raft_periodic(msec_since_last_period)。</p><p>它做两件事，一是计算 time_elapsed，用于判定心跳超时和选举超时。二是 apply_log</p><p>几乎所有的信息都在 raft_server_private_t 里。也就是说只要把 raft_server_t *raft 的指针地址找到即可 —— 这比较简单。然后引用 raft_private.h 对结构体进行解析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">raft_term_t</span> current_term;</span><br><span class="line">  <span class="type">raft_node_id_t</span> voted_for;</span><br><span class="line">  </span><br><span class="line">  <span class="type">raft_index_t</span> commit_idx;</span><br><span class="line">  <span class="type">raft_index_t</span> last_applied_idx;</span><br><span class="line">  <span class="type">int</span> state;</span><br><span class="line">  <span class="type">int</span> timeout_elapsed;</span><br><span class="line">  </span><br><span class="line">  <span class="type">raft_node_t</span>* nodes;</span><br><span class="line">  <span class="type">int</span> num_nodes;</span><br><span class="line">  </span><br><span class="line">  <span class="type">raft_node_t</span> *current_leader;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="type">raft_server_private_t</span>;</span><br></pre></td></tr></table></figure><p>代价：为这个结构体编写反序列化函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *addr = get_var_addr(<span class="string">&quot;raft&quot;</span>);</span><br><span class="line"><span class="type">raft_server_private_t</span> *raft = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*raft));</span><br><span class="line">memcpy_guest2host(raft, addr, <span class="keyword">sizeof</span>(*raft));   <span class="comment">// 此时里面的指针还是在 tracee 进程的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">raft_node_t</span> *nodes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*nodes));</span><br><span class="line">memcpy_guest2host(nodes, raft-&gt;nodes, <span class="keyword">sizeof</span>(*nodes));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>running state (procfs)  &lt;=&#x3D;&gt;  recorded state (structure)  &lt;=&#x3D;&gt;  stored state (serialized)</p><p>目前的状况</p><ul><li><p>运行起 raft 协议</p></li><li><p>逻辑比较琐碎。数据结构管理混乱，有一些 bug（结构体倒来倒去）</p><ul><li>经典：用链表存的消息队列，serialize deserialize不停。每跑一次就得复制一份。一会儿用的是以前留下的，一会儿用的是从文件里读的。最终导致网络的行为有问题。</li></ul></li><li><p>数据结构不连续，不适合映射到磁盘上。需调整。</p><ul><li>数组，预分配</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/20240505-brokenthoughts/"/>
      <url>/20240505-brokenthoughts/</url>
      
        <content type="html"><![CDATA[<p>我想学一点关于女性的心理学，这样也能算是知己知彼。</p><p>想来想去，还是不觉得有人能管住我，拿捏我。有些事情没做，纯粹是因为我自己还做不到。</p><p>在有勇气做出大方向、大的路线的选择以外，我更需要的是事无巨细地去研究一件事的细节。至今为止我一直都在强调的往往都是我不缺的东西，却把我真正缺少的东西忽视掉了。</p><p>我看到有一个回答里写的军用地图，能够细化到连一棵独立的树都标注在图上。所以好好想一想，军事上的成功除了大方向上的决策以外，在看不到的地方是事无巨细的绣花工作，或许称之为“微操”。</p><p>胆大心细。一定要逼自己做这样的工作。</p><p>最近身上也发生了各种各样的变化，尤其是对以前听过的小故事进行了重新思考，甚至是亲历。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK工作</title>
      <link href="/20240504-dmck/"/>
      <url>/20240504-dmck/</url>
      
        <content type="html"><![CDATA[<p>这次至少要把 raft 跑起来</p><p>还缺的内容：</p><p>1、根据 raft 框架写一个应用程序 <font color="gree">OK</font></p><p>2、把规约所需的语义信息爬出来</p><p>3、environment</p><p>首先做environment 模拟网络通信。写一个一主一备来测试。</p><ul><li>socket管理</li><li>数据报队列</li></ul><p>4、hash去重</p><p>UDP 测试程序 OK</p><p>分析 environment</p><p>1、对socket、connect、listen、send、recv等的拦截</p><ul><li>拦截与模拟 <font color="gree">OK</font></li><li>tracer 与 tracee 之间的数据拷贝 <font color="red">NO</font></li></ul><p>2、对数据报的管理 - 数据结构 <font color="gree">OK</font></p><p>观察 ticketd 是怎么做初始化的</p><p>main</p><ul><li>传参</li><li>raft_new</li><li>set callbacks</li><li>start server for client</li><li>add self</li><li>start socket</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接着复盘</title>
      <link href="/20240504-review/"/>
      <url>/20240504-review/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上（5.2）在酒吧问一个超级姐的姐姐要了微信，但我的打招呼方式太学生气了。然而对方是浙江台州的，就。。反正之后要更注意这方面的技巧，需要花时间琢磨一下。</p><p>我现在性格上应该是不成问题，但是之前都不屑于去学一点技巧，轻视了套路。当然信心还是有的，毕竟人同意加好友了，说明印象不差。</p><p>困惑。这世界上到底是享受到性爱的人多还是享受不到的人多。呃其实也不是这个问题。而是总有人看起来轻轻松松就享受到了性，而自己就要耐心地守着。我也是急了。我到底输在哪？</p><p>并不服气。然而并不是要甩锅。我唯一希望的事情是，我想干的事情，就要干一件成一件。无论是个人问题，还是科研课题，我都想要完全地掌控。野心只是一方面，事实上我现在是有点万念俱灰的。我没有放过自己，我不想放过自己，因为<strong>放过自己就不好玩了</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>尾声：以后怎么办</title>
      <link href="/20240430-tot5/"/>
      <url>/20240430-tot5/</url>
      
        <content type="html"><![CDATA[<p>一连五篇是同一天写出来的。有两篇不太重要就不录入了。</p><p>反复提的问题，即使每一次都没有完全解决，每一次都没有得到自己的足够重视，也要不厌其烦地去提。千万不要还没解决掉，就开始主动放弃。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>想要得到谁的夸奖，是不会骗人的</title>
      <link href="/20240430-tot4/"/>
      <url>/20240430-tot4/</url>
      
        <content type="html"><![CDATA[<p>上周几乎全都在和 Z女士 见面。周日的酒局她似乎玩得挺开心，之后也催着我组局，周二就又来了一次。我也才知道波士顿壶这种东西到底有多方便。</p><p>周一到 Tribeca，稍微聊了两嘴。我感到 &lt;数据删除&gt; 这件事极度危险。</p><p>两三年下来，我和 Z女士 之间的了解只能说不多不少。不知道应该以什么样的关系进入下一阶段。现在的我比起大三的时候毕竟有一些进步，但我已经不想走回头路了。</p><p>周四被 Z女士 拉着教他抽烟。一年前我对于这种事情其实是极力阻拦的，后来自己也学会了；再后来竟至于教人抽烟。我可能的确是缺少幸福感。或者更准确地说，是缺少羁绊。</p><p>不过有一件事现在是确定无疑的：我无比重视 Z女士 对我的评价，比其他任何人的都重视。所以我会尽力好好表现，有的事也会选择性隐瞒……</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>惊醒</title>
      <link href="/20240430-tot2/"/>
      <url>/20240430-tot2/</url>
      
        <content type="html"><![CDATA[<p>Z女士 一句话点醒了我。除了 M女士 以外，我似乎更是应该小心谨慎。</p><p>&lt;数据删除&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>恋爱、报复与忏悔</title>
      <link href="/20240430-tot1/"/>
      <url>/20240430-tot1/</url>
      
        <content type="html"><![CDATA[<p>前段时间发生了不少事，下面进行技术总结。</p><p>这一篇是一连串的事情中对我影响最小但是最 dramatic 的。</p><p>Sさん 碰巧转给我 Pさん 的长篇动态，里面详细地揭露了一位“海后” M女士 是如何通过约拍与自己暧昧，最终被发现是一场巨大 NTR 的事件：在 地点A 处分别之后，二人的行踪错开，使得 Pさん 刚好发现 M女士 在另一位 Gさん 的怀里。</p><p>当即我并未发现所指人物 （M女士）是我认识的人。但两小时之后，我灵光乍现，怀疑根据 Pさん 的描述，其中时间地点与我认识的一位朋友的朋友圈更新几乎吻合。在简单的交涉之后，我向 Pさん 确认了我的猜想，并大跌眼镜。因为本人曾经与 M女士  吃过一顿饭。我并不怀疑，如果 M女士 的糖衣炮弹再猛烈一点，我将成为受害者之一。复盘的时候，Z女士 说，如果我看上了 M女士，那她一辈子都看不起我，因为我曾经喜欢过的女生都是很神奇很酷的类型。我只能庆祝自己是如此侥幸，因为的确我当时身陷另一个僵局于是就把这边的事情搁置了。</p><p>这是属于动摇之人的强运。</p><p>update: </p><p>没想到，这件事后来又能连上。某日 Hさん 来找我忏悔，说他的旧相识一直在外面沾花惹草。我一听直接爆出 M女士 的大名，直接震慑住了对方。据 Hさん 交代，其因为心情不好在寒假时冷落了 M女士，于是 M女士 试图以通过与其他男性勾勾搭搭的方式吸引 Hさん 的注意。</p><p>并感叹了 Pさん 的确让他心生嫉妒。但他自己已经不想再掺和这件事了，已经心累了。</p><p>-終わり-</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你不理解吗？我们看到的东西，都不一样</title>
      <link href="/20240430-tot3/"/>
      <url>/20240430-tot3/</url>
      
        <content type="html"><![CDATA[<p>Y女士 与一位男同学似乎暧昧过。据说一切都是线下发生的而没有留下任何文字证据，导致两方亲友对这件事情的看法都不一样。</p><p>我也没有什么立场，或者说给这件事情定性什么的。事实上对我完全没影响。只是对于 “视角” 所带来的态度差异又了解了一分。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图形绘制技术Lab1</title>
      <link href="/20240415-CGLab1/"/>
      <url>/20240415-CGLab1/</url>
      
        <content type="html"><![CDATA[<h1 id="图形绘制技术-Lab1"><a href="#图形绘制技术-Lab1" class="headerlink" title="图形绘制技术 Lab1"></a><center>图形绘制技术 Lab1</center></h1><h5 id="复杂光源的实现"><a href="#复杂光源的实现" class="headerlink" title="复杂光源的实现"></a><center>复杂光源的实现</center></h5><center>502023330051 孙博文</center><h2 id="1-恒定功率光源"><a href="#1-恒定功率光源" class="headerlink" title="1 恒定功率光源"></a>1 恒定功率光源</h2><p>根据<br>$$<br>\Phi_e &#x3D; \int_{Area}\int_{Hemisphere}L_e(x, \omega)\cos\theta d\omega dA<br>&#x3D;L\pi S<br>$$<br>可知 Radiance 为 $Power &#x2F; (\pi * shape.getArea())$</p><img src="image-20240415213747112.png" alt="image-20240415213747112" style="zoom:50%;"><p>结果：</p><p><img src="1-1713188409799.png" alt="1"></p><h2 id="2-球面光源"><a href="#2-球面光源" class="headerlink" title="2 球面光源"></a>2 球面光源</h2><p>按俯仰角 $\phi$ 对球面面积进行微分，得到：</p><p>$$<br>dS &#x3D; 2\pi R^2 \cos\phi\ d\phi &#x3D; 2\pi R^2 d\sin\phi &#x3D; 2\pi Rdz<br>$$<br>直观的理解是，将球面在 $z$ 轴上分割为高相等的无穷细的圆环，它们之间的面积相等。因而按 $z$ 坐标与方位角 $\theta$ 均匀采样可以等可能地采样到球面上的每一个点。</p><p>于是设置两个随机变量：$z &#x3D; 1 - 2u, \theta &#x3D; 2\pi v\ (u, v\in [0, 1])$ </p><p>根据 $z$ 偏移量与方位角算出法向量，并乘以半径再加上球心 $\boldsymbol {pos}$ 得到交点。</p><p>pdf 即为 1 &#x2F; 球表面积</p><img src="image-20240415213523699.png" alt="image-20240415213523699" style="zoom:50%;"><p>结果：</p><p><img src="2.png" alt="2"></p><h2 id="3-三角形网格光源"><a href="#3-三角形网格光源" class="headerlink" title="3 三角形网格光源"></a>3 三角形网格光源</h2><p>首先在 <code>TriangleMesh</code> 中添加面积累加得到的数列，在构造函数中，对各三角形面积累加计算总面积，并构造数列。</p><p>然后使用 <code>u * getArea()</code>，在数列中进行二分查找得到采样的目标三角形，编号为L。</p><p>为了在三角形内的采样均匀，计算新的 u<br>$$<br>u &#x3D; \dfrac{u * getArea() - area_L}{area_{L + 1} - area_L}<br>$$<br>这样，对于任意的三角形，$u$ 仍然遵循在 $[0, 1]$ 间的均匀分布，虽然精度有所下降。</p><p>为了在三角形内均匀采样，需要判断 $u + v &gt; 1$ 如果成立，则采样点超出三角形外。此时只要使得：</p><p>$u &#x3D; 1 - u, v &#x3D; 1 - v$，即可修正到三角形内并保持均匀采样。<br>pdf 即为 1 &#x2F; 总表面积</p><p><img src="image-20240415213631568.png" alt="image-20240415213631568"></p><p>结果：</p><p><img src="3.png" alt="3"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《德意志意识形态》first time</title>
      <link href="/20240317-marx/"/>
      <url>/20240317-marx/</url>
      
        <content type="html"><![CDATA[<p>序言：把人从幻象、观念、教条和臆想的存在物的枷锁中解放出来。</p><ul><li>费尔巴哈：用符合人的本质的思想来代替臆想</li><li>鲍威尔：批判地对待臆想</li><li>施蒂纳：从头脑里抛掉臆想，这样当前的现实就会崩溃（意指只要改变人们的思想，就可以撼动社会现实）</li></ul><p>以上都是青年黑格尔派的天真的幼稚的空想，是自以为是狼、也被人看成是狼的绵羊（没有引起现实的革命，要严肃地批判）。</p><p>Chapter 1 费尔巴哈，唯物主义观点与唯心主义观点的对立。</p><p>德意志意识形态：以青年黑格尔派为代表的德国哲学，颠倒意识与存在、思想与现实的关系，以纯思想批判反对现存制度的实际斗争。</p><p>这是一种“在可敬的德国市民中唤起怡然自得的民族感情的哲学叫卖”。</p><p>站在德国以外的立场上来考察并表明黑格尔派的运动的狭隘性、地域局限性。</p><p>肯定了1842－1845年的思想发展为“绝对精神的瓦解过程”</p><p>整个德国哲学，从施特劳斯到施蒂纳的批判，都局限于对于宗教观念的批判。青年黑格尔派同老年黑格尔派的共同信念：宗教、概念、普遍的东西统治着现存世界。一派认为这种统治是篡夺而加以反对，另一派认为这种统治是合法的而加以赞扬（qb，必要之恶）。</p><p>青年黑格尔派认为，观念、思想、概念，是某种独立东西意识的一切产物，是人们的真正枷锁。老年黑格尔派认为它们是人类社会的真正镣铐。那么只要同意识里的这些幻想作斗争就行了。</p><p>只为反对“词句”而斗争。</p><p>全部人类历史的第一个前提无疑是有生命的个人的<strong>存在</strong>。一当人开始生产自己的生活资料，即迈出由他们的肉体组织所决定的这一步的时候，人本身就把自己和动物区别开来。</p><p>人表现生命的一定方式——生活方式——生产什么，怎样生产。</p><p>生产随着人口的增长开始，以个人彼此之间的交往为前提。而交往的形式是由生产决定的。</p><p>各民族之间的相互关系取决于每一个民族的生产力、分工和内部交往的发展程度。民族本身的整个内部结构也取决于自己的生产以及自己内部和外部的交往发展程度。新的生产力，只要不是单纯量的发展，都会引起分工的发展。</p><p>一个民族内部的分工，首先引起工商业劳动同农业劳动的分离，从而引起城乡的分离和城乡利益的对立。</p><p><strong>分工的各个不同发展阶段，同事也就是所有制的各种不同形式。</strong></p><p>所有制，就是个人在劳动材料、劳动工具和劳动产品的相互关系。</p><p>分析了发展中的三种所有制形式：1、部落所有制－氏族，2、公社所有制和国家所有制－部落形成城市，3、封建的或等级的所有制－城市及乡村。</p><p>等级划分在乡村（中世纪）是王公－贵族－僧侣－农民，在城市（古代）是师傅－帮工－学徒－平民短工。</p><p>由此可见，事情是这样的：以一定的方式进行生产活动的一定的个人（或是，在一定的生产关系下的一定的个人）发生一定的社会和政治关系。</p><p><strong>现实的</strong>个人，是从事活动的，进行物质生产的，因而是在一定的物质的、不受他们任意支配的界限、前提和条件下活动着的。</p><p>接下来——思想、观念、意识的生产最初是直接与人们的物质活动，与人们的物质交往，与现实生活的语言交织在一起的。</p><p><strong>表现在某一民族的政治、法律、道德、宗教、形而上学等的语言中的精神生产也是这样。</strong></p><p><strong>意识在任何时候都只能是被意识到了的存在，而人们的存在就是他们的现实生活过程。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《小逻辑》again</title>
      <link href="/20240317-hegel/"/>
      <url>/20240317-hegel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我的确从没有如此精读过。读《纯粹理性批判》的时候是按讨论的概念去写总结的。而黑格尔的哲学写作，就如同他的哲学思想一般，是一个整体性的：自为因果，循环发展。因而试图按部门去读解是困难的。做笔记的目的在于，能够时时都作整体性的梳理。</p></blockquote><p>第一版序是纯粹的客套</p><p>第二版序</p><p> 一般科学教育的理智导致一种重要的消极结果，即认为采取有限概念的道路就没有中介可能达到真理。</p><p> （我有点没看懂后面这个批评）</p><p> “人们对待斯宾诺莎好像对待一条死狗”。（对唯理论的轻视？）</p><p> 哲学的历史就是发现关于“绝对”的思想的历史。绝对就是哲学研究的对象。（康德：上溯到“无条件者”）</p><p> 谈宗教的部分就不<strong>看了。</strong></p><p>第三版序略</p><p>致辞</p><p> “这个时代之走到对于理性的绝望…” </p><p> 批判哲学确信它证明了我们对永恒、神圣、真理什么也不知道，并将此种无知、浅薄和空疏宣称为一切理智努力的最终结果。（批评康德式的不可知论，把人的理性提到一个更高的点上：我们对于绝对的概念的追寻绝不是一种臆想。在上课前，给学生先打一针鸡血）。 </p><p> 小逻辑总体上是黑格尔的课程讲义。并附有学生从课堂上归纳的解释。</p><p>导言</p><p>Para 1 对于事物作<strong>思维着的</strong>考察，必指出思维内容的必然性，证明其存在与规定性。因而，困难在于寻得一个哲学的开端是一种困难。以任何当前直接的东西作为开端，那只是提出了一种假定。</p><p>Para 2 概括讲来，哲学可以定义为对于事物<strong>思维着的</strong>考察。哲学作为一种特殊的思维方式（与普遍的人的思维对应），思维成为认识，成为把握对象的概念式的认识。</p><p> 基于思维表现人性的意识内容，每每首先不借思想的形式出现，而是作为情感、直觉或表象等形式而出现。情绪与思维并不是截然分开的。 </p><p> （欲望、意志、情绪，有别于纯粹的思想，同样是人类理性。）</p><p>Para 3 情绪、直观、印象等，是意识内容所表现的诸形式。在任何一种或混合形式下的内容都是意识的对象。而形式在遗失的对象中归为内容而呈现。因而每一形式好像是特殊的对象。（我意欲的和我思考的东西，它们仅仅是以不同形式呈现在意识当中。）</p><p> 我们所意识到的情绪、直观、欲望、意志等规定，一般被称为<strong>表象</strong>。大体上可以说，哲学是以思想、范畴，或更确切地说，是以<strong>概念</strong>去代替表象。</p><p> 表象的感觉材料的一个命题：这片树叶是绿的。这样的命题却也掺杂了存在、个体性的<strong>范畴</strong>。</p><p> （而哲学的难点则在于作抽象思维。）“把思想本身，单纯不杂地作为思考的对象”。（单纯地思考范畴？还是单纯地思考概念？）</p><p>Para 4 略</p><p>Para 5 意识的真实内容，一经翻译为思想和概念的形式，反而更能保持其真相，甚至反而能更正确地认识的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组会主题</title>
      <link href="/20240315-progres/"/>
      <url>/20240315-progres/</url>
      
        <content type="html"><![CDATA[<p>尼玛早上6点就有人进来了，刚夜里3点还有人在隔壁通宵，今天疑似有点撞大运了。</p><p>这次的工作量可能不太够，所以尽量就啰嗦一点。</p><ul><li>bakery算法，完整版，去掉choosing版，atomic和safe寄存器的考量</li><li>一个raft协议的考察，使用udp去实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">process(i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        choosing[i] = true;</span><br><span class="line">        number[i] = 1 + max(number[1], number[2], ..., number[n-1]);</span><br><span class="line">        choosing[i] = false;</span><br><span class="line">        </span><br><span class="line">        for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            while (choosing[j]);</span><br><span class="line">            while (number[j] != 0 &amp;&amp; (number[j], j) &lt; (number[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &lt;critical section&gt;</span><br><span class="line"></span><br><span class="line">        number[i] = 0; </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1: Send(T2, REQUEST_VOTE, term = 1)</span><br><span class="line">T1: Send(T3, REQUEST_VOTE, term = 1)</span><br><span class="line">T3: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Send(T1, GRANT_VOTE)</span><br><span class="line">T3: Send(T1, GRANT_VOTE)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1: Send(T2, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Send(T1, GRANT_VOTE)</span><br><span class="line">T1: Send(T3, REQUEST_VOTE, term = 1)</span><br><span class="line">T3: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T3: Send(T1, GRANT_VOTE)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>禁止吸烟</title>
      <link href="/20240313-banned/"/>
      <url>/20240313-banned/</url>
      
        <content type="html"><![CDATA[<p><img src="IMG_20240313_012453.jpg" alt="IMG_20240313_012453"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无垠小手</title>
      <link href="/20240311-update/"/>
      <url>/20240311-update/</url>
      
        <content type="html"><![CDATA[<p>很久没有写博客了。但也不是没有任何记录，这段时间的所想我都1510地用纸笔记录下来了。等到心情闲下来我就更新到线上。对着屏幕可能并不是无话可说，但也许是觉得混合波长的光线过于聒噪。</p><p>周五花了一大笔钱买了一套正装，然后立即就约上摄影师拍了一套照片。平时不常拍照片的我在镜头的审视下尽显死角，要么是表情僵硬，要么是体态不到位。一直以来其实容貌焦虑都是有的，不过我在高中时期学到了一点成年人的从容，于是生搬硬套地带到了大学里。大部分时间里，还是那个放飞自我的人；一旦察觉到露怯的可能，我就会端着了。一开始是沉默寡言，给人一种不苟言笑的感觉；后来想起了那份从容，于是假装放松，身体后仰，眼神放空；不过这还没形成一种气质。众人评议的结论是我的各种态度会很受男生的欢迎，不过据我观察也不尽然。至少我现在这个疯批气质还是会劝退很多人。</p><p>既然要端着，那就贯彻到底。不知道从什么时候开始我就沉迷于各种各样的正装。但同时也喜欢上了打耳洞，这两项可以说是风格迥异。就最后的结果而言，我整个人身上都有了一种人格分裂的美。当然我从来没怀疑过自己人格的整体性，并且也没有那种分裂的迹象。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>于计算理论课上</title>
      <link href="/20240304-misc/"/>
      <url>/20240304-misc/</url>
      
        <content type="html"><![CDATA[<p>上周发生了非常非常多的事。到了周末最后的最后，我也不能说是爆炸，毕竟心态并无大碍，而且现实的事情并没有对我完全展开。</p><p>可能漂亮妹子说的一两句话就够我琢磨好一会儿了吧。</p><p>所有的惆怅，都有待现实的展开去消除。</p><p>“我仍然想和你一起做梦。”</p><p>话说，去问别人的戒指的寓意真的好么？这种东西相信的人会直接得出结论，不信的就完全不会管。而我是。。知道，并且自己遵守这套游戏规则，但也会怀疑别人。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IOT 认证技术</title>
      <link href="/20240112-iot/"/>
      <url>/20240112-iot/</url>
      
        <content type="html"><![CDATA[<p>我肯定需要加一行小字。只有表格的话，预览会出一点问题。</p><p>填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用</p><table><thead><tr><th>认证技术</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>指纹识别</td><td>高度准确，辨识度高。 便于使用，用户体验良好。 可以嵌入到设备的物理按键或屏幕中。</td><td>指纹信息可能被复制（尽管现代系统采用活体检测）。 需要专门的硬件支持。 部分人可能有阻碍指纹录入的情况。</td></tr><tr><td>面部识别</td><td>便于使用，用户体验良好。 无需接触设备即可进行认证。 部分系统采用3D面部扫描，提高安全性。</td><td>部分面部识别系统可能被攻击，例如使用照片欺骗。 在低光环境或夜间光线不足时可能准确度降低。 部分系统对面部变化敏感。</td></tr><tr><td>虹膜扫描</td><td>生物特征独一无二，辨识度高。 无需接触设备即可进行认证。 对于眼镜、隐形眼镜等外部因素的影响较小。</td><td>需要专门的硬件支持。 目前较为昂贵。 可能在低光环境下工作不佳。 部分用户可能对虹膜扫描有顾虑。</td></tr><tr><td>声纹识别</td><td>无需接触设备即可进行认证。 对语音特征的辨识度较高。 不受外部环境光线等条件限制。</td><td>受到环境噪音的干扰。 可能受到声音录制或模仿的攻击。 不适合在公共场合等需要保持安静的环境中使用。</td></tr><tr><td>手势识别</td><td>通过分析用户的手势，可以实现动态认证。 无需接触设备即可进行认证。 增加了用户体验的创新性。</td><td>安全性相对较低，容易被模仿。 部分用户可能不喜欢在公共场合使用手势认证。 部分系统可能对手势的识别准确度有限。</td></tr><tr><td>行为分析和生物特征融合认证</td><td>通过结合用户行为和生物特征进行认证，提高了系统的安全性。 具备持续认证的能力，不仅仅局限于静态认证。 可以适应不同使用环境。</td><td>需要复杂的算法和分析。 在初期阶段可能存在准确度和鲁棒性方面的挑战。 部分系统可能对用户行为的监测引起隐私担忧。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Raft 实验报告</title>
      <link href="/20240110-raft/"/>
      <url>/20240110-raft/</url>
      
        <content type="html"><![CDATA[<h1><a href="#fen-bu-shi-xi-tong-ke-cheng-shi-yan-bao-gao" class="header-anchor">#</a><span id="fen-bu-shi-xi-tong-ke-cheng-shi-yan-bao-gao">分布式系统课程实验报告</span></h1><p>502023330051 孙博文</p><h2><a href="#shi-xian-mu-biao" class="header-anchor">#</a><span id="shi-xian-mu-biao">实现目标</span></h2><p>基于所给go语言框架实现了一个简单的 Raft 协议，包括选举、复制。最终通过了如下的测试(包含 Part1 和 Part2 的全部测试)：</p><img src="image-20240110214418292.png" alt="image-20240110214418292" style="zoom:50%;"><h2><a href="#fen-xi-yu-she-ji" class="header-anchor">#</a><span id="fen-xi-yu-she-ji">分析与设计</span></h2><p>定义角色</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LEADER = <span class="number">-1</span></span><br><span class="line">FOLLOWER = <span class="number">-2</span></span><br><span class="line">CANDIDATE = <span class="number">-3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>并设置时间相关变量</p><ul><li>选举超时间隔 100-500ms</li><li>心跳间隔100ms</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ElectionTOMin = <span class="number">100</span></span><br><span class="line">ElectionTOMax = <span class="number">500</span></span><br><span class="line">HBInterval = <span class="number">100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>定义日志项</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Term    <span class="type">int</span></span><br><span class="line">Index   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Raft结构体定义</p><p>为了实现选举，心跳机制和日志追加等内容，还引入了一些其他字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log    []Entry     <span class="comment">// 日志</span></span><br><span class="line">lastApplied   <span class="type">int</span>    <span class="comment">// 已应用</span></span><br><span class="line">role           <span class="type">int</span>         <span class="comment">// 角色</span></span><br><span class="line">leaderID       <span class="type">int</span>  </span><br><span class="line">electionTimer  *time.Timer <span class="comment">// 选举超时</span></span><br><span class="line">heartBeatTimer *time.Timer <span class="comment">// 心跳间隔</span></span><br><span class="line">applyCh        <span class="keyword">chan</span> ApplyMsg <span class="comment">// 日志应用</span></span><br></pre></td></tr></table></figure><h4><a href="#rpc-xiang-guan" class="header-anchor">#</a><span id="rpc-xiang-guan">RPC相关</span></h4><p>RequestVote 和 AppendEntries, 和论文基本一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="type">int</span></span><br><span class="line">CandidatedId <span class="type">int</span></span><br><span class="line">LastLogIndex <span class="type">int</span></span><br><span class="line">LastLogTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term        <span class="type">int</span> </span><br><span class="line">VoteGranted <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="type">int</span>       </span><br><span class="line">LeaderId     <span class="type">int</span>       </span><br><span class="line">PrevLogIndex <span class="type">int</span>       </span><br><span class="line">PrevLogTerm  <span class="type">int</span>       </span><br><span class="line">Entries      []Entry</span><br><span class="line">LeaderCommit <span class="type">int</span>       </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term      <span class="type">int</span> </span><br><span class="line">Success   <span class="type">bool</span></span><br><span class="line">NextIndex <span class="type">int</span>  <span class="comment">// 之后应用的Log索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a href="#xie-yi-shi-xian" class="header-anchor">#</a><span id="xie-yi-shi-xian">协议实现</span></h2><p>节点启动后, 将创建3个goroutine:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go rf.LeaderElection()</span><br><span class="line">go rf.HeartBeat()</span><br><span class="line">go rf.LogApply()</span><br></pre></td></tr></table></figure><p>分别对应选举, 心跳, 与日志应用</p><h3><a href="#jie-dian-xuan-ju" class="header-anchor">#</a><span id="jie-dian-xuan-ju">节点选举</span></h3><p>首先节点需要在三个角色中切换. 因此设计了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> goLeader()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> goCandidate()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> goFollower(term <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>其中转换到 Follower 需要对应的任期.</p><p>节点启动后,都初始化为 Follower, 并设置选举超时. 进入 LeaderElection 协程后, 等待一个随机的选举超时, 如果自身是 Follower 或 Candidate, 则 <code>goCandidate()</code>, 任期 + 1, 发起选举, 给自己投一票, 然后发送 <code>RequestVote</code>RPC. 发送时即接收回复, 收到多数派承认则成为 Leader.</p><h3><a href="#xin-tiao" class="header-anchor">#</a><span id="xin-tiao">心跳</span></h3><p>对于 Leader, 等待心跳间隔后发送一个 <code>AppendEntry</code>, 附加上 nextIndex 指示的一部分 Log, 发给所有的 Follower 即可.</p><h3><a href="#ri-zhi-fu-zhi" class="header-anchor">#</a><span id="ri-zhi-fu-zhi">日志复制</span></h3><p>发送者发送心跳后, 会受到回复.</p><p>如果 reply.Term &gt; currentTerm, 此时发送者已经不是 Leader, 无需响应;</p><p>如果 reply 成功, 则更新对应节点的 matchIndex 等信息, 并尝试更新 commitIndex;</p><p>如果 reply 失败, 则可能后退任期进行重试.</p><p>而接收者的行为可以概括为:</p><ul><li>拒绝 Term 小于自身任期的请求</li><li>lastLogIndex 小于心跳包的 PrevLogIndex, 说明节点日志陈旧, 通过回复 Leader 一个 NextIndex 来指示下次的发送</li><li>除此之外, 覆盖原有条目</li><li>接收 LeaderCommit, 更新 commitIndex</li></ul><h3><a href="#ri-zhi-ying-yong" class="header-anchor">#</a><span id="ri-zhi-ying-yong">日志应用</span></h3><p>通过 LogApply() 中的循环, 不断更新最新被应用的条目, 直到不超过 commitIndex 的条目.</p><h2><a href="#shi-yan-zong-jie" class="header-anchor">#</a><span id="shi-yan-zong-jie">实验总结</span></h2><p>Raft 相比于 Paxos 已经较为容易理解，但是在实现过程中，依然难以完美。主要问题出现在并发程序上。一共三个节点，加上每个节点有3个&#x2F;实际是4个协程，各种打印信息交织在一起，很难分析出问题的原因。</p><img src="image-20240110213025465.png" alt="image-20240110213025465" style="zoom: 50%;"><p>▲没有大写RPC相关结构体的字段浪费了大量时间，直到看到了这段提示</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自由</title>
      <link href="/20240102-free/"/>
      <url>/20240102-free/</url>
      
        <content type="html"><![CDATA[<p>自由是个倒装。它的本意就是「由自」，一切认识与实践，皆由自我而开辟出来。这才是最具解放性的：不预设一个超越性的维度，不需要任何高级的存在为自己背书，一切矛盾都是我和我自己的矛盾。对于世界而言，一切的矛盾就是世界和世界它自己的矛盾。</p><p>对于差异性的抹平要比差异本身更加难以为继。随着温度下降，四大基本作用一个一个地分离出来，不同的粒子在此时创造出来。从来都是从一致的东西当中产生断裂，诞生差异，扬弃了原先的那个整全，才是世界的运动方向。不是东风压了西风，就是西风压了东风。</p><p>只是没人有勇气接受这样的「自由」。没有人敢「自由」。这需要主体价值观的「惊险一跃」：先是感受到绝对的自由的无限性；然而这无限性归根结底是单一的：除了「不存在不存在」以外，什么规定也没有做出。一贯的、平整的无限性，对于人类的理智而言是无法把握的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK 第?次汇报前准备</title>
      <link href="/20231225-dmck/"/>
      <url>/20231225-dmck/</url>
      
        <content type="html"><![CDATA[<p>总的来说，要做的是这几件事：</p><p>1、尽量把带malloc，带page变动的恢复做出来</p><p>2、完善状态恢复的实现</p><p>3、做一个交互式的控制台</p><p>4、模拟网络相关系统调用</p><p>5、环境部分的代码</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>审美和恐惧</title>
      <link href="/20231220-utsukushisa/"/>
      <url>/20231220-utsukushisa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>感觉应该是从哪里抄的。我没有自己思考过这些东西的记忆。</p></blockquote><p>人们以为自己可以审美（忍受）恐惧就会没有恐惧了，这时候显在的的确就是审美。</p><p>处于恐惧之中的主体会享乐来试图缓解恐惧，想要彻底消灭恐惧。但他的享乐冲动会越来越多。他看的或做的事情可能越来越危险，暴力，血腥。显然，他开始对恐惧上瘾。对恐惧的口味会越来越重。实在一点，再实在一点，因为这还不够把自身的恐惧否定掉。</p><p>审美主体想要摆脱自恋，以为去否定自己，不自我赞扬，不肯定自己多么优秀，就是不自恋，但其却迷恋上了一个悲剧性的想象自我。他爱上了没人爱的自己，这是他的自我认同。</p><p>审美主体主观上可能不会觉得他会因为这些否定而痛苦，但客观上却是痛苦的。我这里所说的客观就是主体所不知道的知识。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>行动力？</title>
      <link href="/20231214-tatakau/"/>
      <url>/20231214-tatakau/</url>
      
        <content type="html"><![CDATA[<p>该如何言说我的当下？</p><p>“我千万不能太陶醉在这种虚假的快感里了,周末必须放松一下,认清我的人生旨趣必须是打鱼摸虾耽误庄稼,吃喝嫖赌抽烟烫头。”</p><p>我的行动力有点丧失了。或者也不是。至少在打孔这件事上我做到了完全果断。这些学业上的事，归根结底是我自己不太想做。</p><p>但总是要混到这个该死的文凭的。想想时间还剩一周，却有这么多事要做。我的内心缓缓升起两个字：歇逼。</p><p>不能正经做事，似乎是这一整个学期的情况。从什么时候开始的呢？已经很难去回忆了。</p><p>还有一会儿天就亮了，我希望还是在8点之前结束战斗。</p><p>明天，呃，如果结束得早，就该回去睡觉。</p><p>下午上课之后，来实验室写编译原理。周末尽量留多点时间来处理组会…与周一、二、三…</p><p>但是各种进度为0，只能疯狂一点了。</p><p>今天是周五。现在是6:09</p><p>我知道不能耽搁在写东西缓解焦虑上，但显然是很焦虑，几乎控制不了了。恐惧催人享乐，陷入了一种循环。</p><p>需要一个地方来安放我的心。但事实上，做事是安放焦虑的唯一方法，但我显然</p><p>做不了事。</p><p>其实我并不是这样的人。我肯定是很有动力去做的，且有能力有意愿。但事情就因为各种奇怪的原因延宕了。“奇怪的想法”。</p><p>好了，周末是最后的冲刺阶段，没有链子可以掉了。</p><p>所谓“绝境”的意义，我不止一次地领教。现在是真到了：没有一次比这更加 dangling （录者语：没事，以后有更逆天的）</p><p>我并没有那个勇气去退学。哈哈哈哈。。。</p><p>但是，其实我肯定也不是想放弃。唯一想摆脱的是当前这种状态，显然，要以比正确还正确地姿态来面对，那就是——竭尽全力跳出循环。</p><p>这也容易。不是对自己“狠一点”，因为这里面还有回旋的余地。而现实是苍白的、直接的、不容商量的、没有回旋余地的。不能幻想一种界限&#x2F;界定，超过这个标准就算尽力，而是说，尽力是一件发生的事，而不是对已经产生的结果的描述。因为这种事后的描述一定是带有粉饰的。</p><p>我们在时候决不需要一个评价“尽力了”如何。事实上是不可评价的。事情的发生并不需要主观的量度。</p><p>因而不要“狠一点”，而要领悟“绝对”。</p><p>我“绝对”要做到，而不是尽力做。不做到，就性命攸关。</p><p>这样看，就是达到一种强迫症式的人格。我必然能，我必定要，在自己的面前表演那个高度社会化的人。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>酒神精神</title>
      <link href="/20231206-dionysus/"/>
      <url>/20231206-dionysus/</url>
      
        <content type="html"><![CDATA[<p>无论如何追问意义，最后都会得到沉默的回应。生命的无意义仅在于不存在客观的终极解释。在此基础上自我产生悲剧式的解释，因为这个原处缺失被发现。</p><p>酒神的内核在于，人在悲剧中的兼任。对痛苦的对抗时展现着生命的。</p><p>在于与痛苦对抗的生存姿态，从中感受到生命本体的欢乐，使微观视角下的悲剧称为宏观的戏剧。</p><p>个体视角局限下的悲剧成为一般生命直观下的喜剧。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Piecing</title>
      <link href="/20231204-piecing/"/>
      <url>/20231204-piecing/</url>
      
        <content type="html"><![CDATA[<p> 小睡了 1.5 小时。起来还是看丁主任的比赛，在追到 7:7 之后，基本上就直接失去还手之力了。火箭看起来就像是在放水一样。（2023英锦赛）</p><p>早上比赛结束后本来打算小睡一会儿，然后下床抽了两支烟。要我说，这第二支实在是有点多余。一根已经足够进入状态。两根除了感觉很冷意外也就没什么了。</p><p>之后就听到升国旗了。心一横就直接起了床，想想也是，没什么好睡的。课肯定是盖上了，顶多睡到9点半，还得赶着起来洗澡。</p><p>等等。我宿舍冰箱门关了吗？。。。要写一个checklist放在宿舍门口了。</p><p>前几天我随手发了一句 “我不是女同”。这本来就是先射箭再画靶，其实根本没人想到这个，是我自己唐突地想到了这样一句话。而实际的意思是：我艹，原来我是女同。。。</p><p>刚才又在想另一个问题。如果在以后可能会有（大概率不会有）的高中同学会上，那我最能拿得出手的是什么东西？我感觉右耳大概最后会有 8-10 个耳洞吧（2024.10.8 录入语：现在刚好 8 个）。</p><p>其实就是这样一个问题：怎么向所有人解释我的钛合金右耳？</p><p>“你的耳朵是怎么回事？”“我去打了几次耳洞”</p><p>“你怎么打这么多？”“我自己挺喜欢这个的”</p><p>就这样，大部分的对话就应该终止于此。并没有人会在意这个，大部分人应该是不太瞧得上这种风格。</p><p>这是一种什么感觉：从同一个班出来，大家各奔东西。一些人去了豪华的大都市，享受上流生活；还有那么几个在底层鬼混。。。我的心理设定就把自己放在了这个低位。如果说这件事有任何值得自豪的，无非是忍受穿孔时的疼痛，以及毫不留情地表达着对于世俗价值观的蔑视。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一种自动发生的界说</title>
      <link href="/20231130-automata/"/>
      <url>/20231130-automata/</url>
      
        <content type="html"><![CDATA[<p>也不知道日子要什么时候才能恢复正常。可能已经有半个月没有正常睡过觉了，并且也有在抽烟。</p><p>谁能想到会发生什么呢？今年五月份是玩得比较疯的时候。即使这样也不如当下放纵。这并不是说抽烟时不可接受的、是令人感到耻辱、羞愧的。</p><p>在压抑的时候，一个人往往更加控制不住自己。放纵的时候，确实全身心地贯注于当下的欲望，而不被别的事情所沾染。</p><p>显式地纵情，比压抑中的“偷跑”的破坏力明显是更小的。</p><p>这里我并没有做什么价值判断，而只是描述两种模式对于“稳态”的影响。好比T人常常有情感的爆发，而F人是将其藏匿于与惯常无异的行动当中。</p><p>如果要问我Prefer哪一种，我只能说无论何时都要接受当下的自我；但更重要的是承认变化的Automatic。自动发生的一种本性，比起自我，非我更显现出一个随时变化着的意向。</p><p>随心而并非随性，自为而并非自在。</p><p>“酒神精神”的肯定也绝不是僵死的，而是运（滑）动中的。</p><p>所以主要是感受到什么而写了这些？抽烟比起喝酒的接受程度在当下是要低许多的。然而我是否应该考虑这个问题？对此提出疑问主要还是考虑到，作为一个习惯性&gt;成瘾性的行为，对身体的损害时较大的。抽烟它本身，作为习惯，甚至不如酒精容易控制。我不知道烟与酒哪一个更伤身，但自身的接受度可以说明一切。我不可能不喝酒，但是消除烟的影响是看似轻而易举的。因为这件事情并没有预想中的快感，也没有预想中的成瘾性。我日常就像个瘾君子一样精神萎靡。从开始抽烟之前就有这种表现了。因而是自己就取消了对这种“精神影响”的信仰。</p><p>所以，戒烟的实质是一种精神胜利法，而且仅仅能以精神胜利法的方式实现。只要你蔑视它作为精神药物的“必要性”，就很容易做到。</p><p>戒烟失败又怎么办？那就是不要把失败想象成一种奇耻大辱。拍拍屁股接着来又能怎么样？不能让“大他者”来监视你的过程并且在失败的时候嘲笑你（嘲笑自己）。</p><p>而我抽烟的理由，很不幸；很万幸。没有任何理由，只是突然想。这表明在背后驱动着的根据实际上只是一种拟制。</p><p>没什么想说的了。现在在想有没有可能把手写的只言片语写成博客？应该是没什么时间了。至少把纸面上的东西都收集起来吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>思政课作业</title>
      <link href="/20231127-politics/"/>
      <url>/20231127-politics/</url>
      
        <content type="html"><![CDATA[<p>502023330051 孙博文 计算机科学与技术系 计算机科学与技术专业</p><h2 id="我是谁，我要做什么"><a href="#我是谁，我要做什么" class="headerlink" title="我是谁，我要做什么"></a><center>我是谁，我要做什么</center></h2><p>​我是孙博文，来自计算机科学与技术专业。我出生于一个无产阶级家庭：父亲是建筑工人，母亲是保洁工人。从小家教相对严格，加上在初高中时期都遇上了欣赏我的老师，使得我拥有努力上进的部分先决条件。</p><p>​作为市民社会的成员，我的未来规划无非是利用所学知识成为异化的生产关系中被异化的劳动者。异化在劳动所在之处，而人不能不劳动，就像人不能不吃饭。但低头做事之余，依然要仰望星空。我想要把哲学的思辨与实践作为我终身热心的事业。</p><p>​人生的意义无非在于认识世界与改造世界。认识是将自然的规律完全精神化，化为直观和思维的规律，整个自然借助意识将自己溶化为一种理智的理论（谢林. 先验唯心论体系）。而相对应的实践是将思维中的概念实现为自然世界中的实在。这两种相会合的活动是自然的必然的倾向，是人类自社会产生以来都坚持着的主题。</p><p>​这样谈论人生意义似乎显得太大了，一个人能够产生的影响是非常有限的。但我们能够说，因为这一影响微不足道因而它就是没有必要的吗？我认为不是。这也反映出当下的一种焦虑症，对应一种虚无主义的世界观。很多人都抛弃了实践当中最细微的那些，仿佛它们不配被称为实践；同时又对于翻天覆地的改变抱有幻想。</p><p>​这就不得不引到我对当前社会发展所抱有的最大困惑：青年人的思想工作到底应该如何开展。</p><p>​当下的青年有一种小资产阶级化的倾向。当然，想要“小资产阶级化”的无产阶级还是无产阶级。许多人的愿望竟然是不劳动就能获得幸福的生活。在当前的生产力与生产关系下，实现这一目标的唯一途径就是实现他们自己从无产阶级到小资产阶级的历史反向运动。这一反向运动，对于整个无产阶级是必然失败的。但我们竟不能够严肃地批判，因为当前的形势毕竟没有发展成剧烈的“你死我活的斗争”。不严肃的、不清醒的想法毕竟还不至于使人变得走投无路。</p><p>​同时，当下的青年似乎也没有自信力。形势并没有到令人沮丧的地步，以至于中年人们显得比青年人有信心。更具体地来说，青年的自信心有一种分化：一派抱有适当的信心，而另一派则非常沮丧，甚至在南大这样的高等学府，这种信心的丧失更甚：他们都认为自己以后找不到工作。</p><p>​因而，我也希望将哲学作为精神分析学的引子，以期找到其原因与解决办法。</p><h2 id="思政课要为学生先"><a href="#思政课要为学生先" class="headerlink" title="思政课要为学生先"></a><center>思政课要为学生先</center></h2><p>​学生们需要一个子弹头、钢笔尖式的人物。</p><p>​而这样的一个人物，所能起的最大作用，就是给所有人带来理论上的理性。教师这一身份最合适。</p><p>​二十出头的年纪是大多数学生对于政治话题最敏感的时期，就算对政治再不感兴趣的人也会形成他自己的观点。而同学们在上面讲一些东西并不会引发更多的认同。毕竟大家在台上讲得内容和他们平时关注的内容相差甚远。作为教师和学生的距离虽然比较远，但老师毕竟也有做学生的时期。所以学生的心理是好推断的。</p><p>​我们提倡自由和包容；时代的主题还是和平与发展。这些基调不是大学的思政课程能够影响的，因而我们不可能讨论太尖锐的话题，同时也就失去了在这些话题上进行教育的可能。不过，即使我们一点也不能奢求所有同学都对社会现实的问题都抱有相同的立场，但是至少要抱有对于他所处的社会经济地位中合理的立场。这就需要一些分析方法的介入：阶级分析和意识形态分析。 </p><p>​介绍这些分析方法，是有一些积极作用的。首先它是一种正确的独立思考的工具。很多时候我们对自诩“独立思考”的人感到头疼，都是因为他在本质上仍然是道听途说，拾人牙慧，把别人具有感染力的观点不加以批判地使用。而这样的人其实在某种程度上是“驳不倒的”，因为他之所以从众多看法中采取了这个或那个看法，其来源多半是基于他的某些信仰。而一些有偏差的信仰，往往又是他并不能把我到自己在切身利益中的真正立场。</p><p>​其次它能够给予朴素的情感与观点一些切实的信心。总是说“劝同志们读一点书，免得受知识分子的骗”。朴素的想法最容易迷茫。它从“人的感受”的质料中最直接地产生出来，也最容易受到各种方面的批判。有了分析的方法来应证这些观点，我们就容易有理论上的自信，就不容易“受知识分子的骗”了。</p><p>​在积极作用之外，还有一些“消极”的作用。这里的消极是说，虽然它不能够带来正面的认识增加，但至少告诉我们哪些看法是不可取的。</p><p>​这些完全客观的理论工具一经被把握，便成为青年学生对抗意识形态渗透的最好工具，而不需要再多言其他的。信念动摇的来源在于没有信心，而喜欢理性的人的特性就是喜欢从理论出发推出当前的处境。如果能够运用分析的工具确定无疑地判断当下的形势，疑虑也就自然地消解了。</p><h2 id="同一和综合的统一——谈谈对辩证法的认识"><a href="#同一和综合的统一——谈谈对辩证法的认识" class="headerlink" title="同一和综合的统一——谈谈对辩证法的认识"></a><center>同一和综合的统一——谈谈对辩证法的认识</center></h2><h6 id="毛泽东-在延安文艺座谈会上的讲话、实践论、矛盾论-读后感"><a href="#毛泽东-在延安文艺座谈会上的讲话、实践论、矛盾论-读后感" class="headerlink" title="毛泽东 在延安文艺座谈会上的讲话、实践论、矛盾论 读后感"></a><center>毛泽东 在延安文艺座谈会上的讲话、实践论、矛盾论 读后感</center></h6><p>​“唯心论者是强调动机否认效果的，机械唯物论者是强调效果否认动机的，我们和这两者相反，我们是辩证唯物主义的动机和效果的统一论者…………检验一个作家的主观愿望即其动机是否正确，是否善良，不是看他的宣言，而是看他的行为（主要是作品）在社会大众中产生的效果。”（毛泽东. 在延安文艺座谈会上的讲话，1942）</p><p>​从康德的范畴表开始，到黑格尔时已经自觉地使用“正反合”作为辩证法的形式了。提出一对截然相反的论题A和非A，在这里辩证法的答案是：A又非A，因为A是非A。</p><p>​我们应该如何理解这样的说法？ 形式逻辑的矛盾律与同一律绝对不允许辩证法如此这般的操作。但辩证法的实质是什么？</p><p>​“列宁说，‘就本来的意义讲，辩证法是研究对象的本质自身中的矛盾’”（毛泽东. 矛盾论，1937）。我们在使用形式逻辑的时候，仅仅是在形式上使用它。我们形式地说A是A的时候，总是不管A到底是什么的，就算A本身是不存在的、不正确的，我们依然说“A是A”是对的，因为形式逻辑只管抽离了其中的对象而言的形式上的正确性。而辩证法是“研究对象本质”的。对于辩证法而言，不管是A还是非A，它里面到底装了什么还是要打问号的。所以它超越形式上的逻辑，而成为一种内容的逻辑。</p><p>​对于辩证法而言，它极力要达到的终点是弥合、修补、消除矛盾，把所有的东西都统筹在一起。对于两个不相容的概念之间的连接，我们称之为综合；而从一个概念中分析出其中既有的东西叫做分析。“同一”则是分析的极限：从一个东西分析出它自己，一步也没有进。辩证法做的就是这样的一件事：对于矛盾的双方既综合又同一。</p><p>回到一开始引用的例子。首先提出，</p><p>正题：强调动机否认效果</p><p>反题：强调效果否认动机</p><p>合题：效果就是动机的体现</p><p>​这个合题是如何达到的？在辩证法里，“合题”不如说是“裂题”。辩证法不是把黑的白的放到一起搅合成灰的，而是看到问题本身的裂隙；看到被讨论的概念其自身的矛盾；看到概念超出形式规定的“内容”；看到问题本身所分裂出来的那个“更值得被问的问题”。</p><p>​这里的正题和反题一列出来，我们从形式上看，它们是水火不容的。但是这种“水火不容”当中暗含的预设是，动机和效果一点关系都没有。那么我们立马就要反应过来，动机和效果果真是没有一点关系的吗？动机是我们的认识，效果是我们的实践，我们要做到主观和客观、理论和实践、知和行的具体的历史的统一（毛泽东. 实践论，1937）， 因而，只有在实践中达到了预想的结果，人的认识才被证实了。换言之，只有文艺工作达到了预期的效果，才能说明文艺工作者的动机是清楚而没有偏差的。</p><p>​这样，矛盾的双方就被我们通过对双方概念的实际分析，综合而同一地统一起来了。可以这样说：辩证法就是对原问题的扬弃。</p><h2 id="阶级斗争的形式正在起变化——共产党宣言读后感"><a href="#阶级斗争的形式正在起变化——共产党宣言读后感" class="headerlink" title="阶级斗争的形式正在起变化——共产党宣言读后感"></a><center>阶级斗争的形式正在起变化——共产党宣言读后感</center></h2><p>​共产党宣言诞生的185年后，阶级斗争除了原来的形式之外，已经产生了新的形式。而当今的世界在普遍进入资本主义社会形态之后，俨然成为广大无产阶级和资产阶级最终的决斗场。</p><p>​但是通过广泛的矛盾转移的手段，当今阶级斗争的烈度已经达到一种低谷。而伴随着消费主义，出现的是资本主义新的现代统治形式。通过用景观社会取代商品社会，通过一种甜蜜的意识形态控制，消解主体的反抗性和批判性。在没有“你死我活”的斗争的情况下，人们是容易被这样的一种景观遮蔽的。人们只能单向度地盲从并丧失对本真的生活的渴望和要求。</p><p>​现代资本主义，同样生产穷人。这部分穷人必须是相对而言的，而不是赤贫，作为社会阶层的底层结构出现。与美轮美奂的景观社会不同，它们是被资本主义社会生产出来充当被比较对象的，其作用是为另外一些人提供比较而言的满足感。</p><p>​在一般的视角下，无产阶级是物质财富的生产者，资产阶级是消费者；而在辩证法的视角下，资产阶级俨然也是生产者：他们为社会生产一种上层的奢华的景观，和底层的悲惨的景观，供无产阶级和小资产阶级消费，实现对新的资产阶级的再生产，以维持这个体系。</p><p>​就更不用论证艺术、教育等意识形态宰制和高福利、政治体制等政治经济手段所带来的影响了。其中就以意识形态的影响最为深远，包括但不限于人性论、资产阶级的理论人道主义。在这些手段的影响下，有的人不相信共产主义；有的人认为自己能够跃升为小资产阶级或资产阶级。</p><p>​这与共产党宣言创作时期的背景已经相去甚远。但我们依然坚持马克思主义，依然不忘初心。因为我们能够认识到，这些转变其实是历史发展的内在症结，资本主义社会中诞生的一切都是资本主义自身的特殊性质带来的，正如资本主义诞生了无产阶级，作为扬弃资本主义自身的力量。所以我们并不惧怕这种斗争形式的变化，而是接受历史的必然性，把握这种变化，然后诞生新的理论与新的实践。这就是马克思主义的本来面貌：它不是在固定僵死的历史背景下的认识以及斗争方法，也不是给出一个放之四海而皆准的某种答案，而是告诉我们如何做突破历史的局限性的尝试，用普遍又特殊的分析方法分析具体的情景。</p><p>​马克思主义哲学的核心就在于，找到人自身所蕴含的革命性和解放性的力量。所以，与黑格尔将认识和实践作为绝对精神运动中的阶段相比，马克思主义哲学将实践抬到了最高的位置，这标志着人的直接现实的能动性被提到了最高的位置，从康德提“人为自然界立法”以来，人的实践理性在这里获得了最高的尊严。</p><p>​因此，我们要不忘初心，并且与时俱进，了解到当前世界资本主义的新的发展，斗争的新的形式与形势。并且发挥自己的能动性，去进行改造世界的实践。</p><p>​作为辩证唯物主义者，要时时感受到自己的新生。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Libido</title>
      <link href="/20231125-libido/"/>
      <url>/20231125-libido/</url>
      
        <content type="html"><![CDATA[<p> 什么是性欲？</p><p>一个只会对我造成烦扰的东西出现在视野中。</p><p>当我看到美丽且露骨的内容时，这一欲望即被激发出来。然而其满足却不仅仅是自身可以完成的。</p><p>拉康将做爱比作两个人各自的、以对方的身体为工具的手淫。但差错就出现在“有一个客体”那里。或者说是一种差距。无论字面上的分析再令人绝望、再透彻、再切中要害。</p><p>我们可以看出实际上上述的比喻只是在表达“性关系不可能”这一命题。从孤立的主体视角看自然是如此。然而我并不可能因此而批判精神分析为一种孤立的片面的学说，即使这多半是出自一种信念。因而要解读其真意；或是说探究性爱的真正内容，只能认为此处所采用的言辞仅仅是一种临时的阐明之用。</p><p>手淫和做爱的确是又差异的。这一差异不在别处，而正在于完成这一目的的手段、客体，是真实的人（而非工具化的人）。</p><p>而这一个人的作用在于何处？一则实在的感官的体验，二是意识的想象作用。在手淫中，我们尚且可以作有限而贫乏的想象。三是反馈，或是说，建立起想象的“协同性”。</p><p>所以要采用分析的方法，考察做爱之所以为做爱，其中不可缺少的部分是什么。换个说法即为，去掉一些要素，直到剩下某些要素，但凡再去掉其中之一，便不可想象此种性爱能够作为一种性爱。正如直观不可能以没有广延的形式而称为一种直观。</p><p>答案自然是那个存在于想象中的协同。正如性伴侣的不应便得性爱索然无味。失去交互的作用，人根本无法称其自己是处于某种性爱当中。通过当下存在的“另一个”来确证我自己处于这样的享乐结构当中。</p><p>“给点反应行不行”。大约如此。人仿佛能感受得到对方的欲望，尽管它不一定是对方所想的那样，这就是想象的作用了。</p><p>故精神分析的批判重点实则是表达“想象的协同性”的荒谬。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>timing</title>
      <link href="/20231116-timing/"/>
      <url>/20231116-timing/</url>
      
        <content type="html"><![CDATA[<p>可喜可贺，作业都交上了</p><p>从现在开始就是组会时间。。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关关难过关关过</title>
      <link href="/20231115-hurdle/"/>
      <url>/20231115-hurdle/</url>
      
        <content type="html"><![CDATA[<p>尽力做好，不论结果。</p><p>总是要熬完的，硬着头皮也得上。</p><p>研究生有几个人从没失意过呢？那些博士生的心理素质也强多了。也不是。他们面对更加严重的问题也能走下去。</p><p>想想那些每天都和导师交锋的人，不也都活得好好的。黄开乐不也很厉害，所以不要一次的状况比较危急就大惊小怪。</p><p>关关难过关关过；桥到船头自然直。</p><p>讲什么内容呢？进展不多，有了解其他工作。</p><p>1、相关工作：CrystalBall MaceMC MODIST DEMETER。对比，摘出可用的。由此找到这份工作的位置。</p><p>2、被测系统、协议选型</p><p>上次找了一个C实现。我们的优点体现在 ①有状态②非侵入，不修改③尽可能的通用化</p><p>3、系统设计进展（Coding）</p><p>时间的生成 - 根据执行的进程，与 Choose().  Stateless？之后就都是工程问题。</p><p>4、拿出设计的文档</p><p>5、代码暂未释出 - 先拿出来，放一个仓库。之后再来跟进</p><p>另外是，关于 Time 的产生，应该是一个重点。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组会前时间表</title>
      <link href="/20231114-timing/"/>
      <url>/20231114-timing/</url>
      
        <content type="html"><![CDATA[<p>要点：</p><ul><li>分布式系统作业 - 还挺简单的 - 2h</li><li>软件分析作业 - 今晚搞定</li><li>程序设计语言的形式语义作业 - 还挺简单的 - 2h</li><li>（16日）ISER proposal - 组会开完之后马不停蹄</li><li>组会</li></ul><p>11.14 </p><p>19-24 软分</p><p>11.15</p><p>0-6 休息</p><p>6-8 组会</p><p>8-10 SEM</p><p>10-12 dissys</p><p>12-13 休息</p><p>13-24 组会</p><p>11.16</p><p>0-7 休息</p><p>7-13 组会</p><p>13-14 休息</p><p>14-16组会</p><p>16-24 iser</p><p>总计：20小时组会准备 </p><p>8 + 2 + 2 + 5</p><p>每天都有7小时休息</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK 中期报告草稿</title>
      <link href="/20231107-dmckMID/"/>
      <url>/20231107-dmckMID/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><p>科研选题：基于 ptrace 实现的适用于分布式系统测试的操控执行框架</p><h3 id="1-1-研究背景"><a href="#1-1-研究背景" class="headerlink" title="1.1 研究背景"></a>1.1 研究背景</h3><p>分布式系统运行的过程中往往会出现大量不确定性的因素。在多个节点上运行的进程协同工作，会产生通信、调度上的偶然变化，构造分布式系统的时候往往无法穷举这些情况，程序的异常处理不完善导致系统潜在的崩溃可能。并且在错误发生之后，引发问题的执行路径通常难以还原，导致最终定位不到问题所在。</p><p>面对这一问题，通常的做法是模型检测。使用 TLA+ 等形式化验证工具对分布式算法进行建模。然而，面对真实而复杂的系统实现，强行使用形式化的方法进行建模则面临着困难的约简：约简过多，则与实际系统偏差越远；约简越少，则执行的分支越多，容易出现“状态爆炸”的问题。</p><p>为了解决上述问题，Mandanlal 等人提出了 CMC，一个用于直接对代码进行模型检测的执行框架。在工作中，他们对一个 ad-hoc 网络协议 AODV 的三种实现进行了模型检测。Junfeng Yang 等人提出了 eXplode 对文件系统进行穷举式的测试。后提出了一个在 Windows 上对实现级的分布式系统进行透明的模型检验的 MoDist 框架。类似的工作还有 MaceMC、CristalBall 等。</p><h3 id="1-2-ptrace-简介"><a href="#1-2-ptrace-简介" class="headerlink" title="1.2 ptrace 简介"></a>1.2 ptrace 简介</h3><p>ptrace 是 Linux 内核提供的进程跟踪的系统调用，它允许父进程检查和替换子进程的内核镜像（包括寄存器）的值。</p><p>子进程调用 ptrace(PTRACE_TRACEME) 且父进程调用 ptrace(PTRACE_SEIZE) 后，父进程即可对子进程的执行进行控制：在子进程进行系统调用前或系统调用返回后停止；获取子进程系统调用信息；读写子进程内存和寄存器的值；模拟系统调用执行等。通过几种基本操作，能够实现程序的确定性执行。</p><h2 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2 系统设计"></a>2 系统设计</h2><p>单线程程序从一个特定的状态出发，其状态转换分为两类。一是进行系统调用，对操作系统对象进行创建、删除、读写；二是系统调用以外的运算逻辑。对于第二类而言，其代表的状态转换是确定性的，即给定进程状态和代码，执行代码达到的目标状态是唯一确定的；对于第一类而言，则状态转换还要取决于操作系统对象的状态。比如同样执行 read() 系统调用，如果文件的内容正同时被其他进程改变，则产生的结果不确定。</p><p>在多线程程序以及分布式系统中，由于其由多个独立执行的程序组成，因而其执行路径还受到各执行流之间的调度的影响。 </p><p>因此，为了对分布式系统进行模型检验，首先需要穷尽系统调用的可能结果；同时穷尽系统所有节点的各操作执行的先后顺序。</p><h3 id="2-1-整体框架"><a href="#2-1-整体框架" class="headerlink" title="2.1 整体框架"></a>2.1 整体框架</h3><p>对于 n 个节点的分布式系统，我们用 n + 1 个进程进行整个系统的操控执行：</p><ul><li>一个 tracer 进程，用以控制所有的进程</li><li>n 个 tracee 节点进程，即受控运行的分布式系统</li></ul><p>以 3 个节点为例，对于一个运行中的分布式系统，其状态为 $S&#x3D; &lt;Env, Node1, Node2, Node3&gt;$，其中：</p><p>$Node$N$ 代表节点的状态，包括节点的堆、栈、寄存器。</p><p>$Env$ 代表节点之外的环境，包括被节点使用的操作系统对象的状态，如网络消息，系统时间，打开的文件等。</p><p>在分布式系统执行的过程中，能够引发状态不确定性的分歧操作包括：消息的先后顺序，消息是否到达，以及消息等待是否超时。</p><p>tracer 进程每次从一个状态 $S$ 开始控制其中一个节点，运行到下一个分歧操作前，即：消息发送前，消息接受前，以及请求系统时间之前。之后对于每一个节点，都由 Choose() 函数根据运行时的上下文决定下一个分歧操作可能的状态转换集合$Transfer$，且对于每一种可能性 $t \in Transfer$，生成如下的“转换边”：  $(Node$N.t(), &lt;Env, Node1, Node2, Node3)&gt;)$ </p><p>它表示，状态的下一次转换从状态四元组出发，通过 $Node$N$ 执行 $p()$ 所代表的转换可达到下一个状态：</p><p>$(Node$1.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’, Node1’, Node2, Node3)&gt;$ </p><p>$(Node$2.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’, Node1, Node2’, Node3)&gt;$ </p><p>$(Node$3.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’’, Node1, Node2, Node3’)&gt;$ </p><p>总的工作流程是：设置一个状态转换边的队列；每一次从中取出一条边并执行达到新的状态，在新的状态的基础上，生成新的转换边并入队。</p><p>对于 DMCK 的实现有两种，一种是 stateful，即通过保存和恢复节点的内存、寄存器等信息来重现状态；一种是 stateless，通过重放记录的执行路径来重现状态。我们的工作主要是 stateful 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S = &lt;Env, Node1, Node2, Node3&gt;</span><br><span class="line"></span><br><span class="line">q.add(Edge(skip, S))</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">    edge = q.deque()</span><br><span class="line">    S&#x27; = edge.transfer()</span><br><span class="line">    forall (node in Nodes) &#123;</span><br><span class="line">        // 只根据 node 的状态就可以算出当前执行上下文了</span><br><span class="line">    Transfers = Choose(node)    </span><br><span class="line">    forall (t in Transfers) &#123;</span><br><span class="line">    q.add(Edge(t, S&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def transfer(edge) &#123;</span><br><span class="line">S = edge.getState()</span><br><span class="line">t = edge.getTransfer()</span><br><span class="line">node = t.getNode()</span><br><span class="line">nodeState = S.getNodeState(node)</span><br><span class="line">nodeState.t()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-相关工作"><a href="#2-2-相关工作" class="headerlink" title="2.2 相关工作"></a>2.2 相关工作</h3><p>CMC 是一个 stateful 的模型检测工具，能够对 C 代码直接进行模型检测，被用于检测网络协议和文件系统（FiSC）。但是 CMC 的检测需要侵入式地修改源程序代码，以使得被测程序运行在 CMC 的地址空间内。</p><p>MaceMC 使用深度优先搜索和随机行走来检测网络协议实现中的 liveness 问题，但是被测系统需要是 Mace 生成的 C&#x2F;C++ 实现。Yabandeh 等人基于 MaceMC 提出的 CrystalBall 增加了 Steering Execution，在运行的过程中分析未来的错误状态，并通过控制执行来避免。</p><p>Yang 等人提出的 MoDist 是一个适用于 Windows 上的分布式系统的模型检测框架。它与 MaceMC 一样是 stateless 的。</p><h3 id="2-3-目标场景（与相关工作不一样的）"><a href="#2-3-目标场景（与相关工作不一样的）" class="headerlink" title="2.3 目标场景（与相关工作不一样的）"></a>2.3 目标场景（与相关工作不一样的）</h3><ul><li>支持对 go 语言编写的程序进行检测</li><li>stateful，不用每次都从头开始控制获得最新状态（节省运算性能，可能更占用空间）</li><li>无侵入性（不用修改实现的源码）</li></ul><h2 id="3-被测案例"><a href="#3-被测案例" class="headerlink" title="3 被测案例"></a>3 被测案例</h2><h3 id="3-1-计数器"><a href="#3-1-计数器" class="headerlink" title="3.1 计数器"></a>3.1 计数器</h3><p>被测的程序是 3 个独立的递增计数器，由 tracer 同时控制其运行，能够生成并执行 3 个进程的全部可能的调度顺序。</p><h3 id="3-2-client-x2F-server"><a href="#3-2-client-x2F-server" class="headerlink" title="3.2 client&#x2F;server"></a>3.2 client&#x2F;server</h3><p>客户端定时向服务端发送心跳消息，服务端每次收到心跳消息就刷新计时器，若超时则打印一条超时信息。tracer 通过调度顺序以及虚拟时钟模拟延迟，通过截获网络的调用模拟丢包，进行错误注入。</p><h3 id="3-3-共识"><a href="#3-3-共识" class="headerlink" title="3.3 共识"></a>3.3 共识</h3><h4 id="3-3-1-编程作业"><a href="#3-3-1-编程作业" class="headerlink" title="3.3.1 编程作业"></a>3.3.1 编程作业</h4><h4 id="3-3-2-开源案例-待测"><a href="#3-3-2-开源案例-待测" class="headerlink" title="3.3.2 开源案例(待测)"></a>3.3.2 开源案例(待测)</h4><p><a href="github.com/willemt/raft">github.com&#x2F;willemt&#x2F;raft</a> 是一个 C 实现的 Raft 共识协议。其优势在于单线程，且本身没有指定通信方式。数据发送与接收的接口在 raft 运行实例启动时由使用者通过注册回调函数自定义，因而可以自由选取节点间的通信协议。</p><p>TODO: 另选取一个 go 语言的实现。</p><h2 id="4-实现方法"><a href="#4-实现方法" class="headerlink" title="4 实现方法"></a>4 实现方法</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十周工作重点</title>
      <link href="/20231107-work/"/>
      <url>/20231107-work/</url>
      
        <content type="html"><![CDATA[<p>列举一下本周工作：</p><ul><li>软件分析A4</li><li>Semantic作业</li><li>PL作业</li><li>ISER proposal</li><li>DMCK main</li><li>…</li></ul><p>其他方面的就不在这里写了。现在是14：32，到19：00还有270分钟。我们抓紧把DMCK多搞一点。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>仔细地考察一下皮肤问题的解决</title>
      <link href="/20231103-skin/"/>
      <url>/20231103-skin/</url>
      
        <content type="html"><![CDATA[<p>前情提要：</p><p>作息饮食和锻炼是正道。仅为应急处理方法</p><p>痤疮是<em>一谱系疾病</em>，从微粉刺到广泛瘢痕的聚合性痤疮。</p><p>在正常的代谢过程中，毛囊皮脂腺导管上皮细胞脱屑，皮脂腺分泌皮脂，皮脂携带脱屑从毛囊口排出，其中可含有大量的皮肤正常菌群，如痤疮丙酸杆菌、需氧葡萄球菌及马拉色菌等。</p><p>痤疮是一种具有损容性的毛囊皮脂腺的慢性炎症性皮肤病。</p><p><strong>一、生理性粉刺</strong></p><p><strong>1. 微粉刺</strong></p><p>微粉刺是全部痤疮损害的基础，肉眼不可见。微粉刺在表皮下继续演变发展成肉眼见的痤疮皮疹大约需8周时间</p><img src="v2-489e9e6ad71fac7870e500e8f233813d_1440w.webp" alt="img" style="zoom:33%;"><p>毛孔内部存在明显的导管角化过度和由此引起的毛囊皮脂腺导管的堵塞，形成微粉刺。</p><p><strong>2.</strong> <strong>白头粉刺</strong></p><p>白头粉刺又称封闭性粉刺(Closed Comedo)，由微粉刺发展而来。外观为皮肤表面出现的白色稍隆起的小疙瘩。皮损为针尖到针头大小灰白色球形小丘疹，类似粟丘疹。肉眼看不到毛囊开口部，只有当皮肤被过度的伸拉时，才可以看到，并可挤压出白色糊状物。</p><img src="v2-290187a0ce5b2ee51bfba121d5a7eb6b_1440w.webp" alt="img" style="zoom:33%;"><p><strong>3.</strong> <strong>黑头粉刺</strong></p><p>黑头粉刺(blackhead)又称开放性粉刺(open come-do)由白头粉刺发展而来，或直接来源于微粉刺。外观为明显扩大的毛孔中的小黑点，略高于皮面或与皮面平行，可挤出乳白色的豆腐渣样的粉刺栓。开始暴露的角栓头小于1mm，随着毛囊口的扩大，暴露越多，一些可达5mm。</p><p><img src="v2-e8c8fb61a2e71e39b005ee19a59b8cbf_1440w.webp" alt="img"></p><p><strong>二、炎症性痤疮</strong></p><p><strong>1. 丘疹性痤疮</strong></p><p>丘疹性痤疮(papules)由白头粉刺发展而来。随着白头粉刺扩张，毛囊皮脂腺导管破裂，导致炎性损害的形成，位置较深的粉刺破裂可以形成丘疹。皮肤表面为红色坚实丘疹，一般为米粒到绿豆大小，暗红色，顶端略尖而稍硬的小丘疹，有的丘疹中心可有黑头粉刺或顶端未变黑的皮脂栓。</p><p>丘疹是痤疮最基本损害，具有代表性的损害。</p><img src="v2-5172635ae79d396d6aa0c01fdb593b6d_1440w.webp" alt="img" style="zoom: 25%;"><p>丘疹性痤疮 图5-1</p><p><strong>丘疹性痤疮病理显示：</strong>在毛囊漏斗部闭塞的情况下，形成毛囊皮脂腺内缺氧的环境。厌氧性痤疮丙酸杆菌大量繁殖，分解皮脂，产生化学趋化因子，白细胞聚集而发生炎症性丘疹。</p><img src="v2-13a1294d6cca3c94c106d5f103c7b941_1440w.webp" alt="img" style="zoom:33%;"><p>丘疹性痤疮病理示意图 图5-2</p><p><strong>2.</strong> <strong>脓疱性痤疮</strong></p><img src="v2-7d6adb5c9c6719e56d39976eec795b96_1440w.webp" alt="img" style="zoom:50%;"><p>脓疱性痤疮 图6-1</p><p>脓疱性痤疮(pustule)由白头粉刺发展而来。 随着白头粉刺的扩张，毛囊皮脂腺导管破裂，导致炎性损害的形成。脓疱多位于丘疹顶端，可以像豌豆大小或更大。如果损害较浅，突出于表皮，几天内脓疱破裂，脓液排出，可见粉刺栓与脓液流到皮面皮肤愈合且没有瘢痕的形成。如果是丘疹性痤疮的继发感染，则脓疱较深，可以引起凹陷性疤痕或瘢痕疙瘩。</p><p>脓疱还可以形成几种转归，上皮重新角化过度，炎症后粉刺继续生长，内容物往往排到深层组织，引起广泛而严重的炎症反应。继发的粉刺比原损害大，可以重复破裂形成大的囊肿。</p><p><strong>脓疱性痤疮病理显示：</strong>在封闭的毛囊皮脂腺结构中大量中性粒细胞被游离脂肪酸和白细胞趋化因子吸引过来，消灭、吞噬痤疮丙酸杆菌，发生剧烈炎症反应，白细胞形成脓细胞，形成脓腔，腔内还可以看到坏死、脱落的毛囊组织。</p><p><img src="v2-97e1dea84db1c2ffda9fd12c9e0682ad_1440w.webp" alt="img"></p><p>脓疱性痤疮病理示意图 图6-2</p><p><strong>3. 结节性痤疮</strong></p><p>结节性痤疮(nodule)由丘疹脓疱性痤疮发展而来。丘疹脓疱性痤疮的炎症继续扩大深入，则于皮下形成大小不等的淡红色、暗红色或紫红色厚壁的结节。通常位于面颊上部的两侧以及关节活动区域的前后。</p><p>损害一般位置较深，可高出皮面呈半球形或圆锥形隆起，也可不高出皮面，基底有明显的浸润、潮红，触之有压痛。结节范围较大，一个大的结节可包含几个毛囊和粉刺。直径5～10mm的结节称为小结节，大于1 cm称为大结节，有的结节常达到2～3cm。结节刚开始较坚实，周围很红，以后可变软，表面还可破溃形成出血性痂。此种损害可持续数月，或以后逐渐吸收，或化脓破溃形成瘢痕。</p><p><img src="v2-8e025974c5ab8537fdb481ab0d6d709d_1440w.webp" alt="img"></p><p>结节性痤疮 图7-1</p><p><strong>结节性痤疮病理显示：</strong>在脓疱的基础上，毛囊皮脂腺内大量的角质物、皮脂、脓细胞堆积，大量皮脂排不出去，引来大量中性粒细胞，吞噬、消火痤疮丙酸杆菌，炎症较剧烈，部位又较深，使毛囊皮脂腺结构破坏。结节结节多为两个或两个以上毗邻的粉刺破裂融合而成。包含的毛囊、血管、神经和汗腺等结构被完全破坏，损害内可有出血或渗出的血清，并可见残存的毛发和角化物。损害中出现大量的异物巨细胞，以后逐出现早核细胞和组织细胞。</p><img src="v2-3804cbef221a4d01b8e9ce19cd78baf6_1440w.webp" alt="img" style="zoom:33%;"><p>结节性痤疮病理示意图图7-2</p><p><strong>4. 囊肿性痤疮</strong></p><p>囊肿性痤疮(acne cystica)由结节发展而来，是最轻的聚合性痤疮，皮损主要为大小不等的囊肿，囊肿表现为光滑、圆顶、稍高出皮肤的圆形或是卵圆形结构，质软，挤压时有波动感，直径常为1 cm左右，呈暗红或正常皮色。该皮损常较结节易破裂，破裂后形成出血性痂。囊肿多侵犯患者的背部，会出现于面、颈和项部。以后可以发生很明显的瘢痕，甚至成为瘢痕疙瘩。有时可继发化脓菌感染，破溃后流脓，常经久不愈，可持续5～10年。</p><img src="v2-81edcb8a3da6c25bab632d105618906f_1440w.webp" alt="img" style="zoom:33%;"><p>囊肿性痤疮 图8-1</p><p><strong>囊肿性痤疮病理显示：</strong>在结节的基础上，毛囊皮脂腺结构内大量脓细胞的聚集，剧烈的炎症把整个毛囊皮脂腺正常结构破坏掉，形成固态或液态的物质聚积，既有脓液、细菌残体、皮脂和角化物，又有炎症浸润。较深部位的囊腔里的内容物逐渐地向皮肤表面移动，最后穿破皮肤，排出内容物。其排出物所经过的通道形成纤维化的管道，形成瘘管。单纯性囊肿性痤疮往往无化脓或轻微化脓。</p><img src="v2-7d5634d6af1230e8cde57e5f1559d438_1440w.webp" alt="img" style="zoom:33%;"><p>囊肿性痤疮病理示意图 图8-2</p><p><strong>三、瘢痕</strong></p><p>瘢痕分为两种：</p><p>（一）萎缩性瘢痕，如冰渣样瘢痕、纤维凹陷性瘢痕、萎缩性斑疹、毛囊性斑状萎缩、毛囊周围弹力纤维变性性瘢痕。</p><img src="v2-87bafdde28775e1fff7d522bf6571680_1440w.webp" alt="img" style="zoom:33%;"><p>瘢痕 图9-1</p><p><strong>萎缩性瘢痕病理显示：</strong>表皮层甚至真皮层缺失，胶原组织的萎缩，局部纤维化，弹性纤维消失等。</p><p>萎缩性瘢痕病理示意图</p><img src="v2-4a703c00e3ce08b9d64195a9a002b46f_1440w.webp" alt="img" style="zoom:33%;"><p>图9-2</p><img src="v2-40d819ea29a9440ba4c2eb1b8efd9d8e_1440w.webp" alt="img" style="zoom:33%;"><p>图9-3</p><img src="v2-efcf27ce5c2622152ab4df083223f599_1440w.webp" alt="img" style="zoom:33%;"><p>图9-4</p><p>（二）增生性瘢痕，如瘢痕疙瘩、软化瘢痕等。</p><p>增生性瘢痕</p><p><strong>增生性瘢痕病理显示：</strong>胶原组织增生。</p><p>至此各位应该已经对什么是痤疮以及痤疮的类型有了较为系统的了解，下篇将为各位痘友详细介绍痤疮的病因和影响因素，有兴趣的小伙伴可移步下篇。</p><p><img src="v2-8b7d3e79b1de31402226e6e62464f443_r.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随便写写</title>
      <link href="/20231103-dontknow/"/>
      <url>/20231103-dontknow/</url>
      
        <content type="html"><![CDATA[<p>有能力打开20把锁的钥匙。</p><p>我现在实在是想象不到被一段感情拴着有多恐怖。</p><p>并不是说我不能够专一。我只是希望两个人在一起就随意一点，不要没事摆个批脸质问对方为什么没做到什么什么。。。</p><p>我只能handle这种关系。我对人的控制欲是0，希望能将心比心，不要来对我施加控制。</p><p>有点要买的东西</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>适莽苍者</title>
      <link href="/20231101-clothes/"/>
      <url>/20231101-clothes/</url>
      
        <content type="html"><![CDATA[<p>（后录入的时候，已经找不到日期了）</p><p>适莽苍者，三餐而反，腹犹果然。</p><p>脑子里突然浮现就写下来了。（现在想想，从那个时候开始，我就一直特别喜欢逍遥游）</p><p>现在是下午4点，工作仍未开始。我仍未知道什么时候开始讨论。看来今晚是不能寐了。</p><p>大概成了整个办公室通宵次数最多的那个。。。虽然也没干什么。</p><p>发现自己在以往对自己外形上的需求（主要是服装上）克扣得太多了。应该更多地花钱去试衣服，不行可以退了。以前没有这样的意识导致真的看衣服的时候也没什么眼光。所以稍微定点小目标，每个月都要看看有没有合适的衣服可以买的。</p><p>目前的主基调是休闲的正装，面料一般、有点设计感，略显随意的西装、衬衫，etc.</p><p>还有风衣。不过这个如果料子不好会更有廉价感，除非设计特别在线，否则千万不要被卖家秀蒙蔽了。</p><p>等周一周二看看上身效果怎么样，尤其是那条裤子。</p><p>很麻烦，不想工作，但也没什么别的事可干（也不是）。可能还是上班更适合我。</p><p>但是因为要工作又不敢着手干别的事，闭环。寄了！</p><p> 一不小心走捷径是最危险的状态，拖延症大概是在趋利避害。寄！</p><p>摸鱼、不停地摸鱼。</p><p>记下来，写代码之余就是写文档，应该是不容有失。先画个靶子：</p><p>基本完成进程关停与启动的重写；能够真正搞定恢复与路径还原；基本实现 Choose()；实现一个 easy 的网络模型（支持 server&#x2F;client 操作）</p><p>暂时，不用去管时间。完成被测系统的选型。在此基础上，完成已完成部分的技术文档。</p><p>具体来说，是进程地址空间的dump和 fd 的恢复。</p><p>重要的是做出一个可交互的操作模式，比如人工选进程去运行。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不知道该咋整</title>
      <link href="/20231031-untitled/"/>
      <url>/20231031-untitled/</url>
      
        <content type="html"><![CDATA[<p>刚tmd到工位。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>置之死地</title>
      <link href="/20231030-death/"/>
      <url>/20231030-death/</url>
      
        <content type="html"><![CDATA[<p>「置之死地」</p><p>对于地球的千万种生命，乙醇足以致命。腐败的食物中散发出的发酵气息昭示着凶险。 为了取得生存必需的养料 ，动物进化出了脱氢酶。而人类作为最特殊的那一个，甚至发掘其作为快感来源之一。</p><p>酒——aqua vitae——生命之水，是一种让人「接近死亡」的饮料。完全醉酒前的回光返照，则是人主观意识最接近活着的时候。玻璃瓶中的酒只需一饮而尽，而后迸发的是生命的极致体验——濒死感。</p><p>鲜花易逝，有好事者摘取并作为装饰，生命即进入倒计时，仅能在短期内绽放。</p><p>我们都是要将自己燃尽的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>心想事成</title>
      <link href="/20231030-willing/"/>
      <url>/20231030-willing/</url>
      
        <content type="html"><![CDATA[<p>「心想事成」</p><p>有一个古老的关于戒烟的传说。戒烟的人在决定戒烟的那一刻就要想着：「我已经戒烟了」，而不是想着「我从今天开始戒烟」。</p><p>这不是简单的心理暗示。</p><p>我已经戒烟了。从此抽烟没有任何借口。而当实在忍不住去抽了一根的时候，也并不意味着戒烟这件事宣告破产。嘬两口，弹弹烟灰，再掐灭它，继续埋头戒烟。</p><p>饭桌上朋友发你一根：</p><p>你摇摇头说「我正在戒烟」，朋友会劝你「哎呀就一根，不影响你戒」，你会动摇「是啊，慢慢戒呗，少抽点没事的」。</p><p>你摆摆手说「我早就戒了」，朋友会羡慕「哎呀真厉害，你怎么戒的」，你会骄傲「说戒就戒了，有什么难的」。</p><p>最忌讳的想法是从客观的角度审视自己「戒烟失败」，进而思想上滑了坡：抽一根已经失败，抽一包一条也是失败，不如抽个爽。</p><hr><p>在情绪的泥沼里无法自拔的人，尽管他们想摆脱——至少表面上如此；尽管他们有所行动——至少从外界看来，已经足够努力。但一次又一次只是同一个模式的循环。</p><p>这种死结消除不了的根本原因在于，人根本「不愿意」去消除。恰恰相反，他们以这个无限循环的死结产生的创伤为养料，维持着一个想象性的自我认同。就像胎记标示着一个独一无二的人一样。</p><p>「什么档次，竟然敢称理解我」。于是任何理解都被否认。「你根本就不懂」。</p><p>每个人都用同种可悲的方式，维持着自我。于是并不是不可接受。</p><p>但是想要破解此局并不困难，只需要问两个问题：</p><p>谁规定了什么叫放下？——我说我放下了，别人可能觉得不是，那是别人的事。</p><p>凭什么要放下？——就好像放不下是什么难以启齿的事，就好像放不下会毁了一辈子，其实根本无伤大雅。</p><p>将评判的标准交由所谓客观理性，那么总有一个角度能给出否定的论证。只有收回决定和判断的权利，才有可能实现主观的意愿。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么喜欢纸笔</title>
      <link href="/20231020-bridge/"/>
      <url>/20231020-bridge/</url>
      
        <content type="html"><![CDATA[<p>今晚是约定的采访日。总得来说只要随意点就完事了，虽然还是不懂主题到底是什么。</p><p>下周二要去打耳桥。另外得陪人去查双相障碍。不过我也没准备好：如果查出来真的有，那我该怎么处理？</p><p>首先是劝她把结果告诉家里，毕竟她大部分时间都是脱产在家。如果她当场情绪比较强烈呢？那稍微喝两口，是否有点危险。。。最后就是必须送到家。</p><p>耳桥是打左耳还是右耳？可能我左侧对人的时间要多一些，放右边吧，因为我总是要摸左耳。</p><p>面对纸笔，我至少能够表达。原因的一部分也许是：我真的想看到好看的手写内容。有“书写”的过程来分散注意力，以至于无意识可以自如地流淌。而我又并不能投入注意到键盘输入的过程。“审美”与“理性”同时进行时候的我活跃的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一版置顶</title>
      <link href="/20231017-top/"/>
      <url>/20231017-top/</url>
      
        <content type="html"><![CDATA[<p>只要是我在电脑里写下的文字，除了少量牵扯到对其他人的看法的，几乎都会在这里出现。</p><p>我是一个看起来很正常的不正常的人。经常喝酒，轻度抽烟。喜欢花但是不太懂，养一些容易养活的盆栽，不过不想花太多精力。</p><p>正在努力学习调酒；并且努力取得练习调酒的经济条件。毕竟一瓶一两百的酒要比两块多的可乐要难获取得多。以低价格经营着一家宿舍内的酒吧；当然也可以做外送。</p><p>我用右耳的人体的穿刺警示着来往的人；尽管所有人都觉得我的性格没什么问题——甚至可以说性格极好。但经过23年的人生短跑，我知道自己可以对朋友很好，但完全没有耐心去搞这个年代里时兴的那种亲密关系。</p><p>我否认所有对爱情的普遍的模式化的定义：“爱谁就该怎么做”；我否认爱情中可以存在两个人：爱情顶多是两个人各自的爱情，其指向也不是别的，而正是与对方的身形刚好错位的幻影；我否认爱情是“崇高”、“神圣”的：不要拘泥于外界的灌输影响下你对爱情的各种幻想，爱情顶多是“独特”的。</p><p>我会认真思考每一个社会契约中的隐含条款，并在不逃避责任的情况下享受权利；或是通过<strong>拒绝行使权利与拒不承担责任</strong>来表达我对该条款的抗议。所以请不要通过<strong>附加隐含条款的“好意”</strong>将压力给到我头上。</p><p>有任何要求，任何疑惑，任何不满：</p><h1 id="讲。"><a href="#讲。" class="headerlink" title="讲。"></a>讲。</h1><p>我从来都不生气。请不要再当谜语人了。</p><p>2023-10-17</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件分析A1 实验前后</title>
      <link href="/20231017-taieA1/"/>
      <url>/20231017-taieA1/</url>
      
        <content type="html"><![CDATA[<p>虽然我赶时间，但还是要小心地对待这个作业。</p><p>看看 tai-e 的结构：我们这次要关注的有哪些？</p><p>要提交的包括</p><ul><li>LiveVariableAnalysis.java</li><li>Solver.java</li><li>IterativeSolver.java</li></ul><p>活跃变量分析，solver，和递归求解器</p><p>我估计：</p><p>活跃变量分析调用递归求解器，递归求解器调用求解器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LiveVariableAnalysis &#123;</span><br><span class="line">public SetFact&lt;Var&gt; newBoundaryFact(CFG&lt;Stmt&gt; cfg);</span><br><span class="line"></span><br><span class="line">public SetFact&lt;Var&gt; newInitialFact();</span><br><span class="line"></span><br><span class="line">public void meetInto(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target);</span><br><span class="line"></span><br><span class="line">public boolean transferNode(Stmt stme, SetFact&lt;Var&gt; in, SetFact&lt;var&gt; out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IterativeSolver::doSolveBackward();</span><br><span class="line"></span><br><span class="line">Solver&lt;Node, Fact&gt;::initializeBackward();</span><br></pre></td></tr></table></figure><p>我做完了，事实证明我全猜反了</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>债</title>
      <link href="/20231017-publishversion/"/>
      <url>/20231017-publishversion/</url>
      
        <content type="html"><![CDATA[<p>爱不生债。谁也不欠谁的。若我自认欠债，则将对方至于隐形放债人的不义地位。反过来也如此。</p><p>我认真地考虑在自己的身上添加一个警示标志，以表示我并非正常人，并没有任何正常恋爱的可能。因而劝退不能理解我的所谓“正常人”。</p><p>每个人都反常，只是他们不自知罢了。</p><p>此种表达的徒劳无功——并非错误，而是从歇斯底里的质问中得到沉默的响应，并转而求诸自身。</p><p>我决定这个月就去打耳桥。</p><p>有说点什么的冲动，但是已经不知道该说什么了…每次面对纸笔就充满表达欲，面对屏幕则立即消失了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迎新讲话</title>
      <link href="/20231014-talk/"/>
      <url>/20231014-talk/</url>
      
        <content type="html"><![CDATA[<p>当然也不尽然是在写讲稿。主要是思路。</p><p>要求：讲一讲怎么在大学里面过得舒服。侧重生活、生活与工作分离这些内容。让大家放下心来，缓解小年轻们的焦虑。</p><p>此外，需要幽默有梗一点，不要太绷着</p><p>首先声明，我们这个根本不算是脱口秀。</p><p>所有内容仅代表个人观点</p><p>任何商品请从正规网站购买</p><p>不要贪图低价商品</p><p>只要坚持认为自己不可能这么幸运，就可以避免90%诈骗</p><h2><a href="#yi-ge-ben-ke-sheng-de-zi-wo-xiu-yang-xin-tai" class="header-anchor">#</a><span id="yi-ge-ben-ke-sheng-de-zi-wo-xiu-yang-xin-tai">一个本科生的自我修养：心态</span></h2><h3><a href="#ni-xian-bie-ji" class="header-anchor">#</a><span id="ni-xian-bie-ji"><del>你先别急</del></span></h3><p>因为急也没用。</p><p>我们的社会总是要求大家在20多岁的时候得到30多岁的时候的东西。</p><p>事业、思想成熟、<del>爱情</del></p><p>大家自己没啥事也都喜欢拿这些事pua自己。</p><p><strong>建议在看到别人有什么的时候，仔细想想他有的东西是不是那么个事儿</strong></p><p>没有什么东西是天经地义地“就是好”的。要根据自己最深刻的愿望形成价值观。</p><p><strong>如果你反复问自己，我到底要的是什么？</strong></p><p>我想要钱-&gt;我要的其实是金钱带来的丰富的物质生活，而钱只是一个中介罢了-&gt;丰富的物质生活？什么算丰富？谁规定的？-&gt;我要的明明是那个理想，为什么最后都落到money上？-&gt;有钱只是社会对我的期许罢了。</p><p>我想要成功-&gt;怎么算成功？依然是社会的期许？</p><p>社会不期许你有钱、成功…只要对社会有用，一点微小的作用。</p><p>人不可避免地要“生产”某些东西。总有人会享受到你创造的价值，而人能够通过生产这些有价值的东西感到满足。</p><p>&#x3D;&gt;只有那些兜售成功学的人才会希望你向往成功（是的，他们甚至都不希望你成功）</p><p>手段是多种多样的。做出科研成果，投入到现实应用中是一种；进行知识分享，让他人也获得知识；生产可供消费的商品与服务同样也是。</p><p>喜欢做菜的人学炒菜&#x3D;&gt;大家都很喜欢吃。</p><p>​</p><p>多花点时间，好好考虑，自己到底喜欢什么。</p><p>过得从容一点。</p><h2><a href="#da-xue-sheng-cun-zhi-nan" class="header-anchor">#</a><span id="da-xue-sheng-cun-zhi-nan">大学生存指南</span></h2><p>工作生活分离。生活区域（特指宿舍）就要有生活气息。</p><p>——只有我工作时间摸鱼，杜绝休闲时间加班。</p><p>足够的照明（多买点灯装点一下）、 适量的书（当然全是书也行）、个人电脑&#x2F;显示器。</p><p>卫生打扫干净， 住起来会更惬意<del>（仙林的水泥地面超容易起灰简直没法住）</del></p><p>合适的装饰：绿色植物，花卉，购买的&#x2F;自制的手工艺品，瓶瓶罐罐；运动装备；喜欢的海报；etc</p><p>生活电器：咖啡机&#x2F;电热锅&#x2F;烤面包机&#x2F;冰箱（一筐违章电器，总有办法的）</p><p><del>买个折叠桌，冬天炖炖火锅围着吃</del></p><p>工作区域：图书馆，或者你喜欢的任何教室</p><p>南大图书馆的环境普遍还是很好的。就是不能机械键盘炸馆。（使用电脑的同学可以去机房自习）</p><p>只要不在宿舍，摸鱼的动机就减少了80%</p><p>建议准点上下班：早9晚5，或者其他的什么安排。</p><p><del>一定不要养成这个干不完就不睡觉的习惯</del></p><p><del>尤其是你们计算机的</del></p><p>多去户外，多出学校。我院的巨大优势之一是学生普遍压力不高；巨大缺陷是学生之间交流太少（全员自闭）。到了大四发现错过了培养社交能力的黄金时期，大呼上当。</p><p>——实际上，大家都在宿舍里躺尸。可千万不要再这样了。</p><p>读研，尤其是读博之后，你就知道有朋友、会交朋友是多么重要的事情了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小总结</title>
      <link href="/20230919_whatislove/"/>
      <url>/20230919_whatislove/</url>
      
        <content type="html"><![CDATA[<p>获取信心的关键在于：各种各样的人都能获得幸福。但是他们也都是像我一样有太多缺陷的普通人。就算并不优于他们，但也不算逊色。</p><p>如果我最终失败了，并不是因为我不好，而是我在这一段中的表现并不符合对方的期待。我有这样的能力，我有这样的意愿，展示出对方喜欢的一面。</p><p>既然如此那就自信地拿出来就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9月工作要点</title>
      <link href="/20230919_points/"/>
      <url>/20230919_points/</url>
      
        <content type="html"><![CDATA[<p>一些题外话：商院那边的校对工作可以挑选一个状态不太好的时间去做。尽量自动化吧</p><p>主题当然还是：用我们的系统调用拦截机制去跑一个进程。甚至是两个进程。</p><p>比较方便的一个小玩具是一个 Server-Client 的系统，比如天气查询系统之类的。可以集齐获取时间、日期这些要素。</p><p>之前提过两个东西。一个是可以去读写内存的地址空间，那就使用 &#x2F;proc&#x2F;pid&#x2F;memory 这个文件？让我先试试。</p><p>第二个是使用 clone 系统调用来管理</p><p>得想办法设计一下架构</p><p>1、用 procfs 重写地址空间读写</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学期初准备</title>
      <link href="/20230913_new/"/>
      <url>/20230913_new/</url>
      
        <content type="html"><![CDATA[<p><del>预约体检</del></p><p><del>交社保</del></p><p>挂刷课脚本（记得做试题）</p><p><del>9.14 8:30 体检</del></p><p><del>9.14 16:00-18:00 233 报告厅 软件所全体师生会议</del></p><p>记得预约牙医</p><p><del>信息确认</del></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩托车相关知识</title>
      <link href="/20230830-motor/"/>
      <url>/20230830-motor/</url>
      
        <content type="html"><![CDATA[<p> 购车前须知及入门准备</p><p>1、品牌（没说到的品牌不适合新手，或者牌子太小）</p><p>T0 本田Wing 川崎 雅马哈  质量、保值率、B格 OK 无脑冲</p><p>T1 豪爵、豪爵铃木 国产一哥 外观好看</p><p>T1.5 高金、凯越、升仕、力刻 正经想造好车的品牌，但需要时间</p><p>T2 新大洲本田、五羊本田、无极、赛科龙、春风、济南铃木、光阳、SYM三阳 各有优劣，小毛病</p><p>T3 奔达、长江、QJMOTOR钱江（不想做车只想做营销）、大阳、力帆 直接二手</p><p>T4 各类小品牌、杂牌 除非外观特别好看否则不建议购买</p><p>T5 地平线（？）</p><p>费用</p><p>1、驾照 800±</p><p>2、头盔 400± 护膝护肘200+</p><p>3、购车 1-2w</p><p>新车：裸车价+车价8%左右购置税+246&#x2F;626交强险+60上牌</p><p>二手车：卖价+100发票+50过户</p><p>购车渠道：当地实体店</p><ul><li>品牌官网查询经销商</li><li>摩托范</li></ul><p>新手选车的关键点</p><p>1、保值率：尽量选择梯队排名靠前的热门车型</p><p>2、安全性：尽可能选前后轮都带ABS大幅减少摔车概率</p><p>3、售后：离自己近的大车行</p><p>车型分类</p><p>1、街车</p><p>传统街车、运动复古街车 水桶车。复古街车适合改装</p><p>2、ADV拉力车</p><p>长途越野全地形车。专业度要求及售价高，新手不推荐。市面上很多自称拉力车的只能算休旅车。</p><p>3、休旅车</p><p>适合铺装道路长途骑行，烂路不如专业ADV。</p><p>4、复古巡航</p><p>小巡航 车身小，坐高低，适合市区街道代步通勤，有外观改装空间。</p><p>大巡航 硬汉，又长又宽，改装空间巨大。部分可胜任一些短途摩旅。</p><p>5、弯梁</p><p>不用捏离合就换挡，不担心熄火。但无路权，专治低血压。</p><p>6、踏板车</p><p>小平踏5km以内便携实用性无敌。大多排量 ≤ 150cc。</p><p>中小踏 &gt; 150cc 为提升车架强度提升操控性，一般取消了平踏空间。</p><p>大踏板 &gt; 250cc 不用换挡的休旅车。车身巨大，新手不好驾驭。</p><p>7、仿赛 跑车 长途骑行累，几乎没有装载能力。</p><p>明确需求</p><p>1、街车&#x2F;运动复古接车&#x2F;复古小巡航</p><p>综合性较强，动力、外观、实用性都占一部分。需求不清晰可先练手</p><p>2、仿赛</p><p>跑车外观，运动属性，短途代步。长途与其他实用性完全不在乎</p><p>3、复古街车&#x2F;复古巡航</p><p>独特风格、改装。骑范不骑快</p><p>4、休旅车</p><p>长途需求、装载能力，大气。</p><p>5、小平踏，中小踏板</p><p>实用为主，代步无敌，家中常备。</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK-ptrace</title>
      <link href="/20230726_ptrace/"/>
      <url>/20230726_ptrace/</url>
      
        <content type="html"><![CDATA[<p>稍微总结一下技术路线：</p><p>首先，被测方注册信号处理函数，并分配好信号执行的栈空间（sigaltstack）。两个处理函数，分别用于保存和恢复进程。</p><p>保存，具体来说就是把堆、栈、全局变量全都dump到文件。对于例子而言，这个文件大约是500KiB。压缩后是5KiB。</p><p>恢复，从文件中把数据再拷进来。首先不能破坏信号执行的栈区，要保留好 restore 函数的执行环境；其次要修改 restore 结束后返回的位置（主要是栈指针。pop rbp 之后，rbp要回到 dump 发生的位置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp // rbp 是 restore 发生时的 user_stack 上的地址</span><br><span class="line">movq %rsp, %rbp  // rsp 是 ss_stack 上的地址</span><br><span class="line">...</span><br><span class="line">movq %rbp, %rsp</span><br><span class="line">popq %rbp   // 此时需要回到 dump 发生时的 user_stack 地址。当时的栈区已全部恢复</span><br></pre></td></tr></table></figure><ul><li>总结下来，restore 不能破坏 restore 的栈结构，但是要把 push 的 rbp 换成 dump 下来的。之后 rsp 回到正常位置后，自然会取到正确的返回地址。</li></ul><p>问题：</p><p>1、FILE * 是分配在堆上的。这带来的问题是，恢复了上次的堆空间之后，FILE * 所指的内容随着执行进度的不同，也会发生变化</p><p>解决A：使用操作系统的文件描述符表。此处用栈上 fd 代替堆上 FILE *。仍然需要管理操作系统对象，并且不能 kill 进程，每一个分支都得保留一个 proxy 进程用来维持系统资源。尝试过感觉稍微有点困难。</p><ul><li>困难点在于，fork() 的 proxy 进程，脱离了 tracer。在有 tracer 的情况下，当 read() 系统调用被 SIGRESTORE 打断后，可以控制 read() 重新执行。在没有 tracer 的情况下，打断了就是打断了。</li><li>当然我们可以直接在打断失败的调用基础上修改返回的数据，这样单一调用的结果没问题。但是文件描述符的状态就没有发生变化了。</li></ul><p>解决B：不使用操作系统的文件描述符表，而是全部自己模拟（全模拟有大量细节要考虑。类似于 select&#x2F;epoll 的行为仍不明确。但是估计最终是这样）</p><p>2、随机性的产生 （choose()）</p><p>取决于被测程序使用何种随机。考虑以下简单情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> devrandom;  <span class="comment">// open(&quot;/dev/urandom&quot;, O_RDONLY);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    read(devrandom, &amp;ret, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种还是有一个系统调用可以控制的。但是如果面对这种使用场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> determ = rand() % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (rand) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read 的返回值很多，但是最终我们只要两个分支。根据概率分布的不同，我们可能需要走好多遍才能遍历两个分支。</p><p>故而，此类函数全都需要劫持或从代码上改写为 choose(N)。</p><p>choose(N) 要做什么？</p><ul><li>构造一棵执行路径树。每个节点都需要有可能的取值范围，这个可能需要手工确定。</li><li>获取当前的执行路径。产生新的取值</li><li>让被测程序走到新的节点</li></ul><p>rand.invoke()  –&gt; 被 ptrace 截停并通知父进程 –&gt; 父进程发信号使 rand 被拦截，并保存程序状态</p><p>–&gt; 父进程根据当前状态查表得知此处 rand 调用的取值可能 </p><p>–&gt; 对每种可能，新启动实例并给予返回值，运行至下一个选择的状态然后被 ptrace 捕获</p><p>ptrace 如何拦截用户函数？查询符号表，在函数开头插入 0xcc，这样就会触发 SIGTRAP… 接着只需要设置 rax 作为返回值，然后 ret。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *rand = symlookup(<span class="string">&quot;rand&quot;</span>);</span><br><span class="line">ptrace(PTRACE_POKEDATA, pid, rand, <span class="number">0xc3cc</span>);   <span class="comment">// cc c3 00 00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WIFEXITED(wstatus) == <span class="literal">true</span> &amp;&amp; WSTOPSIG(wstatus) == SIGTRAP) &#123;</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">    kill(pid, SIGDUMP);</span><br><span class="line">    <span class="keyword">for</span> (all possible val) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">            exec() the tested;</span><br><span class="line">        &#125;</span><br><span class="line">        kill(pid, SIGRESTORE);</span><br><span class="line">        ptrace(PTRACE_SYSCALL, pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    regs.rax = WANTED_BRANCH();</span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个 rand 也不是真正执行的</p><p>只要算好了 rand 的可能取值，就可以刚刚好跑过所有分支不重复。</p><p>3、怎么对其他程序应用此方案</p><ul><li>如果不用 signal handler，而是用 PEEKDATA 的方式 dump 进程，可以想象到效率</li><li>但进程信号表并不能 survive execve。如果原来的 elf 里没有这个 handler，没有办法后加</li><li>魔改elf感觉最稳。硬往里加text和data，有一定希望</li></ul><p>目前就局限在 C&#x2F;C++ 代码的单进程、单线程程序。</p><p>4、牵扯到线程调度怎么办</p><p>还没有调查如何控制并发调度。甚至还不知道 ptrace 一个多线程程序会发生什么。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本科跑路步骤</title>
      <link href="/20230630-boxign/"/>
      <url>/20230630-boxign/</url>
      
        <content type="html"><![CDATA[<p>扫描复印学位证</p><p>拆机</p><p>封箱</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Practical Software Model Checking via Dynamic Interface Reduction (SOSP&#39;11)</title>
      <link href="/20230626-explode/"/>
      <url>/20230626-explode/</url>
      
        <content type="html"><![CDATA[<p>通过动态Interface约简（Reduction）实现软件的模型检测</p><p>实现级别的软件模型检测。直接通过系统实现检测软件的缺陷。但是状态空间爆炸导致扩展性很差。DeMeter的贡献：1、提出动态 Interface约简，新的约简方法。2、用合理的工作量，在现有的 MC 中实现了动态 Interface 约简的框架。3、为框架提供了分布式运行时环境引擎，支持了并行分布式的 MC。</p><p>与 MaceMC 和 MoDist 集成，每一个差不多1000行代码工作量。可约简5到10^5倍的状态空间（Paxos、BerkeleyDB、Chord、Pastry。DeMeter 探索了Paxos的全部有意义的状态空间，提供了非常可靠的保障。</p><p>Dynamic Interface Reduction (DIR)   Interface，界面？接口？连接？</p><p>两个原则：</p><p>1、check components separately。（？）</p><p>软件通过封装隐藏细节。基于这个，一个典型的分布式系统就可以看作是一组进程通过消息交换交互。message traces （of a component and the rest of system）决定了这一component行为。</p><p>Interface 行为以外的所有行为，都是 Locally contained。给定了所有component的 InterBehav，DIR就可以只看本地状态空间。不需要去探索全局状态空间。（就像是硬件虚拟化、一叶障目的感觉）</p><p>2、discover interface behavior dynamically.(?)</p><p>分别 MC 各个组件，需要知道 interface behavior。DIR就在探索时动态发现这类行为。这个过程忽略组件内的复杂度，它不会通过interface传播。并且这个过程是自动的，所以不用手动指定（枯燥、error-prone、不准确）。而且，只会出现现实中会有的 interface behav，避免了 false positive。</p><p>主要思路：对于多个本地的执行流，它们拥有不同的本地状态却有相同的发送序列。这些本地状态的变化有可能不会传导给整个系统。所以就像 cache hit 一样。</p><p>所以，只要interface很好地掩盖了实现细节，DIR就能很好地工作。</p><p>由例子，过渡到DIR的系统模型和算法</p><h2><a href="#xi-tong-mo-xing" class="header-anchor">#</a><span id="xi-tong-mo-xing">系统模型</span></h2><p>DeMeter 检查标准的并发&#x2F;分布式系统。抽象地说，系统从一个初始状态出发，经过状态转换到达下一个状态。一个转换是 enabled 如果 not blocked （？？？）并且能够在当前状态下被调度到。</p><p><em>环境</em> 是用来建模状态转换当中的 <em>非确定性</em> 的（状态图中的分叉）。这种分叉就包括线程进程调度、消息顺序、时钟、错误，和其他很多不确定性（随机）。</p><p>实现级别的Mchecker一般有两大块。</p><p>一是 system wrapper。暴露处于下层的系统并允许环境中不确定性的控制。</p><p>二是 exploration mechanism，建在 syswrapper 上层，探索系统状态空间——记录和控制非确定性以寻找软件缺陷：异常，崩溃，断言，安全性违例。</p><p>处于下层的 system：C 为 components 的集合。（每个节点）。Components 通过 interface objects 进行互动（通讯信道、共享对象）。状态转变有 internal（don’t access interface objects）和 interface transitions（access）。</p><p>interface transition： output and input。（读和写信道、共享内存、收发消息）</p><p>两个transition <em>依赖</em> 如果它们的执行互相影响：一个会使另一个 enable、disable，或调换顺序产生不同结果。比如两个竞争的写&#x2F;读写。</p><p>从初始态，系统的执行（transition 序列）被建模为 <em>trace</em>，其中的 transition 拥有dependency &lt;&#x3D; 关系的偏序。两个偏序等价的 trace 认为相同。给定 trace $\tau$，然后一个 transition t 在之后发生，即可扩展为新 trace τ·t 。同时可定义前缀，。。。。</p><p>SKELETON，只有interface transition 的trace。对 component c 的 interface-equivalent，就是说 skel(localc(τ)) &#x3D; skel(localc(τ’))。</p><p>A partial order ($\preceq$) is defined between transitions in the same thread, between a send transition and its corresponding receive transition across threads and processes, and is transitive.</p><p>看完本篇剩下的：5小时</p><p>想好讲什么：2小时</p><p>做ppt：2小时</p><p>参考别的：3小时</p><p>整个 Local 和 Global explorer 的交互还是很清晰的。</p><p><img src="image-20230627001823927.png" alt="image-20230627001823927"></p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>教务处要的东西</title>
      <link href="/20230610-jiaowu/"/>
      <url>/20230610-jiaowu/</url>
      
        <content type="html"><![CDATA[<h1 id="期中项目选题及要求"><a href="#期中项目选题及要求" class="headerlink" title="期中项目选题及要求"></a>期中项目选题及要求</h1><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>在现代的编程语言中，表达式求值是必须要支持的一部分，比如 <code>Python</code> 的命令行模式，可以作为一个增强版的计算器来使用。</p><p>![image](Untitled 2.assets&#x2F;python-command-line.png.34cf22df)</p><p>本项目要求实现一个类似的表达式求值工具，接受变量赋值（比如 <code>a = 233</code>）和表达式求值（比如 <code>a + 114514</code>）两种语句，检查输入的错误，并计算表达式的值。</p><h3 id="项目指南"><a href="#项目指南" class="headerlink" title="项目指南"></a>项目指南</h3><p>2022.12.08 upd：项目指南更新，修正了一些错误与遗漏之处，欢迎大家找错误。</p><p><a href="https://box.nju.edu.cn/f/914aebbc04c347db879e/">新版链接</a>。</p><p>2022.12.26 upd：李清扬助教对手册的讲解：<a href="https://box.nju.edu.cn/f/0dd03c818a644077979c/">点此链接</a></p><p>旧版请查看 <a href="https://box.nju.edu.cn/f/dd2244548a2b43bcb59a/">NJU Box 链接</a> （可下载）。</p><h3 id="评分标准"><a href="#评分标准" class="headerlink" title="评分标准"></a>评分标准</h3><p>本题为客观题，由 dotOJ 黑箱测试自动评分，根据通过的测试点客观给分，OJ 得分即为你期中项目的得分。与主观题不同，你<strong>不</strong>需要提交项目文档。</p><p>你可以及时看到得分，但无法得知错误的测试数据点（<strong>助教不会给</strong>，保证公平性），与平时编程练习的形式<strong>完全相同</strong>，可多次提交，取最高分，以 dotOJ 显示为准。</p><blockquote><p>蔡之恒：感觉师姐去年造数据的时候有点偷懒，今年想办法加强一波（</p></blockquote><p>本题将同其他作业一样参与查重，并按照 <a href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p><p>选做该题目，将有<del>较大</del>机会得到期中项目的满分。其中，正确实现所有必做部分，可得到 70% 的分数；每正确实现一个选做部分，将额外得到 10%，也就是说，实现题面中所有部分，将得到满分。</p><p>除去该题之外，其余题目均为主观题，都将在期中项目截止后人工验收，因此选做本项目的同学的得分分布将会作为其他项目评分的参考标准，我们会尽力保证期中项目所有选择的在评分时的公平性。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含若干行，每行为一个表达式或赋值语句，关于输入输出的详细规约请参考<a href="https://box.nju.edu.cn/f/dd2244548a2b43bcb59a/">项目指南</a>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个输入的表达式或赋值语句，输出 <code>Error</code> 或相应的值。</p><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2</span><br></pre></td></tr></table></figure><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="小恐龙"><a href="#小恐龙" class="headerlink" title="小恐龙"></a>小恐龙</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：李薛成</p><p>验题人：李薛成</p></blockquote><h3 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h3><p>机房电脑上除了<a href="https://oj.cpl.icu/contest/27/problem/45"><em>扫雷</em></a>、<a href="https://oj.cpl.icu/contest/34/problem/159"><em>蜘蛛纸牌</em></a>，还是要数<em>Chrome</em>的小恐龙最好玩了，一玩就是一节信息课（）</p><p>没玩过的同学们也可以现在就打开 <em>Chrome</em>，在地址栏输入 <code>chrome://dino</code> （或者断网）就可以畅玩了！（<em>Edge</em>的小恐龙被换成冲浪了没法玩）</p><p>Sakiyary 在高中每节信息课都和同学比拼小恐龙赛跑，但自从上了大学，时移事易，物是人非（还记得2016年夏的守望先锋吗.jpg），Sakiyary 再也找不回当年玩小恐龙的感觉（再也没有超过高中时的最高纪录）。</p><p>现在请你来帮帮他，写一个 C 语言的小恐龙并和 Sakiyary 一起比拼，让他找回当年的感觉！</p><hr><h3 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用命令行的字符界面或图形界面来制作并运行游戏。</p><p>建议用键盘来操控小恐龙而不是鼠标。（Chrome 的小恐龙使用了空格键与上下两个方向键来操控）</p><p>你可以用命令行字符或图形界面的贴图绘出小恐龙，<strong>题目注解</strong>中提供了一种可能的字符小恐龙画法，请根据小恐龙的大小决定整个场景的大小，障碍物同理。（小恐龙之外的形象也可以，但不能是竖线、正方形、圆形等简单几何图形。下文均以“小恐龙”来指代玩家所操控的角色）</p><p>你需要至少实现两种障碍物，即需要跳跃的障碍物（如仙人掌）和需要下蹲的障碍物（如飞鸟）。</p><p>你需要让你的代码能够在别人的电脑上（按照你自己给出的<strong>环境要求与规定</strong>）<strong>编译并正确运行</strong>。</p><p>Sakiyary 将人工审查你的代码（与其他同学、各大开源平台上的开源代码进行比对与查重）并按照 <a href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p><hr><p>你需要正确地实现游戏进程：</p><ol><li>如何实现小恐龙向前跑动与障碍物迎面而来的效果与动画？</li><li>如何实现小恐龙跳起落下、下蹲的效果与动画？</li><li>如何实现按键操控且保证键盘输入<strong>不冲突不积压</strong>？</li><li>如何判断小恐龙与障碍物的碰撞与 Game Over？</li><li>如何计算与记录小恐龙跑出的分数？</li><li>如何暂停游戏、继续游戏？</li><li>如何<strong>在不重启程序的情况下</strong>重新开始一局新的游戏？</li></ol><p>关于上述第3点，给出一些补充：</p><ol><li>根据正常操控逻辑，跳跃键（如空格键）需要点按生效，下蹲键（如下方向键）需要长按生效。</li><li>如果一边按毫无意义的按键（如字母键），一边按跳跃键，小恐龙能否不卡顿地正常起跳？</li><li>如果长按或快速按跳跃键，小恐龙会飞上天吗？还是只能一下一下地跳？</li><li>如果在跳跃的过程中按下蹲键，小恐龙会有什么表现？</li><li>如果按住下蹲键的同时按跳跃键，小恐龙会有什么表现？</li></ol><p>按键操控有许多细节，大家都可以在原版小恐龙游戏中尝试，并在自己的代码中体现出来。若能完美实现，获得一定的加分，见下。</p><hr><p>关于两种界面的实现，分别给出一定的要求：</p><h3 id="命令行字符界面"><a href="#命令行字符界面" class="headerlink" title="命令行字符界面"></a>命令行字符界面</h3><p>推荐使用 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">Windows Terminal</a> 来运行程序，你需要锁定整个命令行界面的大小，可以自定义命令行字体大小，自行判断小恐龙与整个场景的比例。</p><p>字符的动画可以通过清屏+重新输出全部来实现（但这种做法效率很低哦），游戏的帧率与动画速度需要自行把控。</p><p>但显然，这个游戏越流畅越好玩。思考怎样让界面的字符动画能够尽可能流畅且屏幕不闪烁。</p><h3 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h3><p>图形界面的难点就是你要去自学怎么写好图形界面……参见本课程 <a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>但在绘制小恐龙与场景与实现动画保证流畅度的时候会比字符界面简单非常多。</p><p>故就难度而言其实与命令行字符界面差不多，甚至更加简单。但要求也会更高哦~</p><hr><h3 id="评分标准-1"><a href="#评分标准-1" class="headerlink" title="评分标准"></a>评分标准</h3><p>Sakiyary 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong> ，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li><li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现一些扩展功能：<ul><li>随得分增长小恐龙加速；</li><li>更多种类的障碍物；</li><li>道具与状态（飞行、无敌、冲刺）；</li><li>符合游戏逻辑的情况下自由发挥</li></ul></li><li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li></ul><hr><h3 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="题目注解"><a href="#题目注解" class="headerlink" title="题目注解"></a>题目注解</h3><ol><li><p>小恐龙越大，整个场景就越大，字符界面动画的显示就越卡顿，碰撞判断就越困难。</p><p>这里提供一种使用<strong>扩展ascii码</strong>的 12×812×8 的小恐龙画法（仅限 Windows mingw gcc）：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SetConsoleOutputCP(<span class="number">437</span>);</span><br><span class="line">    <span class="type">char</span> dino[<span class="number">8</span>][<span class="number">12</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">200</span>, <span class="number">205</span>, <span class="number">181</span>&#125;,</span><br><span class="line">        &#123;<span class="number">47</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">218</span>, <span class="number">196</span>, <span class="number">217</span>&#125;,</span><br><span class="line">        &#123;<span class="number">92</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">208</span>, <span class="number">208</span>, <span class="number">217</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">198</span>, <span class="number">203</span>, <span class="number">187</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">207</span>, <span class="number">205</span>, <span class="number">32</span>, <span class="number">207</span>, <span class="number">205</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++, <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dino[i][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预览效果：</p><p>![image](Untitled 2.assets&#x2F;QQ图片20221121145105.png.2e50b1e5)</p><p>TODO（持续更新ing……）</p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="羊了个🐏"><a href="#羊了个🐏" class="headerlink" title="羊了个🐏"></a>羊了个🐏</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：张哲恺</p><p>验题人：张哲恺</p></blockquote><h3 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h3><p>没玩过<em>羊了个羊</em>的人只能度过一些相对美好的夜晚😄</p><p><em>羊了个羊</em>是一款突然也不知道为什么就火起来了的<strong>垃圾</strong>游戏，玩家可以选择地图中随机出的卡片放到界面下方的卡槽中，卡槽中每具有三张同种类的卡片就可以消除掉它们，如果地图中的卡片被全部消除则 You Win，如果卡槽中卡片堆满了则 Game Over。</p><p>可以参考<a href="https://search.bilibili.com/all?keyword=%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A&from_source=webtop_search&spm_id_from=333.1007&search_source=5">一些视频</a>来了解具体的游戏流程。</p><hr><p>Corax 在接触到<em>羊了个羊</em>之后很快就恨上了这款随机无解的垃圾游戏，在无数的夜晚向文件传输助手转发了无数的广告之后，Corax终于破防了，然而他的好胜心不允许他征服不了这款游戏，于是他决定让你帮他写一个<strong>更合理</strong>的<em>羊了个羊</em>，以此来通关这个游戏曲线救国。</p><hr><h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏</p><p>游戏的逻辑需要正确实现，例如当地图上的卡片被清空或者卡槽中的卡片堆满且无法消除时游戏要能够正常结束，卡槽中同种类的卡片应该堆放在<strong>相邻</strong>的位置，每三张相同卡牌要能够正常消除等</p><p>卡牌要能够明确地分辨其边界，地图中需要有<strong>多层卡牌</strong>，并且能通过上层卡牌看到部分下层卡牌（可参考实机游戏画面，字符界面会在后面说明），下层卡牌上面的数张上层卡牌未被清空前不可选择下层的卡牌（具体要求在后面说明），你需要保证游戏有解，即不会存在剩下两张或一张某种卡牌的情况</p><p>你还需要实现一些附加的游戏道具功能，如洗牌（即重新打乱地图中卡牌的位置，但你仍然需要保证游戏有解），撤销（即将最近一张放入卡槽的卡牌放回其原有的位置），移出卡牌（即将卡槽中现有的卡牌移出，并放置于地图中的随机位置）</p><p>游戏中要能够暂停、继续、退出游戏，在游戏结束后要能够重新开始，而不是关掉程序重新打开</p><hr><h3 id="图形界面附加要求"><a href="#图形界面附加要求" class="headerlink" title="图形界面附加要求"></a>图形界面附加要求</h3><p>首先请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>如果你选择使用图形界面运行游戏，那么需要通过鼠标点击卡牌进行操作，通过设置图片的饱和度或给图片蒙一层半透明蒙版等来区分可选择的上层卡牌和暂时不可选择，仅可见的下层卡牌。</p><h3 id="字符界面附加要求"><a href="#字符界面附加要求" class="headerlink" title="字符界面附加要求"></a>字符界面附加要求</h3><p>如果你选择使用字符的命令行界面运行游戏，那么需要通过键盘进行操作，为了区分卡牌的边界和能看见下层的卡牌，你需要给每一张卡牌画上边界，可参考下图</p><p>![img](Untitled 2.assets&#x2F;image.png.0ab1f489)</p><p>示例中用<code>+</code>和<code>-</code>绘制了地图边界，用<strong>扩展ascii码</strong>中的 <code>191</code>，<code>192</code>，<code>217</code> 和 <code>218</code> 以及 <code>-</code> 和 <code>|</code> 绘制了卡牌的边框，为了在你的代码中使用扩展ascii码（关于什么是扩展ascii码以及更多其中的符号请自行STFW），你可以尝试以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SetConsoleOutputCP(<span class="number">437</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输出的编码标准切换至允许使用扩展ascii编码的标准，你也可以使用其他的字符来绘制边框，总之你的游戏中卡牌的边框要可见。但卡槽中的卡片可以没有边框，否则会显得有些冗杂</p><p>选择卡牌时可以通过<code>↑</code>，<code>↓</code>，<code>←</code>，<code>→</code>或者WASD来控制选择光标的移动，并将选中的卡牌编号或者整张卡牌的颜色切换为显眼的颜色，因此你的程序逻辑要<strong>正确地控制光标的移动</strong>，例如在上面的图片中按下右键，22号卡牌变回白色，33号卡牌变为红色，再按下右键，应该是位于顶层可被选中的11号卡牌变为红色，而非位于第二层且仍被第一层卡牌压住的55号卡牌变为红色，（如果5号卡牌上没有第一层卡牌，那么应该是它被选中）另外，如果Corax <strong>输入一系列预期之外的字符你的程序应该无视并且仍然能够正常运行</strong></p><p>为了改变输出的字符颜色，你可以使用以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is white now. U&#x27;ll change it to red.\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is red now. U&#x27;ll change it again\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It turns back to white.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以尝试改变 <code>SetConsoleTextAttribute</code> 函数的第二个参数来获得不同的颜色。</p><p>至于按下键盘上的哪个键将当前选中的卡牌放入卡槽可由你自己定义。</p><p>tips：以上代码均仅适用于 Windows 操作系统环境，如果是 Linux&#x2F;macos 用户请自行 STFW&#x2F;RTFM，应该需要用到 UTF-8 字符集。</p><hr><h3 id="评分标准-2"><a href="#评分标准-2" class="headerlink" title="评分标准"></a>评分标准</h3><p>Corax 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，没有 bug。（bug 太多会倒扣）</li><li>Corax 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现一些扩展功能：<ul><li>若Corax在一定时间内消除了足够数量的卡牌，即可进入<code>狂热模式</code>，在此期间他可以快速地消除地图上的卡牌，但你需要通过一定手段保证狂热模式结束后游戏仍然有解，并且Corax在游戏期间要能看见狂热模式的积攒条；</li><li>除此之外，你还可以设计一些其他有趣的功能。</li></ul></li><li>对于图形界面，实现正确的图片动态移入卡槽可酌情加分。</li><li>对于命令行字符界面，实现附加的选牌逻辑加分，附加的选牌逻辑如下：<ul><li>当输入→后如果当前卡牌的正右方没有卡牌，但右下&#x2F;上方有卡牌，那么应该移动到右下&#x2F;上方的卡牌，其他三个方向同理；</li><li>除此之外，你需要用另外一种颜色来标记可以被选中的卡牌，区分不可被选中的卡牌和已经被选中的卡牌。</li></ul></li></ul><hr><h3 id="技术要求-1"><a href="#技术要求-1" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）。</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="提交方式-1"><a href="#提交方式-1" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="飞行棋"><a href="#飞行棋" class="headerlink" title="飞行棋"></a>飞行棋</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：浦亮</p><p>验题人：浦亮</p></blockquote><h3 id="项目概述-2"><a href="#项目概述-2" class="headerlink" title="项目概述"></a>项目概述</h3><p>飞行棋是<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%81%E5%AD%97%E6%88%B2%E9%A1%9E%E9%81%8A%E6%88%B2">十字戏类游戏</a>，以模拟飞机飞航为主题，游戏以飞机由机场起飞至目的地，所以称为飞行棋。飞行棋是<a href="https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B">中国</a>参考<a href="https://zh.m.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E5%8D%81%E5%AD%97%E6%88%B2">英国十字戏</a>发展出来的，而<a href="https://zh.m.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E5%8D%81%E5%AD%97%E6%88%B2">英国十字戏</a>是从<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%B0%E5%BA%A6%E5%8D%81%E5%AD%97%E6%88%B2">印度十字戏</a>演变出来的。</p><p>在这个项目里，需要大家完成一个简易版本的飞行棋游戏，最终呈现的效果可以是命令行呈现，也可以是自己学习图形库后以GUI的形式呈现。</p><p>![image](Untitled 2.assets&#x2F;QQ图片20221102224124.png.0d47332e)</p><h3 id="项目要求-1"><a href="#项目要求-1" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用命令行的字符界面或图形界面来制作并运行游戏。最终实现的效果既可以是通过在终端里打印飞行棋的棋盘来表现，也可以是完整的图形界面。但要求一定要对棋盘上的情况有所呈现。</p><p>shuilongzhihun 将人工审查你的代码（与其他同学、各大开源平台上的开源代码进行比对与查重）并按照 <a href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p><h3 id="简化版飞行棋规则-游戏基本逻辑"><a href="#简化版飞行棋规则-游戏基本逻辑" class="headerlink" title="简化版飞行棋规则(游戏基本逻辑)"></a>简化版飞行棋规则(游戏基本逻辑)</h3><ol><li>有2-4个“玩家”。</li><li>每个“玩家”操控一个颜色对应的棋子，“玩家”可以是真人控制也可以是电脑控制，<strong>“玩家”可以全是真人也可以全是电脑。</strong>真人通过与实现系统交互来进行游戏，电脑玩家自动进行游戏。</li><li>每个玩家四颗棋子，初始都在机场不能出门，按顺序投骰子（1-6点的骰子）。如果玩家骰子抛出6，则可以让自己一个在机场的棋子在起点准备出发，并且再抛一次骰子决定可以出门走几格（该次抛骰子无论抛出几都只能作为刚刚准备出发的棋子前进的步数）。<ol><li>如果玩家的每个棋子都在机场或者终点处，且没有抛到6，则该玩家这个回合结束。</li><li>如果玩家抛出的点数是1-5，且有至少一个既不在机场也不在终点的棋子，则可以选择一个棋子根据点数往前移动一定步数。在简化实现中，所有的棋子都共享一条直线型的跑道！</li><li>如果玩家同时有棋子在机场和已经出发，在抛到6的情况下如何处理留给同学自行设计（可以设计成只能让棋子出发，或者也可以设计成可以选择让已经出发的前进，或其他设计）。</li><li>为了方便大家的实现，在这里做了简化处理。如果有同学想实现原版的效果，可以作为扩展功能实现。</li></ol></li><li>同时要求 <strong>直线型的跑道格子数量不低于15个</strong>，也就是下图中中间的深蓝色格子不少于15个。</li><li><strong>终点的格子数应该为6个</strong></li></ol><p>![image](Untitled 2.assets&#x2F;r1.png.2925d469)</p><ol><li>在终点前要进行分流，各自进入对应颜色的分流终点。然后进入终点分流阶段。</li></ol><p>![image](Untitled 2.assets&#x2F;r2.png.5e82d363)</p><p>如图，绿色的棋子如果此时是抛出了某些点数，或者是因为前面抛出了点数走到了这个位置还有几步没有走完，接下来都应该进入绿色对应的终点区域</p><ol><li>在终点区域，到达终点的判定是正好走到最后一格。如果没有走到则等待下一轮抛投，如果走到最后一格还有剩余步数，则需要反弹剩余步数。</li></ol><p>![image](Untitled 2.assets&#x2F;r3.png.16a0cb13)</p><p>如上图，在当前位置时，如果抛出的点数是3，则正好到达终点。如果抛出的点数是5，则反弹效果如图所示。</p><p>![image](Untitled 2.assets&#x2F;r4.png.23a43eea)</p><ol><li>一颗棋子达到终点的时候，就将这个棋子移出整个棋盘，记为成功到达。玩家胜利的条件是让全部的四颗棋子都到达终点。</li><li>对于同格子情况的处理：有不同的规则版本，在此处统一：<ol><li>对于途径的其他棋子无视，不论那个途径的格子里有几个棋子。</li><li>如果本次移动最终落点处是己方棋子，则这两个棋子可以同时存在这个格子里（但是不采取某些可以叠子的规则，后续再进行移动的时候同一格的棋子仍然视为多个分开的个体前进）</li><li>如果本次移动最终落点处有敌方棋子，则己方棋子占据这个格子，所有在这个格子的敌方棋子不论数量都返回机场（也就是需要抛到6才能再出发的状态）</li></ol></li></ol><h3 id="电脑操作"><a href="#电脑操作" class="headerlink" title="电脑操作"></a>电脑操作</h3><p>对于上述提到的电脑玩家操作，应当保证电脑的表现正常，即不存在非法操作（比如没有投到6但是让一个棋子出发），而且所有操作都是正常操作（比如不会在投了骰子且有棋子可以移动的情况下什么都不做）。</p><p>电脑玩家的操作也应当以某种方式（输出日志或其他）展现出来。</p><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><p>上述描述的实现标准是一个简化改进版本的要求，同学们可以在现有的基础上尝试实现更多效果，包括但不限于：</p><ul><li>一个实现得非常好的命令行交互系统或者图形界面；</li><li>体现简化版本中没有提到的“飞”，即在某个满足特定要求的特定位置时可以飞到另外一格；</li><li>体现简化版本中没有提到的“跳”，即给中间的深蓝色格子进行染色，当棋子移动的最终落点在同色的格子上时可以往前跳到下一个同色格子上；</li><li>把跑道改为原版中的环形跑道的设计；</li><li>……</li></ul><p>你可以随意添加功能，<strong>但是理论上不能破坏现在的基本规则或者是使得规则变得更简单改动</strong>（例如删除终点的反弹但是又不设计一个更复杂的规则代替将会反过来影响你的成绩）。</p><hr><p>关于两种界面的实现，分别给出一定的要求：</p><h3 id="命令行字符界面-1"><a href="#命令行字符界面-1" class="headerlink" title="命令行字符界面"></a>命令行字符界面</h3><p>参见本课程 <a href="http://docs.cpl.icu/#/project/cli_req">命令行字符界面要求</a>，只是简单的将模拟的棋盘用一些代表特殊意义的字符不断的输出在屏幕上是可以的。</p><h3 id="图形界面-1"><a href="#图形界面-1" class="headerlink" title="图形界面"></a>图形界面</h3><p>参见本课程 <a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><hr><h3 id="评分标准-3"><a href="#评分标准-3" class="headerlink" title="评分标准"></a>评分标准</h3><p>shuilongzhihun 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li><li>shuilongzhihun 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现上述的扩展功能或自行发挥。</li></ul><h3 id="技术要求-2"><a href="#技术要求-2" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="项目注解"><a href="#项目注解" class="headerlink" title="项目注解"></a>项目注解</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>该部分仅作为参考的建议和提示，如果你有更好的设计思路和实现，完全可以自己采用。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>对于棋子和棋盘格状态的存储，用数组和变量的方式就可以实现。比如用数组来记录当前棋子的位置和当前的状态，再用一些数组来存储棋盘格子内的状态。</p><h4 id="游戏控制"><a href="#游戏控制" class="headerlink" title="游戏控制"></a>游戏控制</h4><p>对于游戏整体逻辑控制 可以参考如下的设计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!game_ends)&#123;</span><br><span class="line">    player=(player+<span class="number">1</span>)%player_num;<span class="comment">//切换玩家</span></span><br><span class="line">    die_point=<span class="built_in">getDieRes</span>();<span class="comment">//投骰子</span></span><br><span class="line">    <span class="built_in">move</span>(player,die_point);<span class="comment">//移动部分的判断</span></span><br><span class="line">    game_ends=<span class="built_in">judge</span>();<span class="comment">//判断游戏是否结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令行字符界面呈现"><a href="#命令行字符界面呈现" class="headerlink" title="命令行字符界面呈现"></a>命令行字符界面呈现</h4><p>只是简单的将模拟的棋盘用一些代表特殊意义的字符不断的输出在屏幕上是可以的。例如像下面的模拟输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------</span><br><span class="line">GG</span><br><span class="line">GG                         DDDDD(green)</span><br><span class="line">  □□□□□□□□□□□□□□□□□□□□□□□□□</span><br><span class="line">YY                         DDDDD(yellow)</span><br><span class="line">YY</span><br><span class="line">Green team throw the die and get 2 point!</span><br><span class="line">Green team ubable to move!</span><br><span class="line">------------------------------------------------</span><br><span class="line">GG</span><br><span class="line">GG                         DDDDD(green)</span><br><span class="line">  □Y□□□□□□□□□□□□□□□□□□□□□□□</span><br><span class="line">Y□                         DDDDD(yellow)</span><br><span class="line">YY</span><br><span class="line">Yellow team throw the die and get 6 point!</span><br><span class="line">Yellow team throw the die again and get 2 point!</span><br><span class="line">Yellow team moves.</span><br></pre></td></tr></table></figure><p>当然，如果你对字符进行了染色并且实现了刷屏的效果(屏幕上不是通过类似上述分隔符分隔的多次输出来展示，而是通过清屏再输出或者修改屏幕上显示的某些字符来实现)，这个设计可以被认为是一个扩展功能，根据效果可以作为评分标准里扩展功能部分的分数。</p><h4 id="DEBUG模式"><a href="#DEBUG模式" class="headerlink" title="DEBUG模式"></a>DEBUG模式</h4><p>为了方便助教测试和自己debug，推荐自己在程序里加入一个“外挂”，比如在输入某些指令后，或者全局定义某些变量值为1或自定义宏(例如#define DEBUG)开启自己定义的debug模式，你可以编写操控骰子投出的点数的代码，从而可以控制棋子的走动。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="comment">//假设这是一个用于得到投骰子结果点数的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDieRes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该部分不计入分数，但是强烈推荐做一下。</strong></p><h4 id="先动脑-再动手！"><a href="#先动脑-再动手！" class="headerlink" title="先动脑 再动手！"></a>先动脑 再动手！</h4><p>由于在很多地方都存在共通之处，同学们在编写代码的时候可以先思考一下有些地方的代码是不是可以抽象出来作为一个函数在多个地方复用，而通过设置一些变量来进行区分，这样可以很好的实现代码的压缩，防止出现屎山，也会减少在复制的时候有些地方没改完全导致出错!</p><p>对于每个玩家阵营，很多流程是一样的，是否可以把里面的一些操作抽象出来，而不是在每回合的循环里复制四遍代码？</p><p>比如对于每个棋子（飞机）可以增加一个标签来标记他是什么颜色的棋子，这样对于棋子的一些操作就可以通用了。</p><p>比如对于真人和电脑玩家的区分，本质区别其实只有在移动的时候有区别，而且移动都要检查是否合法，那么可以考虑一个设计是：对于玩家的每个棋子，判断投出骰子对应点数的移动是否合法，如果合法，那么就返回一个所有可以选择移动的棋子列表，电脑是从中随机选一个移动，而真人是自己选择。这样真人和电脑的代码差异就变得很小了。</p><h3 id="提交方式-2"><a href="#提交方式-2" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：肖江</p><p>验题人：肖江</p></blockquote><h3 id="项目概述-3"><a href="#项目概述-3" class="headerlink" title="项目概述"></a>项目概述</h3><p>单色蜘蛛纸牌是一款经典的休闲益智纸牌游戏，该游戏基本规则如下：</p><ul><li>有 �<em>N</em> 副牌，�<em>M</em> 个牌槽，�<em>K</em>次发牌机会</li><li>初始牌槽中有 �×13−�×�<em>N</em>×13−<em>K</em>×<em>M</em> 张牌</li><li>只可以移动牌槽最上层的连续牌组</li><li>移动的目的地要么是空牌槽，要么能够和被移动牌组连接上</li><li>形成一组完整的连续牌组后（�<em>A</em>~�<em>K</em>），该牌组被从牌槽中收回</li><li>可以申请发牌，每个牌槽中新增一张牌，新增的牌可以和原牌组不连续</li><li>所有牌全部收回时判定胜利</li><li>无法进行有效操作时判定失败</li></ul><p>比如有4个牌槽：</p><p>![image](Untitled 2.assets&#x2F;image.png.7bba8639)</p><p>那么此时可以进行的操作是：</p><ol><li>将牌槽1的 <code>A, 2, 3</code>移动到牌槽2；</li><li>将牌槽1的 <code>A, 2</code> 移动到牌槽3；</li><li>将牌槽3的 <code>3</code> 移动到牌槽2；</li><li>申请发牌。</li></ol><p>其余均为非法操作。</p><p>更具体的规则过程可以观看如下两个视频</p><ul><li><a href="https://www.bilibili.com/video/BV1s64y1s7aP">判定胜利</a></li><li><a href="https://www.bilibili.com/video/BV1XS4y1C7kh">判定失败</a></li></ul><h3 id="项目要求-2"><a href="#项目要求-2" class="headerlink" title="项目要求"></a>项目要求</h3><p>我们需要在字符界面或者图形界面实现一个单色的蜘蛛纸牌。</p><p>该蜘蛛纸牌共包含88副牌（�<em>A</em>~�<em>K</em>），1010 个牌槽，初始时 1010 个牌槽各拥有 66、66、66、66、55、55、55、55、55、55 张牌，最上层的牌可见，其余牌不可见，有 55 次发牌机会，每次给 1010 个牌组各发一张牌，其余规则和游戏介绍中的一致。</p><h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4><ul><li>初始化牌桌，展示牌槽，可发牌次数和已收回牌组；</li><li>移动牌组；</li><li>发牌；</li><li>收回已形成的完整牌组；</li><li>结束判定。</li></ul><h4 id="扩展功能-1"><a href="#扩展功能-1" class="headerlink" title="扩展功能"></a>扩展功能</h4><ul><li>撤回一次或多次操作；</li><li>提示有效操作：<ul><li>需要按照要求和优先级进行提示，详见项目注解；</li></ul></li><li>计时器；</li><li>多色的游戏模式。</li></ul><hr><p>关于两种界面的实现，分别给出一定的要求：</p><h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>部分功能仍然需要实现动画，详见项目注解中命令行交互方式，并遵守<a href="http://docs.cpl.icu/#/project/cli_req">命令行字符界面要求</a>。</p><h3 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h3><p>可以直接参考游戏介绍中的视频，使用拖拽，高亮，鼠标点击按钮等交互方式，但请遵守<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><hr><h3 id="评分标准-4"><a href="#评分标准-4" class="headerlink" title="评分标准"></a>评分标准</h3><p>875C 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li><li>875C 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现上述的扩展功能或自行发挥。</li></ul><h3 id="技术要求-3"><a href="#技术要求-3" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="项目注解-1"><a href="#项目注解-1" class="headerlink" title="项目注解"></a>项目注解</h3><p>接下来对失败条件判定和有效操作提示，以及交互方式做更进一步的解释</p><h4 id="失败条件判定和有效操作提示"><a href="#失败条件判定和有效操作提示" class="headerlink" title="失败条件判定和有效操作提示"></a>失败条件判定和有效操作提示</h4><p>由于失败条件以及有效操作的定义和证明不属于C语言课程的范围，在这里我们直接给出它的定义，大家按照定义实现即可。</p><p>首先定义最大上层连续牌组，即一个牌槽内的上层的最多的连续牌组，如一个牌槽自底向上的牌是<code>?, ?, ?, K, Q, 9, 7, 8, 3, 2, A</code>（<code>?</code>表示未翻面的牌），则最大上层连续牌组为<code>3, 2, A</code>。</p><h4 id="失败条件"><a href="#失败条件" class="headerlink" title="失败条件"></a>失败条件</h4><p>失败条件为同时满足以下三条：</p><ol><li>所有牌槽的最大上层连续牌组<strong>并集不包含</strong>完整的一副牌；</li><li>无法移动任何最大上层连续牌组；</li><li>无剩余发牌次数。</li></ol><h4 id="失败条件示例"><a href="#失败条件示例" class="headerlink" title="失败条件示例"></a>失败条件示例</h4><p>假设一共有 33 个牌槽且无法发牌（项目要求是 1010 个，这里示例用 33 个展示逻辑过程）</p><p>![image](Untitled 2.assets&#x2F;image.png.303ee8c1)</p><p>他们的最大上层连续牌组为 <code>&#123;A, 2, 3&#125;, &#123;8, 9, 10&#125;, &#123;5,6&#125;</code>，并集为 <code>&#123;A, 2, 3, 5, 6, 8, 9, 10&#125;</code>，不包含 �<em>A</em>~�<em>K</em>，且所有最大上层连续牌组都无法移动，且无法发牌，故判定失败。</p><h4 id="有效操作"><a href="#有效操作" class="headerlink" title="有效操作"></a>有效操作</h4><p>有效操作包括以下三种，<strong>按优先级从高到低排序，即“能提示1，就不要提示23”</strong>：</p><ol><li>通过移动牌组，将一副牌直接收回；</li><li>移动某个牌槽的最大上层连续牌组（但不能是全牌组和空牌组互换）；</li><li>发牌。</li></ol><h4 id="有效操作1示例"><a href="#有效操作1示例" class="headerlink" title="有效操作1示例"></a>有效操作1示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p><p>![image](Untitled 2.assets&#x2F;image.png.1a93a157)</p><p>此时可以通过将牌槽2的A移动到牌槽3，再将牌槽3的A,2,3移动到牌槽1，将一整副牌收回。</p><p>提示并不需要提示完整的操作过程，只需要高亮最大上层连续牌组并集能包含 �<em>A</em>~�<em>K</em> 的牌槽即可，样例中可以高亮牌槽1, 2, 3。</p><h4 id="有效操作2示例"><a href="#有效操作2示例" class="headerlink" title="有效操作2示例"></a>有效操作2示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p><p>![image](Untitled 2.assets&#x2F;image.png.34a931dc)</p><p>他们的最大上层连续牌组为<code>&#123;A, 2, 3&#125;, &#123;4&#125;, &#123;5, 6, 7&#125;</code>，你可以提示将牌槽1的 <code>A, 2, 3</code> 移动到牌槽2，也可以提示将牌槽2的 <code>4</code> 移动到牌槽3，但是不可以提示将牌槽3的所有牌移动到牌槽4。</p><h4 id="有效操作3示例"><a href="#有效操作3示例" class="headerlink" title="有效操作3示例"></a>有效操作3示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p><p><img src="https://oj.cpl.icu/image/image.png.00ecbcd9" alt="image"></p><p>他们的最大上层连续牌组为<code>&#123;A, 2, 3, 4&#125;, &#123;4&#125;, &#123;6, 7&#125;, &#123;K&#125;</code>，此时既没有有效操作1，也没有有效操作2，可以直接提示发牌。（如果无法发牌就说明应该判定失败了）</p><h3 id="命令行交互方式"><a href="#命令行交互方式" class="headerlink" title="命令行交互方式"></a>命令行交互方式</h3><h4 id="初始化牌桌，展示牌槽，可发牌次数和已收回牌组"><a href="#初始化牌桌，展示牌槽，可发牌次数和已收回牌组" class="headerlink" title="初始化牌桌，展示牌槽，可发牌次数和已收回牌组"></a>初始化牌桌，展示牌槽，可发牌次数和已收回牌组</h4><p>无需动画，直接展示，可发牌次数和已收回牌组可以使用数字展示。</p><p>牌槽牌面最简单也需要使用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--+</span><br><span class="line">| A|</span><br><span class="line">+--+</span><br></pre></td></tr></table></figure><p>展示，不能只有一个字符。</p><h4 id="移动牌组"><a href="#移动牌组" class="headerlink" title="移动牌组"></a>移动牌组</h4><p>可以直接使用命令进行交互，如 <code>m 3 2 1</code> 表示牌槽3移动到牌槽2，移动1张牌。</p><p>也可以使用，选定原牌槽-&gt;选定牌组-&gt;选定目标牌槽的方式进行移动。</p><p>动画至少需要三个关键帧，即原牌桌，移动到半途的牌桌，移动完毕的牌桌。</p><h4 id="发牌"><a href="#发牌" class="headerlink" title="发牌"></a>发牌</h4><p>可以使用按键发牌。</p><p>动画需要至少两个关键帧，展示要发的牌，将牌发到各个牌槽。</p><h4 id="收回已形成的完整牌组"><a href="#收回已形成的完整牌组" class="headerlink" title="收回已形成的完整牌组"></a>收回已形成的完整牌组</h4><p>动画至少需要两个关键帧，高亮完整牌组，收回牌组且计数器增加&#x2F;牌组增加。</p><h4 id="结束判定"><a href="#结束判定" class="headerlink" title="结束判定"></a>结束判定</h4><p>弹窗，不要覆盖牌桌，因为需要截图展示，可以在牌桌旁展示弹窗提示胜利或失败。</p><h4 id="撤回操作"><a href="#撤回操作" class="headerlink" title="撤回操作"></a>撤回操作</h4><p>无需动画，直接使用弹窗提示撤回的操作类型——发牌&#x2F;移动，并还原牌桌状态。</p><h4 id="提示有效操作"><a href="#提示有效操作" class="headerlink" title="提示有效操作"></a>提示有效操作</h4><p>按照有效操作一节中的要求和优先级进行有效操作提示，使用按键或命令激活提示。</p><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>直接展示即可，不要出现跳表情况，即不能出现 <code>00:01</code> 直接变成 <code>00:04</code>。</p><h3 id="提交方式-3"><a href="#提交方式-3" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="苏联块"><a href="#苏联块" class="headerlink" title="苏联块"></a>苏联块</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：孙博文</p><p>验题人：孙博文</p><p>Sakiyary：我摆烂了，不想格式化题面了，和其他项目题总要求是一样的……</p></blockquote><p>“俄罗斯方块”（Tetris）是一个经久不衰的小游戏。我们这就来做一个：</p><p>原版游戏当中Tetra4。我们做一个 Extended Edition</p><p>硬性要求：不做掉大分。</p><ul><li><p>掉落的方块，在原游戏基础上增加几种：</p><p>3方块的 “L” 和 “l” 型, 5 方块的 3 种 “L” 型。</p></li><li><p>容纳方块大小至少为 12 列 16 行。游戏界面自适应当前终端，如果终端尺寸不够放下全部内容，则不能启动并给出一行提示。</p></li><li><p>使用上下左右方向键！方向键！方向键！实时控制方块旋转与下落，直到方块的下表面与已有方块接触，则刷出下一个方块</p></li><li><p>旋转前后，如果没有卡上游戏 tick （即向下掉落一格的时刻），方块的最下端高度不应变化</p></li><li><p>输入不合法的字符，不应使你的程序卡顿、崩溃、异常。</p></li><li><p>行填满需要消除，下落。并计分。</p></li><li><p>屏幕内给出操控指示。支持暂停，和重新开始。</p></li></ul><p>软性：</p><ul><li>最好能打印出较为标准的正方形。比如终端内打印两个黑方块▇▇来组成一个。<del>否则方块旋转后会变形</del></li><li>按下方向下键时方块速度增加</li><li>支持计分榜等扩展功能</li></ul><p>本实验选题不会奖励写图形界面的同学。如果图形界面有bug还可能导致多的扣分。</p><p>命令行界面简洁而完整。</p><h3 id="评分标准-5"><a href="#评分标准-5" class="headerlink" title="评分标准"></a>评分标准</h3><p>请仅提交三个文件放在 .zip 压缩包内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">submission.zip</span><br><span class="line">  - tetris.c</span><br><span class="line">  - tetris.exe / tetris.out</span><br><span class="line">  - report.txt</span><br></pre></td></tr></table></figure><p>我们会运行你的程序。基本能玩就给 80 分。游戏交互逻辑较好并且没 bug 就是一伯分。</p><p>我们会做包括但不限于下列操作：</p><ul><li>正常地游玩游戏</li><li>键盘随机输入一大堆随机字母数字，并观察你程序的行为</li></ul><p>项目报告</p><ul><li>你的平台(Windows&#x2F;Linux&#x2F;MacOS)，编译选项，（依赖的图形库），具体交互方式(图形化拖拽 or 命令行按键)</li><li>简单思路</li><li>完成项目的感想和意见</li><li>建议使用 txt 纯文本</li><li>不要过长，不超过两页，主要是将前两项说清楚，方便助教验收，前两项说清楚就是满分，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可</li></ul><h1 id="期末项目选题及要求"><a href="#期末项目选题及要求" class="headerlink" title="期末项目选题及要求"></a>期末项目选题及要求</h1><h2 id="冬津羽戏"><a href="#冬津羽戏" class="headerlink" title="冬津羽戏"></a>冬津羽戏</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：张哲恺</p><p>验题人：张哲恺</p></blockquote><h3 id="项目概述-4"><a href="#项目概述-4" class="headerlink" title="项目概述"></a>项目概述</h3><p>俗名打砖块😄打砖块是一款总共可以发射数个小球，并通过控制挡板位置，反弹小球使其击碎路径上砖块并不断反弹的游戏。</p><p>同样可以参考<a href="https://www.bilibili.com/video/BV1Rb411c7RF/?spm_id_from=333.337.search-card.all.click&vd_source=20202ec91c1882d95954b8843ae70102">一些视频</a>来了解具体的游戏流程。</p><hr><p>Corax 收到大冒险家 Sakiyary 想要自己做一个打砖块游戏的委托但是却不知所措，于是他决定转发委托，并作为中间商在其中狠狠捞一笔。不过纯粹的打砖块太过次时代缺乏趣味性，只能让Sakiyary 获得 3030% 的满意度，为了让产品能 100100% 使委托人满意，他需要你附加实现<strong>双人联机mod</strong>和<strong>奇幻之旅DLC</strong>。</p><hr><h3 id="实现要求-1"><a href="#实现要求-1" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>游戏的逻辑需要正确实现，例如挡板只能在一定的区域内移动，当小球从地图下边界离开时要重新发球，地图中所有砖块都被击碎后要结束游戏或进入下一关（刷新地图），挡板和砖块要能够反弹小球，砖块反弹小球后要判定其受到撞击，反弹的角度需要对称等等。</p><p>砖块的不同种类要能够区分（具体内容将在下面继续说明）</p><hr><h3 id="双人联机mod要求"><a href="#双人联机mod要求" class="headerlink" title="双人联机mod要求"></a>双人联机mod要求</h3><p>你需要使用socket网络编程实现两个客户端在同一局游戏中操控两个不同的挡板一起游戏，采用客户端、服务端二分的模式，因此你需要编写<strong>两个程序</strong>。</p><p>服务端：</p><ul><li>监听某个主机的某个端口</li><li>监听并应答来自客户端的连接和请求</li><li>维护游戏状态，包括两个玩家各自的挡板位置等，因此在多人模式下，你需要<strong>对两个玩家的挡板做出相应的区分</strong></li></ul><p>客户端：</p><ul><li>向服务端发起请求或通讯</li><li>维护游戏状态，包括小球的运动轨迹，地图的状态（此状态也可交由服务器维护，具体做法由你自己决定）等</li></ul><p>在联机游玩的两个客户端程序之间画面的延迟不能太高，状态要能够正确维护。</p><p>参考的思路是：服务端创建<strong>监听线程</strong>，每接收到一个消息，将其放入一个全局队列中，等待处理；另一个线程负责<strong>处理来自客户端的请求</strong>，while(1) 循环从队列中取一条消息，然后分析其中的内容。客户端创建与服务端连接的线程，负责<strong>与服务端进行通信</strong>；另一个线程，负责<strong>计算游戏进程和输出游戏图形</strong>。这里需要用到<strong>多线程</strong>，具体的做法请STFW&#x2F;RTFM，至于原因你不妨让服务端对某一种客户端请求一直不做应答试试看:D</p><p><strong>既然只是mod，你也需要支持单机游玩</strong>，毕竟 Corax 虽然不能双人成行，但是他单人也行，<strong>请注意你应该如何实现单机和联机两种模式，减少代码克隆的现象。</strong></p><hr><h3 id="奇幻之旅DLC要求"><a href="#奇幻之旅DLC要求" class="headerlink" title="奇幻之旅DLC要求"></a>奇幻之旅DLC要求</h3><p>你需要给砖块和小球附加不同的元素属性，砖块可以添加生命值属性（需要额外进行数次撞击才能彻底击碎），还需要添加一系列道具。</p><p>不同元素属性的砖块需要通过<strong>颜色</strong>来区分，例如红色代表火元素，深蓝色代表水元素，浅蓝色代表冰元素，紫色代表雷元素，黄色代表暂时还没有元素。</p><p>对于字符界面选手来说，可以使用自己喜欢的符号或画出的图形来代表小球和砖块，为了改变输出的字符颜色，你可以使用以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is white now. U&#x27;ll change it to red.\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is red now. U&#x27;ll change it again\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It turns back to white.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以尝试改变 <code>SetConsoleTextAttribute</code> 函数的第二个参数来获得不同的颜色。</p><p>tips：以上代码均仅适用于 Windows 操作系统环境，如果是 Linux&#x2F;macos 用户请自行 STFW&#x2F;RTFM，应该需要用到 UTF-8 字符集。</p><p>对于砖块和小球的元素属性，你可以设计丰富有趣的机制，小球的元素可以由<strong>上次与挡板相撞时挡板的元素属性</strong>来确定，玩家可以控制并改变挡板的元素属性。例如火元素与雷元素相遇会爆炸，对半径一定范围内的砖块全部造成一次攻击；水元素与雷元素、冰元素相遇会引发链式反应，导致相邻的水元素方块全部受到一次攻击；雷元素与冰元素相遇会强化小球，使其在下次与地图边界相撞并反弹前不会被砖块反弹；暂时无元素方块在被相应元素小球撞击后会附着上相应元素等等。</p><p>你需要设计一系列丰富有趣的道具，例如在地图下边界暂时生成防护墙保护小球不会离开地图，小球与挡板或砖块碰撞后生成额外的小球，挡板自身发射垂直向前的子弹攻击砖块等等，道具的触发条件也可以多种多样，可以由击碎砖块后随机触发，可以由击碎特殊砖块触发，也可以由当前小球击碎数个砖块后触发。</p><p>你可以从<a href="https://box.nju.edu.cn/f/636b2c46f0c240a08031/">链接中的视频</a>参考上述描述的具体实现。</p><hr><h3 id="评分标准-6"><a href="#评分标准-6" class="headerlink" title="评分标准"></a>评分标准</h3><p>打砖块本体占分比重 30%，奇幻之旅DLC占分比重 40%，双人联机mod占分比重 30%，后两者的分数<strong>依赖于打砖块本体</strong>，也即如果你只写了一个实现完美的联机mod你的分数也只会是 0 分</p><p>Corax 人工评判，以上三个模块实现每个模块内的要求基本正常即可得到各自模块内 80% 以上的分数（也可以通过前两项拿满分，第三项水一水来得到 80% 以上的分数）。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="https://oj.cpl.icu/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，没有 bug。（bug 太多会倒扣）</li><li>Corax 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>对于打砖块本体，能够实现挡板的普通速度和双倍速度移动，一定范围内的上下移动并根据与小球相撞时挡板的移动方向和速度改变小球的反弹方向（不要求严格按照物理规律，有<strong>不惊动牛顿棺材板</strong>的影响即可，当然如果能模拟真实物理情况也很好，你同样可以参考<a href="https://box.nju.edu.cn/f/636b2c46f0c240a08031/">链接中的视频</a>）加分。</li><li>对于奇幻之旅DLC，不同元素的反应和道具丰富有趣无bug，能够实现砖块生命值大于等于2时元素产生反应后自身附着元素消失，根据反应给周围的方块附着元素（例如水与雷的链式反应可能可以使与路径上的砖块相邻的砖块附着上雷元素等），并且小球与挡板发生的元素反应可以使小球的下次碰撞产生相应的反应（例如火球与雷元素挡板相撞并反弹后，下次与砖块相撞时引发爆炸等等，此时小球具有的反应状态应该在程序内对玩家可见）即可加分。（<strong>每一点都可以加分，不是全部实现才加分</strong>）</li><li>对于双人联机mod，能够实现游玩过程中两个客户端画面延迟非常小，多线程和要求中提到的问题完成较好即可加分。</li></ul><hr><h3 id="技术要求-4"><a href="#技术要求-4" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）。</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="提交方式-4"><a href="#提交方式-4" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="中国象棋"><a href="#中国象棋" class="headerlink" title="中国象棋"></a>中国象棋</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：肖江</p><p>验题人：肖江</p></blockquote><h3 id="项目概述-5"><a href="#项目概述-5" class="headerlink" title="项目概述"></a>项目概述</h3><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/278314">中国象棋</a>是一种起源于中国，历史悠久的棋类游戏。你需要实现一个双人联机对战的象棋游戏。</p><h3 id="实现要求-2"><a href="#实现要求-2" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>游戏的逻辑需要正确实现，比如各类棋子不能有非法移动，最终胜负判定能够正常进行</p><h3 id="联机要求"><a href="#联机要求" class="headerlink" title="联机要求"></a>联机要求</h3><p>你需要使用socket网络编程实现两个客户端在同一棋局内对弈的功能，采用客户端，服务端分离的模式，因此你需要实现<strong>两个程序</strong>。</p><p>你可以采取<a href="https://zhuanlan.zhihu.com/p/36884005">状态同步或者帧同步</a>的方式对客户端和服务端进行分工。</p><p>状态同步：棋盘的运算都发生在服务端，客户端只负责和用户交互</p><p>帧同步：棋盘的运算都发生在客户端，服务端只负责转发客户端动作消息到对手侧</p><p>在联机游玩的两个客户端程序之间画面的延迟不能太高，状态要能够正确维护。</p><p>参考的思路是：服务端创建<strong>监听线程</strong>，每接收到一个消息，将其放入一个全局队列中，等待处理；另一个线程负责<strong>处理来自客户端的请求</strong>，while(1) 循环从队列中取一条消息，然后分析其中的内容。客户端创建与服务端连接的线程，负责<strong>与服务端进行通信</strong>；另一个线程，负责<strong>计算游戏进程和输出游戏图形</strong>。这里需要用到<strong>多线程</strong>，具体的做法请STFW&#x2F;RTFM。</p><h3 id="额外功能"><a href="#额外功能" class="headerlink" title="额外功能"></a>额外功能</h3><p>你可以实现一部分额外功能以获得更高的分数，包括但不限于</p><ul><li>悔棋</li><li>倒计时</li><li>打赏&#x2F;催促对方<ul><li>“你这么菜你老师不会生气吧哥哥”</li><li>“每一盘都当最后一盘，然后也不要怕输”</li><li>“3,2,1，落子！”</li></ul></li><li>添加道具&#x2F;技能<ul><li>改变棋子的行为规则</li><li>改变整个棋局的状态，比如添加棋子，转换棋子等</li><li>可以参考<a href="https://www.bilibili.com/video/BV1cr4y1Q72G">万宁象棋</a></li></ul></li></ul><h3 id="评分标准-7"><a href="#评分标准-7" class="headerlink" title="评分标准"></a>评分标准</h3><p>原生象棋移动和胜负判定占分比重 60%，额外功能占分比重 15%，联机功能占分比重 20%，代码风格，项目组织占分比重 5%。</p><p>875C 人工评判，以上三个模块实现每个模块内的要求基本正常即可得到各自模块内 80% 以上的分数。</p><p>使用图形界面<strong>并不会得到更高的分数</strong>，若图形界面不符合要求或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><h2 id="技术要求-5"><a href="#技术要求-5" class="headerlink" title="技术要求"></a>技术要求</h2><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在<a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a>自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）。</li><li>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</li></ul><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h2 id="提交方式-5"><a href="#提交方式-5" class="headerlink" title="提交方式"></a>提交方式</h2><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile/ CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="落井大战"><a href="#落井大战" class="headerlink" title="落井大战"></a>落井大战</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：李薛成</p><p>验题人：李薛成</p></blockquote><h3 id="项目概述-6"><a href="#项目概述-6" class="headerlink" title="项目概述"></a>项目概述</h3><p>Downwell，是一款风靡全球的 <a href="https://baike.baidu.com/item/Roguelike/10973209">Roguelike</a> 竖版过关游戏，是一位日本音乐专业的大佬在大四折腾出来的小游戏。你可能从没听说过这款游戏，那么你可以从下面几个链接中初步了解一下：</p><p><a href="https://zhuanlan.zhihu.com/p/20589067">Downwell - 日本独立游戏佳作 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/26949872">《下井大战》的游戏性是你难以想象的 - 知乎</a></p><p>也可以上这款游戏的官网 <a href="https://downwellgame.com/">Downwell (downwellgame.com)</a> 购买&#x2F;下载体验，或者上 B 站看大佬的通关视频<a href="https://www.bilibili.com/video/BV1uE411j7ew/">视频链接</a>。</p><p><del>（速去 Steam 买！优惠只要 ￥4.5，1月6日0点结束！）</del></p><hr><h3 id="项目要求-3"><a href="#项目要求-3" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>首先我们要明确你需要做一个什么样的游戏出来。显然，如果你能模仿原作实现它的绝大部分功能，拿到满分应该很大。但我们还是来解构一下这款游戏的要素：</p><h3 id="基础要素"><a href="#基础要素" class="headerlink" title="基础要素"></a>基础要素</h3><ul><li>一位可以操控的主角，主角需要三种基础交互：左、右移动、跳跃&#x2F;向下射击。</li><li>一个竖版的地图（井），地图上随机生成有方块拼成的各种形状平台供主角落脚。</li><li>怪物们，可以是在墙上爬、在平台上爬、在空中飞、同时会或不会发射子弹攻击、带刺或不带刺的怪物。</li><li>主角在平台上时只能跳跃，在空中可以向下射击子弹，发射的同时获得一定的滞空，同时消耗弹夹中的子弹数量。弹夹需主角停留在平台上方可自动地逐渐地回满。</li><li>主角与怪物都有各自的血量，如主角有 4 格血、怪物有 8 格血，受到一次攻击就掉相应的血。</li><li>主角踩在不带刺的怪物上方可以对怪物造成伤害，踩在带刺的怪物身上会受到伤害。</li></ul><p>到这里，游戏最最基本的解构就完成了。</p><h3 id="Rougelike-要素"><a href="#Rougelike-要素" class="headerlink" title="Rougelike 要素"></a>Rougelike 要素</h3><p>但原作是 Rougelike 游戏，所谓肉鸽（Rougelike），首先是在一定固定规则上的随机，如随机地形、随机怪物，其次就是通过阶段性的随机奖励&#x2F;道具，来提升或改变角色的能力（攻击力、攻击方式、弹夹容量、血量、恢复力等等）。同时，地图并不是一图到底无限延伸，而是分为一个个关卡。怪物也会随着关卡层数（下降层数）变强，数量、种类更多、速度更快、攻击更猛。在关底（最后的关卡）有强力 Boss，打败 Boss 游戏就算通关。来解构一下这一部分的要素：</p><ul><li>随机性，地形随机生成，怪物（符合关卡难度的基础上）随机生成，道具随机生成等等。</li><li>要让主角变强，就要获得奖励&#x2F;道具。道具可由击杀怪物掉落，或者通过击杀怪物得到的货币来到随机生成的商店处购买（商店内道具随机生成）。这也使得主角需要更多的交互操作，如在商店中购买道具、开启主动技能等等。同时需要有货币机制。</li><li>关卡设计，如每次下降一定的单位长度就自动进入下一关，每过一关主角可以获得一些随机道具。关卡中的怪物需要体现递进，即越来越难。难度的提升可以体现在怪物活动方式、攻击方式上的不同与递进。</li><li>在关底设计 Boss，拥有独特的存在方式、活动方式与攻击方式，可以模仿上述视频中 Boss 的行为与机制。</li><li>通关机制，评分机制。</li></ul><p>那么 Rougelike 要素就差不多了，这只是一些粗浅的解构，但对本项目已经足够了。</p><hr><p>在初步解构完要素的基础上，开始提出具体的要求：</p><ul><li>和<a href="https://oj.cpl.icu/contest/34/problem/156">小恐龙🦖（dino）</a>中大部分要求基本相同。</li><li>地图中随机平台的生成，不能完全堵住路，也不能太过散乱。</li><li>子弹（我方或敌方）的路线设计（直线、曲线、跟踪）与内存管理。</li><li>至少实现三种不同机制的怪物（如只爬动不攻击、爬动且带刺、只飞行不攻击）。</li><li>合理的碰撞判定与扣血机制。</li><li>弹夹消耗与补充机制，发射子弹时主角的滞空机制。</li><li>关于 Rougelike 要素的具体要求全凭你自己的理解，随意发挥即可。</li></ul><hr><h3 id="评分标准-8"><a href="#评分标准-8" class="headerlink" title="评分标准"></a>评分标准</h3><p>Sakiyary 人工评判，正确实现<strong>基础要素</strong>与其相关的具体要求即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong> ，若图形界面不符合<a href="https://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会 <strong>倒扣</strong> ）</li><li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现 Rougelike 要素的相关功能与具体要求。</li><li>模拟出原作的更多机制与游戏性。（不是贴图，是游戏机制）</li><li>在不改变原有游戏性的前提下，实现超出原作的合理的扩展功能。</li><li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li></ul><hr><h3 id="技术要求-6"><a href="#技术要求-6" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="提交方式-6"><a href="#提交方式-6" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="滑雪冒险"><a href="#滑雪冒险" class="headerlink" title="滑雪冒险"></a>滑雪冒险</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：李薛成</p><p>验题人：不知道</p></blockquote><h3 id="项目概述-7"><a href="#项目概述-7" class="headerlink" title="项目概述"></a>项目概述</h3><p>好耶，是滑雪大冒险！这款游戏的 BGM 应该耳熟能详吧，不熟也不要紧，我们直接来看 B 站大佬的魔改版👉 <a href="https://www.bilibili.com/video/BV1VK411R7BM/">我做了个滑雪大冒险，但是纳西妲！</a></p><hr><h3 id="项目要求-4"><a href="#项目要求-4" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。（等一下，这道题真的能用字符界面吗？）</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>首先我们要明确你需要做一个什么样的游戏出来。显然，如果你能模仿原作实现它的绝大部分功能，拿到满分应该很大。但我们还是来解构一下这款游戏的要素：</p><h3 id="基础要素-1"><a href="#基础要素-1" class="headerlink" title="基础要素"></a>基础要素</h3><ul><li>一位可以操控的主角，主角只需要一种交互：跳跃。</li><li>一个无限延伸山坡，作为地图。</li><li>追赶主角的雪崩，随分数升高速度逐渐增大（小幅度）。</li><li>主角的“装备”们（如雪橇、企鹅、雪怪、摩托、鹰等）</li><li>坡道上的障碍物（石块），碰到障碍物时，若主角无装备，则摔倒；若有装备，则按一定的顺序掉一件装备。</li></ul><p>到这里，游戏最最基本的解构就完成了。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>这个游戏其实有几个难点，如山坡的生成、雪崩跟着山坡的滑动、装备们的组合等。</p><ol><li>山坡可以是固定的斜着的波浪线，也可以是随机参数的线性函数的平滑拼接。</li><li>雪崩甚至可以直接用一个长方形来模拟，意思到了就行，也可以将雪崩精细地实现为随山坡滑动的有宽度（高度？）的曲线。</li><li>装备的组合首先是视觉上的位置关系，其次就是你想将这个实现到哪种程度，粗糙一些也可以，十分精细也可以。</li></ol><p>实现全看自己的想法，但是给分也会根据你实现各难点的方式与难度来评判。</p><hr><p>在初步解构完要素的基础上，开始提出具体的要求（<strong>基础版</strong>）：</p><ul><li>和<a href="https://oj.cpl.icu/contest/34/problem/156">小恐龙🦖（dino）</a>中大部分要求基本相同。</li><li>地图中坡道的生成，曲线要有起伏，不能有断崖或太多的小疙瘩。（可以用固定模式生成）</li><li>随分数增长不断加速的追赶主角的雪崩。（可以用简单的图形模拟）</li><li>随机出现的障碍物。（如大大小小的石头）</li><li>“装备”们的运动，至少实现三种装备，且能以合理的不同的方式各自组合。</li><li>合理的碰撞判定与穿装备&#x2F;掉装备&#x2F;摔倒机制。</li></ul><hr><h3 id="评分标准-9"><a href="#评分标准-9" class="headerlink" title="评分标准"></a>评分标准</h3><p>不知道谁人工评判，正确实现<strong>基础版</strong>要求（即用最简单的方式完成各个难点）即可得到 8080% 以上的分数。</p><p>（不好意思，这道题我真不知道字符界面怎么做……）</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会 <strong>倒扣</strong> ）</li><li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>将上述三个难点用精细的方式实现。</li><li>模拟出原作的更多机制与游戏性。（不是贴图，是游戏机制）</li><li>在不改变原有游戏性的前提下，实现超出原作的合理的扩展功能。</li><li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li></ul><hr><h3 id="技术要求-7"><a href="#技术要求-7" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><hr><h3 id="提交方式-7"><a href="#提交方式-7" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="内存文件系统"><a href="#内存文件系统" class="headerlink" title="内存文件系统"></a>内存文件系统</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>出好实验要求了。本题由 OJ 进行自动测试，OJ 最大的特点就是严格，不能蒙混过关了。</p><p><a href="https://box.nju.edu.cn/f/0dd09ebfbbb3457fbaad/">实验要求（简单版）</a> 请查看群文件的最新版。部分测试用例也在群文件中。</p><p>推荐使用 linux，git，make。可以先尝试着提交，任何问题请提出。</p><p>Windows 上的提交不能用 make submit。你需要手动将你的目录下的 <strong>.git 文件夹</strong>压缩成 zip 手动在 OJ 那里上传。</p><p>按时提交即得 20 分诚信分。（与 gitm 一样）前言</p><p>这可能是大家第一次做类似的工作：你不是编写一个完整的程序，而是按照要求实现一些函数。这些函数将会被我们调用，以检测是否实现了所要求的功能。</p><p><strong>本要求为（基本上是）最终版本。其中重要的描述修正将以这样的形式标出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+++ 这里是修改过的描述，请注意检查 +++</span><br></pre></td></tr></table></figure><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>文件系统是操作系统的重要组成部分。调用文件系统 api，我们可以轻松地将数据持久化到磁盘上。C 语言中为我们提供了一组 api，它们基于操作系统 api，允许我们对文件进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Linux 操作系统中，上述的 C 文件操作 api 是基于一组操作系统的文件 api 实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现要求你实现一个内存文件系统（ramfs）。顾名思义，这个文件系统的所有数据并不持久化到磁盘上，而是保存到内存当中，是一个易失性的文件管理系统。</p><h3 id="文件系统的约定"><a href="#文件系统的约定" class="headerlink" title="文件系统的约定"></a>文件系统的约定</h3><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><p>Ramfs 的目录结构与 Linux 的树形结构一致。在初始状态下，只存在根目录 “&#x2F;“。文件系统中存在两类对象，目录与文件。目录下可以存放其他对象，而文件不可以。即在树形结构中，文件只能是叶子节点。</p><p>例 (#)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── 1.txt            &quot;/1.txt&quot;</span><br><span class="line">├── 2.txt            &quot;/2.txt&quot;</span><br><span class="line">└── dir              &quot;/dir&quot;</span><br><span class="line">    ├── 1.txt        &quot;/dir/1.txt&quot;</span><br><span class="line">    └── 2.txt        &quot;/dir/2.txt&quot;</span><br></pre></td></tr></table></figure><p>可以看到，在根目录下一共有 3 个项目：两个文件，一个目录 dir，而 dir 下还可以拥有两个文件。右侧的字符串称为对象的“绝对路径”。</p><p>单个文件和目录名长度 &lt;&#x3D; 32 字节，</p><h6 id="修订1"><a href="#修订1" class="headerlink" title="修订1"></a>修订1</h6><p>+++ <strong>是字母、数字、英文句点的任意组合。例如，’.’ 不是当前目录，’..’ 也不是上级目录</strong> +++</p><p>对于存在<strong>不合法文件名</strong>的路径，你的文件系统 api 应当统一通过返回 -1 来拒绝此类操作。</p><p>所有 api 调用中，路径长度 &lt;&#x3D; 1024 字节。（也就是说，文件系统的路径深度是存在上限的）。</p><p>文件系统 api 统一使用绝对路径，即以 ‘&#x2F;‘ 开头。在未创建任何文件时，就已经存在 “&#x2F;“ 指向的根目录。该目录可打开，不可删除，其余性质与一般目录一致。</p><h4 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h4><p>整个文件系统同时存在的所有文件内容不会超过 512 MiB（不含已经删去的文件和数据），给予 1GiB 的内存限制。</p><p>同时存在的文件与目录不会超过 65536 个。</p><p>同时活跃着的文件描述符不会超过 4096 个。</p><p>对于所有数据点，文件操作读写的总字节数不会超过 10GiB。时限将给到一个非常可观的量级。</p><p>各数据点的性质：</p><ol><li><p>如原始的 main.c</p></li><li><p>根目录下少量文件创建 + ropen + rwrite + rclose</p></li><li><p>在 2 的基础上，测试 O_APPEND，rseek</p></li><li><p>在 3 的基础上扩大规模</p></li><li><p>少量子目录创建（&lt;&#x3D; 5 层）+ 文件创建与随机读写</p></li><li><p>在 5 的基础上，测试 rrmdir, runlink。</p></li><li><p>大文件测试。多 fd 对少量大文件大量读写 + rseek + O_TRUNCATE</p></li><li><p>复杂的文件树结构测试。大量的 O_CREAT，rmkdir, rrmdir, runlink。少量读写</p></li><li><p>文件描述符管理测试。大量 ropen、rclose，多 fd 单文件</p></li><li><p>综合场景的大型测试。模拟真实的系统。</p></li></ol><p>错误将会分散在各个数据点中。你需要保证你的 API 能正确地判断错误的情况并按照要求的返回值退出。</p><p>如果你获得 ”Wrong Answer“，说明仅仅是程序行为与 API 不一致。如读写的结果不正确，应该打开失败的文件却成功了…</p><p>如果获得 ”Runtime Error”，说明你的程序会出现运行错误而 crash。比如你在遍历文件树时，解引用了空指针…</p><h4 id="接口简述"><a href="#接口简述" class="headerlink" title="接口简述"></a>接口简述</h4><p>我们要求你实现如下的 api，以实现文件系统的管理。其具体行为将会在 api 说明部分阐释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>注意，我们要求你实现的是内存操作系统。故你的程序应当使用内存管理 api（malloc、free）来存放文件所需的数据结构，以及文件的所有内容。请小心地管理好内存注意不要超限。</p><h3 id="开始你的项目"><a href="#开始你的项目" class="headerlink" title="开始你的项目"></a>开始你的项目</h3><p>我们为你准备了一个 git repo。请基于这个 git repo 进行你的项目。如果你不会 git，请学着使用。</p><p>在 git repo 中我们为你提供了一个自动编译脚本 Makefile。并且为你配置好了记录自动追踪。请不要随意修改 Makefile。你的修改记录将成为查重时证明独立完成的重要证据。</p><p>推荐在 Linux 操作系统中完成本作业。如果你要使用 Windows，产生的问题由你自己解决。</p><p>获取代码框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://git.nju.edu.cn/Tilnel/ramfs.git&quot;</span></span><br></pre></td></tr></table></figure><p>注意：请在默认的 master 分支上进行开发。最终 OJ 的评分也将以你的 master 分支为准。</p><p><strong>你应当在 ramfs.c 中包含你的所有实现</strong>（包括指定的函数和你使用的所有数据结构）。评测机会用我们自己的 Makefile（和分发版本一致）、ramfs.h（和分发版本一致）、main.c（包含更强力的测试用例）进行编译运行。因此你对 ranfs.h 和 main.c 以及 Makefile 的修改在 OJ 上不会产生效果。</p><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make submit TOKEN=<span class="variable">$&#123;你的token&#125;</span></span><br></pre></td></tr></table></figure><p>请在题目中“打开代码编辑器”后，获取你的提交 token。注意在校园网环境下提交。然后你就能在提交列表中看到你的提交。</p><blockquote><p>由于服务器现可以通过 public.oj.cpl.icu 访问，你可以对 Makefile 中 submit 目标下的 url 进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@ -25,5 +25,5 @@ submit:</span><br><span class="line">     @cd .. &amp;&amp; zip -qr $&#123;FILE&#125; $&#123;BASE&#125;/.git</span><br><span class="line">     @echo &quot;Created submission archive $&#123;FILE&#125;&quot;</span><br><span class="line">     @curl -m 5 -w &quot;\n&quot; -X POST -F &quot;TOKEN=$&#123;TOKEN&#125;&quot; -F &quot;FILE=@$&#123;FILE&#125;&quot; \</span><br><span class="line">-               https://oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">+               http://public.oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">        @rm -r $&#123;TEMP&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意在 make submit 之前，你需要将最新的改动 commit。同样注意保持你的工作目录整洁，如果你的 git repo 超过 20MiB（这一定是因为你放了很多很多奇怪的玩意），则没有办法提交。</p><p>你的 git repo 中不应当包含各种形式的编译产生的中间文件、编译结果。我们的 Makefile 只会在 build 目录下产生文件，我们也会配置好 .gitignore 文件避免 track 这些文件。</p><h3 id="API-手册"><a href="#API-手册" class="headerlink" title="API 手册"></a>API 手册</h3><h6 id="修订2"><a href="#修订2" class="headerlink" title="修订2"></a>修订2</h6><p>+++ <strong>你的实现不应当有任何输出</strong> +++</p><p>以下注意区分两种对象的定义：文件（file），目录（directory）。</p><p>另一个重要的对象是：文件描述符（file descriptocr），简称 FD。它是所有<strong>打开的文件和目录的指示符</strong>，为一个非负整数。在 Windows 操作系统中称之为“句柄”。我们使用路径打开一个文件或目录，操作系统就会为这一次文件的打开分配一个文件描述符，它就像是一个“把手”一样。我们用这个文件描述符来指示打开的文件，进行对文件的操作。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);  <span class="comment">// open 返回一个文件描述符</span></span><br><span class="line">read(fd, buf, <span class="number">5</span>);                   <span class="comment">// 从打开的 fd (/1.txt) 中读取五个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><h6 id="修订3"><a href="#修订3" class="headerlink" title="修订3"></a>修订3</h6><p>+++ 打开 ramfs 中的<strong>文件或目录</strong>。如果成功，返回一个文件描述符（一个非负整数），用于标识这个对象。+++</p><p>如果打开失败，则返回一个 -1。</p><p>pathname 为一个字符串，为一个绝对路径。<strong>对于所有存在的文件和目录，你的 ropen 调用都应当成功</strong>。特别地，在指示一个目录时，pathname 的末尾可以有多余的 ‘&#x2F;‘。pathname 中间同样可以有冗余的 ‘&#x2F;‘。</p><p>例如，在上文的例 (#) 中，以下的绝对路径是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dir/        =/dir</span><br><span class="line">////dir       =/dir</span><br><span class="line">/1.txt        =/1.txt</span><br><span class="line">//dir/1.txt   =/dir/1.txt</span><br></pre></td></tr></table></figure><p>以下的绝对路径是不存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/3.txt</span><br><span class="line">/1.txt/       (文件路径后不可以有多余的&#x27;/&#x27;)</span><br><span class="line">/di/r/1.txt   (不存在这个路径)</span><br></pre></td></tr></table></figure><p>flag 指示打开方式，这些打开方式仅对<strong>文件</strong>起作用。如果被打开的是目录则自动忽略。其取值有如下可能（或可以是它们的组合）：</p><p>注意，在 C 中，以 0 开头的数字采用 8 进制表示法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND  02000 以追加模式打开文件。即打开后，文件描述符的偏移量指向文件的末尾。若无此标志，则指向文件的开头</span><br><span class="line">O_CREAT   0100 如果 pathname 不存在，就创建这个文件，但如果这个目录中的父目录不存在，则创建失败；如果存在则正常打开</span><br><span class="line">O_TRUNC   01000 如果 pathname 是一个存在的文件，并且同时以可写方式 (O_WRONLY/O_RDWR) 打开了文件，则文件内容被清空</span><br><span class="line">O_RDONLY  00 以只读方式打开</span><br><span class="line">O_WRONLY  01 以只写方式打开</span><br><span class="line">O_RDWR    02 以可读可写方式打开</span><br></pre></td></tr></table></figure><p>这些标志位的组合方式是使用按位的或运算。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_TRUNC | O_RDWR   (可读可写，打开时清空)</span><br><span class="line">+++ O_CREAT | O_WRONLY (若不存在，创建后以只写方式打开；否则以只写方式直接打开) +++ （原来写成读写了）</span><br><span class="line">+++ O_APPEND   (文件描述符的偏移量指向文件末尾，并可读) +++</span><br></pre></td></tr></table></figure><h6 id="修订8"><a href="#修订8" class="headerlink" title="修订8"></a>修订8</h6><p>+++ O_TRUNC 但文件以只读方式打开时，在 Linux 中为 unspecified 行为。此处约定为正常只读打开而不清空。 （1.15 聊天记录）+++</p><h6 id="修订4"><a href="#修订4" class="headerlink" title="修订4"></a>修订4</h6><p>+++ 注意点：+++</p><p>+++ <code>O_RDWR | O_WRONLY</code> 共同存在时，取只写的语义； +++</p><p>+++ 由于 <code>O_RDONLY</code> 是 0，因此若未指定任何读写方式时，默认是只读的； +++</p><p>+++ 同时，易得 <code>O_RDONLY | O_WRONLY == O_WRONLY</code>。因此组合只读只写得到的结果是只写。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭打开的文件描述符，并返回 0。如果不存在一个打开的 fd，则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>向 fd 中的<em><strong>偏移量</strong></em>（马上解释）位置写入以 buf 开始的至多 count 字节，覆盖文件原有的数据。如果 count 超过 buf 的大小，仍继续写入（数据保证不因此而产生段错误），将 fd 的<em><strong>偏移量</strong></em>后移 count，并返回实际成功写入的字节数。如果写入的位置超过了原来的文件末尾，则自动为该文件扩容。</p><p>如果 fd 不是一个可写的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>在本实验中，ramfs 中同时存在的文件大小不会超过限制。因此你的 rwrite 对于一个能够写入的文件，事实上总应返回 count。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>从 fd 中的<em><strong>偏移量</strong></em>位置读出至多 count 字节到 buf 指向的内存空间当中，</p><h6 id="修订5"><a href="#修订5" class="headerlink" title="修订5"></a>修订5</h6><p>+++ 将<em><strong>偏移量</strong></em>后移实际读出的字节数，并返回实际读出的字节数。+++</p><p>因为可能会读到文件末尾，因此返回值有可能小于 count。</p><p>如果 fd 不是一个可读的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><h4 id="偏移量（offset）"><a href="#偏移量（offset）" class="headerlink" title="偏移量（offset）"></a>偏移量（offset）</h4><p>想象你用手指指着读一本书，offset 相当于你手指指向的位置。你每读一个字，手指就向前前进一个字；如果你想改写书本上的字，每改写一个字，手指也向前前进一个字。</p><p>每一个文件描述符都拥有一个偏移量，用来指示读和写操作的开始位置。这个偏移量对应的是文件描述符，而不是“文件”对象。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/1.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);</span><br><span class="line">write(fd1, <span class="string">&quot;helloworld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">read(fd2, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h6 id="修订6"><a href="#修订6" class="headerlink" title="修订6"></a>修订6</h6><p>--- 此时 buf 中将从文件的开头读到”hello\0”。但如果换一种方式： ---  </p><p>+++ 此时 buf 中将从文件的开头读到”hellow”。但如果换一种方式： +++</p><p>假设 “&#x2F;1.txt” 中原来有数据 “helloworld\0”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDWR);</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">read(fd, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时，write 在读取时，将文件指针前移了 5 个字节。于是read在读取的时候，将会从第6个字节开始读取。也即，read 将会读到 “world\0”。对于同一个文件描述符，读取和写入操作是共享偏移量的；对于不同的文件描述符，它们的偏移量则是各自独立的。</p><p>对于 open 操作，如果没有 O_APPEND 标志来将偏移量指向末尾，那么默认指向文件开头。</p><p>如何自由地修改和获取文件描述符的偏移量呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于修改 fd 表示的文件描述符的偏移量，并返回当前文件的实际偏移量。</p><p>whence有三种取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEEK_SET 0   将文件描述符的偏移量设置到 offset 指向的位置</span><br><span class="line">SEEK_CUR 1   将文件描述符的偏移量设置到 当前位置 + offset 字节的位置</span><br><span class="line">SEEK_END 2   将文件描述符的偏移量设置到 文件末尾 + offset 字节的位置</span><br></pre></td></tr></table></figure><p>rseek 允许将偏移量设置到文件末尾之后的位置，但是并不会改变文件的大小，<strong>直到它在这个位置写入了数据</strong>。在 超过文件末尾的地方写入了数据后，原来的文件末尾到实际写入位置之间可能出现一个空隙，我们规定应当以 “\0” 填充这段空间。</p><p>+++ 但不允许将偏移量设置到文件开头之前，也就是一个负数的绝对偏移量。这种情况下返回 -1。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>创建目录，成功则返回 0。如果目录的父目录不存在或此路径已经存在，则失败返回 -1。</p><p>如，原来系统中只存在根目录 “&#x2F;“，调用：<code>rmkdir(&quot;/path/to/dir&quot;)</code> 返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个空目录，成功则返回 0。如果目录不存在或不为空，或 pathname 指向的不是目录，返回 -1。测试保证不对打开的 pathname 做 rrmdir。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个文件，成功则返回 0。如果文件不存在或 pathname 指向的不是文件，则返回 -1。测试保证不对打开的 pathname 做 runlink。</p><p>额外的一个 api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_ramfs();</span><br></pre></td></tr></table></figure><p><strong>可以</strong>用于初始化你的文件系统。比如创建根目录。我们用于测试的 main() 将总会包含它。（要在里面做什么取决于你自己！）</p><p>我们的测试用例长什么样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* our main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();     <span class="comment">// 你的初始化操作</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/dir&quot;</span>) == <span class="number">0</span>);   <span class="comment">// 应当成功</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;//dir&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为目录已存在</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/a/b&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为父目录不存在</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  assert((fd = ropen(<span class="string">&quot;//dir///////1.txt&quot;</span>, O_CREAT | O_RDWR)) &gt; <span class="number">0</span>);  <span class="comment">// 创建文件应当成功</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 应当完整地写入</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_CUR) == <span class="number">5</span>);  <span class="comment">// 当前 fd 的偏移量应该为 5</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">0</span>);  <span class="comment">// 应当成功将 fd 的偏移量复位到文件开头</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(rread(fd, buf, <span class="number">7</span>) == <span class="number">5</span>);   <span class="comment">// 只能读到 5 字节，因为文件只有 5 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>);   <span class="comment">// rread 应当确实读到 &quot;hello&quot; 5 个字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">3</span>, SEEK_END) == <span class="number">8</span>);  <span class="comment">// 文件大小为 5，向后 3 字节则是在第 8 字节</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 再写 5 字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">5</span>, SEEK_SET) == <span class="number">5</span>);  <span class="comment">// 将偏移量重设到 5 字节</span></span><br><span class="line">  assert(rread(fd, buf, <span class="number">8</span>) == <span class="number">8</span>);   <span class="comment">// 在第 8 字节后写入了 5 字节，文件大小 13 字节；那么从第 5 字节后应当能成功读到 8 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0world&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>); <span class="comment">// 3 字节的空隙应当默认填 0</span></span><br><span class="line">  assert(rclose(fd) == <span class="number">0</span>); <span class="comment">// 关闭打开的文件应当成功</span></span><br><span class="line">  assert(rclose(fd + <span class="number">1</span>) == <span class="number">-1</span>); <span class="comment">//关闭未打开的文件应当失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="修订7"><a href="#修订7" class="headerlink" title="修订7"></a>修订7</h6><p>+++ 我们将会在这份手册的最后，提供几份测试代码供大家参考。大家可以将这些代码放到你的 <code>main.c</code> 中，并使用 <code>make run</code> 进行测试。+++</p><h3 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h3><p>首先是目录树。这里给出一个参考的文件对象结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FILE_NODE, DIR_NODE &#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">dirents</span>;</span>  <span class="comment">// if it&#x27;s a dir, there&#x27;s subentries</span></span><br><span class="line">    <span class="type">void</span> *content;         <span class="comment">// if it&#x27;s a file, there&#x27;s data content</span></span><br><span class="line">    <span class="type">int</span> nrde;              <span class="comment">// number of subentries for dir</span></span><br><span class="line">    <span class="type">int</span> size;              <span class="comment">// size of file</span></span><br><span class="line">    <span class="type">char</span> *name;            <span class="comment">// it&#x27;s short name</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p>目录的子项的数量会变化；文件的内容大小也会变化。因次我们可能需要对 <code>dirents</code> 或 <code>content</code> 的内存大小进行动态的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>这一函数会创建一段新的空间，将原来的内容复制到新的空间上，并释放原来的指针。注意原有指针一定也是动态分配的。</p><p>其次是文件描述符。对于文件描述符来说，其重要的只有这几个属性：读写性质，偏移量，指向的实际文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FD</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    node *f;</span><br><span class="line">&#125; FD;</span><br></pre></td></tr></table></figure><p>最初的根文件可以直接定义成全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node root;</span><br></pre></td></tr></table></figure><p>然后在 <code>init_ramfs</code> 中进行初始化。</p><p>接下来的事情，就很显然了：</p><p>添加文件和目录，就是往树里添加节点；</p><p>删除文件，就是删除节点；</p><p>读取内容，就是从 content 里复制出一段…</p><p>一个小建议：使用 <code>memcpy</code> 而不是 <code>strcpy</code>。（区别在哪？读手册）</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>第一个数据点已经给出。</p><p>test2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">notin</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[i] == fd) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">genfd</span><span class="params">(<span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (notin(i, fds, n))</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();</span><br><span class="line">  <span class="type">int</span> fd[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(ropen(<span class="string">&quot;/abc==d&quot;</span>, O_CREAT) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_RDONLY)) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    assert(rwrite(fd[<span class="number">0</span>], <span class="string">&quot;\0\0\0\0\0&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">1</span>], <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">2</span>], <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">3</span>], <span class="string">&quot;\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  assert(rclose(genfd(fd, <span class="number">4</span>)) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0\0\0\0\0\0\0\0&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hellohello&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;worldworld&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x001\x002\x003\x0fe\x0ff\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他的请再等等吧（</p><p>2023.1.14 补：</p><p>上线了测试点 4，在 main() 的开头做了一件事：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rread(<span class="number">-100000000</span>, buf, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>所有人都炸掉了。但按照手册，它应该返回 -1。这只是测试中不合理数据的一角，请大家保证自己的实现的可靠性。</p><p>如果你对某些特例会产生什么行为抱有疑问，欢迎提问。</p><h6 id="修订9"><a href="#修订9" class="headerlink" title="修订9"></a>修订9</h6><p>+++ 再次强调请小心地管理内存，否则内存容易超限，特别是注意释放掉已经不用的空间。</p><p>+++ OJ 评测结果解释：</p><p>+++ 答案错误：你的函数行为与规定的行为不一致。可能是文件系统中的内容不一致，也可能是函数返回值不符合约定。</p><p>+++ 运行错误：你的函数在内部崩溃了。</p><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://box.nju.edu.cn/f/8ef6cedb59de48f8a0b7/">实验要求</a> 请看群文件最新版。</p><p>项目框架将发布在 <a href="https://git.nju.edu.cn/Tilnel/gitm.git">https://git.nju.edu.cn/Tilnel/gitm.git</a></p><p><del>目前题目只有一个样例，直接交就是一伯分</del>。但我出好数据之后会重新评测。</p><p>有一个送分样例。正确按时提交保底 20 分。</p><p>Windows 上的提交不能用 make submit。你需要手动将你的目录下的 .git 文件夹压缩成 zip 手动在 OJ 那里上传。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>git 是当今世界上最流行的版本控制系统。本实验要求你通过提交 git repo 的方式来提交一个迷你版的命令行工具 gitm(inus)。</p><p><strong>注意：本实验将只能在 Linux 操作系统中完成</strong>，因为你不得不使用系统调用，而 OJ 是 Linux 的。提交 Windows 上可以编译运行的代码，在评测机上注定不可兼容。</p><p>首先，你需要学习 git ，否则你将完全不明白 gitm 的功能，并且也无法用 git 来管理本次作业的代码。</p><blockquote><p>是的！我们将会发布一个由 git 管理的框架代码，并且要求你一直使用 git 来管理，最终提交一个 git repo。</p></blockquote><p>获取框架代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.nju.edu.cn/Tilnel/gitm.git</span><br></pre></td></tr></table></figure><h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><p>所有代码，包括 .c 和 .h 文件需要放在 git repo 的根目录下。对自己使用的头文件的引用请以双引号的形式，以便编译脚本能够正常工作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitm</span><br><span class="line">├── gitm.c</span><br><span class="line">├── gitm.h</span><br><span class="line">├── whateveryouwant.c</span><br><span class="line">├── whateveryouwant.h</span><br><span class="line">├── ...</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">/* gitm.c */</span><br><span class="line">#include &quot;gitm.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可以修改 Makefile，但请不要删除其中的 git 目标依赖。我们在 Makefile 中确保了你的每一次编译运行都能够自动进行 git commit。这些自动的 commit 可以帮助你回滚到自己想要的任意版本，并且在未来查重工作中产生疑问时，良好的 commit 记录将成为重要的证明。</p><p>在你的 git repo 里请包含所有编译所需的源文件，但不要出现编译不需要的多余的源文件。</p><p>尝试编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>你将看到根目录下产生了一个名为 gitm 的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gitm version</span><br></pre></td></tr></table></figure><p>你将看到一个小彩蛋（你之后可以自由地删掉它或修改掉，不影响成绩）。</p><p>注意：本次实验你编写的是一个 “命令行工具”。也就是说，我们将以和使用 git 相同的方式来使用它：在命令行里输入命令和参数。这意味着，这次你需要真正 “解析参数” （被 parse.c 支配的恐惧）。</p><p>而且，这次我们将会在运行中多次调用你的程序。也就是说，你的程序并不是在一直运行着，每一次调用都会做不同的事。你存储在内存里的数据都将随着功能完成，进程结束而消失。所以，关于 gitm repository 的有用的信息，你需要将它们持久化到磁盘上，以便进行后续的操作。因此学习 C 语言的文件操作是必不可少的。</p><p>为了实现一个 git，首先你要了解 git 的功能</p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>假设我们当前在一个文件夹 dir 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm init</span><br></pre></td></tr></table></figure><p>初始化当前的 dir 为一个 gitm repository。如果当前 dir 已经是一个 gitm repo，则不做任何操作。</p><p>此时的 gitm 中应当不存在任何 commit，gitm 的仓库中应不存在任何文件。</p><p>具体来说，你可以在当前目录下创建一个 <code>.gitm</code> 目录，用于存放一些记录仓库状态的文件。</p><blockquote><p>对，就像 git 的 .git 那样！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm commit</span><br></pre></td></tr></table></figure><p>将当前仓库中文件改动后状态作为一个提交，并记录下来。然后不重复地给出一个长度为 8 的小写十六进制数（例如 3bdc8902），用于唯一地指示这一次 commit。</p><p>git 中的提交是一个树形的结构。我们希望你在 gitm 中，同样实现这样的树形结构。</p><img src="git-brance.svg" alt="img" style="zoom: 100%;"><p>gitm 中不要求实现对分支的命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout commit</span><br></pre></td></tr></table></figure><p>checkout 用于将当前目录的状态切换到 commit 所指示的提交上。</p><p>若当前目录的状态较 gitm <strong>当前所处的 commit</strong> 有改动，则拒绝本次 checkout，并且<strong>你的 main() 函数以返回值 1 退出</strong>。</p><p>checkout 正常完成后，你目录中文件的状态（除了 .gitm 目录以外）必须与指定的 commit 相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout .</span><br></pre></td></tr></table></figure><p>特殊地，这一条命令用于将目录文件恢复到当前所处的 commit 时的状态。也就是说，放弃此时对文件的所有改动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm merge commit</span><br></pre></td></tr></table></figure><p>找到当前所处 commit 与命令指定的 commit 的公共祖先，并将两个 commit 合并起来。</p><p>具体来说，是将命令指定的 commit 相对于公共祖先的修改，应用于当前所处的 commit。</p><p>如果合并的两个 commit 相对于公共祖先，均对同一个文件产生了修改（创建、删除、编辑），那么命令直接拒绝执行，输出 “conflict\n” <strong>并使 main 函数返回 1</strong>。</p><p>在其他情况下，你需要合并，并产生一个新的 commit。逻辑上，这个 commit 将成为被合并的两个 commit 的共同后继。</p><blockquote><p>我们如何检测这一点？</p><p>假设有 commit a-g，b, c 由 a 分支而来，d 由 b, c 合并而来，e 是 b 的后继，f 是 c 的后继，g 是 d 的后继。</p><p>你的程序应当有能力找到 e, g 的公共祖先是 b，f, g 公共祖先是 c，在此基础上合并是无冲突的。如果你只能找到 a，则合并有可能产生冲突，因为 e 相对 a 改变了 a.c，而 g 相对 a 也改变了 a.c。</p></blockquote><img src="image-20230103113625830.png" alt="image-20230103113625830" style="zoom: 67%;"><h3 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h3><p>我们会将你的 repo 里所有的 C 源文件和头文件收集起来进行编译，并生成一个名为 <code>gitm</code> 的可执行文件。然后原地创建一个文件夹，作为你的 gitm 需要管理的 repository。例如（其中 &gt; 开头的行表示命令行输出）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line">../gitm init</span><br><span class="line">../gitm commit</span><br><span class="line">&gt; 3bce5ff0                       <span class="comment"># 空 commit，我们的 OJ 一定会创建一个空 commit 作为第一个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt   <span class="comment"># 创建文件并写入</span></span><br><span class="line">../gitm commit</span><br><span class="line">&gt; b926d817</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is my git&quot;</span> &gt; readme.txt</span><br><span class="line">../gitm checkout 3bce5ff0</span><br><span class="line">&gt; You<span class="string">&#x27;ve made change. Please commit or garbage your change.</span></span><br><span class="line"><span class="string">echo $?                          # 给出上一条命令的返回值。正常退出的程序应当为 0</span></span><br><span class="line"><span class="string">&gt; 1</span></span><br><span class="line"><span class="string">../gitm commit</span></span><br><span class="line"><span class="string">&gt; ef938aa6</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt readme.txt .gitm</span></span><br><span class="line"><span class="string">../gitm checkout b926d817</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt .gitm</span></span><br></pre></td></tr></table></figure><p>随着时间的流逝，我将会发布进一步的实验指南。</p><h3 id="实现要求-3"><a href="#实现要求-3" class="headerlink" title="实现要求"></a>实现要求</h3><ul><li>你创建的所有文件都要放到运行目录的 .gitm 目录下。<ul><li>+++ 对目录的体积要求：不要每一次都追踪没有发生变化的文件即可。不需要对每个文件进行增量存储。 +++</li></ul></li><li>commit 数量不会超过 10000 个。</li><li>你的 gitm 只需要管理文本类型的文件。其他类型的文件不会出现。</li><li>不要求追踪空目录</li></ul><p>本实验的测试点预计如下：</p><p>1、hello world（保留 gitm version 的打印信息即得分）</p><p>2、和上面的脚本相似的一段小测试，基础功能</p><p>3、文件数量增加，提交数量增加；但并不会出现子目录</p><p>4、在 3 的基础上，有一定的目录结构</p><p>5、在 4 的基础上，测试 merge 功能（不会很刁钻，只要该拒绝的拒绝，该成功的 merge 对就行了）</p><p>6、测试 .gitm 的空间管理，<strong>要求未发生改动的文件不重复存储，不要求单文件的增量存储</strong></p><p>能够恢复对文件就可以了，不会太刁钻。</p><h3 id="实现指南-1"><a href="#实现指南-1" class="headerlink" title="实现指南"></a>实现指南</h3><p>一个更加 naïve 的思路。从一个 commit 刚刚被提交说起…</p><p>此时，所有的目录结构和文件改动都被提交了，我们可以在当下的目录中进行新的改动。为了能够恢复到刚刚提交的“干净”状态，我们需要为当下的状态做一个暂存，以便之后进行对比。</p><p>现在我们做了一些改动，想要 commit。这里，需要记录下改动的部分，没有改动的部分则默认是保持的。我们可以用文件系统的 api 遍历当前目录和暂存下来的目录，检测文件的增删等。对于依然存在的文件，则需要逐字符对比其中的改动。当所有的改动全部检测完毕后，在 .git 下保存好本次改动中：</p><ul><li>删除了哪些文件</li><li>增加了哪些文件和这些文件的内容</li><li>编辑了哪些文件和这些文件的新版本</li></ul><p>并将本次 commit 及其父节点 commit 号记录下来。</p><p>可以使用的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;     <span class="comment">// 打开目录</span></span><br><span class="line">       <span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;  <span class="comment">// 读取目录中的项目</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;  <span class="comment">// 创建新目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;   <span class="comment">// 删除目录</span></span><br></pre></td></tr></table></figure><blockquote><p>如何更简单地判断新文件是否发生改动，特别是较大文件？</p></blockquote><p>可以对所有存储下来的文件做 <code>md5sum</code>，为文件生成一个摘要。之后再有文件变动时，先去找是否存在相同的 md5，如果新旧文件的 md5 相同，就不用重复保存了。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="废弃的旧思路（依然可以尝试）"><a href="#废弃的旧思路（依然可以尝试）" class="headerlink" title="废弃的旧思路（依然可以尝试）"></a>废弃的旧思路（依然可以尝试）</h3><p>一个 naïve 的思路。</p><p>首先介绍两个工具，一个叫做 diff，一个叫做 patch。这两个工具是大部分发行版自带的。<strong>看到这里请打开你的命令行</strong>一起尝试一下。</p><p>准备任意一个代码文件 a.c，复制到 b.c，在 b.c 中加入一些行，删去一些行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>能看到：</p><img src="Screenshot_20230115_000047.png" alt="img" style="zoom:75%;"><p>可知，diff 可以计算出两个文本文件之间的差距。</p><p>用重定向将这一结果定向到 <code>diff.out</code> 中，我们再用 patch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch a.c diff.out</span><br><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>这次什么也没有输出。a.c 和 b.c 变成一样的了。</p><p>diff 不仅可以给 a.c 打补丁，还可以把补丁从文件中拆下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -r b.c diff.out</span><br></pre></td></tr></table></figure><p>再打开 b.c，就能发现文件变回了之前  a.c 的样子。</p><p>great。所以只要你能够在 commit 的时候遍历目录中的所有文件，挨个 diff 一下，就可以算出当前版本和上个版本的差距了。然后你把这些差距全都写 .gitm 中的某一个文件，大功告成。</p><p>diff 和 patch 可以对两个目录直接计算差值和补丁&#x2F;回退。如果你学会怎么用，省去很多麻烦事。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结：在 .gitm 中我们需要存储的元素</p><ul><li>一个文件，能指示当前所处的提交</li><li>一个文件，包含了所有的提交号，并需要能够指明每个提交在树结构上的祖先节点。对于新 commit 是一个，对于 merge 是两个（这与 git 并不完全相同）</li><li>若干个目录，每个代表一个 commit；每个目录若干个文件，记录它相对祖先节点的变化：增减文件目录，编辑文件</li><li>一个目录，包含了当前 commit 的暂存状态，以便之后用于与编辑后的状态进行比较</li></ul><p>在 gitm 执行的过程中，有这样一些子功能需要实现：</p><ul><li>解析参数，执行对应功能</li><li>遍历当前文件树，与已提交的文件树对比</li><li>将对比的文件树中公共部分进行比较</li><li>分析 commit 记录，确定提交之间的关系</li><li>通过提交之间关系，决定前进或后退</li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中国哲学史 阅读笔记 I</title>
      <link href="/20230605-cphil1/"/>
      <url>/20230605-cphil1/</url>
      
        <content type="html"><![CDATA[<p>本对中哲兴致不高，但受人推荐，不宜推托，故计划分三次读完全书。</p><p>简要回顾上回读到中国哲学的精神。</p><p>中国人不那么关切宗教，是因为他们太关切哲学了。他们在哲学里找到了超越现实世界的那个存在，……。形而上学的功能不是要增长正面的知识，而是概念的澄清和心灵的提高。宗教提供有关实际的正面信息，却与科学提供的不同。因而科学前进一步，宗教后退一步。</p><p>中国哲学要解决的问题：在入世和出世的两极对立中寻求他们的综合。“内圣外王”，政治领袖应有高尚的心灵。与柏拉图的“哲学王”的观念相似。中哲关注政治思想，但也不缺少形而上学、伦理学和逻辑。名家“白马非马”，欲推是辩，以正名实，而化天下焉。（符号学家？）</p><p>表达方式上，富于暗示而不是一泻无余。言有尽而意无穷。（微软拼音输入法是真的垃圾。）得意而忘言。</p><p>中国哲学的背景</p><p>大陆国家（非海洋国家）。</p><p>农业国家的经济思想，农民的物质财产难以移动，而商人的易于转移，容易不顾国家自己逃跑。</p><p>“反者道之动”。任何事物都包含了对自己的否定。居安思危；黎明即将到来。“过犹不及”，中庸之道。</p><p>对自然的理想化。“天人合一”。对农民社会的田园诗式颂歌。</p><p>家族制度。靠土地生活因而世世代代无法离开；祖先崇拜。</p><p>入世出世。儒家游方之内，道家游方之外。方即社会。个人的社会责任，还是任内行自然自动的秉性。</p><p>艺术与诗歌（我感觉偏题了。这是背景？这不是观点吗？并没有写某个政治经济背景对哲学的影响，而是哲学思想对文化作品的影响啊。）道德的教育工具，还是心灵的自由流动。（表现论和实用论的分歧，我们要托马斯曼还是卡夫卡） </p><p>农民的眼界制约着中国哲学的方法论，认识论在中国哲学里未得到发展，因为在一个连续审视过程中，没有明确区分主观与客观的界限。（为什么？）并且中国哲学的语言是提示性的，因为它仍然关注物质世界而非理念世界，说的是具体的事而非抽象的命题。</p><p>（我懂了。意思是中哲重视感性直觉，西哲重视抽象概念。）</p><p>希腊人以贸易维持繁荣，数学发展较早且普遍，更容易理解抽象的概念。并且更加习惯变化、新奇的事物。因而工业革命发生在西方。</p><p>中国哲学虽然是过去的哲学，但仍为当今的人提供一种社会的和人生的理想。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023技科转专业机试-LRU</title>
      <link href="/20230602-LRU/"/>
      <url>/20230602-LRU/</url>
      
        <content type="html"><![CDATA[<p>LRU 代表 “Least Recently Used”（最近最少使用）。在计算机系统中，这一技巧常被用来管理较为紧缺的资源，比如内存或磁盘空间。</p><p>想象你有一个小型的缓冲区（buffer）。当你需要获取一个内存对象的时候，首先检查它是否在当中，如果有，那么就可以很快速地返回。但如果buffer里没有，就需要访问更慢的磁盘。这就需要花费更多的时间。</p><p>接下来，我们来介绍 LRU 策略。LRU 优先将最近使用过的项目保留在buffer中，并在buffer已满时优先将最近最少使用的项目移除。这一策略的根据是，如果一个对象很久没有被访问，那么之后再去访问它的概率也比较低，因而可以“腾笼换鸟”。</p><p>举例说明：</p><p>1、现有一个容量为3的buffer</p><p>2、最初，buffer为空</p><p>3、程序依次访问3个对象：A，B，C。它们都是最近使用的，因而被放在buffer中</p><p>4、再次访问C，C刚好在buffer中，称为命中（hit），返回其值</p><p>4、现在访问D。D不在buffer中，称为缺失（miss）。因为buffer满了，因此最近最少用的对象（A）被移除，将D放入</p><p>5、如果再访问A，那么需要从主存中重新读取，并放到buffer中替换掉最近最少使用的B</p><p>如此重复…</p><p>本题需要你用链表和数组模拟一个缓存-磁盘二级结构。其中磁盘为一个 int 类型的数组，能够容纳 32 * 1024 * 1024 个 int 型整数，其初始值全为0。每一个链表节点都储存一个“键-值”对，表示在“磁盘”中的一个数组下标对应其中的值。缓存有一个容量上限。需要支持以下操作：</p><ul><li>写入：给出数组下标和所赋的值，将值写入模拟的磁盘。需要首先检查cache中是否存在对应项。如果cache是满的，那么最近最少使用的对象应当被移除，以容纳新写入的对象。</li><li>读取：按照所给的下标读取值。如果buffer中存在，则返回buffer中的值，并输出hit。如果不存在，则从数组中读取，并输出miss，然后把这个键-值对放入buffer中。</li><li>调整大小：调整buffer能够存储的键-值对的个数。如果增大容量，则新的项目均为空；如果减小容量，则在旧的项目中保留最近的。</li></ul><p>输入格式：</p><p>第一行两个整数，表示buffer的初始大小和操作的数量；</p><p>之后的每行可能为下列中的一个：</p><ul><li>write $position$ $x$：向磁盘中第 $position$ 个整数的位置写入 $x$。其中 $x$ 在 <code>int</code> 范围内，$0 \leqslant position \leqslant 32*1024 * 1024$</li><li>read $position$：读出磁盘中对应位置的整数值</li><li>resize $size$：调整 buffer 大小为 $size$</li></ul><p>输出格式：</p><p>对于每次读取请求，输出一行，包括读取到的值，空一格，输出”hit”或”miss”。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结构</title>
      <link href="/20230603-structure/"/>
      <url>/20230603-structure/</url>
      
        <content type="html"><![CDATA[<p>最近思考的时候，有一个词语的出现频率很高，叫“结构”。</p><p>举个例子。我常常认为人对一切事情的经历，归根到底是出于他本身的结构。</p><p>又比如。我认为每个人的那些过去也好，内在也好，在结构上并没有什么不同。所以人的灵魂就是匮乏。</p><p>初次与普罗蒂总结的36种戏剧模式正面遭遇时，只是觉得新奇，但并未给予关注。仔细回想起来，童年时和家长看新播的电视剧时，家长常常能准确说出接下来的剧情走向。再到我吃过一点苦头之后，冷静下来，总能找到理论的影子。</p><p>现实世界的故事，如果是进行时，它就跌宕起伏；如果是完成时，它就再难以引起人心中的涟漪。</p><p>所以，坚持自己的与众不同，就是要做表面文章。</p><p>我首先是要好好地驳一驳这两点。然后不出意外，就是很难反驳。并据此分析。</p><p>我看到人都是不同的，因为善良无恶意的人们总因为互不理解而争吵；我又看到人们是相同的，因为他们的言说总是呈现了似曾相识的结构。</p><p>我主张自己的与众不同，否则我的表达与宣泄就丝毫不能给我带来快感；我又主张自己和所有人一样，否则我既不会对别人感到同情也不会被人同情。</p><p>为什么会这样，我还没想好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>答辩之前</title>
      <link href="/20230531-beforedebate/"/>
      <url>/20230531-beforedebate/</url>
      
        <content type="html"><![CDATA[<p>和磊哥、朱姐、章姐…等等人的酒局感觉以后不会再去了。有一种被排除在外的感觉。</p><p>虽然和很多人加了好友，包括赵姐，but。。？有缘再见吧。</p><p>穿越幻象不是一劳永逸的，因为幻象是接二连三地到来的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>notitle</title>
      <link href="/20230525-fans/"/>
      <url>/20230525-fans/</url>
      
        <content type="html"><![CDATA[<p>非正式发布版，随你怎么写吧。</p><p>昨晚写匡院的小作文写到5点，闭眼再一睁是9点，看到一条QQ好友请求，通过之后立刻困得放下手机继续睡了。12点又醒来，收到微信的好友请求，是同一个名字，这次的备注消息是“一个粉丝”。可能是前天晚上酒还没醒，大脑过载，没明白是什么意思。</p><p>我擦，我平时胡言乱语碎碎念的空间居然还有粉丝。一聊才知道是因为精神分析相关的内容，不过我唯一一篇提及精分的日志是从别处转载的。而且已经没怎么更新过动态了。</p><p>倒不是说没什么可更新的。</p><p>之前转载了一篇《<strong>假如你没有五十法郎寻求精神分析治疗…</strong> 》的文章，被路过的网友读到，然后以“一个粉丝”的身份加了我的好友。</p><p>这是我从没想过的。我认为过去的那些碎碎念没有任何价值，并且“言说”这件事对我来说变得越发困难起来。</p><p>原文的作者说要“写下症状，悄悄放在世界上”，将自己的疯癫絮语藏匿于广大的互联网中，以期获得大他者的沉默回应。而事实上后来的两年里他再也没能说出什么。在最后试图用痛苦来丈量自己的虔诚后，他已在倒错中噤声。</p><p>不由得想到那晚站在货架前，我掰着手指头盘算着700毫升的绝对伏特加在我本科的最后一个月要怎么才能喝完。结果我不好说我和它到底是谁在consume谁了。</p><p>不要喝酒；如果一定要喝，不要醉酒；如果一定要醉，不要断片；如果一定要断片，不要在没有朋友的地方断。</p><p>给舍友带来了一些深重的灾难，真的要磕头了。</p><p>想起上一次断片后在微信里跟学姐胡言乱语，她瞬间就理解了状况，真的温柔，我哭死。后来轮到她喝大了，听说给前男友打了十几个未接电话，什么恋爱脑。</p><p>为什么我感到越来越难以言说。</p><p>在并未醉酒的大部分时间里的大部分人只是作为透明的环节参与其中，在场上流动的只有骰子的点数、牌的大小以及杯中的液体。甚至每个人所讲述的任何话语都显得不痛不痒。清醒的人赶到已经开始一段时间的酒局，几乎只会冷静地看着剩下的人“发疯”。</p><p>醉酒后，作为原初创伤的遮蔽，构成幻想的话语变得支离破碎，症状才得以以它原来的方式显现。多数人只有在这种时候，才能够暂时地接受创伤造成的缺失。也正是这种时候人的情绪最高涨，清醒时不那么好玩的事情也变得好玩起来。</p><p>要我温和而克制地叙述那些故事，就像是用话语的垃圾袋把症状装起来扔到大路上。所谓遗忘只能是压抑，压抑后的创伤只会悄悄返回。让创伤成为创伤，承认自己的生命就是一个创伤，不要去舔舐伤口，享受你的症状。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vegas</title>
      <link href="/20230525-vegas/"/>
      <url>/20230525-vegas/</url>
      
        <content type="html"><![CDATA[<p>What happens in Vegas stays in Vegas.</p><p>What happens in the room stays in the room.</p><p>BE GENTLE ANYWAY.</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DCF 随手</title>
      <link href="/20230509-DCF/"/>
      <url>/20230509-DCF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>图片真的全部散失了。</p></blockquote><p>Paxos 算法的变种不是非此即彼的关系，在不冲突的情况下，可以组合使用</p><p><img src="image-20230509131831146.png" alt="image-20230509131831146"></p><p>DCF 是动态库</p><p>异步通知事务</p><p><img src="image-20230509132034495.png" alt="image-20230509132034495"></p><p><img src="image-20230509132148314.png" alt="image-20230509132148314"></p><p>prevote 优化</p><p><img src="image-20230509132906832.png" alt="image-20230509132906832"></p><p>dcf_interface.h</p><p>dcf_start 拉起 </p><p>然后调 write 写   日志流1个就够了</p><p>buffer是不关心内容的，只是达成一致后回调通知数据提交</p><p>但是外部业务可能需要知道。。。key是辅助的信息，回调的时候返回，这样知道是哪个数据得到了承认</p><p>index是序列里的第几个得到了承认</p><p>read 根据写的时候的 index 来读取数据</p><p>stop 就停止</p><p>回调接口，usr_cb</p><p> status_notify 状态通知，数据内核根据这个切换自己的状态</p><p>数据库对接。不重要</p><p>参数配置</p><p><img src="image-20230509133548477.png" alt="image-20230509133548477"></p><p>现在不支持空洞</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>护肤</title>
      <link href="/20230414-thoughts/"/>
      <url>/20230414-thoughts/</url>
      
        <content type="html"><![CDATA[<p>痘坑：医美</p><p>痘印：水杨甙、甘草提取物</p><p>色素沉淀：烟酰胺，维C，维E</p><p>防晒</p><p>珂岸修颜乳</p><p><img src="image-20230414162147386.png" alt="image-20230414162147386"></p><p><img src="image-20230414162245844.png" alt="image-20230414162245844"></p><p>毕生之研 五环修红精华</p><p>快速去痘印：积雪苷霜软膏，多磺酸粘多糖软膏 （临床指导）</p><p>细菌性毛囊炎：莫匹罗星软膏、夫西地酸乳膏</p><p>头上：二硫化硒洗剂</p><p>真菌：联苯苄阳台上</p><p><img src="image-20230414164146099.png" alt="image-20230414164146099"></p><p>首先停掉护肤品。然后好好洗脸。？？？？</p><p><img src="image-20230414164244622.png" alt="image-20230414164244622"></p><p>1控制住手 2洗脸后用（点涂薄涂）过氧苯甲酰凝胶</p><p><img src="image-20230414164423859.png" alt="image-20230414164423859"></p><p>去医院。</p><p><img src="image-20230414164529494.png" alt="image-20230414164529494"></p><p>每天只用一次洗面奶</p><p>先涂修复性精华。雅诗兰黛小棕瓶，好jb贵。</p><p>素森康 二裂酵母水光修护精华</p><p>快的：同一家的贻贝粘蛋白，贵的一笔</p><p>最后保湿。质地轻薄</p><p><img src="image-20230414165258347.png" alt="image-20230414165258347"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>速通纯批（一）导言与先验感性论</title>
      <link href="/20230413-PureCritique/"/>
      <url>/20230413-PureCritique/</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>半学期的哲学课给我最大的感受是，在高中三年大学四年的忽视下，我与科班出身的同学相比缺少的不是对哲学体系的把握能力，而是对理论的系统化表述能力。说得再直白一点，就是“我不会说话”。如果把哲学体系比作概念能指编织而成的一张网络，我的“网络拓扑”与那些成日泡在文本中的同学相差并不大。康德艰深晦涩，但过了最初的一关，剩下的困难几乎都在于长难句。如果把句读直接作为文本，往往会在邓老师不厌其烦的复读中，忘掉了康德论证的结构（Sorry，邓老师，您的句读还是有很大帮助的）。总之，我想说康德的体系并不困难。但自己系统化地表述又是另一个问题。在这上半学期哲学史的pre中，有太多好的例子，例如今天上午刚讲了笛卡尔的第四组反驳与答辩，我还能想起他是在讲“意志”在笛卡尔那里，处于一个什么样的位置。在我看来就已经很了不起了。一个失败的论述到最后往往连最初的观点都丢掉了。</p><p>我本打算速通纯粹理性批判，但越是读下去，以及越是尝试萨特、黑格尔，就越是感到它作为一个入门的系统性论述文本，是不可速通的。尤其在于后来者的概念往往是前者概念的延伸、歪曲、颠倒，有意无意地指涉。另外，如果没有翻过纯批里的每一座山，日后对于现象学的把握也成问题。况且理论来得稍微迟一点并不影响实践，因此这里决定多耗费些时日。</p><p>Tilnel</p><p>抽掉理性能力的一切对象，除了理性其自身及其形式以外，不与任何别的东西打交道。是为纯粹理性。</p><p>数学和逻辑学是完全纯粹的；而物理学仍然需要经验的知识作为基础。</p><p>通常，认为一切知识都必须依照其对象。然而理性究其本性不断由果溯因（我们都会追求所谓究极真理），需要自在事物本身中有一个无条件者，作为一切原因的源头，这是一定会超出经验所认知的。如果认为一切知识都要依照其对象，我们就无法无矛盾地设想一个无条件者。而只要在此作一个颠倒，即对象是依照知识的：我们关于对象的知识是自在之物在人的表象能力下作为现象，而绝非作为自在之物本身被人所认识到的。矛盾就没有了。</p><p>关于“物”，我们“先天地”认识到的只是由我们自己放到它里面去的。理性之所以能认识物，必在于其先天地有认识物的能力，这就是一种“先天知识”，是一切后天的判断中都必然包含的“先天成分。</p><p>为什么要对纯粹理性做如此批判？因人思维的本性是无限追溯事物后的原因，以至引出了三个重要问题：上帝是否存在、灵魂是否不朽、意志是否自由。在形而上学的发展中诞生了唯理论与经验论两派。只依赖理性而不顾经验导向独断论，而只依赖经验却不相信理性导向怀疑论。批判就是为了探究理性在认识的与实践的方面，其能力与界限，进而调和两种观点之间的矛盾，建立未来形而上学的大厦，一种“先验的唯心论”体系。</p><p>“理性能力本身，独立于经验有可能追求到什么样的知识？”这与一般形而上学的可能性或不可能性密切相关。</p><p>几组概念与命题</p><p>I. 纯粹知识与经验性知识</p><p>纯粹的，在康德这里几乎与“先天的”同义。即不掺杂任何经验性的。譬如 1+2&#x3D;3，一切结果必有其原因。当然“结果”与“原因”的概念似乎依然从经验中来，此处按下不表。经验性知识，如今天下雨了。</p><p>II. 先天知识的必然性与普遍性</p><p>必然性，那就是除此之外别无他种可能；普遍性，就是放之四海而皆准的。正如一切数学知识。</p><p>III. 需要规定先天知识的可能性、原则与范围</p><p>上述的人的思维本性所产生的三大课题，是完全离开经验，仅能凭借理性去思维的。但这就导致不经检验地运用理性，因为有不受限制地扩张知识的诱惑。</p><p>IV. 分析判断与综合判断</p><p>分析判断，即我们从语词的概念中即可分析出的命题。如“床是用来休息的”，这一属性能够从物的定义中分析出来。而综合判断，则是将并无关联的概念综合在一起。比如两点之间直线段最短这一命题，“直线段”是质的规定，而“最短”是量的规定。并没有从一个概念中能分析出另一个概念的可能，却连结起来而为人们深信不疑。</p><p>我们在构建知识大厦的时候，有大量的分析工作让我们迷失：分明只是分析的判断，却由于其形式上的变换，被认为是新的洞见，人很容易接受这一假象。</p><p>经验判断全都是综合的。“一切物体有重量”作为经验判断，其中包含的【经验】是[“有重量”这一谓词与“物体”这一概念有可能综合的基础]。“经验”本身是诸直观的一个综合的结合。</p><p>V. 理性的一切理论科学都包含先天综合判断的原则</p><p>数学；物理学：质量守恒；形而上学：世界必有一最初开端。</p><p>纯粹理性的总课题是：先天综合判断何以成为可能</p><p>或：人的认识能力何以成为可能</p><p>先验感性论</p><p>“一种知识不论以何种方式和通过什么手段与对象发生关系，它借以和对象发生直接关系、并且一切思维作为手段以之为目的的，还是直观”。</p><p>这是说，知识与对象发生直接关系的中介、通道、手段，是“直观”；思维一个对象的“手段”是“直观”。比如我要思维一个三角形，必要在心中先生成一个“空间中的三角形”的直观。</p><p>直观只在对象被给予我们时才发生，只会是因为对象以某种方式刺激内心。通过被对象刺激而获得表象的能力叫做“感性”。在这里可以先把它想象成人的感官能力。</p><p>借助感性，对象被给予我们；且感性给我们提供出直观。直观通过“知性”被思维，产生出概念。</p><p>举个例子。路上的远处有一个人形排列的、发出600-700nm波长的电磁波的点阵映入我的眼里，我看到了一个牌子上亮着一个红色的小人，进而知道现在是红灯。我的通俗理解是，感性从乱七八糟的物理现象：各种波长的电磁波、机械波、分子热运动中，归结出各种颜色、音调、冷暖的“感觉质料”，到这里称之为“杂多”；然后再将这些属性归到实体中，向我们呈现出最后的那一个完整的“对象”。</p><p>当我们被一个对象所刺激时，它在表象能力（感性）上产生的结果就是感觉；经过感觉与对象相关的直观就叫做经验性的直观（因此还有非经验性的，即“先天的”直观）。一个经验性的直观的（未被规定的）对象就叫做“现象”。</p><p>这里未被规定的可理解为“未被知性所思维的”。如果一个现象被知性所思维，那它就成为“概念”。这也仅仅是“概念”上的区分。</p><p>故，“现象”中，与“感觉”相关的东西，颜色、温度、气味，称为现象的质料；而在现象中，使得这些杂多得以整理的东西，称为现象的形式。现象的形式既然不是感觉，即是非经验性的，是先天的，是在排除一切经验以外的内心可以找到的，离开一切感觉仍有的。</p><p>康德在这里做了如下的思想实验：将我们对“物体”这一概念的认知不断地减少。首先抽出那些属于知性的东西，如实体性、力、可分性；再抽出属于感性的东西：颜色、温度…我们能够发现，抽出了这些属性之后，我们尚且还能够设想这样的物体——除了广延和形状：我们不能设想一个物体不占据一定的空间。</p><p>作为先天知识的原则，有两种感性直观的纯形式，即先天直观形式，空间和时间。</p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMC - A pragmatic Approach to Model Checking Real Code</title>
      <link href="/20230402-CMC/"/>
      <url>/20230402-CMC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>先说点题外话。经过长时间的感受之后，认为读文献还是用纸的好，目前打印了一批，是准备在本科期间精读完的。方便做标记，也方便找。而且不用盯着屏幕看，很舒服。</p></blockquote><p>测试分布式系统的bug往往需要非常错综复杂的执行序列，一个系统运行几小时、几天、几周。。才有可能触发代码中的问题。</p><p>检查 Bug 的方法，一是 Model Checking。它能够接受一个由实际代码简化来的系统，然后穷举系统执行的所有可能性。但是在现实中有很多缺点：建模非常困难。写模型比写代码化的时间多多了。并且检查这个抽象的模型，还是容易忽略掉实际代码实现里面的问题。</p><p>文章的贡献：</p><p>一是提出了一个新的 Model Checker，CMC，它能够直接对 C 和 C++ 代码实现进行检查，避免了抽象过程中的错误丢失，并且不用花时间去建模了。额外的好处是代码一经改动可以立即检查。</p><p>二是说明了 CMC 在实际的系统中能够得到较好的应用。通过对三个版本的 AODV 网络协议的模型检查，可以预见  CMC 能够应用于其他的系统，尤其是其他的网络协议。</p><p>复杂的系统有复杂的问题。现实中的系统有很多由错综复杂的执行顺序触发的边界情况没有在代码中得到处理。他们在系统中就像是“残渣”一样，日积月累，最后使整个系统瘫痪。我们发现了这种错误之后，通常就很难诊断问题的原因了。因为这些问题并不可复现。导致这些问题的执行流实在是太长，没有办法去重建在车祸现场之前到底发生了什么。</p><p>形式化验证是针对这种深层次的问题的一个可能的办法。它能够系统地列举系统的所有的可能状态。一个基本的模型检测从系统的一个初始状态开始，并且通过非确定地执行事件递归地生成后继的系统状态。所有的状态都被储存在一个哈希表里来确保每一个状态都至多被遍历到一次。这个过程一直持续到所有的状态都能够遍历完成，或者是所有的系统资源都耗尽。这种状态图探索的办法相较于不切实际的大量测试，能够在达到其效果地同时，避免测试当中的冗余。</p><p>传统的模型检测经常假设系统设计是以一种很高的层次，抽象掉实际实现的很多细节的。验证实际上的代码就需要从代码重建这些抽象的描述。这个过程需要大量的人工，妨碍到了模型检测在实际系统当中的应用。并且，人在手工抽象过程中的失误也会导致假阳性或漏报。这种错误既可能在构建模型的时候发生，也有可能在系统演进的过程中发生。</p><p>。。。</p><p>对实际实现进行模型检测的这个想法已经在几个工具当中被采用了。Verisoft，系统地执行 C 实现代码但是不记录状态。其他的软件模型检测工具比如说 [3][25] 是专门用于 Java 程序中的特定 Class 的。CMC 采用了多个研究当中的技术来设计，把它用于 C 和 C++ 编写的程序，它们是工业界应用到的主要语言。</p><p>我们的终极目标是检查所有的代码；但一开始我们关注网络代码。这种代码天然地遵从一种“事件驱动”的编程模型，能够很好地与模型检查工具相契合。网络代码的正确新很重要，因为它们常常处于服务的中心，并且经常是容易受攻击的对象。但是网络协议又难以设计、实现和测试因为网络中包括多台机器之间的复杂行为，并且需要处理多种网络错误，如丢包、连接失败，这些在测试环境中是很难控制的。模型检测就很擅长检查这些相互作用。</p><p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毕业论文结构和部分内容</title>
      <link href="/20230401-thesis/"/>
      <url>/20230401-thesis/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>介绍 openGauss 数据库，以及作为分布式系统的特性。本工作的目标。</p><p>本节内容。</p><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>介绍分布式数据库、openGauss 和要解决的问题。</p><h2 id="研究工作"><a href="#研究工作" class="headerlink" title="研究工作"></a>研究工作</h2><p>简要介绍本文探索了哪些优化，得到了什么样的结果。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="TiKV-优化的-Raft"><a href="#TiKV-优化的-Raft" class="headerlink" title="TiKV 优化的 Raft"></a>TiKV 优化的 Raft</h3><p>TiKV 是一款开源的分布式事务型键-值数据库，采用 Raft 共识协议以保证强数据一致性和高可用性。Raft 与 Paxos 在容错和性能实现方面有很多共同点，但易于理解和实现。</p><p>在分布式系统中，“脑裂”是一个常见的问题。如果在一个 Raft 集群中发生脑裂问题，旧的 Raft Leader 节点不知道新的 Leader 已经被选出，如果此时有客户端的读取请求，则可能会读取到旧值。原版 Raft 的解决办法是让读请求前将全部 Log 按序应用到状态机，再去进行读操作，则可以保证读到的数据满足强一致性。这种方法的缺点在于每一次读请求都需要依次应用所有的 Log，引发严重的性能问题，因此实际上少有实际项目采用这种方法。Raft 协议的作者后来又在 Raft 的教学材料中提出了针对只读请求的优化方法，为 TiKV 所实现。</p><h2 id="论文组织"><a href="#论文组织" class="headerlink" title="论文组织"></a>论文组织</h2><p>这部分讲论文的结构。</p><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="openGauss"><a href="#openGauss" class="headerlink" title="openGauss"></a>openGauss</h2><h2 id="paxos-共识协议"><a href="#paxos-共识协议" class="headerlink" title="paxos 共识协议"></a>paxos 共识协议</h2><h2 id="DCF"><a href="#DCF" class="headerlink" title="DCF"></a>DCF</h2><p>openGauss-DCF 分布式共识框架是基于 Paxos 共识算法实现的一致性数据复制组件。传统的主备+集群管理采用的是主从模式，有容易触发日志分叉而重建数据、选主错误、不支持动态增删节点等缺陷。在这样的需求背景下，采用了基于一致性协议的自仲裁管理方法。</p><p>DCF 基于 Paxos 协议，扩展了多样化的节点角色：Leader 负责将日志复制到其他节点，并维持心跳；Follower 复制来自 Leader 的日志，心跳超时时转换为 Candidate，给其他 Candidate 投票；Pre-Candidate 发起新任期投票，收集来自其他节点的投票；Passive 复制来自 Leader 的日志；Logger 复制日志及给其他 Candidate 投票。</p><p>对比基本的 Paxos 协议，DCF 的实现采取了两个优化：一是 preVote 优化，通过加入 Pre-Candidate 状态，发起任期不变的预选举，成功后才进行正式选举，以避免网络断连导致节点频繁发起选主使任期持续增加。二是 Lease 优化，在 Leader 网络故障与多数派断连后主动降为 Follower，防止事实上存在两个 Leader。</p><h1 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h1>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何寻找文献</title>
      <link href="/20230331-howtosearchforpapers/"/>
      <url>/20230331-howtosearchforpapers/</url>
      
        <content type="html"><![CDATA[<p>成为了苦逼的研究生，除了要撸代码以外，更重要的是多看文献。文献看得够多，在研究中遇到的问题就总能从看过的文献中汲取灵感。</p><p>本文是我从网上搜刮完一轮之后，拼凑而成的如何找文献的总结。</p><p>网站</p><p>Web of science: apps.webofknowledge.com</p><p>Sci-hub: sci-hub.tw&#x2F;</p><p>软件</p><p>Endnote</p><p>本子和笔</p><p><a href="https://zhuanlan.zhihu.com/p/74728960">如何快速找到与研究方向相关的最新文献与权威文献？ - 知乎 (zhihu.com)</a></p><p><strong>1.读文献对于科研的意义</strong></p><p><strong>① 了解研究方向和领域</strong></p><p>科研不同于本科学习，很多知识、最前沿的进展都是从文献中获取与追踪。</p><p>在研究生初期，我们大部分人都会被导师安排先阅读哪些重要文献，对研究内容有个大致的了解，再开始具体的研究工作。</p><p><strong>② 实验idea的创造</strong></p><p>对于实验型学科，大部分的实验idea来源于文献。</p><p>所谓idea，也许就是把a方法的因素改变成为了b方法再应用于A领域，或者A领域的a方法在B领域中的应用，又或者将a方法改成b方法再应用到B领域中。</p><p>我的这个说法是一个最简单的模型，实际的科研比这个过程要复杂得多，但是有很多优秀的idea就是这么得来的。</p><p><strong>③ 撰写文章时引用</strong></p><p>现在大部分学校的博硕士毕业都是有论文发表要求的，本科不需要发表论文，但是如果有论文或者撰写论文的经历，在保研考研出国的升学过程中都是一个科研经历的亮点。</p><p>而一篇好的论文，须全面地概括本领域的现状，以及研究方法的参考。</p><p>写这部分内容需要正确地引用相关文献，所以我们在写论文之前读到这些相关文献就要保存下来、记录下相关的点，以便引用时用到。</p><p><strong>2. 如何通过文献了解本领域的概况？</strong></p><p><strong>① 阅读本领域权威综述</strong></p><p>登陆教育网或者教育网VPN，在Web of Science中输入关键词，再精炼文献类型为“REVIEW”，过滤为“领域内热点论文”。</p><p>（不方便使用教育网时请跳至下面两种方法）</p><p><img src="v2-9a87a0f91fd179600d32fccf8bd08274_720w.webp" alt="img"></p><p>Web of Science搜索文献界面</p><p><img src="v2-a4352af09d6dd888caac7cf17e8ca90f_720w.webp" alt="img"></p><p>精炼文献搜索范围为Review</p><p>然后勾选那些与自己领域密切相关、影响力大（被引用次数多）的条目，导出到“Endnote Desktop”，用Endnote软件打开就可以在本地看到了。</p><p>如何下载在第四部分再详细说明。</p><p><strong>② 阅读谷歌学术排前的论文</strong></p><p>谷歌学术的使用方法就是在谷粉学术网站中直接输入关键词，以前有个纳米人的网站也有这个功能，但是最近好像不太好使了。</p><p>谷歌学术搜索下来排前的论文一般都是被引次数多，在这个领域中产生巨大影响的论文，非常值得仔细阅读的。</p><p><strong>③ 找导师沟通</strong></p><p>如果领域中文献太多，或者是不知道导师想让你做什么样的工作，那就大大方方地直接找导师沟通吧。<br>导师肯定知道研究方向的必读论文、大牛，获得这些信息后再去找文献阅读，会事半功倍。</p><p>阅读材料：</p><p>教科书 - 专著和综述论文 - 实验性论文</p><p><strong>论文筛选算法：优秀的论文藏在优秀的期刊中</strong>：每个月跟踪期刊。</p><p><strong>本领域核心期刊、本领域牛人或主要课题组、高引用次数、研究方向相近的</strong></p><p>paper list <a href="https://www.zhihu.com/question/30026369">分布式系统领域有哪些经典论文？ - 知乎 (zhihu.com)</a></p><p>CCF 中国计算机学会推荐国际学术会议和期刊目录（2022）节选</p><table><thead><tr><th>简称</th><th>全称</th><th>出版社</th><th>网址</th></tr></thead><tbody><tr><td>TOCS</td><td>ACM Transactions on Computer Systems</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/tocs/">http://dblp.uni-trier.de/db/journals/tocs/</a></td></tr><tr><td>TOS</td><td>ACM Transactions on Storage</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/tos/">http://dblp.uni-trier.de/db/journals/tos/</a></td></tr><tr><td>TPDS</td><td>IEEE Transactions on Parallel and Distributed Systems</td><td>IEEE</td><td><a href="http://dblp.uni-trier.de/db/journals/tpds/">http://dblp.uni-trier.de/db/journals/tpds/</a></td></tr><tr><td>PODC</td><td>ACM Symposium on Principles of Distributed Computing</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/podc/">http://dblp.uni-trier.de/db/conf/podc/</a></td></tr><tr><td>ICDCS</td><td>IEEE International Conference on Distributed Computing System</td><td>IEEE</td><td><a href="http://dblp.uni-trier.de/db/conf/icdcs/">http://dblp.uni-trier.de/db/conf/icdcs/</a></td></tr><tr><td>SOSP</td><td>ACM Symposium on Operating Systems Principles</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/sosp/">http://dblp.uni-trier.de/db/conf/sosp/</a></td></tr><tr><td>OSDI</td><td>USENIX Symposium on Operating Systems Design and Implementation</td><td>USENIX</td><td><a href="http://dblp.uni-trier.de/db/conf/osdi/">http://dblp.uni-trier.de/db/conf/osdi/</a></td></tr><tr><td>OOPSLA</td><td>Conference on Object-Oriented Programming Systems, Languages, and Applications</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/oopsla/">http://dblp.uni-trier.de/db/conf/oopsla/</a></td></tr><tr><td>Middleware</td><td>International Middleware Conference</td><td>ACM&#x2F;IFIP&#x2F; USENIX</td><td><a href="http://dblp.uni-trier.de/db/conf/middleware/">http://dblp.uni-trier.de/db/conf/middleware/</a></td></tr><tr><td>TODS</td><td>ACM Transactions on Database Systems</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/tods/">http://dblp.uni-trier.de/db/journals/tods/</a></td></tr><tr><td>VLDBJ</td><td>The VLDB Journal</td><td>Springer</td><td><a href="http://dblp.uni-trier.de/db/journals/vldb/">http://dblp.uni-trier.de/db/journals/vldb/</a></td></tr><tr><td>SIGMOD</td><td>ACM SIGMOD Conference</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/sigmod/">http://dblp.uni-trier.de/db/conf/sigmod/</a></td></tr><tr><td>VLDB</td><td>International Conference on Very Large Data Bases</td><td>Morgan Kaufmann&#x2F;ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/vldb/">http://dblp.uni-trier.de/db/conf/vldb/</a></td></tr><tr><td>PODS</td><td>ACM SIGMOD-SIGACT-SIGAI  Symposium on Principles  of DatabaseSystems</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/pods/">http://dblp.uni-trier.de/db/conf/pods/</a></td></tr><tr><td>JACM</td><td>Journal of the ACM</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/jacm/">http://dblp.uni-trier.de/db/journals/jacm/</a></td></tr><tr><td>Proc. IEEE</td><td>Proceedings of the IEEE</td><td>IEEE</td><td><a href="http://dblp.uni-trier.de/db/journals/pieee/">http://dblp.uni-trier.de/db/journals/pieee/</a></td></tr></tbody></table><p>具体怎么订阅。。嗯。。没想好，这种东西每年一卷而且长的不行，建议再找时间去细细地切成臊子。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>COJ 评测机与 Main Server</title>
      <link href="/20230311-coj-server/"/>
      <url>/20230311-coj-server/</url>
      
        <content type="html"><![CDATA[<h1><a href="#worker-amp-server-of-coj" class="header-anchor">#</a><span id="worker-amp-server-of-coj">Worker &amp; Server of COJ</span></h1><p>大概想了一下，感觉是这样的。</p><h2><a href="#server" class="header-anchor">#</a><span id="server">Server</span></h2><ul><li>连接数据库，实际上管理数据</li><li>响应前端请求，鉴权，返回应用内容</li><li>响应Worker请求，提供评测相关信息</li></ul><p>本文主要设计 Server 和 Worker 的交互方式</p><p>首先由 Worker 向 Server 发起一个长连接，发送消息包含：worker 的 group，id，连接口令。Server 将 Worker 添加到评测机 pool （链表）中，并返回分配的 WorkerSeqNumber。</p><p>Server 收到前端的 submission</p><p>-&gt; 将 submission 添加到队尾（rejudge，那就是从数据里取出来放到队尾）</p><p>-&gt; 查询对应的 problem 是否有指定的评测机 group </p><p>-&gt; 取对应 group 链表头（无指定则随机选择）发送 submission 数据 </p><p>-&gt; 等待 Worker 返回，放回到对应队尾。持久化评测数据，返回数据给前端</p><p>Worker 本地不存在数据库，不与 Server 共享文件系统（分布式）。这意味着：</p><ul><li>不能从 db 查询提交详情。由 Server 直接发送。</li><li>需要向 Server 实时请求评测数据、题目信息（包括special judge、sample case、题目的分数衰减等）。<ul><li>为了节约一点，每一个 Problem 有属性 SpjEdited 和 TestEdited。只有在本地无数据最新版本数据的时候，worker 才会重新发请求。</li></ul></li><li>文件和时间戳可以保存在本地文件系统，故单机的 Worker 之间是共享这些数据的。重启后，如果版本没有更新，则不需要重新请求。</li></ul><p>Server 监听 Client 和 Worker 消息，使用两个不同的 Socket。</p><p>worker api:</p><p>&#x2F;connect?group&#x3D;{}&amp;password&#x3D;{}</p><p>返回：&gt;&#x3D;1 的未占用最小序列号</p><p>&#x2F;tests?problemid&#x3D;{}</p><p>返回：problemid 对应问题的评测数据 tarball</p><p>&#x2F;task  请求评测任务（可能很久后才返回）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;submissionId&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;problem&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hasSpj&quot;</span><span class="punctuation">:</span> Bool<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Spj&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span> (base64)</span><br><span class="line">        <span class="attr">&quot;samplecase&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span> Json of base64 encoded input/output</span><br><span class="line">        <span class="attr">&quot;testcase&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span> Json array of input/output file path and testcase weight</span><br><span class="line">        <span class="attr">&quot;validLanguage&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;skipSample&quot;</span><span class="punctuation">:</span> Bool<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> Int，</span><br><span class="line">        <span class="attr">&quot;SpjEdited&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;TestEdited&quot;</span><span class="punctuation">:</span> String</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Language&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Src&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span> (base64)</span><br><span class="line">    <span class="attr">&quot;HasInput&quot;</span><span class="punctuation">:</span> Bool<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;UserInput&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span> (base64)</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>&#x2F;submission</p><p>参数：id, score, message, failedOn, verdict, judgedAt, memory, time…</p><h2><a href="#worker" class="header-anchor">#</a><span id="worker">Worker</span></h2><ul><li>读取配置文件。包含本地文件的存储路径，server 的 ip:port，worker 的分组及 cpuset</li><li>fork 出对应数量个进程，并设置进程绑定 cpuset</li><li>连接 Server，得到自身的 workerSeqNo（用作本地 isolate 容器编号。这样就不会被多个 worker 混用了）</li><li>请求任务-处理-返回</li></ul><p>重点说一下处理：</p><p>请求到评测任务后，先检查评测数据版本。如果最新版本不存在，则向 Server 请求，然后丢到本地目录，并加上时间戳。</p><p>再检查如果有 spj，是否有最新版本二进制。如果没有，就重新编译。</p><p>然后就和 dotoj 的流程差不多了…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Compile(code):</span><br><span class="line">  switch code.Language:</span><br><span class="line">    case C:</span><br><span class="line">      Exec(gcc, -o, main, ...)</span><br><span class="line">    case Cpp:</span><br><span class="line">      Exec(g++, -o, main, ...)</span><br><span class="line">    default:</span><br><span class="line">      return COMPILE_NO_SUCH_LANGUAGE</span><br><span class="line"></span><br><span class="line">RunCase(cases):</span><br><span class="line">  for case in cases:</span><br><span class="line">    Exec(main, case.input)</span><br><span class="line">    if (hasSpj)</span><br><span class="line">      spj(case.answer, case.output)</span><br><span class="line">    else</span><br><span class="line">      diff(case.answer, case.output)</span><br><span class="line"></span><br><span class="line">RunSubmission():</span><br><span class="line">  if language == Lab:</span><br><span class="line">    return RunLab()</span><br><span class="line">  if hasSpj:</span><br><span class="line">    if stat(checker + date) == ENOENT:</span><br><span class="line">      Compile(spj)</span><br><span class="line">  Compile(src);</span><br><span class="line">  if hasInput:</span><br><span class="line">    Exec(main, CustomInput)</span><br><span class="line">    return Output</span><br><span class="line">  if !skipSample:</span><br><span class="line">    result = runCase(Samples)</span><br><span class="line">    if result != AC:</span><br><span class="line">      return WA with X</span><br><span class="line">  result = runCase(Tests)</span><br><span class="line">  return Result, ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Deprecated </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二月</title>
      <link href="/20230308-summary/"/>
      <url>/20230308-summary/</url>
      
        <content type="html"><![CDATA[<p>到校一个月之后，我终于算是建立起了还算正常的作息，以及一套日常工作的机制流程。</p><p>买平板是一个收益和损失并存的决策。首先确实各处都更方便了，不用背着纸质资料到处跑；损失就在于摸鱼更方便了，而且还花了很多钱。</p><p>我在犹豫是否购买的时候，有这样一种想法：我在不断地衡量这次消费是否“值”。我是把它作为一种投资来看，而投资确实就是一种“赌博”。一个东西有没有用，要去试试才知道。当然这几天使用下来，最好的一点其实是它在不断地提醒我要及时充电…</p><p>我是一个没有什么电量焦虑的人，所以经常忘记充电。冬天的时候手机的电尤其不经用，在外面走着走着手机就歇逼了。虽然我没什么情绪，但终究还是造成了不少的麻烦。另外一个是我的笔记本的续航可以说是完全烂掉了，指望它就不太可能。这些问题还是慢慢地引起了我的新的需求，就是方便携带又续航强大的电子设备。其实这类设备最理想的形态，是一个联网的远程桌面client：它仅仅需要搭载这一功能即可，这样无论到哪里，都可以在同一个设备上继续工作。但毕竟还是太天真的愿景。</p><p>目前用这个来看文献也是很方便。但我似乎主要是用来实时地查一些东西，以及作为多媒体设备…主要是因为阅读的主力部分还没开始做。</p><p>想来我前两天列举的要做的事，已经成为本周的目标了。但是没问题，只要在做了在做了，就没问题。。。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ramfs 调分内幕</title>
      <link href="/20230305-ramfs-score/"/>
      <url>/20230305-ramfs-score/</url>
      
        <content type="html"><![CDATA[<p>调分：</p><p>按测试点通过率，1，2， 3一档，5， 6一档，9 一档，4 一档，7，8 一档</p><p>20 + 20 + 15 + 15 &#x3D; 70</p><p>8 + 7 85</p><p>5 90</p><p>4 94</p><p>3 + 3 100</p><p>然后 20 分写了的，就酌情加分</p><p>（调分后，平均分仅仅提升2分到81）</p><p>算了，应该这样：20，60，70，78，84，88，92，96，98，100</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>COJ 后端设计方案（初步）</title>
      <link href="/20230301-coj/"/>
      <url>/20230301-coj/</url>
      
        <content type="html"><![CDATA[<p>Dependencies:</p><ul><li>gcc</li><li>make</li><li>postgresql14</li><li>libpq5</li><li>davidmoreno&#x2F;onion</li><li>isolate</li><li>To be continued..</li></ul><p>主要特性：</p><p>评测机可部署在多台不共享文件系统的机器上</p><p>对异构多核可以将评测机分组并限制在对应核心</p><p>数据库中的数据对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Administrator 0x7  <span class="comment">// all</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UserManager 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ContestManager 0x2  <span class="comment">// 管理 Contests 和 Problems</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SubmissionManager 0x4   <span class="comment">// rejudge, 提交作废，手动评测，之类的</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> Id[<span class="number">32</span>]; <span class="comment">// uuid</span></span><br><span class="line">    <span class="type">char</span> Email[<span class="number">32</span>]; <span class="comment">// smail.nju, null terminated</span></span><br><span class="line">    <span class="type">char</span> ContestantId[<span class="number">32</span>]; <span class="comment">// 学号, like 2312xxxxx; 或者老师、助教的自定义名称。用作登录名</span></span><br><span class="line">                           <span class="comment">// null terminated，仅限数字、字母、下划线</span></span><br><span class="line">    <span class="type">char</span> ContestantName[<span class="number">32</span>]; <span class="comment">// null terminated，用作排行榜显示。任意 &lt;= 31 字节的 utf-8 字符串</span></span><br><span class="line">    <span class="type">char</span> Password[<span class="number">32</span>]; <span class="comment">// null terminated, libcrypt 加密后存储</span></span><br><span class="line">    <span class="type">int</span> ClassId; <span class="comment">// 班级号</span></span><br><span class="line">    <span class="type">uint32_t</span> Roles; <span class="comment">// 用户组 flags                           </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Class</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">16</span>]; <span class="comment">// e.g. 2021SE1, 2022SZ6, GUEST, NOCLASS.</span></span><br><span class="line">    <span class="comment">// null terminated.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bulletin</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">int</span> Weight;</span><br><span class="line">    <span class="type">char</span> *Content;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">PublishAt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ExpireAt</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Problem</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">int</span> ContestId;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Ordinary, TestKitLab &#125; Type;</span><br><span class="line">    <span class="type">char</span> Title[<span class="number">128</span>]; <span class="comment">// null terminated</span></span><br><span class="line">    <span class="type">char</span> *Description;</span><br><span class="line">    <span class="type">char</span> *InputFormat;</span><br><span class="line">    <span class="type">char</span> *OutputFormat;</span><br><span class="line">    <span class="type">char</span> *FootNote;</span><br><span class="line">    <span class="type">double</span> TimeLimit;  <span class="comment">// s</span></span><br><span class="line">    <span class="type">int</span> MemoryLimit;  <span class="comment">// KiB</span></span><br><span class="line">    <span class="type">bool</span> HasSpecialJudge;</span><br><span class="line">    <span class="type">bool</span> SkipSample;</span><br><span class="line">    <span class="type">int</span> SampleCasesCnt;</span><br><span class="line">    <span class="type">char</span> **SampleCasesInput;  <span class="comment">// Base64</span></span><br><span class="line">    <span class="type">char</span> **SampleCasesOutput;  <span class="comment">// Base64</span></span><br><span class="line">    <span class="type">int</span> TestCasesCnt;</span><br><span class="line">    <span class="type">char</span> **TestCasesInputPath;  <span class="comment">// $DATA_ROOT/tests/problemId/&#123; path &#125;</span></span><br><span class="line">    <span class="type">char</span> **TestCasesOutputPath;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">SpjEdited</span>;</span>  <span class="comment">// 用于 spj 更新，worker 重新编译</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">TestEdited</span>;</span>  <span class="comment">// 用于测试点更新，worker 重新请求</span></span><br><span class="line">    <span class="type">bool</span> IsGroupLimited; <span class="comment">// Worker Group 限制</span></span><br><span class="line">    <span class="type">char</span> *WorkerGroup;  <span class="comment">// 仅可由对应组 Worker 评测</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contest</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> *description;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Public, Private, Protected &#125; Visibility; </span><br><span class="line">    <span class="comment">// protected，考试中模式，做对了也不能看别人代码</span></span><br><span class="line">    <span class="comment">// Private，仅管理员与存在提交记录者可见。不再有 Contestant 的设定</span></span><br><span class="line">    <span class="comment">// Public，Contest 开始时间后就公开，做对可查看所有源码</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Practice, CodeForces, ACM, OI &#125; ContestMode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">BeginTime</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">SoftDDL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">HardDDL</span>;</span></span><br><span class="line">    <span class="type">bool</span> HasDecay;</span><br><span class="line">    <span class="type">bool</span> IsDecayLinear;</span><br><span class="line">    <span class="type">int</span> Decay[<span class="number">3</span>];  <span class="comment">// percent</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">DecayTime</span>[3];</span> <span class="comment">// before DecayTime[i], has Decay[i]</span></span><br><span class="line">    <span class="comment">// After DecayTime[2], Score *= Decay[2] %</span></span><br><span class="line">    <span class="comment">// After HardDDL, Score = 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Submission</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">char</span> UserId[<span class="number">32</span>];</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> C, Cpp, Rust &#125; Language; <span class="comment">// </span></span><br><span class="line">    <span class="type">int</span> ProblemId;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">SubmittedAt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">JudgedAt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FAILED, REJECTED, TESTOK, PENDING, JUDGING, ACCEPTED, WRONGANSWER,</span><br><span class="line">         TIMELIMITEXCEEDED, COMPILEERROR, MEMORYLIMITEXCEEDED,</span><br><span class="line">         PARTIALLYACCEPTED, RUNTIMEERROR, NGLANGUAGE, DRPRECATED &#125; Verdict;</span><br><span class="line">    <span class="type">char</span> *SourceCode;  <span class="comment">// Base64</span></span><br><span class="line">    <span class="type">int</span> Time; <span class="comment">// ms</span></span><br><span class="line">    <span class="type">int</span> Memory; <span class="comment">// KiB</span></span><br><span class="line">    <span class="type">int</span> Score; <span class="comment">// 0 - 100</span></span><br><span class="line">    <span class="type">bool</span> HasInput;  <span class="comment">// T</span></span><br><span class="line">    <span class="type">char</span> *UserInput;  <span class="comment">// 自定测试, Base64</span></span><br><span class="line">    <span class="type">char</span> *Message;  <span class="comment">// Base64, Manual or CompilerOutput, or RuntimeStdErr</span></span><br><span class="line">    <span class="type">char</span> *JudgedBy;  <span class="comment">// groupId-groupSeqNo or Manual</span></span><br><span class="line">    <span class="type">char</span> *FailedOn; <span class="comment">// Base64, given by Worker</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有请求和返回值都用 <strong>json</strong></p><p>分为 Controller 和 Service 模块。其中 Controller 模块根据对应功能调用 Service 中的函数，并依此来判断 http 返回状态与内容。</p><p>Service 模块执行鉴权、实际的业务逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> Deprecated </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计开题</title>
      <link href="/20230225-bishe/"/>
      <url>/20230225-bishe/</url>
      
        <content type="html"><![CDATA[<p>研究背景 + 意义，附参考文献 &gt; 600</p><p>中国计算机学会数据库专委会在《“十四五”数据库发展趋势与挑战报告》中指出分布式数据库是未来数据库系统发展的重要方向。据 IDC 调研，超过 90% 的企业认可分布式数据库的部署效果。分布式数据库以其高性能、高可用、高扩展、高弹性为其主要优势。</p><p>openGauss 是国内热门的开源分布式数据库项目，脱胎于华为的 GaussDB 数据库，相比其他开源数据库而言，提供了面向多核架构的并发控制技术，针对了当前多核 NUMA 架构的趋势，可结合硬件优化提升系统整体性能。同时作为一个高可用分布式数据库，支持主备同步、异步、级联的部署模式，提供基于 Paxos 分布式一致性协议的日志复制和选主框架[1]。在开发过程中，引入许多成熟的技术，做到了极致性能、高可靠性、高安全性。在中国数据库排行中，长期位于前3。</p><p>在单机性能方面，openGauss 已经做了诸多优化，如 CBO 查询优化、LLVM 查询动态编译执行，以及各种基于 NUMA 硬件架构的优化。但作为分布式高可用数据库，往往为了副本一致性，增加了通讯开销与等待时间，使得跨节点的性能较为低下。本研究基于 openGauss 现有架构，围绕其高可用分布式一致性协议，对其实现方法、执行流程中的各环节进行考察，在保持副本一致性的同时，通过协议、架构的优化降低其开销。</p><p>国产数据库作为基础软件，产业化道路时间短，基础薄弱，尚未实现市场收益与自身投入的良性循环；同时受制于国际厂商垄断：Oracle 形成的事实上的垄断。且作为数据库产品，用户对其产品成熟度、品牌影响力与信心更加敏感，因为数据的可靠性是用户最看重的。阿里的 OceanBase 在内部被采用，到 TPCC 测试登顶也是一个漫长的过程。因此，对分布式数据库的研究，切合了当下国产基础软件研发的需要。</p><p>国内外研究现状 &gt; 800</p><p>国产原生分布式数据库中，由阿里自主从0开始研发的 OceanBase 是领导者，在 TPCC 和 TPCH 测试上都刷新了世界纪录，并且已经在商用领域得到广泛使用。其基于 Paxos 协议实现高可用三地三中心五副本容灾，同时支持高扩展与 HTAP 混合负载。PingCAP 自主设计研发的开源分布式关系型数据库 TiDB 则坚持开源作为创新引擎，通过全球社区协作开发，为企业级用户提供不断迭代和演进的产品服务。腾讯云 TDSQL 历史较久，对内服务微信支付、腾讯会议、音乐等业务。其提供事务型、云原生、分析型多种产品架构，在国家级别政务民生、金融核心系统上支撑关键业务，支持了第七次全国人口普查全面电子化。其技术创新领先，在11个权威期刊发布论文；同时持续回馈开源社区，多位腾讯工程师凭借对 MySQL 8.0 版本的贡献荣获 MySQL 社区开源贡献大奖。</p><p>在分布式一致性协议方面，openGauss 自身提出了 DCF 分布式一致性框架，基于 Paxos 算法，实现数据同步强一致。其算法结合了 Raft 的主机选举方法，同时灵活地增加了 Logger 角色，只进行日志复制；另外实现了单级级联备，主备间也可以以异步方式进行同步，降低了对主机的压力。但级联备机只能从备机同步，意味着如果备机需要全量 build，级联备也必须重新全量 build，无论其副本是否与主机一致。同时不支持多级级联。</p><p>国内其他的分布式数据库中，以 TiKV 为例，基于 Raft 算法实现了线性一致性的分布式系统。客户端将请求发送给 Leader，Leader 再通过 Raft 将请求复制到主备机的 Log，最终 Commit。各 TiKV 自行应用 Log 到 DB，其状态不能同时一致，若此时发生主机切换，有可能违反线性一致性；若依次全部应用，则无法并发操作状态机，性能较差。于是 TiKV 社区提出了两种优化 ReadIndex 与 LeaseRead， 在保证线性一致性的同时，大幅提升了系统性能。</p><p>国际主流的开源分布式数据库中，以 MariaDB Galera Cluster 为例，它采用多主同步复制，既保持了整个集群的数据一致性，也允许在集群的所有节点上并行执行事务，提高读写性能。但传统同步复制通常采用两阶段提交（2PC）或分布式锁实现，随着节点数量增加，事务冲突和死锁概率增加。为解决这一问题，Galera 的同步复制采用了组通信、写集、数据库状态机、事务重排序等技术，称之为“虚拟同步复制”，使其性能目标得以实现。</p><p>主要研究或解决的问题和拟采用的方法</p><p>主要研究：openGauss 分布式一致性协议的事务、备份性能分析及调优。</p><p>拟采用的方法：</p><p>性能度量方面，通过 perf 对函数执行时间进行分析；监视主备机的各项性能负载；编写测试，对固定 workload 计算时间开销。</p><p>协议优化方面，尝试对日志同步实现 ReadIndex 优化，甚至 LeaseRead 优化；同时实现多级联备机特性。保证仍满足线性一致性。</p><p>工作进度计划 （每2周）</p><p>1、实验环境搭建，阅读项目文档及代码</p><p>2、考察分布式一致性框架，梳理完整协议工作流程</p><p>3、确定测试的数据库工作负载，形成测试代码</p><p>4、对数据库进行初步调整，并测试，形成初步优化方向</p><p>5、根据优化方向，调整协议机制，形成新的工作流程</p><p>6、将调整后的机制实现为代码</p><p>7、测试、再调整，形成最终结果</p><p>8、整理资料与总结分析，撰写毕业论文</p><p>这歌一股霉味？</p><p>问题是改进的需求。不优化是哪里？</p><p>面向openGauss数据库的副本一致性协议优化技术研究</p><p>评测 性能 有问题</p><p>设计度量，数据集，方法，通过xx技术发现瓶颈</p><p>针对瓶颈发现问题，然后原理，然后优化</p><p>以国产开源openGauss分布式数据库为研究对象。在前期的了解过程中，观察到其副本一致性协议中，将Log异步复制到各个备机，再由备机重放到 DB 并持久化的过程，若在状态不一致时发生主机切换则违反线性一致性；若保证按序全部应用，则协议效率降低。本研究借鉴 TiKV 对一致性协议的优化，在保持副本一致性的同时，优化 openGauss 数据库的主备同步效率。</p><p>以国产开源openGauss分布式数据库为研究对象。在前期的了解过程中，观察到其副本一致性协议中，将Log异步复制到各个备机，再由备机重放到 DB 并持久化的过程，若在状态不一致时发生主机切换则违反线性一致性；若保证按序全部应用，则协议效率降低。本研究的主题是通过优化 openGauss 数据库的副本一致性协议，在保证一致性的同时，加速主备同步，进而提升事务执行的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Nginx 下用 proxy—pass 配置多个 location</title>
      <link href="/20230225-nginx/"/>
      <url>/20230225-nginx/</url>
      
        <content type="html"><![CDATA[<p> 给出以下 server 配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> s.tilnel.com;</span><br><span class="line">    <span class="section">location</span> /proxy &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 <code>http://s.tilnel.com/proxy/xxx</code> 时，会转发为 <code>http://127.0.0.1:8080/proxy/xxx</code>。这显然不是本意。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> s.tilnel.com;</span><br><span class="line">    <span class="section">location</span> /proxy/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/; <span class="comment"># backslash is important here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> = /proxy &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">302</span> /proxy/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成。</p><p>但有一点：比如 rslsync 这种毒瘤 Web 控制台自己就会重写 URL。那就别费劲整了。。。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 mdadm 创建软件 raid</title>
      <link href="/20230224-mdadm-raid0/"/>
      <url>/20230224-mdadm-raid0/</url>
      
        <content type="html"><![CDATA[<p>有很多平时配置的细节都丢失了。。需要趁机记录一下，防止以后全忘了。</p><p>1 sector &#x3D; 1 LBA &#x3D; 512 Bytes</p><p>1 block &#x3D; 1 KiB</p><p><code>mdadm</code> 可以用来管理软件 raid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -C /dev/md0 -l raid0 -n 2 /dev/sdX /dev/sdY</span><br></pre></td></tr></table></figure><p>有的时候需要单独操作 <code>/dev/sdX</code>，此时就需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --stop /dev/md0</span><br></pre></td></tr></table></figure><p>然后设备就消失了。之后依然可以用相同的办法重建，但不知道是否需要用相同的顺序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md0</span><br></pre></td></tr></table></figure><p>显示 raid 的信息。</p><p>直接在设备上创建 ext4 文件系统实操不行，必须要有分区表；必须要创建至少一个分区。</p><p>重新组装 raid：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --assemble /dev/md0 /dev/sdX /dev/sdY</span><br></pre></td></tr></table></figure><p>保存当前 raid 配置，并自动执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -E -s -v &gt;&gt; /etc/mdadm/mdadm.conf</span><br></pre></td></tr></table></figure><p>注意记得修改 <code>/etc/fstab</code></p><p>如果 raid 出了问题，记得加 ro 挂载为只读</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o ro /dev/md0p1 /mnt/storage</span><br></pre></td></tr></table></figure><p>一些其他文件系统的操作：</p><p>查看文件占用的扇区号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs -R <span class="string">&quot;stat /path&quot;</span> /dev/blockdevice</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdparm --fibmap /path</span><br></pre></td></tr></table></figure><p>扫描坏扇区（这次不知道为什么，屁都没扫到）：</p><p>non-destructive write test:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">badblocks -svn -o output_file /dev/sdXn</span><br></pre></td></tr></table></figure><p>read-only test:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">badblocks -sv -o output_file /dev/sdXn</span><br></pre></td></tr></table></figure><p>查看占用文件的进程（和 lsof 有什么区别？）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fuser -m path</span><br><span class="line"><span class="comment"># kill all</span></span><br><span class="line">fuser -m -v -i -k path <span class="comment"># interactive</span></span><br></pre></td></tr></table></figure><blockquote><p>fuser is more useful in identifying process id opening a particular file. lsof is useful to find out all file(s) opened by particular process. Save this answer.</p></blockquote><p>写入卡住了，想找坏道，但是没找到，然后发现它自己好了。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Extensible Distributed Coordination</title>
      <link href="/20230125-ExtensibleDistributedCoordination/"/>
      <url>/20230125-ExtensibleDistributedCoordination/</url>
      
        <content type="html"><![CDATA[<p>Abstract</p><p>数据中心的很多服务都有赖于基于分布式锁和消息队列原语的协调和同步操作。我们认为将这些系统当中的协调服务设计为可扩展的是一件非常重要的事。如果不恁能够扩展协调服务的功能，有可能到头来一直在用一个不好的协调算法，最后导致低性能。而添加了扩展性，则需要一些机制来约束扩展以能够作出合理的安全性和性能的保证。我们提出了一个方案，它允许我们以安全的方式，动态地引入和移除扩展。为了避免设计差的插件带来性能上的开销，它限制了扩展对资源的访问。最终的测试中，扩展版本的 ZooKeeper 和 DepSpace 都在分布式的队列中获得了一个数量级的性能提升 （17x for Zookeeper, 24x for DwpSpace），并且其依赖的协调核心能够保持很小的体积。</p><p>Introduction</p><p>现代的 Web-scale 服务很复杂，很难设计和维护。一部分复杂性来源于满足可扩展性和容错；另外一部分来源于使用极其复杂的分布式协议，它们出了名地难实现。于是协调服务就被提出并投入使用，以在对外给出更加简洁的接口的同时，提供同样的服务。</p><p>简而言之，协调服务提供了一个一致的、高可用的数据存储，拥有足够的同步能力以应对客户端进程对基本任务的执行，如互斥操作和领导选举，并且储存重要的系统配置。这样的客户端通常是在上百上千服务器集群上部署的服务进程。协调服务的两个特性解释了它们成功的原因：1、它们为更大的分布式系统提供了一个坚实可信的锚点（基础？），使用坚固的状态机复制协议实现来避免所有的单点错误，并且 2、它们的少而有限的接口，也叫做协调内核，能够以简单的 RPC 的形式被调用，就算不是分布式计算编程的专家，也能够凭直觉弄懂。</p><p>尽管简化了使用，有限的协调内核也有一个明显的缺点：受限在一组特定的原语之内。更加复杂的协调任务，比如一个分布式队列，必须被实现为一组多个 RPC 调用，在性能上非常吃亏。例如，因为 ZooKeeper 没有提供在数据节点当前值的基础上更新值的原语，这样的一个操作必须用一个读再根据情况写入来实现，导致在资源抢占较频繁的条件下的性能非常糟糕。这种缺陷是有限的协调内核天生就有的。一种办法是增加新的原语，然而这也就导致丢失了上面所说的有限接口的好处。</p><p>在这篇工作中，我们因此而采用了不同的办法：让协调服务变为可扩展的。因此，我们展示了一个模型，它允许客户端动态地、安全地扩展一个协调服务，通过一小段定制的代码在服务端原子地运行。另外，我们设计了一个沙盒来约束这些扩展不要降低或干碎整个系统的性能。</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Project 2 客观题杂谈</title>
      <link href="/20230120-summary/"/>
      <url>/20230120-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Project-2-客观题杂谈"><a href="#Project-2-客观题杂谈" class="headerlink" title="Project 2 客观题杂谈"></a><center>Project 2 客观题杂谈</center></h1><center>南京大学 孙博文<br>tilnel@smail.nju.edu.cn</center><p>谢谢选题的同学们，过程中出了一些波折，年前选做的同学被折腾得厉害，算是共同完成了客观题的出题完善工作。</p><p>分低不要担心，我会 curve 到和主观题相似的分布和平均分。分数过低的，我会看一眼完成度再给主观打分；ddl 前提交初始 repo 的同学，得准时与诚信分 20，看情况可能更高点。</p><p>认真独立做这两题的学习效果绝对不赖。</p><p>通过客观题的法宝就是充分测试。</p><p>[toc]</p><h2 id="Ramfs"><a href="#Ramfs" class="headerlink" title="Ramfs"></a>Ramfs</h2><p>ramfs 的测试点到 9 就算完结了。1 月 19 的晚上，sbw 躺在床上想破头也没想到如何构造与现实应用场景类似，又重 IO，又好用这几个捉襟见肘的 API 写出来的测试。于是干脆就直接取消了：反正 10 不管怎么写，估计都不会超过 1-9 的测试量了。</p><p>下面给出一些比较通用的建议。</p><h3 id="输入合规检查"><a href="#输入合规检查" class="headerlink" title="输入合规检查"></a>输入合规检查</h3><p>实现 API 的时候，要对输入数据进行 validate。test4 里的那个 rread(-100000000) 就已经足够惊悚，大家最后都改过来了。但如果在某一个数据点里偷偷再安插一个 rwrite(1000000)，你改正过一次的程序，也能应对这种摧残吗？…这种已经属于很初级的要求。但我们的数据点也并未再从边角料里挖两个坑给大家跳：手册里提过的那些边界情况，对了这次就对了。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>主张：分配的时候，就想好是谁最终释放。比如 ropen 中分配的空间，肯定是 rclose 释放；O_CREAT 分配的空间，最终肯定是 unlink 去释放。如果一段空间不需要跨函数使用，那么尽量做到谁分配，谁释放。</p><p>譬如，有这样的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">generate_some_string</span><span class="params">(<span class="type">int</span> arguments)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ret = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">char</span> *pathname, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *something = generate_some_string(args);</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc 的这段空间，由 generate 分配，主要由 ropen 实际使用，最终也只能在 ropen 中回收。但是孤立地看 ropen，并不一定意识得到它调用了一个会分配一段空间的函数而没有释放掉。所以，更好的做法是由 ropen 进行分配，将指针作为参数传给被调用者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">generate_some_string</span><span class="params">(<span class="type">char</span> *destination, <span class="type">int</span> arguments)</span> &#123;</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">char</span> *pathname, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *something = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    generate_some_string(something, args);</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="built_in">free</span>(something);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，free 和 malloc 就对应起来了。</p><p>管理内存的另外一点，就是注意函数的所有出口之前，释放掉用完的所有空间。有的时候函数中遇到某些异常状态，提前终止执行了，这个时候可能已经分配了一些内存。然而有的时候，只会想到在最终正常执行返回之前释放内存，疏忽了那些“分支”。</p><p>就算 coding 再怎么精打细算，也逃不掉释放不完的命。这种时候就要利用工具了：</p><p>address sanitizer。在 Makefile 的 gcc 后面加一个参数 <code>-fsanitize=address</code>，即可看到泄漏的内存总大小、泄漏位置。<strong>是 Linux 专属武器</strong>。</p><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>实验评测的时间是充裕的，但仅限你没有写出非常消耗时间的垃圾设计。必要的循环遍历、链表遍历并不会让你得到时间超限。譬如，从 0 到 4095 循环来找到一个空闲的 fd；譬如，遍历子目录的 sibling 链表找到名称匹配的那一个。你不需要写节约时间（某种意义讲，也挺浪费时间的）高级数据结构，比如哈希表，etc。也不需要用倍增等方式去节约 realloc 的调用。</p><blockquote><p>Premature optimization is the root of all evil. –Donald Knuth</p></blockquote><blockquote><p>Keep it simple, stupid.</p></blockquote><p>讲一个我看到的案例。一位同学某测试点超时，我把测试点拆成两半，仅运行前半耗时 6s，仅运行后半耗时 5s。但如果放在一起，总耗时就会变成 90s：前半的时间不变，后半拖慢了很多。最终分析下来结果是这样的：前半执行时，他代码中的某个循环条件会增加。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cond; i++) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个 cond 不断地增长。后半受到这个增长的影响，每次又都跑完了整个循环，时间就炸了。</p><p>但其实这是可以避免的！因为这个循环是“找到了就可以退出”的循环。他只是忘记写 break…当然他后来自己凭借肉眼找到了，我觉得很牛逼。</p><p>除了肉眼，我们还有什么办法做性能测试呢？当然一切的前提是：自己写了测试点。</p><p>以 789 三个点为例，7 是大文件测试，那少说也得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwrite(fd, buf, <span class="number">400</span> MB);</span><br></pre></td></tr></table></figure><p>像这样顶着上限去测试。</p><p>8 是文件树测试，这就更容易了，无非就是宽度和深度。</p><p>9 是 fd 管理。那就是频繁 ropen, rclose，以及多个 fd 一起读写。OJ 测试的上限是 4096，自己测就往极限去靠就 OK 了。</p><p>有了测试点以后，我们就可以运行了。测试点在设计上，要能够灵活地修改规模。在不同规模下，对同一性质的测试点做多次测试，可以总结一些规律。也可以对测试的运算量的数量级以及运行时间做预测。如果结果比预测慢很多。就可以去被测函数的代码里寻找性能下降的原因，比如 fd 资源紧张因此分配变慢，这是合理的；但 fd 资源空闲时依旧分配较慢，这就不太对劲。</p><blockquote><p>目前大多数个人计算机的效率在每秒 1e8 次循环的数量级。</p></blockquote><p>有什么工具能定位性能问题？</p><p>Linux Perf.</p><h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p>老规矩，先用测试把问题暴露出来。在此基础上，gdb 也好，IDE 的断点调试、内存监视也好。</p><h2 id="Gitm"><a href="#Gitm" class="headerlink" title="Gitm"></a>Gitm</h2><p>gitm 目前有一位同学选做，做得还是很用心的。估计后续没人想选做，就摸了。这题比起 ramfs，系统设计的味儿更浓一点。</p><p>这题的原型是去年 Project-2 的 git–。我去年是期待出成今年这个形式的，最后原操刀人出成了标准输入交互程序。大家都喜欢写熟悉的 OJ，看到是客观题就被骗进来，但是因为难度不低，最后分数惨淡，不得不 curve。Ramfs 还算离传统 OJ 的形式近一点；再近一点，无非是我把函数调用改成格式化的输入，用 scanf 代替编译链接 main.c。设计成这样就是为了让大家不得不学学 Makefile，命令行这些东西。gitm，就走得更远了，它要求你的程序和自身以外的更多东西打交道了：参数解析，数据持久化，外部命令…整个程序的逻辑非常好想，但是搞明白每一样东西怎么用，怎么将它们配合起来，就比较困难啦。</p><p>这题其实是有捷径可以走的。只要会组合一点命令行，配合 diff 和 patch，就能轻松写出一个 200 行以内的形 C 实 shell 的 gitm，能得到 80 以上的分数。</p><h2 id="测试思路"><a href="#测试思路" class="headerlink" title="测试思路"></a>测试思路</h2><p>difftest：用一个正确的实现和你的实现做对比。</p><p>ramfs 的正确实现这不是就很好找吗？把 ramfs 的 API 用真实文件系统 API 去实现，这就是标准实现啦，至多需要把两者的差异做一个适配，写下来也就没几行代码。这样的标准实现，首先它可以用来证明你的测试写得没问题。</p><p>注意 Linux 默认进程打开的文件描述符上限是 1024，并且开局已经占去了 3 个。但是这也够你自己的实现喝一壶的了。</p><p>其次就是用来做 difftest：你做一步，我做一步，然后我们看看结果是不是一样呗？</p><p>gitm 也是类似的思路。这不是有 git 可以参考嘛，我们只需要两边各做一步，然后对比结果，就好了。。。记得用脚本而不是傻乎乎地每次都手敲。</p><h2 id="扩充知识"><a href="#扩充知识" class="headerlink" title="扩充知识"></a>扩充知识</h2><p>全是关于 ramfs 的。但不能帮助你写 ramfs。</p><p>Linux 文件系统 API 的实际情况和 ramfs 有差异：</p><p>open 其实不支持 O_WRONLY | O_RDWR，会打开失败。</p><p>使用 O_APPEND，不管 rseek 到哪，永远都是在结尾 write。此时 offset 只能对读操作生效。</p><p>打开已有目录时，O_CREAT 会导致失败。</p><p>unlink 时如果文件仍在打开中，会把 unlink 交由 fd 来做。即最后一个引用文件的 fd 被关闭时，文件（的这一链接）被删除。</p><blockquote><p>什么是链接？为什么叫 unlink 而不叫 remove、rmfile？</p></blockquote><p>文件只是节点。这一节点可以在多处被多次引用，这就是链接的实质。对同一文件的多个硬链接只占1份空间。文件系统管理时使用“引用计数”，只有在引用计数归零的那一次 unlink 时，文件内容真正从文件系统中消失。</p><p>目录是可以 open 的。我们不能 read 或 write，但是可以 openat（在 fd 指向的目录中打开文件），getdents（获得 fd 指向目录中的子目录项）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>人生苦短，多用工具。</p><p>有 bug 不要盯着看。如果本地跑过了，就想办法写点测试让它跑不过；如果本地跑不过，但是看不出问题，就跑起来看（调试器）。</p><p>内存泄漏和段错误有 sanitizer；答案错误可以打 Log 看看是哪一步出问题；时间超限有 perf。</p><p>学习新的工具，每样学 10 分钟，能节省 90% 的瞪眼时间。浪费的时间都够读个 PhD 毕业了（别骂了）。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gitm final ver</title>
      <link href="/20230114-gitm-final/"/>
      <url>/20230114-gitm-final/</url>
      
        <content type="html"><![CDATA[<h1 id="Gitm-实验手册与指南"><a href="#Gitm-实验手册与指南" class="headerlink" title="Gitm - 实验手册与指南"></a><center>Gitm - 实验手册与指南</center></h1><center>南京大学 孙博文<br>tilnel@smail.nju.edu.cn</center><p>随意的项目要求 + 很简单的指导，主要是设计思路 + 可利用的工具。</p><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>git 是当今世界上最流行的版本控制系统。本实验要求你通过提交 git repo 的方式来提交一个迷你版的命令行工具 gitm(inus)。</p><p><strong>注意：本实验将只能在 Linux 操作系统中完成</strong>，因为你不得不使用系统调用，而 OJ 是 Linux 的。提交 Windows 上可以编译运行的代码，在评测机上注定不可兼容。</p><p>首先，你需要学习 git ，否则你将完全不明白 gitm 的功能，并且也无法用 git 来管理本次作业的代码。</p><blockquote><p>是的！我们将会发布一个由 git 管理的框架代码，并且要求你一直使用 git 来管理，最终提交一个 git repo。</p></blockquote><p>获取框架代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.nju.edu.cn/Tilnel/gitm.git</span><br></pre></td></tr></table></figure><h2 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h2><p>所有代码，包括 .c 和 .h 文件需要放在 git repo 的根目录下。对自己使用的头文件的引用请以双引号的形式，以便编译脚本能够正常工作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitm</span><br><span class="line">├── gitm.c</span><br><span class="line">├── gitm.h</span><br><span class="line">├── whateveryouwant.c</span><br><span class="line">├── whateveryouwant.h</span><br><span class="line">├── ...</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">/* gitm.c */</span><br><span class="line">#include &quot;gitm.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可以修改 Makefile，但请不要删除其中的 git 目标依赖。我们在 Makefile 中确保了你的每一次编译运行都能够自动进行 git commit。这些自动的 commit 可以帮助你回滚到自己想要的任意版本，并且在未来查重工作中产生疑问时，良好的 commit 记录将成为重要的证明。</p><p>在你的 git repo 里请包含所有编译所需的源文件，但不要出现编译不需要的多余的源文件。</p><p>尝试编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>你将看到根目录下产生了一个名为 gitm 的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gitm version</span><br></pre></td></tr></table></figure><p>你将看到一个小彩蛋（你之后可以自由地删掉它或修改掉，不影响成绩）。</p><p>注意：本次实验你编写的是一个 “命令行工具”。也就是说，我们将以和使用 git 相同的方式来使用它：在命令行里输入命令和参数。这意味着，这次你需要真正 “解析参数” （被 parse.c 支配的恐惧）。</p><p>而且，这次我们将会在运行中多次调用你的程序。也就是说，你的程序并不是在一直运行着，每一次调用都会做不同的事。你存储在内存里的数据都将随着功能完成，进程结束而消失。所以，关于 gitm repository 的有用的信息，你需要将它们持久化到磁盘上，以便进行后续的操作。因此学习 C 语言的文件操作是必不可少的。</p><p>为了实现一个 git，首先你要了解 git 的功能</p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>假设我们当前在一个文件夹 dir 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm init</span><br></pre></td></tr></table></figure><p>初始化当前的 dir 为一个 gitm repository。如果当前 dir 已经是一个 gitm repo，则不做任何操作。</p><p>此时的 gitm 中应当不存在任何 commit，gitm 的仓库中应不存在任何文件。</p><p>具体来说，你可以在当前目录下创建一个 <code>.gitm</code> 目录，用于存放一些记录仓库状态的文件。</p><blockquote><p>对，就像 git 的 .git 那样！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm commit</span><br></pre></td></tr></table></figure><p>将当前仓库中文件改动后状态作为一个提交，并记录下来。然后不重复地给出一个长度为 8 的小写十六进制数（例如 3bdc8902），用于唯一地指示这一次 commit。</p><p>git 中的提交是一个树形的结构。我们希望你在 gitm 中，同样实现这样的树形结构。</p><img src="git-brance.svg" alt="img" style="zoom: 100%;"><p>gitm 中不要求实现对分支的命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout commit</span><br></pre></td></tr></table></figure><p>checkout 用于将当前目录的状态切换到 commit 所指示的提交上。</p><p>若当前目录的状态较 gitm <strong>当前所处的 commit</strong> 有改动，则拒绝本次 checkout，并且<strong>你的 main() 函数以返回值 1 退出</strong>。</p><p>checkout 正常完成后，你目录中文件的状态（除了 .gitm 目录以外）必须与指定的 commit 相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout .</span><br></pre></td></tr></table></figure><p>特殊地，这一条命令用于将目录文件恢复到当前所处的 commit 时的状态。也就是说，放弃此时对文件的所有改动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm merge commit</span><br></pre></td></tr></table></figure><p>找到当前所处 commit 与命令指定的 commit 的公共祖先，并将两个 commit 合并起来。</p><p>具体来说，是将命令指定的 commit 相对于公共祖先的修改，应用于当前所处的 commit。</p><p>如果合并的两个 commit 相对于公共祖先，均对同一个文件产生了修改（创建、删除、编辑），那么命令直接拒绝执行，输出 “conflict\n” <strong>并使 main 函数返回 1</strong>。</p><p>在其他情况下，你需要合并，并产生一个新的 commit。逻辑上，这个 commit 将成为被合并的两个 commit 的共同后继。</p><blockquote><p>我们如何检测这一点？</p><p>假设有 commit a-g，b, c 由 a 分支而来，d 由 b, c 合并而来，e 是 b 的后继，f 是 c 的后继，g 是 d 的后继。</p><p>你的程序应当有能力找到 e, g 的公共祖先是 b，f, g 公共祖先是 c，在此基础上合并是无冲突的。如果你只能找到 a，则合并有可能产生冲突，因为 e 相对 a 改变了 a.c，而 g 相对 a 也改变了 a.c。</p></blockquote><img src="image-20230103113625830.png" alt="image-20230103113625830" style="zoom: 67%;"><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>我们会将你的 repo 里所有的 C 源文件和头文件收集起来进行编译，并生成一个名为 <code>gitm</code> 的可执行文件。然后原地创建一个文件夹，作为你的 gitm 需要管理的 repository。例如（其中 &gt; 开头的行表示命令行输出）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line">../gitm init</span><br><span class="line">../gitm commit</span><br><span class="line">&gt; 3bce5ff0                       <span class="comment"># 空 commit，我们的 OJ 一定会创建一个空 commit 作为第一个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt   <span class="comment"># 创建文件并写入</span></span><br><span class="line">../gitm commit</span><br><span class="line">&gt; b926d817</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is my git&quot;</span> &gt; readme.txt</span><br><span class="line">../gitm checkout 3bce5ff0</span><br><span class="line">&gt; You<span class="string">&#x27;ve made change. Please commit or garbage your change.</span></span><br><span class="line"><span class="string">echo $?                          # 给出上一条命令的返回值。正常退出的程序应当为 0</span></span><br><span class="line"><span class="string">&gt; 1</span></span><br><span class="line"><span class="string">../gitm commit</span></span><br><span class="line"><span class="string">&gt; ef938aa6</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt readme.txt .gitm</span></span><br><span class="line"><span class="string">../gitm checkout b926d817</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt .gitm</span></span><br></pre></td></tr></table></figure><p>随着时间的流逝，我将会发布进一步的实验指南。</p><h2 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h2><ul><li>你创建的所有文件都要放到运行目录的 .gitm 目录下。<ul><li>+++ 对目录的体积要求：不要每一次都追踪没有发生变化的文件即可。不需要对每个文件进行增量存储。 +++</li></ul></li><li>commit 数量不会超过 10000 个。</li><li>你的 gitm 只需要管理文本类型的文件。其他类型的文件不会出现。</li><li>不要求追踪空目录</li></ul><p>本实验的测试点预计如下：</p><p>1、hello world（保留 gitm version 的打印信息即得分）</p><p>2、和上面的脚本相似的一段小测试，基础功能</p><p>3、文件数量增加，提交数量增加；但并不会出现子目录</p><p>4、在 3 的基础上，有一定的目录结构</p><p>5、在 4 的基础上，测试 merge 功能（不会很刁钻，只要该拒绝的拒绝，该成功的 merge 对就行了）</p><p>6、测试 .gitm 的空间管理，<strong>要求未发生改动的文件不重复存储，不要求单文件的增量存储</strong></p><p>能够恢复对文件就可以了，不会太刁钻。</p><h2 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h2><p>一个更加 naïve 的思路。从一个 commit 刚刚被提交说起…</p><p>此时，所有的目录结构和文件改动都被提交了，我们可以在当下的目录中进行新的改动。为了能够恢复到刚刚提交的“干净”状态，我们需要为当下的状态做一个暂存，以便之后进行对比。</p><p>现在我们做了一些改动，想要 commit。这里，需要记录下改动的部分，没有改动的部分则默认是保持的。我们可以用文件系统的 api 遍历当前目录和暂存下来的目录，检测文件的增删等。对于依然存在的文件，则需要逐字符对比其中的改动。当所有的改动全部检测完毕后，在 .git 下保存好本次改动中：</p><ul><li>删除了哪些文件</li><li>增加了哪些文件和这些文件的内容</li><li>编辑了哪些文件和这些文件的新版本</li></ul><p>并将本次 commit 及其父节点 commit 号记录下来。</p><p>可以使用的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;     <span class="comment">// 打开目录</span></span><br><span class="line">       <span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;  <span class="comment">// 读取目录中的项目</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;  <span class="comment">// 创建新目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;   <span class="comment">// 删除目录</span></span><br></pre></td></tr></table></figure><blockquote><p>如何更简单地判断新文件是否发生改动，特别是较大文件？</p></blockquote><p>可以对所有存储下来的文件做 <code>md5sum</code>，为文件生成一个摘要。之后再有文件变动时，先去找是否存在相同的 md5，如果新旧文件的 md5 相同，就不用重复保存了。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="废弃的旧思路（依然可以尝试）"><a href="#废弃的旧思路（依然可以尝试）" class="headerlink" title="废弃的旧思路（依然可以尝试）"></a>废弃的旧思路（依然可以尝试）</h3><p>一个 naïve 的思路。</p><p>首先介绍两个工具，一个叫做 diff，一个叫做 patch。这两个工具是大部分发行版自带的。<strong>看到这里请打开你的命令行</strong>一起尝试一下。</p><p>准备任意一个代码文件 a.c，复制到 b.c，在 b.c 中加入一些行，删去一些行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>能看到：</p><img src="Screenshot_20230115_000047.png" alt="img" style="zoom:75%;"><p>可知，diff 可以计算出两个文本文件之间的差距。</p><p>用重定向将这一结果定向到 <code>diff.out</code> 中，我们再用 patch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch a.c diff.out</span><br><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>这次什么也没有输出。a.c 和 b.c 变成一样的了。</p><p>diff 不仅可以给 a.c 打补丁，还可以把补丁从文件中拆下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -r b.c diff.out</span><br></pre></td></tr></table></figure><p>再打开 b.c，就能发现文件变回了之前  a.c 的样子。</p><p>great。所以只要你能够在 commit 的时候遍历目录中的所有文件，挨个 diff 一下，就可以算出当前版本和上个版本的差距了。然后你把这些差距全都写 .gitm 中的某一个文件，大功告成。</p><p>diff 和 patch 可以对两个目录直接计算差值和补丁&#x2F;回退。如果你学会怎么用，省去很多麻烦事。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结：在 .gitm 中我们需要存储的元素</p><ul><li>一个文件，能指示当前所处的提交</li><li>一个文件，包含了所有的提交号，并需要能够指明每个提交在树结构上的祖先节点。对于新 commit 是一个，对于 merge 是两个（这与 git 并不完全相同）</li><li>若干个目录，每个代表一个 commit；每个目录若干个文件，记录它相对祖先节点的变化：增减文件目录，编辑文件</li><li>一个目录，包含了当前 commit 的暂存状态，以便之后用于与编辑后的状态进行比较</li></ul><p>在 gitm 执行的过程中，有这样一些子功能需要实现：</p><ul><li>解析参数，执行对应功能</li><li>遍历当前文件树，与已提交的文件树对比</li><li>将对比的文件树中公共部分进行比较</li><li>分析 commit 记录，确定提交之间的关系</li><li>通过提交之间关系，决定前进或后退</li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Art Performance Lecture Notes</title>
      <link href="/20230113-artperformance/"/>
      <url>/20230113-artperformance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>晚上听课里说的一个剧 阿喀琉斯进场<br><img src="image-20230113023838864.png" alt="image-20230113023838864"></p></blockquote><p>精神分析视角看阿布拉莫维奇的行为艺术作品</p><p>本文中提出的反思是通过分析行为艺术家玛丽娜·阿布拉莫维奇的作品 Rythm0, Rythm 10, Imponderables, Rest Energy 和对视引发的。</p><p>自传中写到，玛丽娜·阿布拉莫维奇 1946 年出生于贝尔格莱德，当时塞尔维亚人正处于战争的结束和前南斯拉夫共产主义政权的开始。她是获得勋章的共产主义战争英雄的长女，即使没有盟军的政治和物质支持，也依旧坚持对轴心国军队的武装抵抗。这让阿布拉莫维奇夫妇对他们的国家有着共同的自豪感。他们有两个孩子和一间房子，里面有严格的纪律教育，有既定的规则，需要严格遵守最勤奋的士兵。母亲是遥远而几乎冷漠的冷漠的化身。她有条不紊，并制定了女儿每天必须遵守的规则。如果由于某种原因忽略了一些小细节，她将受到毒打的惩罚。</p><p>因此不难理解，在阿布拉莫维奇的作品中，为什么常常涉及强制、痛苦和规则。这些作品是对她童年期经历的一种重建。[1] 她的作品中，总是体现着非常强烈的对抗性，无论是与乌雷合作的作品中，还是在她独立完成的作品中。与某种权力或力量对抗是重要的主题，它包含了一种二元论的色彩。文化运动五月风暴对二元论进行了消解，通过政治斗争和话语争鸣，多元化、多样性和差异性逐渐成为政治正确性的内容，但这无法回避自由世界需要借助二元论来维系其整体性、其在价值谱系中的崇高地位。[2]。但阿布拉莫维奇的作品则将二元对立中的价值判断问题重新搬了出来：强调多元化、差异性的政治正确仅仅是对一个内在被需求的对抗性结构的遮蔽。她的作品即成为了言说、宣泄这种二元性的空间。</p><p>Rythm0 中，阿布拉莫维奇最初穿着黑色的 T 恤站在那里。她对观众给出了两个信号，一是“桌子上的72种工具”：口红、子弹、枪、菜刀、鞭子。其中这些危险物品的暗示着“伤害”、“死亡”……二是“对她做任何事都是可以的”，看似中性的描述，实则是对围观者的一种怂恿、挑动。很快，她身上的黑色 T 恤被剪开，有人用上了膛的枪指着她；同时，也有人自动对她进行保护。最终在人们的保护中，这件作品自然地结束了。在这里，对立的双方是什么？是阿布拉莫维奇和外界的一切？还是毫无顾忌地对她“做任何事”的观众，与保护着她的观众的对立？我认为这里最终呈现的效果无疑是后者。更准确地说，是“自由冲动”与“道德感”的对立。这其实是一个非常重要，并且结论并不是那么明确的论题。</p><p>这里的“冲动”，并不是“原始冲动”所指的人的动物性。从源头上来看，它与“道德感”是产生于同样的阶段的，都是拉康意义下的“自我”。同时，也不能单单认为只有“道德感”是受到社会规训、异化而来的。这两种态度都应当被认为是在大写他者的欲望驱使下产生的态度。没有哪一个是更本真的，如果抛弃一切预设的立场，想要对两种行为做出价值判断，则变得更加困难。</p><p>Rest Energy 中，阿布拉莫维奇和乌雷两人合作着拉开了一支弓，并把箭头对准了阿布拉莫维奇的心脏。二人的胸口都装了录音器，在长达 4 分 10 秒的时间里，加速的心跳清晰可闻。这是一个既危险又浪漫的场景，当然是表明了一种绝对的信任关系。另一个主流的解读是，展现了生命的脆弱。弓在其中是一种危险感的代表，生与死的界限仅仅在于一个微不足道的改变甚至失误。</p><p>我在这件作品中，看到它是主体间关系的一种形象的表达。黑格尔发现了“我在我的存在中依赖别人”，或者说，“我是一个由于一个别人才是自为的存在”。他们承认着他们自己，因为他们彼此相互地承认着他们自己。但当自我意识处在自在阶段时，那另一个对方却带有“否定性的性格”，所以，我与他人的初始关系是极端对立的，这表现为一种斗争，一场“生死的斗争”。[3] 这里就出现了由对象反射得来的物性镜像式的关系：通过它的对方才是它自己。</p><p>总结</p><p>浅浅地把这学期所斜视的两个领域的东西无端地结合起来。事实上我在看到作品的时候这就是我产生的第一反应，但是事后再去想就非常牵强。最后匆忙地写下来，字数也未达标，望谅解。</p><p>[1] Simões, L. and Passos, M. (2018)  玛丽娜·阿布拉莫维奇的行为艺术作为一种变革性体验。<em>心理学</em>，<strong>9</strong>，1329-1339. DOI：<a href="https://doi.org/10.4236/psych.2018.96081">10.4236&#x2F;Psych.2018.96081</a></p><p>[2] 翟晶，没有他者性的他者:论三位当代艺术家，《世界美术》 2016 年 04 期</p><p>[3] 张一兵：《拉康哲学映像——不可能的存在之真》修订版，上海人民出版社，第 107 页</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并行 LU 分解</title>
      <link href="/20230112-mpp-lu/"/>
      <url>/20230112-mpp-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="实验2-LU-分解-（OMP-与-MPI-实现）"><a href="#实验2-LU-分解-（OMP-与-MPI-实现）" class="headerlink" title="实验2 LU 分解 （OMP 与 MPI 实现）"></a>实验2 LU 分解 （OMP 与 MPI 实现）</h1><p>191240046 孙博文</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>在线性代数中，LU 分解是矩阵分解的一种，可以将一个矩阵分解为一个下三角矩阵和一个上三角矩阵的乘积（有时是它们和一个置换矩阵的乘积）。LU分解主要应用在数值分析中，用来解线性方程、求反矩阵或计算行列式。</p><p>在 LU 分解的过程中主要的计算是利用主行 i 对其余各行 就 (j &gt; i)  做初等行变化，各行计算之间没有数据相关关系。因此可以对矩阵按行划分来实现并行计算。考虑到计算过程中处理器负载的均衡，对矩阵采用行交叉划分；假设处理器个数为 p，矩阵的阶数为 n，则每个处理器处理的行数为 $m &#x3D; \lceil n &#x2F; p\rceil$。</p><p>OpenMP 是基于线程的编程模型，设计基于多线程的 OpenMP 的 LU 分解算法，其主要思想为：外层设置一个列循环，在每次循环中开设 THREAD_NUMS 个线程，每个线程处理的矩阵 A 的行为上述的 m，一次循环过后则完成对应列的变换，这样在 n 次循环过后便可完成矩阵 A 的 LU 分解。即 L 为 A 中下三角部分的元素，其对角线上元素为 1，其他为 0。U 为 A 中 的上三角部分。</p><p>对于 MPI 而言，则是将矩阵数据由 0 进程按行交叉划分发送到各个进程中。在计算过程中，主行数据所在的进程将主行的数据广播到其他各进程。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>核心伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Begin</span><br><span class="line">  对所有处理器，同时执行如下算法：</span><br><span class="line">  for i = 0 to m - 1 do</span><br><span class="line">    for j = 0 to p - 1 do</span><br><span class="line">      if (my_rank=j) then</span><br><span class="line">        v = i * p + j   // 主行</span><br><span class="line">        for k = v to n - 1 do</span><br><span class="line">          f[k] = a[k, v]</span><br><span class="line">        end for</span><br><span class="line">        将 f 广播到所有处理器</span><br><span class="line">      else</span><br><span class="line">        v = i * p + j</span><br><span class="line">        接收广播的主行到 f</span><br><span class="line">      end if</span><br><span class="line">      u = i * p + my_rank</span><br><span class="line">      if (my_rank &lt;= j) then</span><br><span class="line">        for k = u + my_rank to n - 1 step p do</span><br><span class="line">          a[k, v] = a[k, v] / f[v]</span><br><span class="line">          for w = v + 1 to n - 1 do</span><br><span class="line">            a[k, w] = a[k, w] - f[w] * a[k, v]</span><br><span class="line">          end for</span><br><span class="line">        end for</span><br><span class="line">      else</span><br><span class="line">        for k = u to n - 1 step p do</span><br><span class="line">          a[k, v] = a[k, v] / f[v]</span><br><span class="line">          for w = v + 1 to n - 1 do</span><br><span class="line">            a[k, w] = a[k, w] - f[w] * a[k, v]</span><br><span class="line">          end for</span><br><span class="line">        end for</span><br><span class="line">      end if</span><br><span class="line">    end for</span><br><span class="line">  end for</span><br><span class="line">End     </span><br></pre></td></tr></table></figure><p>对于 MPI 来说，仅仅是使用 Bcast 而已；而对于 OMP 编程，除了对第二层循环添加 <code>#pragma omp parallel</code> 以外，还要在 j 循环的末尾加上 <code>#pragma omp barrier</code>，保证当前主行的运算全部结束后，才能选出下一个主行。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="OMP"><a href="#OMP" class="headerlink" title="OMP"></a>OMP</h3><p>在 LU 分解运算开始之前用 <code>omp_get_wtime()</code> 记录下开始的时间，在运算完成后再用当前时间减去开始时间得到运算过程持续的时间。</p><p>输入的矩阵阶数 $n &#x3D; 1000$，是一个下三角矩阵和上三角矩阵的乘积。期望 LU 分解能将其还原。</p><div>$$A = \begin{aligned}\begin{bmatrix}1 & 0 & 0 & ... & 0\\2 & 1 & 0 & ... & 0\\3 & 2 & 1 & ... & 0\\... & ... & ... & ... & ...\\n & n - 1 & n - 2 & ... & 1\\\end{bmatrix}\begin{bmatrix}1 & 2 & 3 & ... & n\\0 & 1 & 2 & ... & n - 1\\0 & 0 & 1 & ... & n - 2\\... & ... & ... & ... & ...0 & 0 & 0 & ... & 1\\\end{bmatrix}\end{aligned}$$</div><p>编译时开启优化选项 <code>-O2</code>，得到的可执行程序在 6 核心 12 线程，3.4GHz 的平台上，得到计算过程的运行时间结果如下：</p><table><thead><tr><th>线程数</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>1</td><td>0.233030</td><td>0.150938</td><td>0.093188</td><td>0.069713</td><td>0.108846</td></tr><tr><td>2</td><td>0.226725</td><td>0.146629</td><td>0.097024</td><td>0.066818</td><td>0.113264</td></tr><tr><td>3</td><td>0.244155</td><td>0.170408</td><td>0.094506</td><td>0.069337</td><td>0.151547</td></tr><tr><td>4</td><td>0.259125</td><td>0.161575</td><td>0.096396</td><td>0.070211</td><td>0.186803</td></tr><tr><td>5</td><td>0.215795</td><td>0.149947</td><td>0.099653</td><td>0.072364</td><td>0.166726</td></tr><tr><td>AVG</td><td>0.235766</td><td>0.155899</td><td>0.096153</td><td>0.069689</td><td>0.145437</td></tr><tr><td>加速比</td><td>1.00</td><td>1.51</td><td>2.45</td><td>3.38</td><td>1.62</td></tr><tr><td>效率</td><td>1.00</td><td>0.75</td><td>0.61</td><td>0.42</td><td>0.10</td></tr></tbody></table><h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h3><p>输入与上述相同，结果为：</p><table><thead><tr><th>线程数</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>1</td><td>0.252182</td><td>0.177158</td><td>0.065233</td><td>0.066492</td><td>0.086463</td></tr><tr><td>2</td><td>0.240585</td><td>0.173630</td><td>0.077885</td><td>0.064615</td><td>0.086954</td></tr><tr><td>3</td><td>0.251120</td><td>0.156510</td><td>0.083122</td><td>0.062328</td><td>0.101553</td></tr><tr><td>4</td><td>0.223808</td><td>0.168837</td><td>0.077668</td><td>0.067501</td><td>0.087048</td></tr><tr><td>5</td><td>0.289730</td><td>0.164849</td><td>0.085826</td><td>0.066900</td><td>0.138214</td></tr><tr><td>AVG</td><td>0.251485</td><td>0.168197</td><td>0.077947</td><td>0.065567</td><td>0.100046</td></tr><tr><td>加速比</td><td>1.00</td><td>1.49</td><td>3.23</td><td>3.84</td><td>2.51</td></tr><tr><td>效率</td><td>1.00</td><td>0.75</td><td>0.81</td><td>0.48</td><td>0.16</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并行矩阵乘法</title>
      <link href="/20230112-mpp-mul/"/>
      <url>/20230112-mpp-mul/</url>
      
        <content type="html"><![CDATA[<h1 id="实验1-矩阵乘法"><a href="#实验1-矩阵乘法" class="headerlink" title="实验1 矩阵乘法"></a>实验1 矩阵乘法</h1><p>191240046 孙博文</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>设 A 和 B 是两个 $n\times n$ 矩阵，它们的乘积也是 $2\times 2$ 矩阵。根据乘积关系，我们有<br>$$<br>C[i, j] &#x3D; \Sigma^{n}_{i &#x3D; 1}A[i, k]\times B[k, j]<br>$$<br>串行程序中，C 的每个元素需要 n 次乘法和 n - 1 次加法。因此，C 的计算复杂度为 $O(n^3)$。</p><p>实际上，C 中个元素的计算在本质上是独立的，可以将矩阵划分成多个块，这样串行矩阵乘法中矩阵元素的乘-加运算代换为子矩阵的乘-加运算，然后指派给不同的处理器，实现并行运算。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在运算的最外层循环前加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="comment">/* calculate */</span></span><br></pre></td></tr></table></figure><p>让 omp 自动对计算过程进行划分。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>在矩阵乘法运算开始之前用 <code>omp_get_wtime()</code> 记录下开始的时间，在运算完成后再用当前时间减去开始时间得到运算过程持续的时间。</p><p>输入的矩阵阶数 $n &#x3D; 1000$，</p><div>$$\begin{aligned}A = \begin{bmatrix}1 & 2 & 3 & ... & n\\2 & 3 & 4 & ... & n + 1\\... & ... & ... & ... & ...\\n + 1 & n + 2 & n + 3 & ... & 2n - 1\\\end{bmatrix}\ \ \ \ B = \begin{bmatrix}1 & ... & 1\\... & ... & ...\\1 & ... & 1\\\end{bmatrix}\end{aligned}$$</div><p>编译时开启优化选项 <code>-O2</code>，得到的可执行程序在 6 核心 12 线程，3.4GHz 的平台上，得到计算过程的运行时间结果如下：</p><table><thead><tr><th>线程数</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>1</td><td>0.981532</td><td>0.521334</td><td>0.265093</td><td>0.294094</td><td>0.338403</td></tr><tr><td>2</td><td>0.914313</td><td>0.487340</td><td>0.262216</td><td>0.462756</td><td>0.356789</td></tr><tr><td>3</td><td>0.937469</td><td>0.493963</td><td>0.262745</td><td>0.273746</td><td>0.352335</td></tr><tr><td>4</td><td>0.863467</td><td>0.519115</td><td>0.270767</td><td>0.273420</td><td>0.347093</td></tr><tr><td>5</td><td>0.981426</td><td>0.510974</td><td>0.263687</td><td>0.412166</td><td>0.320763</td></tr><tr><td>AVG</td><td>0.935641</td><td>0.506545</td><td>0.264902</td><td>0.343236</td><td>0.343077</td></tr><tr><td>加速比</td><td>1.00</td><td>1.85</td><td>3.53</td><td>2.73</td><td>2.73</td></tr><tr><td>效率</td><td>1</td><td>0.92</td><td>0.88</td><td>0.34</td><td>0.17</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra - A Decentralized Structured Storage System</title>
      <link href="/20230110-Cassandra/"/>
      <url>/20230110-Cassandra/</url>
      
        <content type="html"><![CDATA[<p>Abstract</p><p>Cassandra 是一个分布式存储系统，用来管理一大堆结构化的数据，在许多服务器上。</p><p>高科用，没有单点错。</p><p>用于在上百个节点的基础设施上运行。可能分数据中心。</p><p>这个规模下，大小错误频发。Cassandra 在许多方面重组了数据库并且借鉴了许多实现和策略，但是并没有支持完整的关系数据模型。但是它提供了一个简单的数据模型来支持动态控制数据布局和格式。Cassandra 被设计用于廉价的家用（商用）硬件，在保持高写吞吐量时并未牺牲读取的效率。</p><p>Intro</p><p>Facebook 作为世界上最大的社交网络平台，用户和内容的增长速度非常快。急需高性能、可靠、高效、可扩展的平台。并且软件系统需要将服务器的 failure 作为一种常态而不是意外来处理（容错）。因此开发了 Cassandra。</p><p>Cass 融合了很多有名的技术来提高可扩展性和可用性。最初是为了满足  Inbox Search 服务的存储需求而开发的。在 Facebook 中，这项特性允许用户搜索他们的 Facebook Inbox。这意味着需要处理非常高的写吞吐，大约十亿每天的写操作，并且随着用户数量的增加还会增长。用户从地理上分布的数据中心请求数据，因此降低搜索延迟的核心是跨数据中心的数据复制。从2008年的1亿用户到2010年的2.5亿，Cassandra展现出了它的潜力，现在成为了Facebook许多产品服务的存储服务后端。</p><p>2 相关工作，影响了设计的</p><p>3 数据模型</p><p>4 客户端 api</p><p>5 系统设计和分布式算法</p><p>6 开发中的经验，优化</p><p>7 future work</p><p>DATA MODEL</p><p>表：分布式的多维 map，由 key 来 索引。</p><p>value 是一个高度结构化的数据对象</p><p>表的行key是一个没有大小限制的字符串，一般16-36bytes。</p><p>在每个副本中，对一行的操作是原子化的，无论修改了多少列。</p><p>列可以分组到一起放到集合中，叫做“列族”。</p><p>Cass 内置了两种 column families，Simple 和 Super column families。应用程序可以在其中指定列的排序依据为时间或名称，用来适应服务的需要。</p><p>API </p><p>insert(table, key, rowMutation)</p><p>get(table, key, columnName)</p><p>delete(table, key, columnName)</p><p>columnName 可以是列族中的列，可以是列族，可以是 Super cf，或 SCF 中的列。</p><p>SYSTEM ARCHITECTURE</p><p>分片 Partitioning</p><p>因为需要很高的扩展性，为了动态地将数据分布到节点上，使用一致性hash。一致性hash是基于一个数环来实现的。所有的hash值都对同一个上限去取模，系统中的每一个节点也将被分配一个随机值，并放到数环当中。每一个数据对象通过其key 的hash找到其在环中的位置，顺着环向下走的第一个数据节点即是该对象存放的节点。因此，每一个数据节点都只需要负责其前一个数据节点到它自身之间的hash值即可。</p><p>一致性hash 的好处就是节点的增减只会影响它的直接邻居，其他节点都不受影响。不过这样的设计也有一些问题。第一是为节点分配随机值，可能导致数据和负载分配的不均匀。另外这样的算法考虑不到节点之间的性能差距。一般来说有两个方法能够解决这一问题：一是让一个节点在环上存在多个位置，二是分析环中的负载信息，让轻负载节点在环中移动，以缓解负载重的节点压力。Cassandra 采取了第二种。</p><p>复制 Replication</p><p>Cassandra 使用了复制技术以实现高可用和持久化。每个数据对象都有 N 个副本。</p><p>每一个对象的key k都会在hash环中被分配给一个协调者节点。它管理着数据的复制。除了在本地存储一份外，协调者节点还会将它复制到环中的 N-1 个节点。Cassandra 为客户端提供了数据复制方法的多种选择。“Rack Unaware”, “Rack Aware”(within datacenter) and “Datacenter Aware”. 备份的选择是基于应用选择的策略。如果选择 RU，那么复制到协调者的 N-1 个后继节点上；对于RA和DA策略会稍微复杂一点。Cass 会在节点之间选举一个 leader（Zookeeper）。所有的节点在加入集群的时候，都会与 leader 通讯来获取它们的备份范围。并且 leader 会保证不会有节点负责超过 N-1 个范围。所有的节点所负责的范围的 metadata 会在每一个节点中以 Zookeeper 的容错机制进行本地缓存，以便从错误中恢复的节点也能找回自己负责的部分。此外，对于每一个被负责的范围，都有一个负责节点的“优先列表”。</p><p>每一个节点都有关于其他所有节点的知识。Cassandra 通过放松多竖排的要求，为可能出现的节点故障和网络分区问题提供了持久的保证。有时可能一整个数据中心会因为不可抗力失效。Cassandra 保证每一个数据行都会有跨数据中心的副本。在上文中的“优先列表”即是为了保证其中的节点是分布在多个数据中心的。这些数据中心之间有高速网络连接。跨中心的复制允许我们既能处理数据中心的错误，又能够避免服务中断。</p><p>Membership。这是什么？成员资格</p><p>通过 Gossip 来维护整个集群的成员状态。Gossip 大概是每一个成员每个 T 秒进行一次 heartbeat，选择其他的 member 发送它的优先列表，然后将自己的列表和收到的列表合并起来。</p><p>错误检测。Cassandra 采用了一个 $\Phi$ Accrual Failure Detector (SRDS 2004) 的修改版本。错误检测常见的模式就是采用心跳，如果心跳超时则认为对端失败。在实际使用中，由于网络延迟的抖动会导致误判。系统使用如下方法提高基于心跳探测方式的准确率：</p><p>1、假设心跳消息符合某一概率模型。例如定期发送的心跳消息在有网络延迟的情况下，接受到消息的 interval 符合正态分布。</p><p>2、利用接受到的历史数据（滑动窗口），对概率模型参数进行极大似然估计。</p><p>3、利用估计得出的参数代入模型，计算在当前时刻接收到心跳消息的概率。</p><p>得到概率后，并不直接得出对端是否存活的判断，而向上层应用返回这一概率，由应用自行解释。</p><p>在 Cassandra 中，认为指数分布是较好的近似。</p><p>Bootstrapping 初次启动</p><p>当一个节点初次启动的时候，它会随机选择一个 token来产生节点在环上的位置。为了容错，映射会被持久化到磁盘本地以及 Zookeeper 中。然后 token 的信息会通过 Gossip 在集群当中传播。这就使得每一个节点都能够将请求路由到正确的节点上。在 bootstrap 程序中，如果节点想要加入一个集群，会先读取一个包含了几个通讯点的配置文件，我们把最初的这几个通讯点叫做集群的“种子”。种子也可以通过 Zookeeper 这样的服务来确定。</p><p>Scaling the Cluster 集群扩容</p><p>当一个新节点加入到系统当中时，它会按照优先缓和负载较重的节点的目的来分配 token，这会导致新的节点将原来节点的负责范围划走一半。Cassandra 的 bootstrap 算法是通过操作员通过系统中其他的节点的命令行或者是 Cassandra 的 web 管理面板来启动的。原节点通过 kernel-kernel 的复制技术将数据流转移到新的节点上。</p><p>Local Persistence 本地持久性 （落盘？）</p><p>Cassandra 是依赖于本地文件系统来完成数据持久化的。数据在磁盘上是以可自我恢复的形式存储的。一般的数据写入操作都包含了对 commit log 的写入来保证持久性和可恢复性，以及对内存中数据结构的更新。对内存数据结构的写入仅在 commit log 写入成功后进行。每台机器上都有一块专门的硬盘用于 commit log 的存储，以最大化磁盘的吞吐量。当磁盘中数据结构的规模达到一定的上限，它就会将自己写入到磁盘当中。所有的磁盘写入都是顺序的，并且写入时会产生一个索引以实现基于行 key 的高效查询。这些索引也会随着数据文件一同被持久化。长期运行中，可能会产生许多的索引文件，因此在后台运行了一个合并进程来合并文件。这一过程与 Bigtable 系统中的压缩非常类似。</p><p>一个正常的读操作首先查询内存中的数据结构，然后才会查询磁盘中的文件。文件查询的顺序是从新到旧。当一个磁盘查询发生的时候，我们可能会在磁盘中的很多个文件中查找同一个 key。为了减少不必要的查询，每一个文件都又一个 bloom filter。它聚合了文件中存在的所有 key 值，存放在数据文件当中，且在内存中也有一份。这个过滤器会在查询到来时首先判断被查询的 key 在给定的文件中是否存在。</p><p>实际体验</p><p>深刻的一课：如果没有理解一个新特性产生的影响，就不要添加它。</p><p>许多麻烦的场景其实不是因节点失效或网络分区问题而产生的。</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>On the Nature of Progress (OPODIS&#39;11)</title>
      <link href="/20230109-onthenatureofprogress/"/>
      <url>/20230109-onthenatureofprogress/</url>
      
        <content type="html"><![CDATA[<p>这份工作确定了一个关系，它可以统一看似无关的 progress conditions : 从基于锁的系统的 deadlock-free 和 starvation-free 性质，到 obstruction-freedom （无障碍），lock-freedom（无锁），wait-freedom（无等待） 这样的非阻塞条件。</p><p>所有的性质可以按照两个维度来分类。</p><p>我大概懂意思。但是不想写这篇。</p><p>我到底是为什么这几天都没干活来着？？？</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>临行</title>
      <link href="/20230105-asa/"/>
      <url>/20230105-asa/</url>
      
        <content type="html"><![CDATA[<p>重要的准备</p><p>1、早上去图书馆把书借了</p><p>2、主机，线材，硬盘，耳机，显示器（数码产品）</p><p>3、衣服，鞋</p><p>4、印文献</p><p>5、运动装备</p><p>6、杂物：伞，咖啡，文具，药品，温度计，包，帽子。。</p><p>7、调试主机的连通性，是否能 wol，测试 remote。比去年好的地方在于有跳板了</p><p>8、收拾垃圾</p><p>（感觉东西太多了，少带点衣服）</p><p>回家去可不轻松啊…要写点 openGauss 的总结了。这票干完，就可以开始看书了。</p><p>（想啥呢，项目还要出数据的）</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>找回记忆</title>
      <link href="/20230105-yoru/"/>
      <url>/20230105-yoru/</url>
      
        <content type="html"><![CDATA[<p>找回记忆，其实就是把之前手写的日记录回到电脑里面。这样就可以看到自己较为连续性的变化了。</p><p>我需要这些回忆，好好分析一下大学这段时间里——甚至是高中的时间里，到底什么在影响我，走向什么样的未来。如果不知道自己从何处而来，想必也不可能真正知道自己将往何处去。</p><p>近几年对我最大的影响就是，以往有明确看法的人事物，现在我倾向于悬置判断。这并不是说我没有任何看法，而是下结论变成了一件困难的事，因为本来就很困难。相比于给出一个最终决断，我更习惯于给出一个临时的、局部的看法，并且不急于发表它。</p><p>这好吗？不一定。表面上看是更加谨慎，考虑更加周全，但变得犹犹豫豫，非常迟疑。实际上有一个很大的漏洞，即我不做判断的原因在于我缺乏这样的能力。而悬置判断恰好又让我没有动力去增长这一能力。比起短期内受损，我同样担心长久下去自己形不成一套稳定的看法，而永远都在以相对的眼光去做判断。</p><p>但话说到这里，我又不确定这两样到底是哪一样比较好了。这就是理论不扎实。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中的宏</title>
      <link href="/20230103-macro/"/>
      <url>/20230103-macro/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c</span><br></pre></td></tr></table></figure><p>做了什么？</p><p>example</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mian main</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出了一大串代码…</p><p><img src="image-20230103141627581.png" alt="image-20230103141627581"></p><p><img src="image-20230103141708387.png" alt="image-20230103141708387"></p><p>是不是有一点熟悉…翻到最后的话<br><img src="image-20230103141739040.png" alt="image-20230103141739040"></p><p>这下你明白了：</p><p>预处理就是字符串替换</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A B</span></span><br></pre></td></tr></table></figure><p>它的作用就是，把代码里以“词法单元”形式出现的 A 全都替换成 B。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.val = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A B</span></span><br><span class="line">A.val = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>预处理试试</p><h1 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo() &#123; return 1; &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>宏函数可以有参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(a) &#123; return a; &#125;</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">0</span>);</span><br><span class="line">foo(a + b);</span><br><span class="line">foo(a, b);  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>可变参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(a, ...) &#123; bar(__VA_ARGS__, a); &#125;</span></span><br><span class="line"></span><br><span class="line">foo(m);</span><br><span class="line">foo(m, n);</span><br><span class="line">foo(m, n, p);</span><br></pre></td></tr></table></figure><p>普通的函数也可以有可变参数列表！（你没想过 printf 是怎么做到的吗？）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>man va_args</p><p>注意点1：参数的括号与运算优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> add(a, b) a + b</span></span><br><span class="line"></span><br><span class="line">c = d * add(a, b) * e;   <span class="comment">///???</span></span><br></pre></td></tr></table></figure><p>注意点2：语法语义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo()  bar(); baz();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond) foo();   <span class="comment">// how will it expand?</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> foo() &#123; bar(); baz(); &#125;</span></span><br><span class="line"><span class="keyword">if</span> (cond) foo();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// Syntax error</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> foo() do &#123; bar(); &#125; while(0)   <span class="comment">// jeez!</span></span></span><br></pre></td></tr></table></figure><p>注意点3：副作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">max(a++, b);  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><h1 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A undefined!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A defined!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>条件编译也可以嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> A</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> B</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A B both defined!\n&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;B undefined!\n&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A undefined!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也可以做条件判断！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> A &lt;= 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A &lt;= 2!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A &gt; 2!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>只能判断数字。如果没有指定值的话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> A == 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A == 0!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A != 0!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>error</p><p>但如果随便指定一个不存在的东西…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A SOMESTRANGESTUFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> A == 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A == 0!\n&quot;</span>);    <span class="comment">// THIS IS CHOSEN</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A != 0!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这就是玄学了（</p><h1 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h1><p>在预处理时有两个特殊的运算符。一是一元运算符 #，表示将文本替换成字符串；二是二元运算符 ##，表示将两个文本相连</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print(a) printf(#a)</span></span><br><span class="line"></span><br><span class="line">concat(hello, world);</span><br><span class="line">print(hello world);</span><br></pre></td></tr></table></figure><p><img src="image-20230103165611133.png" alt="image-20230103165611133"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVAL(expr) printf(#expr <span class="string">&quot; = %d\n&quot;</span>, expr)</span></span><br><span class="line"></span><br><span class="line">EVAL(<span class="number">1</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>但上面的定义有一点小问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> this that</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">concat</span><span class="params">(this, Func)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">// =&gt; int thisFunc(int a, int b);</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> this that</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat_temp(a, b) a ## b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) concat_temp(a, b);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">concat</span><span class="params">(this, Func)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">// =&gt; int concat_temp(that, Func)(int a, int b);</span></span><br><span class="line"><span class="comment">// =&gt; int thatFunc(int a, int b);</span></span><br></pre></td></tr></table></figure><h1 id="一些常用的自带宏"><a href="#一些常用的自带宏" class="headerlink" title="一些常用的自带宏"></a>一些常用的自带宏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__FILE__: 当前代码所处的文件名</span><br><span class="line"></span><br><span class="line">__LINE__: 当前代码在文件中的行数</span><br><span class="line">__TIME__: 当前文件在编译时的时间</span><br><span class="line"></span><br><span class="line">__x86_64__: 是否为 X86_64 架构编译</span><br></pre></td></tr></table></figure><p><img src="image-20230103171422726.png" alt="image-20230103171422726"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 a.c   <span class="comment"># ?</span></span><br><span class="line">gcc -m64 a.c</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Log(fmt, ...) fprintf(stderr, <span class="string">&quot;[in file %s, line %d, function %s] &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, __func__, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Log(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;print a log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPL-Project2-ramfs</title>
      <link href="/20230102-ramfs/"/>
      <url>/20230102-ramfs/</url>
      
        <content type="html"><![CDATA[<ul><li>题面&#x2F;讲义&#x2F;api手册</li><li>提交方式</li><li>分数分布</li><li>测试点</li><li>代码框架</li><li>参考实现</li></ul><p>前言</p><p>这可能是大家第一次做类似的工作：你不是编写一个完整的程序，而是按照要求实现一些函数。这些函数将会被我们调用，以检测是否实现了所要求的功能</p><p>题面</p><p>文件系统是操作系统的重要组成部分。调用文件系统 api，我们可以轻松地将数据持久化到磁盘上。C 语言中为我们提供了一组 api，它们基于操作系统 api，允许我们对文件进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Linux 操作系统中，上述的 C 文件操作 api 是基于一组操作系统的文件 api 实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现要求你实现一个内存文件系统（ramfs）。顾名思义，这个文件系统的所有数据并不持久化到磁盘上，而是保存到内存当中，是一个易失性的文件管理系统。</p><p>文件系统的规定</p><p>与 Linux 的树形结构一致。在初始状态下，只存在根目录 “&#x2F;“。文件系统中存在两类对象，目录与文件。目录下可以存放其他对象，而文件不可以。即在树形结构中，文件只能是叶子节点。</p><p>例 (#)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── 1.txt            &quot;/1.txt&quot;</span><br><span class="line">├── 2.txt            &quot;/2.txt&quot;</span><br><span class="line">└── dir              &quot;/dir&quot;</span><br><span class="line">    ├── 1.txt        &quot;/dir/1.txt&quot;</span><br><span class="line">    └── 2.txt        &quot;/dir/2.txt&quot;</span><br></pre></td></tr></table></figure><p>可以看到，在根目录下一共有 3 个项目：两个文件，一个目录 dir，而 dir 下还可以拥有两个文件。右侧的字符串称为对象的“绝对路径”。</p><p>单个文件和目录名长度 &lt;&#x3D; 32 字节，仅包含字母、数字、英文句点。对于存在不合法的文件名的路径，你的文件系统 api 应当统一通过返回 -1 来拒绝此类操作。</p><p>路径长度 &lt;&#x3D; 1024 字节。（变相地说，文件系统的路径深度存在上限）。</p><p>文件系统 api 统一使用绝对路径，即以 ‘&#x2F;‘ 开头。在未创建任何文件时，即存在 “&#x2F;“ 指向的根目录。该目录可打开，不可删除，其余性质与一般目录一致。</p><p>我们要求你实现如下的 api，以实现文件系统的管理。其具体行为将会在 api 说明部分阐释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>注意，我们要求你实现的是内存操作系统。故你的程序应当使用内存管理 api（malloc、free）来存放文件所需的数据结构，以及文件的所有内容。我们保证整个文件系统的所有文件内容不会超过 512 MiB，且给予 1GiB 的内存限制。请小心地管理好内存注意不要超限。</p><p>开始你的项目</p><p>我们为你准备了一个 git repo。请基于这个 git repo 进行你的项目。如果你不会 git，请学着使用。</p><p>在 git repo 中我们为你提供了一个自动编译脚本 Makefile。并且为你配置好了记录自动追踪。请不要随意修改 Makefile。你的修改记录将成为查重时证明独立完成的重要证据。</p><p>推荐在 Linux 操作系统中完成本作业。如果你要使用 Windows，产生的问题由你自己解决。</p><p>获取代码框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://git.nju.edu.cn/Tilnel/ramfs.git&quot;</span></span><br></pre></td></tr></table></figure><p>注意：请在默认的 master 分支上进行开发。最终 OJ 的评分也将以你的 master 分支为准。</p><p>你应当在 ramfs.c 中包含你的所有实现（包括指定的函数和你使用的所有数据结构）。评测机会用我们自己的 Makefile（和分发版本一致）、ramfs.h（和分发版本一致）、main.c（包含更强力的测试用例）进行编译运行。因此你对 ranfs.h 和 main.c 以及 Makefile 的修改在 OJ 上不会产生效果。</p><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make submit TOKEN=<span class="variable">$&#123;你的token&#125;</span></span><br></pre></td></tr></table></figure><p>请在题目中“打开代码编辑器”后，获取你的提交 token。注意在校园网环境下提交。然后你就能在提交列表中看到你的提交。</p><p>注意在 make submit 之前，你需要将最新的改动 commit。同样注意保持你的工作目录整洁，如果你的 git repo 超过 20MiB（这一定是因为你放了很多很多奇怪的玩意），则没有办法提交。</p><p>你的 git repo 中不应当包含各种形式的编译产生的中间文件、编译结果。我们的 Makefile 只会在 build 目录下产生文件，我们也会配置好 .gitignore 文件避免 track 这些文件。</p><p>API 手册</p><p>注意两个对象的定义：文件（file），目录（directory）</p><p>最重要的对象：文件描述符 (file descriptor)</p><p>它是所有<strong>打开的文件和目录的标志</strong>，为一个非负整数。在 Windows 操作系统中称之为“句柄”。我们使用路径打开一个文件或目录，操作系统就会为这一次文件的打开分配一个文件描述符，它就像是一个“把手”一样。我们用这个文件描述符来指示打开的文件，进行对文件的操作。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);  <span class="comment">// open 返回一个文件描述符</span></span><br><span class="line">read(fd, buf, <span class="number">5</span>);                   <span class="comment">// 从打开的 fd (1.txt) 中读取五个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>打开 ramfs 中的文件。如果成功，返回一个文件描述符（一个非负整数），用于标识这个文件。</p><p>如果打开失败，则返回一个 -1。</p><p>pathname 为一个字符串，为文件的绝对路径。对于所有存在的文件和目录，你的 ropen 调用都应当成功。特别地，在指示一个目录时，pathname 的末尾可以有多余的 ‘&#x2F;‘。pathname 中同样可以有冗余的 ‘&#x2F;‘。</p><p>例如，在上文的例 (#) 中，以下的绝对路径是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dir/        =/dir</span><br><span class="line">////dir       =/dir</span><br><span class="line">/1.txt        =/1.txt</span><br><span class="line">//dir/1.txt   =/dir/1.txt</span><br></pre></td></tr></table></figure><p>以下的绝对路径是不存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/3.txt</span><br><span class="line">/1.txt/       (文件路径后不可以有多余的&#x27;/&#x27;)</span><br><span class="line">/di/r/1.txt   (不存在这个路径)</span><br></pre></td></tr></table></figure><p>flag 指示打开方式，其取值有如下可能（或可以是它们的组合）：</p><p>注意，在 C 中，以 0 开头的数字采用 8 进制表示法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND  02000 以追加模式打开文件。即打开后，文件描述符的偏移量指向文件的末尾。若无此标志，则指向文件的开头</span><br><span class="line">O_CREAT   0100 如果 pathname 不存在，就创建这个文件，但如果这个目录中的父目录不存在，则创建失败；如果存在则正常打开</span><br><span class="line">O_TRUNC   01000 如果 pathname 是一个存在的文件，并且同时以可写方式 (O_WRONLY/O_RDWR) 打开了文件，则文件内容被清空</span><br><span class="line">O_RDONLY  00 以只读方式打开</span><br><span class="line">O_WRONLY  01 以只写方式打开</span><br><span class="line">O_RDWR    02 以可读可写方式打开</span><br></pre></td></tr></table></figure><p>这些标志位的组合方式是使用按位的或运算。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_TRUNC | O_RDWR   (可读可写，打开时清空)</span><br><span class="line">O_CREAT | O_WRONLY (若不存在，创建后以读写方式打开；否则以读写方式直接打开)</span><br><span class="line">O_APPEND   (文件描述符的偏移量指向文件末尾，但因为只有此一个标志位，既不可读也不可写)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭打开的文件描述符，并返回 0。如果不存在一个打开的 fd，则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>向 fd 中的<em><strong>偏移量</strong></em>（马上解释）位置写入以 buf 开始的至多 count 字节，覆盖文件原有的数据（如果 count 超过 buf 的大小，仍继续写入），将 fd 的<em><strong>偏移量</strong></em>后移 count，并返回实际成功写入的字节数。如果写入的位置超过了原来的文件末尾，则自动为该文件扩容。</p><p>如果 fd 不是一个可写的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>在本实验中，ramfs 中同时存在的文件大小不会超过限制。因此你的 rwrite 对于一个能够写入的文件，事实上总应返回 count。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>从 fd 中的<em><strong>偏移量</strong></em>位置读出至多 count 字节到 buf 指向的内存空间当中，将<em><strong>偏移量</strong></em>后移 count，并返回实际读出的字节数。因为可能会读到文件末尾，因此返回值有可能小于 count。</p><p>如果 fd 不是一个可读的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>偏移量（offset）</p><p>想象你用手指指着读一本书，offset 相当于你手指指向的位置。你每读一个字，手指就向前前进一个字；如果你想改写书本上的字，每改写一个字，手指也向前前进一个字。</p><p>每一个文件描述符都拥有一个偏移量，用来指示读和写操作的开始位置。这个偏移量对应的是文件描述符，而不是“文件”对象。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/1.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);</span><br><span class="line">write(fd1, <span class="string">&quot;helloworld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">read(fd2, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时 buf 中将从文件的开头读到字符串”hello\0”。但如果换一种方式：</p><p>假设 “&#x2F;1.txt” 中原来有数据 “helloworld\0”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDWR);</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">read(fd, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时，write 在读取时，将文件指针前移了 5 个字节。于是read在读取的时候，将会从第6个字节开始读取。也即，read 将会读到 “world\0”。对于同一个文件描述符，读取和写入操作是共享偏移量的；对于不同的文件描述符，它们的偏移量则是各自独立的。</p><p>对于 open 操作，如果没有 O_APPEND 标志来将偏移量指向末尾，那么默认指向文件开头。</p><p>如何自由地修改和获取文件描述符的偏移量呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于修改 fd 表示的文件描述符的偏移量，并返回当前文件的实际偏移量。</p><p>whence有三种取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEEK_SET 0   将文件描述符的偏移量设置到 offset 指向的位置</span><br><span class="line">SEEK_CUR 1   将文件描述符的偏移量设置到 当前位置 + offset 字节的位置</span><br><span class="line">SEEK_END 2   将文件描述符的偏移量设置到 文件末尾 + offset 字节的位置</span><br></pre></td></tr></table></figure><p>rseek 允许将偏移量设置到文件末尾之后的位置，但是并不会改变文件的大小，直到它在这个位置写入了数据。在 超过文件末尾的地方写入了数据后，原来的文件末尾到实际写入位置之间可能出现一个空隙，我们规定应当以 “\0” 填充这段空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>创建目录，成功则返回 0。如果目录的父目录不存在或此路径已经存在，则失败返回 -1。</p><p>如，原来系统中只存在根目录 “&#x2F;“，调用：<code>rmkdir(&quot;/path/to/dir&quot;)</code> 返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个空目录，成功则返回 0。如果目录不存在或不为空，或 pathname 指向的不是目录，返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个文件，成功则返回 0。如果文件不存在或 pathname 指向的不是文件，则返回 -1。</p><p>额外的一个 api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_ramfs();</span><br></pre></td></tr></table></figure><p><strong>可以</strong>用于初始化你的文件系统。比如创建根目录。我们用于测试的 main() 将总会包含它。（要在里面做什么取决于你自己！）</p><p>我们的测试用例长什么样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* our main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();     <span class="comment">// 你的初始化操作</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/dir&quot;</span>) == <span class="number">0</span>);   <span class="comment">// 应当成功</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;//dir&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为目录已存在</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/a/b&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为父目录不存在</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  assert((fd = ropen(<span class="string">&quot;//dir///////1.txt&quot;</span>, O_CREAT | O_RDWR)) &gt; <span class="number">0</span>);  <span class="comment">// 创建文件应当成功</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 应当完整地写入</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_CUR) == <span class="number">5</span>);  <span class="comment">// 当前 fd 的偏移量应该为 5</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">0</span>);  <span class="comment">// 应当成功将 fd 的偏移量复位到文件开头</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">7</span>];</span><br><span class="line">  assert(rread(fd, buf, <span class="number">7</span>) == <span class="number">5</span>);   <span class="comment">// 只能读到 5 字节，因为文件只有 5 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>);   <span class="comment">// rread 应当确实读到 &quot;hello&quot; 5 个字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">3</span>, SEEK_END) == <span class="number">8</span>);  <span class="comment">// 文件大小为 5，向后 3 字节则是在第 8 字节</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 再写 5 字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">5</span>, SEEK_SET) == <span class="number">5</span>);  <span class="comment">// 将偏移量重设到 5 字节</span></span><br><span class="line">  assert(rread(fd, buf, <span class="number">8</span>) == <span class="number">8</span>);   <span class="comment">// 在第 8 字节后写入了 5 字节，文件大小 13 字节；那么从第 5 字节后应当能成功读到 8 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0world&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>); <span class="comment">// 3 字节的空隙应当默认填 0</span></span><br><span class="line">  assert(rclose(fd) == <span class="number">0</span>); <span class="comment">// 关闭打开的文件应当成功</span></span><br><span class="line">  assert(rclose(fd + <span class="number">1</span>) == <span class="number">-1</span>); <span class="comment">//关闭未打开的文件应当失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会在框架代码中提供几份测试代码供大家参考。大家可以自由地改动测试代码，并使用 <code>make test</code> 进行测试。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/20230111-ramfs-final/"/>
      <url>/20230111-ramfs-final/</url>
      
        <content type="html"><![CDATA[<h1 id="Ramfs-实验手册与指南"><a href="#Ramfs-实验手册与指南" class="headerlink" title="Ramfs - 实验手册与指南"></a><center>Ramfs - 实验手册与指南</center></h1><center>南京大学 孙博文<br>tilnel@smail.nju.edu.cn</center><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这可能是大家第一次做类似的工作：你不是编写一个完整的程序，而是按照要求实现一些函数。这些函数将会被我们调用，以检测是否实现了所要求的功能。</p><p><strong>本要求为（基本上是）最终版本。其中重要的描述修正将以这样的形式标出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+++ 这里是修改过的描述，请注意检查 +++</span><br></pre></td></tr></table></figure><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文件系统是操作系统的重要组成部分。调用文件系统 api，我们可以轻松地将数据持久化到磁盘上。C 语言中为我们提供了一组 api，它们基于操作系统 api，允许我们对文件进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Linux 操作系统中，上述的 C 文件操作 api 是基于一组操作系统的文件 api 实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现要求你实现一个内存文件系统（ramfs）。顾名思义，这个文件系统的所有数据并不持久化到磁盘上，而是保存到内存当中，是一个易失性的文件管理系统。</p><h2 id="文件系统的约定"><a href="#文件系统的约定" class="headerlink" title="文件系统的约定"></a>文件系统的约定</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>Ramfs 的目录结构与 Linux 的树形结构一致。在初始状态下，只存在根目录 “&#x2F;“。文件系统中存在两类对象，目录与文件。目录下可以存放其他对象，而文件不可以。即在树形结构中，文件只能是叶子节点。</p><p>例 (#)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── 1.txt            &quot;/1.txt&quot;</span><br><span class="line">├── 2.txt            &quot;/2.txt&quot;</span><br><span class="line">└── dir              &quot;/dir&quot;</span><br><span class="line">    ├── 1.txt        &quot;/dir/1.txt&quot;</span><br><span class="line">    └── 2.txt        &quot;/dir/2.txt&quot;</span><br></pre></td></tr></table></figure><p>可以看到，在根目录下一共有 3 个项目：两个文件，一个目录 dir，而 dir 下还可以拥有两个文件。右侧的字符串称为对象的“绝对路径”。</p><p>单个文件和目录名长度 &lt;&#x3D; 32 字节，</p><h6 id="修订1"><a href="#修订1" class="headerlink" title="修订1"></a>修订1</h6><p>+++ <strong>是字母、数字、英文句点的任意组合。例如，’.’ 不是当前目录，’..’ 也不是上级目录</strong> +++</p><p>对于存在<strong>不合法文件名</strong>的路径，你的文件系统 api 应当统一通过返回 -1 来拒绝此类操作。</p><p>所有 api 调用中，路径长度 &lt;&#x3D; 1024 字节。（也就是说，文件系统的路径深度是存在上限的）。</p><p>文件系统 api 统一使用绝对路径，即以 ‘&#x2F;‘ 开头。在未创建任何文件时，就已经存在 “&#x2F;“ 指向的根目录。该目录可打开，不可删除，其余性质与一般目录一致。</p><h3 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h3><p>整个文件系统同时存在的所有文件内容不会超过 512 MiB（不含已经删去的文件和数据），给予 1GiB 的内存限制。</p><p>同时存在的文件与目录不会超过 65536 个。</p><p>同时活跃着的文件描述符不会超过 4096 个。</p><p>对于所有数据点，文件操作读写的总字节数不会超过 10GiB。时限将给到一个非常可观的量级。</p><p>各数据点的性质：</p><ol><li><p>如原始的 main.c</p></li><li><p>根目录下少量文件创建 + ropen + rwrite + rclose</p></li><li><p>在 2 的基础上，测试 O_APPEND，rseek</p></li><li><p>在 3 的基础上扩大规模</p></li><li><p>少量子目录创建（&lt;&#x3D; 5 层）+ 文件创建与随机读写</p></li><li><p>在 5 的基础上，测试 rrmdir, runlink。</p></li><li><p>大文件测试。多 fd 对少量大文件大量读写 + rseek + O_TRUNCATE</p></li><li><p>复杂的文件树结构测试。大量的 O_CREAT，rmkdir, rrmdir, runlink。少量读写</p></li><li><p>文件描述符管理测试。大量 ropen、rclose，多 fd 单文件</p></li><li><p>综合场景的大型测试。模拟真实的系统。</p></li></ol><p>错误将会分散在各个数据点中。你需要保证你的 API 能正确地判断错误的情况并按照要求的返回值退出。</p><p>如果你获得 ”Wrong Answer“，说明仅仅是程序行为与 API 不一致。如读写的结果不正确，应该打开失败的文件却成功了…</p><p>如果获得 ”Runtime Error”，说明你的程序会出现运行错误而 crash。比如你在遍历文件树时，解引用了空指针…</p><h3 id="接口简述"><a href="#接口简述" class="headerlink" title="接口简述"></a>接口简述</h3><p>我们要求你实现如下的 api，以实现文件系统的管理。其具体行为将会在 api 说明部分阐释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>注意，我们要求你实现的是内存操作系统。故你的程序应当使用内存管理 api（malloc、free）来存放文件所需的数据结构，以及文件的所有内容。请小心地管理好内存注意不要超限。</p><h2 id="开始你的项目"><a href="#开始你的项目" class="headerlink" title="开始你的项目"></a>开始你的项目</h2><p>我们为你准备了一个 git repo。请基于这个 git repo 进行你的项目。如果你不会 git，请学着使用。</p><p>在 git repo 中我们为你提供了一个自动编译脚本 Makefile。并且为你配置好了记录自动追踪。请不要随意修改 Makefile。你的修改记录将成为查重时证明独立完成的重要证据。</p><p>推荐在 Linux 操作系统中完成本作业。如果你要使用 Windows，产生的问题由你自己解决。</p><p>获取代码框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://git.nju.edu.cn/Tilnel/ramfs.git&quot;</span></span><br></pre></td></tr></table></figure><p>注意：请在默认的 master 分支上进行开发。最终 OJ 的评分也将以你的 master 分支为准。</p><p><strong>你应当在 ramfs.c 中包含你的所有实现</strong>（包括指定的函数和你使用的所有数据结构）。评测机会用我们自己的 Makefile（和分发版本一致）、ramfs.h（和分发版本一致）、main.c（包含更强力的测试用例）进行编译运行。因此你对 ranfs.h 和 main.c 以及 Makefile 的修改在 OJ 上不会产生效果。</p><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make submit TOKEN=<span class="variable">$&#123;你的token&#125;</span></span><br></pre></td></tr></table></figure><p>请在题目中“打开代码编辑器”后，获取你的提交 token。注意在校园网环境下提交。然后你就能在提交列表中看到你的提交。</p><blockquote><p>由于服务器现可以通过 public.oj.cpl.icu 访问，你可以对 Makefile 中 submit 目标下的 url 进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@ -25,5 +25,5 @@ submit:</span><br><span class="line">        @cd .. &amp;&amp; zip -qr $&#123;FILE&#125; $&#123;BASE&#125;/.git</span><br><span class="line">        @echo &quot;Created submission archive $&#123;FILE&#125;&quot;</span><br><span class="line">        @curl -m 5 -w &quot;\n&quot; -X POST -F &quot;TOKEN=$&#123;TOKEN&#125;&quot; -F &quot;FILE=@$&#123;FILE&#125;&quot; \</span><br><span class="line">-               https://oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">+               http://public.oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">        @rm -r $&#123;TEMP&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意在 make submit 之前，你需要将最新的改动 commit。同样注意保持你的工作目录整洁，如果你的 git repo 超过 20MiB（这一定是因为你放了很多很多奇怪的玩意），则没有办法提交。</p><p>你的 git repo 中不应当包含各种形式的编译产生的中间文件、编译结果。我们的 Makefile 只会在 build 目录下产生文件，我们也会配置好 .gitignore 文件避免 track 这些文件。</p><h2 id="API-手册"><a href="#API-手册" class="headerlink" title="API 手册"></a>API 手册</h2><h6 id="修订2"><a href="#修订2" class="headerlink" title="修订2"></a>修订2</h6><p>+++ <strong>你的实现不应当有任何输出</strong> +++</p><p>以下注意区分两种对象的定义：文件（file），目录（directory）。</p><p>另一个重要的对象是：文件描述符（file descriptocr），简称 FD。它是所有<strong>打开的文件和目录的指示符</strong>，为一个非负整数。在 Windows 操作系统中称之为“句柄”。我们使用路径打开一个文件或目录，操作系统就会为这一次文件的打开分配一个文件描述符，它就像是一个“把手”一样。我们用这个文件描述符来指示打开的文件，进行对文件的操作。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);  <span class="comment">// open 返回一个文件描述符</span></span><br><span class="line">read(fd, buf, <span class="number">5</span>);                   <span class="comment">// 从打开的 fd (/1.txt) 中读取五个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><h6 id="修订3"><a href="#修订3" class="headerlink" title="修订3"></a>修订3</h6><p>+++ 打开 ramfs 中的<strong>文件或目录</strong>。如果成功，返回一个文件描述符（一个非负整数），用于标识这个对象。+++</p><p>如果打开失败，则返回一个 -1。</p><p>pathname 为一个字符串，为一个绝对路径。<strong>对于所有存在的文件和目录，你的 ropen 调用都应当成功</strong>。特别地，在指示一个目录时，pathname 的末尾可以有多余的 ‘&#x2F;‘。pathname 中间同样可以有冗余的 ‘&#x2F;‘。</p><p>例如，在上文的例 (#) 中，以下的绝对路径是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dir/        =/dir</span><br><span class="line">////dir       =/dir</span><br><span class="line">/1.txt        =/1.txt</span><br><span class="line">//dir/1.txt   =/dir/1.txt</span><br></pre></td></tr></table></figure><p>以下的绝对路径是不存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/3.txt</span><br><span class="line">/1.txt/       (文件路径后不可以有多余的&#x27;/&#x27;)</span><br><span class="line">/di/r/1.txt   (不存在这个路径)</span><br></pre></td></tr></table></figure><p>flag 指示打开方式，这些打开方式仅对<strong>文件</strong>起作用。如果被打开的是目录则自动忽略。其取值有如下可能（或可以是它们的组合）：</p><p>注意，在 C 中，以 0 开头的数字采用 8 进制表示法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND  02000 以追加模式打开文件。即打开后，文件描述符的偏移量指向文件的末尾。若无此标志，则指向文件的开头</span><br><span class="line">O_CREAT   0100 如果 pathname 不存在，就创建这个文件，但如果这个目录中的父目录不存在，则创建失败；如果存在则正常打开</span><br><span class="line">O_TRUNC   01000 如果 pathname 是一个存在的文件，并且同时以可写方式 (O_WRONLY/O_RDWR) 打开了文件，则文件内容被清空</span><br><span class="line">O_RDONLY  00 以只读方式打开</span><br><span class="line">O_WRONLY  01 以只写方式打开</span><br><span class="line">O_RDWR    02 以可读可写方式打开</span><br></pre></td></tr></table></figure><p>这些标志位的组合方式是使用按位的或运算。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_TRUNC | O_RDWR   (可读可写，打开时清空)</span><br><span class="line">+++ O_CREAT | O_WRONLY (若不存在，创建后以只写方式打开；否则以只写方式直接打开) +++ （原来写成读写了）</span><br><span class="line">+++ O_APPEND   (文件描述符的偏移量指向文件末尾，并可读) +++</span><br></pre></td></tr></table></figure><h6 id="修订8"><a href="#修订8" class="headerlink" title="修订8"></a>修订8</h6><p>+++ O_TRUNC 但文件以只读方式打开时，在 Linux 中为 unspecified 行为。此处约定为正常只读打开而不清空。 （1.15 聊天记录）+++</p><h6 id="修订4"><a href="#修订4" class="headerlink" title="修订4"></a>修订4</h6><p>+++ 注意点：+++</p><p>+++ <code>O_RDWR | O_WRONLY</code> 共同存在时，取只写的语义； +++</p><p>+++ 由于 <code>O_RDONLY</code> 是 0，因此若未指定任何读写方式时，默认是只读的； +++</p><p>+++ 同时，易得 <code>O_RDONLY | O_WRONLY == O_WRONLY</code>。因此组合只读只写得到的结果是只写。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭打开的文件描述符，并返回 0。如果不存在一个打开的 fd，则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>向 fd 中的<em><strong>偏移量</strong></em>（马上解释）位置写入以 buf 开始的至多 count 字节，覆盖文件原有的数据。如果 count 超过 buf 的大小，仍继续写入（数据保证不因此而产生段错误），将 fd 的<em><strong>偏移量</strong></em>后移 count，并返回实际成功写入的字节数。如果写入的位置超过了原来的文件末尾，则自动为该文件扩容。</p><p>如果 fd 不是一个可写的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>在本实验中，ramfs 中同时存在的文件大小不会超过限制。因此你的 rwrite 对于一个能够写入的文件，事实上总应返回 count。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>从 fd 中的<em><strong>偏移量</strong></em>位置读出至多 count 字节到 buf 指向的内存空间当中，</p><h6 id="修订5"><a href="#修订5" class="headerlink" title="修订5"></a>修订5</h6><p>+++ 将<em><strong>偏移量</strong></em>后移实际读出的字节数，并返回实际读出的字节数。+++</p><p>因为可能会读到文件末尾，因此返回值有可能小于 count。</p><p>如果 fd 不是一个可读的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><h3 id="偏移量（offset）"><a href="#偏移量（offset）" class="headerlink" title="偏移量（offset）"></a>偏移量（offset）</h3><p>想象你用手指指着读一本书，offset 相当于你手指指向的位置。你每读一个字，手指就向前前进一个字；如果你想改写书本上的字，每改写一个字，手指也向前前进一个字。</p><p>每一个文件描述符都拥有一个偏移量，用来指示读和写操作的开始位置。这个偏移量对应的是文件描述符，而不是“文件”对象。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/1.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);</span><br><span class="line">write(fd1, <span class="string">&quot;helloworld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">read(fd2, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h6 id="修订6"><a href="#修订6" class="headerlink" title="修订6"></a>修订6</h6><p>--- 此时 buf 中将从文件的开头读到”hello\0”。但如果换一种方式： ---  </p><p>+++ 此时 buf 中将从文件的开头读到”hellow”。但如果换一种方式： +++</p><p>假设 “&#x2F;1.txt” 中原来有数据 “helloworld\0”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDWR);</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">read(fd, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时，write 在读取时，将文件指针前移了 5 个字节。于是read在读取的时候，将会从第6个字节开始读取。也即，read 将会读到 “world\0”。对于同一个文件描述符，读取和写入操作是共享偏移量的；对于不同的文件描述符，它们的偏移量则是各自独立的。</p><p>对于 open 操作，如果没有 O_APPEND 标志来将偏移量指向末尾，那么默认指向文件开头。</p><p>如何自由地修改和获取文件描述符的偏移量呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于修改 fd 表示的文件描述符的偏移量，并返回当前文件的实际偏移量。</p><p>whence有三种取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEEK_SET 0   将文件描述符的偏移量设置到 offset 指向的位置</span><br><span class="line">SEEK_CUR 1   将文件描述符的偏移量设置到 当前位置 + offset 字节的位置</span><br><span class="line">SEEK_END 2   将文件描述符的偏移量设置到 文件末尾 + offset 字节的位置</span><br></pre></td></tr></table></figure><p>rseek 允许将偏移量设置到文件末尾之后的位置，但是并不会改变文件的大小，<strong>直到它在这个位置写入了数据</strong>。在 超过文件末尾的地方写入了数据后，原来的文件末尾到实际写入位置之间可能出现一个空隙，我们规定应当以 “\0” 填充这段空间。</p><p>+++ 但不允许将偏移量设置到文件开头之前，也就是一个负数的绝对偏移量。这种情况下返回 -1。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>创建目录，成功则返回 0。如果目录的父目录不存在或此路径已经存在，则失败返回 -1。</p><p>如，原来系统中只存在根目录 “&#x2F;“，调用：<code>rmkdir(&quot;/path/to/dir&quot;)</code> 返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个空目录，成功则返回 0。如果目录不存在或不为空，或 pathname 指向的不是目录，返回 -1。测试保证不对打开的 pathname 做 rrmdir。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个文件，成功则返回 0。如果文件不存在或 pathname 指向的不是文件，则返回 -1。测试保证不对打开的 pathname 做 runlink。</p><p>额外的一个 api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_ramfs();</span><br></pre></td></tr></table></figure><p><strong>可以</strong>用于初始化你的文件系统。比如创建根目录。我们用于测试的 main() 将总会包含它。（要在里面做什么取决于你自己！）</p><p>我们的测试用例长什么样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* our main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();     <span class="comment">// 你的初始化操作</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/dir&quot;</span>) == <span class="number">0</span>);   <span class="comment">// 应当成功</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;//dir&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为目录已存在</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/a/b&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为父目录不存在</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  assert((fd = ropen(<span class="string">&quot;//dir///////1.txt&quot;</span>, O_CREAT | O_RDWR)) &gt; <span class="number">0</span>);  <span class="comment">// 创建文件应当成功</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 应当完整地写入</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_CUR) == <span class="number">5</span>);  <span class="comment">// 当前 fd 的偏移量应该为 5</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">0</span>);  <span class="comment">// 应当成功将 fd 的偏移量复位到文件开头</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(rread(fd, buf, <span class="number">7</span>) == <span class="number">5</span>);   <span class="comment">// 只能读到 5 字节，因为文件只有 5 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>);   <span class="comment">// rread 应当确实读到 &quot;hello&quot; 5 个字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">3</span>, SEEK_END) == <span class="number">8</span>);  <span class="comment">// 文件大小为 5，向后 3 字节则是在第 8 字节</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 再写 5 字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">5</span>, SEEK_SET) == <span class="number">5</span>);  <span class="comment">// 将偏移量重设到 5 字节</span></span><br><span class="line">  assert(rread(fd, buf, <span class="number">8</span>) == <span class="number">8</span>);   <span class="comment">// 在第 8 字节后写入了 5 字节，文件大小 13 字节；那么从第 5 字节后应当能成功读到 8 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0world&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>); <span class="comment">// 3 字节的空隙应当默认填 0</span></span><br><span class="line">  assert(rclose(fd) == <span class="number">0</span>); <span class="comment">// 关闭打开的文件应当成功</span></span><br><span class="line">  assert(rclose(fd + <span class="number">1</span>) == <span class="number">-1</span>); <span class="comment">//关闭未打开的文件应当失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="修订7"><a href="#修订7" class="headerlink" title="修订7"></a>修订7</h6><p>+++ 我们将会在这份手册的最后，提供几份测试代码供大家参考。大家可以将这些代码放到你的 <code>main.c</code> 中，并使用 <code>make run</code> 进行测试。+++</p><h2 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h2><p>首先是目录树。这里给出一个参考的文件对象结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FILE_NODE, DIR_NODE &#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">dirents</span>;</span>  <span class="comment">// if it&#x27;s a dir, there&#x27;s subentries</span></span><br><span class="line">    <span class="type">void</span> *content;         <span class="comment">// if it&#x27;s a file, there&#x27;s data content</span></span><br><span class="line">    <span class="type">int</span> nrde;              <span class="comment">// number of subentries for dir</span></span><br><span class="line">    <span class="type">int</span> size;              <span class="comment">// size of file</span></span><br><span class="line">    <span class="type">char</span> *name;            <span class="comment">// it&#x27;s short name</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p>目录的子项的数量会变化；文件的内容大小也会变化。因次我们可能需要对 <code>dirents</code> 或 <code>content</code> 的内存大小进行动态的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>这一函数会创建一段新的空间，将原来的内容复制到新的空间上，并释放原来的指针。注意原有指针一定也是动态分配的。</p><p>其次是文件描述符。对于文件描述符来说，其重要的只有这几个属性：读写性质，偏移量，指向的实际文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FD</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    node *f;</span><br><span class="line">&#125; FD;</span><br></pre></td></tr></table></figure><p>最初的根文件可以直接定义成全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node root;</span><br></pre></td></tr></table></figure><p>然后在 <code>init_ramfs</code> 中进行初始化。</p><p>接下来的事情，就很显然了：</p><p>添加文件和目录，就是往树里添加节点；</p><p>删除文件，就是删除节点；</p><p>读取内容，就是从 content 里复制出一段…</p><p>一个小建议：使用 <code>memcpy</code> 而不是 <code>strcpy</code>。（区别在哪？读手册）</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>第一个数据点已经给出。</p><p>test2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">notin</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[i] == fd) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">genfd</span><span class="params">(<span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (notin(i, fds, n))</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();</span><br><span class="line">  <span class="type">int</span> fd[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(ropen(<span class="string">&quot;/abc==d&quot;</span>, O_CREAT) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_RDONLY)) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    assert(rwrite(fd[<span class="number">0</span>], <span class="string">&quot;\0\0\0\0\0&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">1</span>], <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">2</span>], <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">3</span>], <span class="string">&quot;\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  assert(rclose(genfd(fd, <span class="number">4</span>)) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0\0\0\0\0\0\0\0&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hellohello&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;worldworld&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x001\x002\x003\x0fe\x0ff\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他的请再等等吧（</p><p>2023.1.14 补：</p><p>上线了测试点 4，在 main() 的开头做了一件事：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rread(<span class="number">-100000000</span>, buf, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>所有人都炸掉了。但按照手册，它应该返回 -1。这只是测试中不合理数据的一角，请大家保证自己的实现的可靠性。</p><p>如果你对某些特例会产生什么行为抱有疑问，欢迎提问。</p><h6 id="修订9"><a href="#修订9" class="headerlink" title="修订9"></a>修订9</h6><p>+++ 再次强调请小心地管理内存，否则内存容易超限，特别是注意释放掉已经不用的空间。</p><p>+++ OJ 评测结果解释：</p><p>+++ 答案错误：你的函数行为与规定的行为不一致。可能是文件系统中的内容不一致，也可能是函数返回值不符合约定。</p><p>+++ 运行错误：你的函数在内部崩溃了。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gitm</title>
      <link href="/20221228-git/"/>
      <url>/20221228-git/</url>
      
        <content type="html"><![CDATA[<p>git 是当今世界上最流行的版本控制系统。本实验要求你通过提交 git repo 的方式来提交一个迷你版的命令行工具 gitm(inus)。</p><p><strong>注意：本实验将只能在 Linux 操作系统中完成</strong>，因为你不得不使用系统调用，而 OJ 是 Linux 的。提交 Windows 上可以编译运行的代码，在评测机上注定不可兼容</p><p>首先，你需要学习 git ，否则你将完全不明白 gitm 的功能，并且也无法用 git 来管理本次作业的代码。</p><blockquote><p>是的！我们将会发布一个由 git 管理的框架代码，并且要求你一直使用 git 来管理，最终提交一个 git repo。</p></blockquote><p>获取框架代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.nju.edu.cn/Tilnel/gitm.git</span><br></pre></td></tr></table></figure><h2 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h2><p>所有代码，包括 .c 和 .h 文件需要放在 git repo 的根目录下。对自己使用的头文件的引用请以双引号的形式，以便编译脚本能够正常工作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitm</span><br><span class="line">├── gitm.c</span><br><span class="line">├── gitm.h</span><br><span class="line">├── whateveryouwant.c</span><br><span class="line">├── whateveryouwant.h</span><br><span class="line">├── ...</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">/* gitm.c */</span><br><span class="line">#include &quot;gitm.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可以修改 Makefile，但请不要删除其中的 git 目标依赖。我们在 Makefile 中确保了你的每一次编译运行都能够自动进行 git commit。这些自动的 commit 可以帮助你回滚到自己想要的任意版本，并且在未来查重工作中产生疑问时，良好的 commit 记录将成为重要的证明。</p><p>在你的 git repo 里请包含所有编译所需的源文件，但不要出现编译不需要的多余的源文件。</p><p>尝试编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>你将看到根目录下产生了一个名为 gitm 的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gitm version</span><br></pre></td></tr></table></figure><p>你将看到一个小彩蛋（你之后可以自由地删掉它或修改掉，不影响成绩）。</p><p>注意：本次实验你编写的是一个 “命令行工具”。也就是说，我们将以和使用 git 相同的方式来使用它：在命令行里输入命令和参数。这意味着，这次你需要真正 “解析参数” （被 parse.c 支配的恐惧）。</p><p>而且，这次我们将会在运行中多次调用你的程序。也就是说，你的程序并不是在一直运行着，每一次调用都会做不同的事。你存储在内存里的数据都将随着功能完成，进程结束而消失。所以，关于 gitm repository 的有用的信息，你需要将它们持久化到磁盘上，以便进行后续的操作。因此学习 C 语言的文件操作是必不可少的。</p><p>为了实现一个 git，首先你要了解 git 的功能</p><h2 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h2><p>假设我们当前在一个文件夹 dir 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm init</span><br></pre></td></tr></table></figure><p>初始化当前的 dir 为一个 gitm repository。如果当前 dir 已经是一个 gitm repo，则不做任何操作。</p><p>此时的 gitm 中应当不存在任何 commit，gitm 的仓库中应不存在任何文件。</p><p>具体来说，你可以在当前目录下创建一个 <code>.gitm</code> 目录，用于存放一些记录仓库状态的文件。</p><blockquote><p>对，就像 git 那样！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm commit</span><br></pre></td></tr></table></figure><p>将当前仓库中文件改动后状态作为一个提交，并记录下来。然后不重复地给出一个长度为 8 的小写十六进制数（例如 3bdc8902），用于唯一地指示这一次 commit。</p><p>git 中的提交是一个树形的结构。我们希望你在 gitm 中，同样实现这样的树形结构。</p><p><img src="git-brance.svg" alt="img"></p><p>gitm 中不要求实现对分支的命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout commit</span><br></pre></td></tr></table></figure><p>checkout 用于将当前目录的状态切换到 commit 所指示的提交上。</p><p>若当前目录的状态较 gitm <strong>当前所处的 commit</strong> 有改动，则拒绝本次 checkout，并且<strong>你的 main() 函数以返回值 1 退出</strong>。</p><p>checkout 正常完成后，你目录中文件的状态（除了 .gitm 目录以外）必须与指定的 commit 相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout .</span><br></pre></td></tr></table></figure><p>特殊地，这一条命令用于将目录文件恢复到当前所处的 commit 时的状态。也就是说，放弃此时对文件的所有改动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm merge commit</span><br></pre></td></tr></table></figure><p>找到当前所处 commit 与命令指定的 commit 的公共祖先，并将两个 commit 合并起来。</p><p>具体来说，是将命令指定的 commit 相对于公共祖先的修改，应用于当前所处的 commit。</p><p>如果合并的两个 commit 相对于公共祖先，均对同一个文件产生了修改（创建、删除、编辑），那么命令直接拒绝执行，输出 “conflict\n” <strong>并使 main 函数返回 1</strong>。</p><p>在其他情况下，你需要合并，并产生一个新的 commit。逻辑上，这个 commit 将成为被合并的两个 commit 的共同后继。</p><blockquote><p>我们如何检测这一点？</p><p>假设有 commit a-g，b, c 由 a 分支而来，d 由 b, c 合并而来，e 是 b 的后继，f 是 c 的后继，g 是 d 的后继。</p><p>你的程序应当有能力找到 e, g 的公共祖先是 b，f, g 公共祖先是 c，在此基础上合并是无冲突的。如果你只能找到 a，则合并有可能产生冲突，因为 e 相对 a 改变了 a.c，而 g 相对 a 也改变了 a.c。</p></blockquote><p><img src="image-20230103113625830.png" alt="image-20230103113625830"></p><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>我们会将你的 repo 里所有的 C 源文件和头文件收集起来进行编译，并生成一个名为 <code>gitm</code> 的可执行文件。然后原地创建一个文件夹，作为你的 gitm 需要管理的 repository。例如（其中 &gt; 开头的行表示命令行输出）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line">../gitm init</span><br><span class="line">../gitm commit</span><br><span class="line">&gt; 3bce5ff0                       <span class="comment"># 空 commit，我们的 OJ 一定会创建一个空 commit 作为第一个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt   <span class="comment"># 创建文件并写入</span></span><br><span class="line">../gitm commit</span><br><span class="line">&gt; b926d817</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is my git&quot;</span> &gt; readme.txt</span><br><span class="line">git checkout 3bce5ff0</span><br><span class="line">&gt; You<span class="string">&#x27;ve made change. Please commit or garbage your change.</span></span><br><span class="line"><span class="string">echo $?                          # 给出上一条命令的返回值。正常退出的程序应当为 0</span></span><br><span class="line"><span class="string">&gt; 1</span></span><br><span class="line"><span class="string">../gitm commit</span></span><br><span class="line"><span class="string">&gt; ef938aa6</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt readme.txt .gitm</span></span><br><span class="line"><span class="string">../gitm checkout b926d817</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt .gitm</span></span><br></pre></td></tr></table></figure><p>随着时间的流逝，我将会发布进一步的实验指南。</p><h2 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h2><ul><li>你创建的所有文件都要放到运行目录的 .gitm 目录下。<ul><li>注意目录不要膨胀得过大。把每一个 commit 都完整地保存下来是一个方法，但 OJ 会给你扣分的</li></ul></li><li>commit 数量不会超过 10000 个。</li><li>你的 gitm 只需要管理文本类型的文件。其他类型的文件不会出现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>年终盘点</title>
      <link href="/20221221-EndYear/"/>
      <url>/20221221-EndYear/</url>
      
        <content type="html"><![CDATA[<p>1、1.7 首次参与组织200多人的机考：自己的机器，挪用的系统，紧张的安排，垃圾的性能，随时会崩…但渡劫成功</p><p>2、1.21 看白色巨塔</p><p>3、2.6 第一次滑冰</p><p>4、2.11</p><p> <img src="image-20221221214315009.png" alt="image-20221221214315009"></p><p>5、2.14</p><p><img src="image-20221221214352111.png" alt="image-20221221214352111"></p><p><img src="image-20221221214357552.png" alt="image-20221221214357552"></p><p>当然后来真的见面然后寄了</p><p>6、2.19 看长江去了<img src="image-20221221214753639.png" alt="image-20221221214753639"></p><p>7、3.1 人体成分分析体脂率 22.1，开始两个月的减脂</p><p>8、3.12 中山忌辰</p><p>9、3.13 半夜在学校里鬼混，后来的故事懂的都懂了</p><p>10、4.12 2022年第一把冷水澡</p><p>11、4.21 完美洗牌</p><p>12、4.22 M记限时新品汉堡，苏炳添代言</p><p>13、5.3 两个月减脂结束，体脂率降到 16.1</p><p>14、5.14 Deadlift 100 kg。立下 flag 是一年到 200</p><p>15、5.19</p><p>17、6.1 新鞋，国家队同款</p><p><img src="IMG_20220603_000551.jpg" alt="IMG_20220603_000551"></p><p>18、6.17 Deadlift 120kg</p><p><img src="image-20221221220110346.png" alt="image-20221221220110346"></p><p>19、6.23 做10个引体向上</p><p>20、6.26 从手洗转向洗衣机</p><p>21、6.26 Squat 100kg</p><p><img src="image-20221221220236367.png" alt="image-20221221220236367"></p><p>22、6.28 Bench Press 70kg</p><p>23、7.9 新衣回</p><p>24、8.14 在宿舍打地铺睡觉，因为太几把热了</p><p>25、8.22 骑自行车骑嗨了压弯摔了个寄</p><p><img src="image-20221221221015346.png" alt="image-20221221221015346"></p><p><img src="image-20221221221019675.png" alt="image-20221221221019675"></p><p>26、9.18 Squat 120</p><p>27、9.28 保研 + 递补学硕</p><p>28、10.3 Deadlift 150kg</p><p>29、10.10</p><p>30、10.23 第一次配好 vim</p><p>30.5、11.11 2022年最后一次冷水澡</p><p>31、11.15 Squat 130kg</p><p>32、11.18- 后来的事懂的都懂</p><p>33、12.12 看到 Abramovic 和 Ulay 的 Rest energy</p><p>34、12.17 Deadlift 160kg 本年度最满意的一次试举：无腰带，丝滑，锁定到位（就是鞋子穿错了）</p><p><img src="image-20221221222314347.png" alt="image-20221221222314347"></p><p>35、12.19 冠军！</p><p>36、12.21 发烧退烧直播当场干两斤米饭</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Axioms for Memory Access in Asynchronous Hardware Systems</title>
      <link href="/20221221-MISRA1986/"/>
      <url>/20221221-MISRA1986/</url>
      
        <content type="html"><![CDATA[<p>问题与系统定义</p><p>（选择这篇的理由是，它描述了一个“从底层硬件的公设出发推导出读写序列的Serializability”的过程。在分布式系统中，同样也是通过一些底层的访问控制、执行的约束来保证最终结果的一致性。同时，这篇文章的问题构造与证明中，出现了大量的“序”关系。这也是理解分布式系统执行的关键。）</p><p>这份工作的动机是硬件设计中，如何解决对寄存器的异步并发访问的问题。只有基于寄存器行为的一些假设，才能证明其所允许的并发访问的正确性。然而直接从寄存器的物理电气特性去分析行为非常复杂。因此这份工作提出了一个研究寄存器的公理基础，即如果一个寄存器满足特定的公理，就可以称之为一个“serial device”（对其的操作是一个动作组成的序列）。因此有关寄存器的正确性的问题就被大大简化了。这份工作同样证明了他们提出的公理是满足这一要求所需的最弱的条件。在与硬件设计者讨论后，他们认为满足这些要求的设备是物理上可实现的。</p><p>在并发系统的研究当中，常常会假设内存的引用是非并发的。两个同时发生的操作会以任意的一个顺序执行，造成结果的不确定性。对寄存器的非并发访问可以通过锁来实现，使得一个写操作不能与任何其他操作并发。在底层硬件中，flip-flop 是一种可以存储一个 bit 的单元。而想要锁定这个寄存器则必须再实现一个基于 flip-flop 的 lock bit，开销过大并且降低了系统的并发度。于是这份工作考虑去设计一种寄存器，使得并发访问对外显得非并发，而非并发访问会保留它们的顺序。</p><p>定义 valid schedules：</p><blockquote><p>A sequence of operations whose effect is equivalent to some sequential (nonconcurrent) executions of these operations</p></blockquote><p>其影响与结果相当于这些操作的某个顺序执行</p><p>Section 3 Axioms for register</p><p>Section 4 Axioms define only valid schedules (and are the weakest)</p><p>​               (给定调度有效性的简单的充要条件)</p><p>Axioms &lt;&#x3D;&gt; Validity Conditions &lt;&#x3D;&gt; Valid</p><p>基本概念</p><p>操作：读或写。每个操作对应一个值。约定所有写操作的值都是可区分的，这样我们可以知道哪个值是由哪次写操作产生的，并且可以将读取到一个值的读操作与产生它的写操作对应起来。</p><p>每个操作都分为 start 和 end 事件。用 |op:x 和 op:x| 来标注。</p><p>调度：</p><p>一个 start 和 end 的序列，对于每一个 |op 都存在唯一的 op| 与之对应，反之亦然。</p><p>precedes 关系：</p><p>事件在另一事件前发生。|op1:x precesed |op2:y 指 op1 比 op2 先开始。</p><p>op1 precedes op2 指 op1| precedes |op2。即操作整体在先</p><p>concurrent：</p><p>neither op1 precedes op2 nor op2 precedes op1</p><p>nonconcurrent: otherwise</p><p>valid schedule:</p><p>对于一个调度S，能够通过重新安排操作，使得所有的操作都是非并发的，所有的S中的非并发操作保留它们原有的 precedes 序关系，且读操作的返回值与写操作一致。</p><p>形式地说，S 是一个有效调度，当且仅当存在 S 的排列 S’ 使得下列 validity conditions 成立：</p><p>VC1. 对于所有 S‘ 中的操作， |op precedes op| （合法）</p><p>VC2. 任一对 S’ 中的操作非并发</p><p>VC3. 如果 op1 precedes op2 in S, then op1 precedes op2 in S’</p><p>VC4. 在 S’ 中，每个读操作存在一个在前的写操作。并且如果 w:x 是 r:y 的最近的一次写操作，则 y &#x3D; x</p><p>寄存器操作的公理</p><p>在没有歧义的时候，用 |op 和 op| 来表示 op 开始和结束的时间点。</p><p>当我们说 时间点 t within op 时，意味着 |op \leqslant t \leqslant op|</p><p>Axioms</p><p>A1. 对于每个 r:x 存在某个时间点 within r，寄存器的值是 x</p><p>A2. 如果时间点 t 时寄存器的值为 x，并且一个写操作 w:y 在 t 后开始，在 t’ 前结束（t &lt; t’），那么 t’ 时寄存器的值一定不是 x （它可能是未定义的）</p><p>A3. 如果时间点 t’ 时寄存器的值为 x，那么存在某个时间点 t （t\leqslant t’），使得 t within w:x 且 在<br>t 时，寄存器的值为 x</p><p>A4. 如果时间点 t 和 t‘ 时寄存器的值为 x，那么 x 的值在 t 和 t’ 之间一直都是 x</p><p>可以看出这四条公理都是非常直观的：</p><p>A1 相当于在说读取操作一定是有寄存器当中的依据的</p><p>A2 表示一个写操作一定会对寄存器的值产生影响</p><p>A3 在说寄存器中的值一定由某个写操作产生</p><p>A4 是说一个值不可能在不连续的两段时间里出现。也就是说，写操作只会尝试写一次</p><p>Notation. 在一个调度中使用 (x) 来表示在某个时间点，寄存器的值为 x，直到调度中有某个 (y) 出现</p><p>有效调度的性质</p><p>对于任意调度 S，对操作的值定义关系 before：</p><p>(1) x before x, 如果存在 r:x precedes w:x 或不存在 w:x</p><p>(2) x before y, y \neq x，如果对于某两个 op1, op2, op1:x precedes op2:y</p><p>(3) x before z, 如果对于某个 y，x before y 且 y before z</p><p>在这篇文章中，作者将集合上的偏序关系重新定义为：反自反，反对称，传递的关系。</p><p>反自反是为了保证对于调度 S，不存在 r:x 先于 w:x 这样的顺序。</p><p>Theorem 1. 一个调度有效，当且仅当与它相关的 before 关系是一个偏序关系</p><p>\Rightarrow: 从偏序关系，构造任意全序，证明 VC1 - VC4</p><p>\Leftarrow: 对于有效调度 S，存在某个排列 S‘ 满足 VC1-4，其中关于某个值 x 的操作一定是连续的。它规定了值之间的“全序”关系 before。这个全序必须和 S 上的偏序一致，故 S 上的 before 一定是偏序关系，否则不存在与之一致的全序。</p><p>对于任意在满足 A1-A4 的寄存器的调度 S 上的 x 定义：</p><p>Rx &#x3D; {t | 时间点 t 寄存器的值为 x}，这里将其成为 x 的时域</p><p>Observetion1 Rx 是一段连续的时间。如果 t1, t2 \in Rx, 那么 \forall t, t1 &lt; t &lt; t2, t \in Rx (A4)</p><p>Observation2 如果 Rx 非空，那么对于每一个 op:x 中都有某个时间点 within op，寄存器的值为 x (A1, A3)</p><p>Theorem 2. 任何满足 A1, A2, A3 和 A4 的调度都是有效的</p><p>为了证明调度有效，我们要从四条公理证明调度上的 before 关系是偏序的。</p><p>从 A1，A3 可以得到 irreflexive；</p><p>由 Observation1、2 可知 antisymmetric；</p><p>由 before 的定义可知 transitive。</p><p>Theorem 3. 对于一个有效调度，总能在某些特定的时间点对寄存器赋值，从而使得 A1, A2, A3, A4 被满足。</p><p>这里用的是先构造，再证明的方法。其构造方式大致如下：</p><p>找到 S 的满足 VC 的排列 S’, 将操作从 1-n 编号为 op_i，其对应值为 v_i （可能重复）。然后按如下规则进行赋值：</p><p>(1) (v1) 在 |op1 后立刻赋值</p><p>(2) (vi), i &gt; 1，在 |op_i 或 (v_{(i - 1)}) 后立即赋值（取较晚的那个）</p><p>至此，四条公理已被证明是调度有效的充要条件。</p><p>最后，文章又通过构造满足四条公理之三而不满足另外一条，导致调度无效的反例来证明四条公理并无相互蕴含的关系，保证了结果是最简的。</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tenhou账号</title>
      <link href="/20221218-tenhou/"/>
      <url>/20221218-tenhou/</url>
      
        <content type="html"><![CDATA[<p>Selenium ID1DEC0A1F-c4TbfgF7</p><p>可能以后不会打天凤了，姑且存着</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>体育与当代社会课程论文</title>
      <link href="/20221217-sports/"/>
      <url>/20221217-sports/</url>
      
        <content type="html"><![CDATA[<blockquote><p>她是这么教我的。先写个提纲，然后往里面填。虽然我平时大致也是在用这样的方式，但感觉依然言之无物。今天在此就小水一下，整个2000字好了。</p></blockquote><p>Structure</p><p>题名，姓名，学号，院系，中文摘要，关键词</p><p>正文</p><p>参考文献 what，我真的有什么东西可以参考吗</p><p>从“吕小军”品牌的发展看未来退役运动员的出路</p><p>孙博文 191240046</p><p>南京大学 匡亚明学院</p><p>摘要：中国国家举重队员“吕小军”征战3届奥运会连续获得金牌，并多次创下世界纪录。在备战2024年巴黎奥运会的同时，其运动装备品牌“吕小军举重”也在很好地发展着。运动员退役后出路不佳是一个老生常谈的问题，而吕小军的个人品牌则让我们看到了未来退役运动员的发展方向。</p><p>关键词：运动员 退役</p><p>一、吕小军的个案</p><p>2009 年 11 月，吕小军获得第 77 届世界举重锦标赛男子 77 公斤级冠军，并打破世界纪录，在举重界书写下了他自己的姓名。此后在各大比赛上多次打破记录、获得冠军，并蝉联三届奥运会冠军（伦敦奥运会 77 公斤级、里约奥运会 77 公斤级、东京奥运会 77 公斤级。之后在 2022 年宣布将要备战 2024 年巴黎奥运会，或将降为 73 公斤级。</p><p>由于出色的成绩，他本人成为了一个世界性的“网红”。在外网上流传着国际网友剪辑的许多吕小军个人训练的视频，甚至被转发回国内。吕小军在举重上成绩优秀，同时身材也好，被国际上的粉丝成为“绝世美人”。2017 年，吕小军参加儿童举重训练营，认为这些孩子需要更好的装备。那时他有一个想法，在中国为专业和业余举重运动员制造举重设备，于是“吕小军举重”品牌应运而生。</p><p>如今，“吕小军举重”已经有能力制造许多运动装备与器械，包括杠铃、杠铃片、深蹲架、腰带、护腕、套膝等。这似乎与吕小军的粉丝人群有关。在吕小军的粉丝当中，有不少都是健美、力量举、CrossFit 的爱好者，而品牌也把握到了这一特性，将自己打造为这一人群提供商品的品牌。目前在 B 站上，有“奥运冠军吕小军”和“吕小军举重”两个账号。前者是吕小军的个人账号，而后者是品牌账号，可以看出他们还在不断地经营社交媒体，以扩大自身在圈内的影响力。</p><p>总结而言，“吕小军”品牌的发展让吕小军作为举重运动员在退役后，依然拥有自己的事业和收入。</p><p>二、过去的问题</p><p>过去，一个运动员退役后的去处较为局限。对于名气不高的田径、体操、举重项目的运动员，出路并不明朗。而球类项目，雪山项目，水上项目的条件要稍微好一点，因为对于这些方面的培训需求较高，尤其是青少年培训。对于事业编制的运动员，退役后除了国家给钱以外，安排事业单位进行工作。没有编制的就要自己想办法。曾经也出现过体操冠军退役后街头卖艺求生、“亚洲第一大力士”没钱治病的极端案例，引发了国内对运动员退役后的境遇的大讨论。</p><p>三、现状和分析</p><p>如今，退役运动员的生存空间已经大大改善了。</p><p>又是一个案例。在 B 站上有一个 “DNT举重俱乐部” 的账号，粉丝数 1.6 万。训练馆本身位于成都，受聘的教练有袁光弟（1983-1988 中国国家举重队）和周伟剑（安徽省冠军）等。训练馆的人气很足，账号也会不定期发布教学与线下训练的视频。他们一方面可以通过线下开课来赚取学费，另一方面也可以通过线上上课、发布视频的方式为训练馆增长人气。</p><p>我们也可以看到不断有更多的运动员账号进驻，包括服役与退役的。他们都可以借助网络的平台，分享自己专项的训练知识，将自己推广出去。</p><p>当下退役运动员境况改善的原因主要有三。</p><p>一是社交网络的发展让线上交流越来越方便了。如果是以前的文字上网时代，即使在线上能够交流，也达不到可以教学的信息量。同时视野的开阔让人们能够多样化地选择自己感兴趣的运动项目了。我们无法想象在以前只有电视的情况下，能够有如此多的人对于“举重”这一项目产生兴趣。以往的举重运动员，如吕小军是因为在田径比赛中拿奖而被选中；“东方力王”占旭刚则是为了农转非而碰巧练举重。</p><p>二是社会发展对于健康的认识提高了，人们对于运动更加重视了，对于运动项目的教练的需求增加了。很多项目具有较高的专业性，有一定门槛，不容易上手。那么找一个老师就成为了很有必要的事。同时对于专业训练装备的需求也在增加，对于运动基础设施的需求在增加，这就有了运动品牌入场的机会。</p><p>三是公众对于体育赛事越来越热情，越来越多的人在以运动员为其精神榜样。运动员们开启社交账号，分享自己的训练或生活日常，即可收获很多粉丝。这无疑是运动员们向外界推销自身的绝佳渠道。</p><p>四、总结</p><p>当下退役运动员的出路已大大改善。除了体系内运动员分配事业编制以外，还能够成为运动教练、经营自己的装备品牌、活跃于网络成为“网红”接代言等。这下不但让运动员拥有出路，还能够让运动员围绕着自己的运动专项来规划自己的终身事业。</p><p>“吕小军”品牌的成功无疑是一个强心剂。即使不是每一位运动员的名声都像吕小军那样响亮，但是发展品牌，并以个人社交账号来促进品牌的发展的模式是值得借鉴的。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我们现在都懒得起标题了</title>
      <link href="/20221216-whatthefuck3/"/>
      <url>/20221216-whatthefuck3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>把“我”打成我们，是一个无意识的失误</p></blockquote><p>正文部分，我想参照张一兵的剧幕写法尝试一下。形式大概是这样：</p><ul><li>场灯。幕布。</li><li>舞台上？舞台下？</li><li>文本</li><li>音乐</li><li>。。。</li><li>分析</li></ul><p>内容上：</p><p>我的处所即是舞台；</p><p>行动：</p><ul><li>手机聊天（蜷缩着）</li><li>阅读（书在腿上）</li><li>喝酒（啜饮）</li></ul><p>思维：</p><ul><li>爱情在哪里</li><li>我想要什么，不停被大他者夺舍</li><li>意识消失，大笑，歌唱，发疯</li></ul><p>这个设想有点困难，演员的行为需要被转写，不能原样表达场景（就是他妈的难改）。我们还是写第一人称吧。</p><p>去符号，但是忠实地写出来</p><p>大约晚上九点，带上书，水和酒钻进了一个人的角落。在其他人的视线里活得久了，将要独处一夜这件事让我兴奋不已。</p><p>戴着耳机坐在椅子上，身体下陷到屁股快要离开座位，跷起二郎腿当作架书的地方。拧开酒瓶盖，一边小口地啜饮一边心不在焉地翻着电子书，就这样过了午夜，在酒精的作用下已经读不进书了。打开手机，和朋友小聊几句。自诩乐观主义的我一时有很多问题难解：答案似乎写好了，我似乎也相信，但总归无法接受。他的心态倒是好，但从我的视角看又过于冷静了，冷静地像是死掉了一样。</p><p>讨论结束已经是接近断片的状态，意识几乎要融化了，我开始胡言乱语内心的真实，记忆中含妈量极高。然后大约陷入了昏睡。睡着时体温下降得极快，我直接被冻醒了。醒来之后几乎本能地抄起热水壶兑上带来的凉掉的水猛灌，又看了一眼手机，发现几条写得乱七八糟的动态，挠破头皮都想不起来自己写过了。大约喝了半小时热水之后，体温逐渐恢复，这时发现酒瓶已经掉到地上，里面还剩一口的量，想也没想就喝掉了，然后捧着书一直坐到阳光照进窗户。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rest Energy</title>
      <link href="/20221213-restenergy/"/>
      <url>/20221213-restenergy/</url>
      
        <content type="html"><![CDATA[<p><em><strong>Rest Energy</strong></em></p><p><img src="42580.jpg" alt="img"></p><p>Marina Abramović 和 Ulay 的行为艺术作品。在 4 分 10 秒的时间里，两人拉着一支有真实杀伤力的合成弓，并对准了 Marina Abramović 的心脏。在他们的心脏附近装着麦克风，现场可以清楚地听到自己的心跳随着时间的流逝逐渐激烈。</p><p>两人是现实中的情侣，一起创作了许多行为艺术作品，其中 <em>The Lovers</em> （情人·长城）还与中国颇有渊源。二人 1988 访问中国期间，原计划二人从长城两头分别开始步行，直到在中间会面，作为整个作品。然而 Ulay 爱上了来自中国的翻译，二人在相遇后坦白，只好以各自继续前进走完长城来完成这件作品。</p><p>后来在 2010 年，Marina Abramović 的《对视》中，Ulay 再次出现。作品的所有关注者无一不深受感动：22 年后的二人迎来和解。然而（这个是独家八卦）当时二人正处在知识产权的官司当中，那些感动一下又变成完全的滑稽了。</p><p><img src="3fccea50e537ce836171d29ef4b02ed6_720w.webp" alt="img"></p><p>说回 <em><strong>Rest Energy</strong></em>。这件作品最显然的解释，也是 Abramović 自己对此的解释是完全的相信。为了一个作品冒着受伤甚至死亡的风险，将箭矢对准自己，将弓弦交给对方。似乎行为艺术就是有好勇斗狠的传统，像台湾艺术家谢德庆的五件一年行为表演：一年每天24小时每小时打一次卡（会死人的！）；一年不进入任何建筑物（活得下来吗？）。行为艺术不是静态的图像，而是一种“现在进行时”，它作为一个事件在发生。刚看到图的时候，或许会误认为画面里的弓箭只是道具，只是为了用一个形象唤醒人思想中的某个<strong>意象</strong>（imago）。而当了解到真正在发生的事件后，便立即要人哑口无言。</p><p>它成为我最近最钟爱的一件作品，还在于其中暗合了一个经典的结构（也可能是因为我最近在看所以无论什么都能合上）。Lacan 的论文中有这样一个病例，38 岁的埃梅因刺杀法国知名演员达弗洛斯而被捕。其内在逻辑是将他人的形象作为镜像，并加以认同形成了一个实际上是他者的“理想自我”，作为一个追求的对象。真正欲望着一个人的时候，你就会自己去变成那个人，这中间通常包含了非常强烈的反差，以至于主体通过精神分裂的方式直接将幻想实现。对他者的认同，即标志着自我的立即的死亡，“他”对于我是一种杀戮的关系。</p><p>在这副作品中，欲望与死亡恰好是两个鲜明的标志。二人面对面针锋相对，彼此的欲望显露无疑，在你死我活的斗争中，千方百计地置对方于死地。因为“我是一个由于一个别人才是自为的存在”，某种意义上这是一场对“承认”的斗争。而现实的结局是一方臣服于另一方。</p><blockquote><p>因为他们最初是等同的，并且是正相反对的，而它们朝着统一的返回又还没有达到，所以它们就会以两个正相反对的意识的形态而存在。其一为一种独立的意识，它的本质是自为存在，另一为依赖的意识，它的本质是为对方而生活或为对方而存在。前者是<strong>主人</strong>，后者是<strong>奴隶</strong>。[1]</p></blockquote><p>[1] [德] 黑格尔：《精神现象学》</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9-more-pointers 题解</title>
      <link href="/20221208-more-pointers/"/>
      <url>/20221208-more-pointers/</url>
      
        <content type="html"><![CDATA[<h1 id="9-more-pointers-题解"><a href="#9-more-pointers-题解" class="headerlink" title="9-more-pointers 题解"></a>9-more-pointers 题解</h1><p>[toc]</p><blockquote><p>由战犯 Tilnel 贡献本次题解。</p><p>如果有你没见过的函数（用法），请尽量弄懂它。花10分钟学一下，省掉考场上一点自己造轮子的时间。</p></blockquote><h2 id="A-不太简单的词法分析器-tokenizer-c"><a href="#A-不太简单的词法分析器-tokenizer-c" class="headerlink" title="A-不太简单的词法分析器 (tokenizer.c)"></a>A-不太简单的词法分析器 (tokenizer.c)</h2><blockquote><p>本题数据的特性就是，不存在一个连续的字符串里有多个分号的情况。例如：<br><code>return;return;return;return;return;</code></p><p>所以对于分号，你可以当作只有：</p><p>1、在开头<br>2、在末尾<br>3、在中间有一个<br>4、没有<br>5、字符串里只有分号</p><p>这几种情形</p></blockquote><p>根据题目注解写的思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">  <span class="type">char</span> *position = <span class="built_in">strchr</span>(s, <span class="string">&#x27;;&#x27;</span>);   <span class="comment">// if there&#x27;s no &#x27;;&#x27; in s, it returns NULL.</span></span><br><span class="line">  <span class="keyword">if</span> (position == <span class="literal">NULL</span>) process(s);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    process(s 中分号前的部分);</span><br><span class="line">    在输出末尾加个换行;</span><br><span class="line">    process(s 中分号后的部分);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单地想到我们可以直接逐个处理，并把输出记录到字符串当中。</p><p>由于我们要求，要么输出完整的结果，要么只输出 Compile Error，而完整的结果是逐词累积的。如何在一个字符串的末尾去 append 新的内容呢？答案是：<code>strcat()</code>，或 <code>sprintf()</code>。</p><blockquote><p>NAME<br>       strcat, strncat - concatenate two strings</p><p>SYNOPSIS<br>       #include &lt;string.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></blockquote><p><code>strcat()</code> 的做法是把 src 拼到 dest 的后面。需要 dest 有足够的空间。并且只能操作纯字符串。而 <code>sprintf()</code> 可以在指定的位置放置一个格式化输出的字符串。同学们可以自行 RTFM。</p><p>那么，我们就开一个大的字符串去存放输出结果，每次更新。如果出错就输出报错，然后直接返回；否则在最后把结果输出。</p><p>如何分割字符串？以 “abcd;efgh” 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char s[] = &quot;abcd;efgh&quot;;</span><br><span class="line">s[4] = 0;</span><br><span class="line">printf(&quot;%s, %s\n&quot;, s, s + 5);</span><br></pre></td></tr></table></figure><p>它的输出结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd, efgh</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;abcd;efgh&quot;</span>;</span><br><span class="line">s[<span class="number">4</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码将会给出 segmentation fault。</p><p>在 C 语言中，”” 所给出的字符串字面量都将是常量，也就是说它会放在只读的内存空间中。<br><code>char *s = &quot;a string&quot;;</code> 的作用，是将这段只读内存空间的指针赋给 <code>s</code>。因此你不能重新对 <code>s</code> 中的字符进行修改。<br>而 <code>char s[] = &quot;a string&quot;;</code> 是分配一段可读写的内存空间，并将其中的值初始化为该字符串。</p></blockquote><p>在 C 中，字符串是以 ‘\0’ 结尾的。因此我们只需要让我们所需要的字符串部分的后一位为 ‘\0’，即可得到字符串的这一局部。因此想要将字符串按照 ‘;’ 割成两段，非常简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *semi = <span class="built_in">strchr</span>(s, <span class="string">&#x27;;&#x27;</span>);   <span class="comment">// find position of semicolon</span></span><br><span class="line"><span class="keyword">if</span> (semi) &#123;   <span class="comment">// strchr() returns NULL if there&#x27;s no semicolon</span></span><br><span class="line">  *semi = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  process(s);</span><br><span class="line">  process(semi + <span class="number">1</span>);    <span class="comment">// what&#x27;s after semicolon is another part</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  process(s);</span><br></pre></td></tr></table></figure><p>对于 <code>process()</code>，我们的要求则是：</p><ul><li>如果一个词符合五种规则，则追加一条解析</li><li>如果不符合，则直接输出 “Compile Error” 并退出</li></ul><p>直接退出程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure><p>不同于 return，它直接将整个程序正常结束。</p><p>那么，剩下最后一件事：解析规则。根据规则，一个字符串只可能属于其中的一种。故对五个规则依次判断。要注意的是，保留字均符合变量的条件，因此要先判出保留字，再去判变量。</p><h3 id="保留字和运算符"><a href="#保留字和运算符" class="headerlink" title="保留字和运算符"></a>保留字和运算符</h3><p>策略很简单：把所有保留字（运算符）放在一个字符串数组里，碰到以后逐个 <code>strcmp()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **reserved = <span class="built_in">malloc</span>(<span class="number">16</span> * <span class="keyword">sizeof</span>(<span class="type">char</span> *));   <span class="comment">// char **, 实质上是一个 (char *)的数组</span></span><br><span class="line">*(reserved + <span class="number">0</span>) = <span class="string">&quot;const&quot;</span>;</span><br><span class="line">*(reserved + <span class="number">1</span>) = <span class="string">&quot;int&quot;</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, *(reserved + i))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// is a reserved</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// is not</span></span><br></pre></td></tr></table></figure><p>运算符同理</p><p>其实还有一个偷懒的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *operators = <span class="string">&quot; + - * / &lt; &gt; = == &gt;= &lt;= != &quot;</span>; <span class="comment">// why there is space?</span></span><br><span class="line"><span class="type">char</span> *tmp = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %s &quot;</span>, s);   <span class="comment">// add space in the front and rear of s</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(operators, tmp)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// !!</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>保留字是同理。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对于开头，检查是否是字母或下划线；对于后续，检测是否是字母、数字或下划线。</p><p>活用 <code>isalpha()</code>, <code>isdigit()</code>…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || *s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (s++; *s != <span class="number">0</span>; s++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || <span class="built_in">isdigit</span>(*s) || s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><code>isdigit()</code> 过一遍就好</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><code>isdigit()</code> 过一遍，但有一个位置可以是 ‘.’</p><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *reserved = <span class="string">&quot; break char const double enum extern float goto int long return static struct typedef union void &quot;</span>;</span><br><span class="line"><span class="type">char</span> *operators = <span class="string">&quot; + - * / &gt; &lt; &gt;= &lt;= == = != &quot;</span>;</span><br><span class="line"><span class="type">char</span> *tmp, *output;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isinteger</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; *s; s++) <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isfloat</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; *s; s++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*s)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*s == <span class="string">&#x27;.&#x27;</span>) cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isreserved</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %s &quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(reserved, tmp) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isvariable</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || *s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (s++; *s != <span class="number">0</span>; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || <span class="built_in">isdigit</span>(*s) || *s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isoperator</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %s &quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(operators, tmp) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*s) <span class="keyword">return</span>;  <span class="comment">// empty string while splitted by semicolon</span></span><br><span class="line">    <span class="keyword">if</span> (isinteger(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;integer &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isreserved(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;reserved &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isoperator(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;operator &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isfloat(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;float &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isvariable(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;variable &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Compile Error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">    output = <span class="built_in">malloc</span>(<span class="number">8192</span>);</span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">        <span class="type">char</span> *semi = <span class="built_in">strchr</span>(s, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!semi) process(s);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            *semi = <span class="number">0</span>;</span><br><span class="line">            process(s);</span><br><span class="line">            <span class="built_in">strcat</span>(output, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            process(semi + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="B-字符串拼接-stringcat-c"><a href="#B-字符串拼接-stringcat-c" class="headerlink" title="B-字符串拼接 (stringcat.c)"></a>B-字符串拼接 (stringcat.c)</h2><p>从长到短找出最长的公共部分。注意 A 有可能比 B 长，有的同学对于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ababacd ababa</span><br></pre></td></tr></table></figure><p>这样的一组，在寻找公共部分的时候，从 A 的第一个字符找起。显然 5 个字符全匹配了，但匹配部分并不是 A 的后缀。</p><p>偷懒：</p><p>对于一个字符串 B 的前缀 P, 总有</p><p>$strstr(B, P) &#x3D;&#x3D; B$</p><p>那么…</p><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="type">char</span> *a = <span class="built_in">malloc</span>(<span class="number">1001</span>), *b = <span class="built_in">malloc</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b);</span><br><span class="line">        <span class="type">int</span> la = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="type">int</span> lb = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (la &gt; lb) ? la - lb : <span class="number">0</span>; i &lt;= la; i++) &#123;   <span class="comment">// 为什么是 &quot;&lt;=&quot; ?</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(b, a + i) == b) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s%s\n&quot;</span>, a, b + la - i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：为什么这里是 “&lt;&#x3D;”</p><p>思考：<code>strstr(s, &quot;&quot;)</code> 的结果</p><h2 id="C-参数传递-parse-c"><a href="#C-参数传递-parse-c" class="headerlink" title="C-参数传递 (parse.c)"></a>C-参数传递 (parse.c)</h2><blockquote><p>Saki 放上去的参考代码里，有一份我的原实现。那是纯纯的超纲写法。<br>不需要 getopt()。那是 GNUC 的玩意。<br>也不需要 dup2()，这纯纯的 Linux 系统调用。</p></blockquote><p>思路是，从前往后扫就完事了。</p><p>有的同学发现，option requires an argument 只会在最后出现，于是先去看最后一个参数。</p><p>考虑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b:c:</span><br><span class="line">program -b -c</span><br></pre></td></tr></table></figure><p>只看 -c，你可能已经想报错了。但这个 -c 其实应当作为 -b 的值。</p><p>输出与报错的实现思路，和 A 是一致的。</p><blockquote><p>嘿，可以学一下 <code>sprintf()</code> 的使用！</p></blockquote><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *output = <span class="built_in">malloc</span>(<span class="number">4096</span>), *rules = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="type">char</span> *name = <span class="built_in">malloc</span>(<span class="number">1024</span>), *arg = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">char</span> *value = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, rules, name);</span><br><span class="line">    pos += <span class="built_in">sprintf</span>(output + pos, <span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, arg) != EOF)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*arg != <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">char</span> *rule = <span class="built_in">strchr</span>(rules, *(arg + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (rule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(rule + <span class="number">1</span>) == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, value) == EOF) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s: option requires an argument -- &#x27;%c&#x27;\n&quot;</span>, name, *rule);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    pos += <span class="built_in">sprintf</span>(output + pos, <span class="string">&quot;%c=%s\n&quot;</span>, *rule, value);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                pos += <span class="built_in">sprintf</span>(output + pos, <span class="string">&quot;%c\n&quot;</span>, *rule);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: invalid option -- &#x27;%c&#x27;\n&quot;</span>, name, *(arg + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Takeaways-TL-DR"><a href="#Takeaways-TL-DR" class="headerlink" title="Takeaways (TL;DR)"></a>Takeaways (TL;DR)</h2><ul><li>字符串如何终止<ul><li>null byte</li></ul></li><li>学习简单的库函数让你在编程时偷懒<ul><li>但是要搞清楚这些函数的行为</li><li>用好了能节省大量时间</li><li>所以前提是学习的时候不偷懒</li></ul></li><li>指针难写<ul><li>去学断点调试</li><li>去学 GDB</li></ul></li><li>还不知道如何处理 SIGSEGV &#x2F; Segmentation fault ？？？<ul><li>STFW+自己调试，或惨挂</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-pointer 题解</title>
      <link href="/20221207-pointer/"/>
      <url>/20221207-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="8-pointer-题解"><a href="#8-pointer-题解" class="headerlink" title="8-pointer 题解"></a>8-pointer 题解</h1><p>[toc]</p><p>本周均属于简单的编程题。可以先用数组写了再转成指针写法。</p><h2 id="A-内存解释器-interpreter-c"><a href="#A-内存解释器-interpreter-c" class="headerlink" title="A-内存解释器 (interpreter.c)"></a>A-内存解释器 (interpreter.c)</h2><blockquote><p>不需要思考小端存储的事，不需要考虑浮点数非数的情况。<br>这是一道简单题，<strong>别想复杂</strong>，想得越复杂，越难做对。<br>也就是说，代码<strong>不应该超过10行</strong>，不然很可能只能拿部分分……别怪我没提醒。<br>当然，如果你足够强，可以化简为繁，挑战100行的写法。</p></blockquote><p>思路是很显然的，不过在那之前，我们可以稍微 dip into 一下 C 的类型系统，尤其是指针类型系统。</p><h3 id="常规类型"><a href="#常规类型" class="headerlink" title="常规类型"></a>常规类型</h3><p><code>int, float, double, long, long long...</code></p><p>每一种类型都对应了相应的<strong>字长</strong>。如 <code>int</code> 字长为 4，<code>long long</code> 字长为 8，而 <code>long</code> 的字长是机器相关的。在 32 位机上，它是 4 字，而在 64 位机上，它就是 8 字。机器相关的好处就在于，你可以编写可移植的代码。</p><p>当你在函数中写下 <code>int a;</code> 的时候，编译器可以在程序的栈空间里留下 4 个连续的字节空间用以存放这一整数。</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p><code>int *, float *, char *...</code></p><p>在 C 里，所有的指针类型都是机器相关的。指针长度与机器位宽相等，用来指示内存当中的某个位置。</p><p>对于 <code>int *</code> 变量进行解引用，如对 <code>int *a</code> 进行 <code>*a</code> 的操作，则 <code>*a</code> 的类型会自动还原为 <code>int</code>。其他常规类型同理。</p><p><code>void *</code></p><p>这种类型没有指定其解引用后的原类型。但它依然是一个指针。</p><h4 id="指针类型的强制类型转换"><a href="#指针类型的强制类型转换" class="headerlink" title="指针类型的强制类型转换"></a>指针类型的强制类型转换</h4><p>对于任意类型的指针，由于它们的字长是相同的，因此它们之间可以无阻碍地进行强制转换。如对于某个 <code>int *a</code>， 可以通过 <code>(double *)a</code> 来获取一个 <code>double *</code> 类型的指针。那么毫无疑问，如果你对这个指针进行解引用，即 <code>*(double *)a</code>，则机器会按照 <code>double</code> 的类型约定，来解析从指针位置开始的 8 字节作为解引用的值。于是题目就迎刃而解了。</p><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%u\n%f&quot;</span>, a, a, *(<span class="type">float</span>*)&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-子串的位置-substr-c"><a href="#B-子串的位置-substr-c" class="headerlink" title="B-子串的位置 (substr.c)"></a>B-子串的位置 (substr.c)</h2><p>认真阅读 C 库函数的手册，</p><blockquote><p>NAME<br>    strstr, strcasestr - locate a substring</p><p>SYNOPSIS<br>    #include &lt;string.h&gt;</p><p>​    char *strstr(const char *haystack, const char *needle);</p><p>DESCRIPTION<br>       The  strstr()  function finds the first occurrence of the substring needle in the string haystack.  The terminating null bytes (‘\0’) are not compared</p></blockquote><p>……</p><p>现成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">malloc</span>(<span class="number">100005</span>), *t = <span class="built_in">malloc</span>(<span class="number">100005</span>), *tmp = s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t);</span><br><span class="line">    <span class="keyword">while</span> ((tmp = <span class="built_in">strstr</span>(tmp, t)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp - s);</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有接触过 <code>strstr()</code>，那么至少也要想到，把<strong>从字符串里找到一个子串的位置</strong>这个功能封装为一个函数，毕竟要多次调用。</p><h2 id="C-搞个大新闻-title-c"><a href="#C-搞个大新闻-title-c" class="headerlink" title="C-搞个大新闻 (title.c)"></a>C-搞个大新闻 (title.c)</h2><blockquote><p>敬爱的江泽民同志永垂不朽</p></blockquote><p>既然说了是逐词以空格分开，那就可以这样的方式读入（一定要学会！）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF)) &#123;</span><br><span class="line">   <span class="comment">// process(s);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要么就在第 9 次作业再吃一次苦</p><p>C 还有两个库函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><p>只需要对第一个无脑 <code>toupper()</code>，剩下的全都 <code>tolower()</code> 就完事了…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  *s = <span class="built_in">toupper</span>(*s);</span><br><span class="line">  <span class="keyword">for</span> (s++; *s != <span class="number">0</span>; s++)</span><br><span class="line">    *s = <span class="built_in">tolower</span>(*s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *s = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">    convert(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式与并行算法 - 实验</title>
      <link href="/20221204-parallel/"/>
      <url>/20221204-parallel/</url>
      
        <content type="html"><![CDATA[<p>个人使用了 C 语言。环境为 Linux on 12x 3.4GHz (6核12线程）。</p><p>代码编译方式：</p><p>对于并行的 mpqsort.c, mpenum.c, mpmerge.c:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mpqsort.c -O2 -lpthread -o mpqsort</span><br></pre></td></tr></table></figure><p>运行方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mpqsort</span><br></pre></td></tr></table></figure><p>对于串行的 qsort.c, enum.c, merge.c:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc qsort.c -O2 -o qsort</span><br></pre></td></tr></table></figure><p>对于6个程序，可以在路径下用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>一同生成。</p><h2><a href="#bing-xing-suan-fa-wei-dai-ma" class="header-anchor">#</a><span id="bing-xing-suan-fa-wei-dai-ma">并行算法伪代码</span></h2><p>快速排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">para_quicksort(data, i, j, m, id)</span><br><span class="line">    <span class="keyword">if</span> (j - i) &lt;= k or m = <span class="number">0</span> then</span><br><span class="line">        P_id call quicksort(data, i, j)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        P_id: r = partition(data, i, j)</span><br><span class="line">        P_id: send data[r + <span class="number">1</span>, j] to P_id + <span class="number">2</span>^(m - <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        para_quicksort(data, i, r - <span class="number">1</span>, m - <span class="number">1</span>, id)</span><br><span class="line">        para_quicksort(data, r + <span class="number">1</span>, j, m - <span class="number">1</span>, id + <span class="number">2</span> ^ (m  - <span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line">        P_id + <span class="number">2</span>^m - <span class="number">1</span> send data[r + <span class="number">1</span>, j] back to P_id</span><br><span class="line">    end <span class="keyword">if</span> </span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>枚举排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">para_esort(i, j)</span><br><span class="line">    将区间 [i, j] 划分为 nr_thrd 个区间 [Pi, Qi]</span><br><span class="line">    par <span class="keyword">do</span> <span class="title function_">esort</span><span class="params">(Pi, Qi)</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>归并排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">para_mergesort(i, j)</span><br><span class="line">    <span class="keyword">if</span> (j - i) &lt;= len / nr_thrd then</span><br><span class="line">        mergesort(i, j)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m = (i + j) / <span class="number">2</span></span><br><span class="line">        par <span class="keyword">do</span> para_mergesort(i, m)</span><br><span class="line">        par <span class="keyword">do</span> para_mergesort(m + <span class="number">1</span>, j)</span><br><span class="line">        merge</span><br><span class="line">    end <span class="keyword">if</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure><h2><a href="#yun-xing-shi-jian" class="header-anchor">#</a><span id="yun-xing-shi-jian">运行时间</span></h2><table><thead><tr><th></th><th>串行</th><th>并行</th></tr></thead><tbody><tr><td>快排</td><td>5ms</td><td>4ms</td></tr><tr><td>枚举</td><td>2244ms</td><td>273ms</td></tr><tr><td>归并</td><td>5ms</td><td>3ms</td></tr></tbody></table><h2><a href="#jie-guo-fen-xi" class="header-anchor">#</a><span id="jie-guo-fen-xi">结果分析</span></h2><p>对于快排和归并来说，由于可以并行的部分较少，耦合度较高，导致提升并不大。而对于枚举排序，则因为各线程耦合较松，共享内存可以同时读如，导致并行后优化较好。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>openGauss 内容准备</title>
      <link href="/20221128-openGauss/"/>
      <url>/20221128-openGauss/</url>
      
        <content type="html"><![CDATA[<p>45分钟，分块</p><p>1、DB 概述 1-2 min</p><p>2、初次上手 2-3 min 加吐槽</p><p>3、项目基本结构介绍 3-4 min</p><p>4、分布式事务有的没的各种技术 20min</p><p>5、事务以外的各种技术 10min</p><p>6、社区，前景。2min</p><h2 id="DB-概述"><a href="#DB-概述" class="headerlink" title="DB 概述"></a>DB 概述</h2><p>openGauss是关系型数据库，采用客户端&#x2F;服务器，单进程多线程架构；支持单机和一主多备部署方式，同时支持备机可读、双机高可用等特性。</p><p>支持标准SQL，到2003，有2011的大部分核心特性和一些可选。</p><p>开发接口 ODBC， JDBC</p><p>混合存储引擎支持</p><p>openGauss数据库支持行存储引擎、列存储引擎和内存存储引擎等。行存分为“inplace update” 和 “append update”两种模式，前者通过单独的回滚段（undo log）来保留元组的前像以解决读写冲突，可以更自然的支持数据更新；后者将更新记录混杂在数据记录中，通过新旧版本的形式来支持数据更新，对于旧版本需要定期做vacuum操作来支持磁盘空间的回收。列存支持数据快速分析，更适合OLAP（Online Analytical Processing，联机分析处理）业务。内存引擎支持实时数据处理，对有极致性能要求的业务提供支撑。</p><p>事务支持 ACID。显式 - 隐式。主要关注事务。</p><p>显式有：</p><p>Start transaction</p><p>Commit</p><p>Rollback</p><p>Set transaction 设置隔离级别，读写模式，可推迟模式</p><p>对基于 ARM 架构的 鲲鹏 有一些特殊优化</p><p>从华为的 Gauss db T (oltp) 开源而来，支持单节点，一主多备，不支持集群。</p><p>基于postgresql v8</p><h2 id="初次上手："><a href="#初次上手：" class="headerlink" title="初次上手："></a>初次上手：</h2><p>东西很多。基础设施比较充分。编译可以有3种，release | debug | memcheck</p><p>随 src 附带一些测试。还有一些脚本工具，包括 ctags 的自动生成。</p><p>代码的移植性比较垃圾，在 CentOS 7.9 上用 gcc 7.3.0 编译。</p><p>必须用官方发布的第三方依赖库和相同发行版。否则问题超级多。</p><p>不知道 -enable-thread-safety 是什么实际作用。总之检查一直不过，只好 disable。</p><p>总之，更加现代的 bear、clangd 还没能成功整好…也许只能靠 IDE。</p><p>规模是140万行 c。</p><p>第一次dive in这种规模的项目…</p><h2 id="基本结构："><a href="#基本结构：" class="headerlink" title="基本结构："></a>基本结构：</h2><p>公共组件</p><ul><li>系统表，数据库初始化，多线程架构，线程池，内存管理，监控，模拟信号。</li></ul><p>系统表 - 元数据。有数据库列表，拥有者，字符集 之类</p><p>初始化 - initdb + openGauss 进程</p><p>多线程 - 由 PostgreSQL 多进程改造而来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Postmaster 监听，监控子线程。</span><br><span class="line">Startup 数据库启动。REDO日志。如果不是备机就退出。如果是备机就运行，REDO收到的新日志。</span><br><span class="line">Bgwriter 周期性写回 bufferpool</span><br><span class="line">Checkpointer 完成数据库周期性检查和执行检查点命令</span><br><span class="line">Walwriter 周期性持久化（数据库）日志缓冲区</span><br><span class="line">Stat 运行信息。统计。供优化分析和垃圾清理。</span><br><span class="line">Sysloger 写运行日志</span><br><span class="line">VacuumLaunch 通知Postmaster启动垃圾清理线程；平衡多个清理的负载</span><br><span class="line">Vacuumworker 垃圾清理线程</span><br><span class="line">Arch 日志归档。把在线日志拷到归档目录</span><br><span class="line">Postgres 服务线程。每个客户端连接对应一个服务线程。接收客户端操作请求，完成操作</span><br></pre></td></tr></table></figure><p>​</p><p>当然我们的重点是事务</p><p><img src="v2-458771758040c3e831461f1f20ae3b5e_720w.webp" alt="img"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>存储的子模块。</p><p>ACID</p><p>单机到分布式，双层的架构</p><p>GTM - CoordinatorNode - DataNode</p><p><img src="v2-28fa2431148513d3725fec9d2d62e95a_720w.webp" alt="img"></p><p>(1)GTM(GlobalTransaction Manager,全局事务管理器),负责全局事务号的分发、事务提交时间戳的分发以及全局事务运行状态的登记。对于采用多版本并发控制(Multi-Version Concurrency Control,MVCC)的事务模型,GTM 本质上可以简化为一个递增序列号(或时间戳)生成器,其为集群的所有事务进行了全局的统一排序,以确定快照(Snapshot)内容并由此决定事务可见性。在本文openGauss并发控制中,将进一步详述 GTM的作用。</p><p>(2)CN(CoordinatorNode,协调者节点),负责管理和推进一个具体事务的执行流程,维护和推进事务执行的事务块状态机。</p><p>(3)DN(DataNode,数据节点),负责一个具体事务在某一个数据分片内的所有读写操作。本文主要介绍显式事务和隐式事务执行流程中,CN 和 DN 上事务块状态机的推演,以及单机事务和分布式事务的异同。</p><p>主要代码在 src&#x2F;gausskernel&#x2F;storage&#x2F;access&#x2F;transam</p><p>事务管理器 xact.cpp 8000行。xact &#x3D; transaction</p><p>​        two-phase.cpp 3800 Lines. 二阶段提交</p><p>日志 xlog.cpp 19000 行 transaction log</p><p>clog.cpp  transaction-commit log</p><p>csnlog.cpp: tracking commit sequence numbers and in-progress subtransactions</p><p>线程管理 procarray.cpp </p><p>MVCC 多版本并发控制</p><p>锁管理 写并发控制。isolation</p><p>首先是 transaction，执行的全貌。显式隐式，子事务，执行时的并发控制</p><h3 id="（一）事务状态机"><a href="#（一）事务状态机" class="headerlink" title="（一）事务状态机"></a>（一）事务状态机</h3><p>openGauss将事务系统分为上层（事务块TBlockState）以及底层（TransState）两个层次。</p><p>通过分层的设计，在处理上层业务时可以屏蔽具体细节，实现灵活支持客户端各类事务执行语句（BEGIN&#x2F;START TRANSACTION&#x2F;COMMIT&#x2F;ROLLBACK&#x2F;END）。</p><p>（1） 事务块TBlockState：客户端query的状态，用于提高用户操作数据的灵活性，用事务块的形式支持在一个事务中执行多条query语句。</p><p>（2） 底层事务TransState：内核端视角，记录了整个事务当前处于的具体状态。</p><p>首先是显式事务块，也就是由 BEGIN &#x2F; START TRANSACTION 开启的事务。</p><p><img src="v2-42c47056ee587dad7f667d586a0213fc_720w.webp" alt="img"></p><p>在无异常情形下，一个事务块的状态机如图2所示按照默认（TBLOCK_DEFAULT）-&gt;已开始（TBLOCK_STARTED）-&gt;事务块开启（TBLOCK_BEGIN）-&gt;事务块运行中（TBLOCK_INPROGRESS）-&gt;事务块结束（TBLOCK_END）-&gt;默认（TBLOCK_DEFAULT）循环。剩余的状态机是在上述正常场景下的各个状态点的异常处理分支。</p><p>（1） 在进入事务块运行中（TBLOCK_INPROGRESS）之前出错，因为事务还没有开启，直接报错并回滚，清理资源回到默认（TBLOCK_DEFAULT）状态。</p><p>（2） 在事务块运行中（TBLOCK_INPROGRESS）出错分为2种情形。事务执行失败：事务块运行中（TBLOCK_INPROGRESS）-&gt;回滚（TBLOCK_ABORT）-&gt;回滚结束（TBLOCK_ABORT_END）-&gt;默认（TBLOCK_DEFAULT）；用户手动回滚执行成功的事务：事务块运行中（TBLOCK_INPROGRESS）-&gt;回滚等待（TBLOCK_ABORT_PENDING）-&gt;默认（TBLOCK_DEFAULT）。</p><p>（3） 在用户执行COMMIT语句时出错：事务块结束（TBLOCK_END）-&gt;默认（TBLOCK_DEFAULT）。由图2可以看出，事务开始后离开默认（TBLOCK_DEFAULT）状态，事务完全结束后回到默认（TBLOCK_DEFAULT）状态。</p><p>（4） openGauss同时还支持隐式事务块，当客户端执行单条SQL语句时可以自动提交，其状态机相对比较简单：按照默认（TBLOCK_DEFAULT）-&gt;已开始（TBLOCK_STARTED）-&gt;默认（TBLOCK_DEFAULT）循环。</p><p>子事务块 TBLOCK SUBxxx。基本就和事务块类似。。</p><p>TransState 也是类似的，只是是从事务真正执行的视角去看的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TABLE1;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>BEGIN, 开启事务块。</p><p>SELECT，开启一个底层事务执行该语句。</p><p>END 提交退出底层事务，结束事务块</p><p>几个函数，in tcop&#x2F;postgres.cpp 这个文件是 traffic cop 的主模块。</p><p>BEGIN;</p><p><code>exec_simple_query</code> 处理 begin 命令。</p><p>然后，它调用 <code>start_xact_command</code> 开始命令</p><ul><li>调用 <code>StartTransactionCommand</code> ，从 TBLOCK_DEFAULT 开始，</li><li>先调用（底层）<code>StartTransaction</code> ，于是 TRANS_START。</li><li>完成内存，缓冲区，锁初始化。</li><li>TRANS_INPROGRESS</li><li>返回，设为 TBLOCK_STARTED</li></ul><p><code>PortalRun</code> 处理 BEGIN 语句，最后在 BeginTransactionBlock 里 TBLOCK_BEGIN.</p><p><code>finish_xact_command</code> 结束命令。调用 CommitTransactinCommand 设置 TBLOCK_INPROGESS。等待读取下一条命令。</p><p>SELECT;</p><p>exec_simple_query</p><p>start_xact_command，此时是 INPROGRESS，已经在事务块内部，直接返回不改变任何状态。</p><p>PortalRun 执行。ExecutorRun，根据执行计划，最优路径查询。</p><p>finish_xact_command 结束 query 命令。调用 CommitTransactionCommand，而事务块仍为 TBLOCK_INPROGRESS。不改变任何状态</p><p>END;</p><p>exec_simple_query</p><p>start_xact_command 不改变</p><p>PortalRun -&gt; processUtility -&gt; EndTransactionBlock，set TBLOCK_END</p><p>finish_xact_command -&gt; CommitTransactionCommand，当前为 TBLOCK_END，继续调用CommitTransaction提交事务，设置底层状态为 TRANS_COMMIT，并且清理事务资源。最后 TRANS_DEFAULT。返回，上层事务块状态为 TBLOCK_DEFAULT。事务块结束。</p><h3 id="（二）事务ID分配-and-CLOG-x2F-CSNLOG"><a href="#（二）事务ID分配-and-CLOG-x2F-CSNLOG" class="headerlink" title="（二）事务ID分配 and CLOG&#x2F;CSNLOG"></a>（二）事务ID分配 and CLOG&#x2F;CSNLOG</h3><p>1 xid</p><p>transaction id ,  xid uint64 单调增。写在 HeapTupleHeader 的两个位置 xmin 代表插入的 xid, xmax 代表删除或修改的xid。</p><p>为节省空间，在 Page 上写 xid_base， 在 tuple 写 32 位 offset。</p><p>(溢出有调节)</p><p>只有写事务有 xid。“懒分配”。否则用太快。</p><p>子事务用到xid时，如果父务还没分配，则先分配父。确保子 &gt; 父。（越晚越大）。</p><p>2 log，维护映射关系</p><p>CLOG: xid -&gt; commit log</p><p>CSNLOG: xid -&gt; CommitSeqNo log</p><p>内存资源有限，长事务可能存在，所以内存会放不下。因此要写盘。写了盘就要记下哪条是哪个事务…</p><blockquote><p>CLOG以及CSNLOG分别维护事务ID-&gt;CommitLog以及事务ID-&gt;CommitSeqNoLog的映射关系。由于内存的资源有限，并且系统中可能会有长事务存在，内存中可能无法存放所有的映射关系，此时需要将这些映射写盘成物理文件，所以产生了CLOG（XID-&gt;CommitLog Map）、CSNLOG（XID-&gt;CommitSeqNoLog Map）文件。CSNLOG以及CLOG均采用了SLRU（simple least recently used，简单最近最少使用）机制来实现文件的读取及刷盘操作。</p></blockquote><p>CLOG，xid 到提交状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_IN_PROGRESS 0x00  表示事务未开始或还在运行中（故障场景可能是crash）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_COMMITTED 0x01 表示该事务已经提交</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_ABORTED 0x02 表示该事务已经回滚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_SUB_COMMITTED 0x03 表示子事务已经提交而父事务状态未知</span></span><br></pre></td></tr></table></figure><p> CSNLOG用于记录事务提交的序列号。openGauss为每个事务id分配8个字节uint64的CSN号，所以一个8k<strong>B</strong>页面能保存1k个事务的CSN号。CSNLOG达到一定大小后会分块，每个CSNLOG文件块的大小为256kB。同xid号类似，CSN号预留了几个特殊的号。CSNLOG定义代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_INPROGRESS UINT64CONST(0x0) 表示该事务还未提交或回滚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_ABORTED UINT64CONST(0x1) 表示该事务已经回滚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_FROZEN UINT64CONST(0x2) 表示该事务已提交，且对任何快照可见</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_FIRST_NORMAL UINT64CONST(0x3) 事务正常的CSN号起始值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_COMMIT_INPROGRESS (UINT64CONST(1) &lt;&lt; 62) 事务正在提交中</span></span><br></pre></td></tr></table></figure><h3 id="（三）MVCC-可见性判断机制"><a href="#（三）MVCC-可见性判断机制" class="headerlink" title="（三）MVCC 可见性判断机制"></a>（三）MVCC 可见性判断机制</h3><p>MVCC：</p><p>openGauss行存储表支持多版本元组机制，即为同一条记录保留多个历史版本的物理元组以解决对同一条记录的读、写并发冲突（读事务和写事务工作在不同版本的物理元组上）。</p><p>astore存储格式为追加写优化设计，其多版本元组产生和存储方式如图5所示。当一个更新操作将v0版本元组更新为v1版本元组之后，如果v0版本元组所在页面仍然有空闲空间，则直接在该页面内插入更新后的v1版本元组，并将v0版本的元组指针指向v1版本的元组指针。在这个过程中，新版本元组以追加写的方式和被更新的老版本元组混合存放，这样可以减少更新操作的I&#x2F;O开销。然而，需要指出的是，由于新、老版本元组是混合存放的，因此在清理老版本元组时需要的清理开销会比较大。因此，astore存储格式比较适合频繁插入、少量更新的业务场景。</p><p><img src="v2-847adb1622283c44e87b474f942bab7e_720w.webp" alt="img"></p><p>多版本并发控制来维护一致性。扫描数据的时候，每个事务看到的只是拿到快照当时的数据，而不是最新的数据。这样就避免看到并发事务的更新导致不一致了。读写就互相不阻塞，两个锁不冲突。</p><p>CSN 机制</p><p><img src="v2-85f56ddab9dfecbe315fcae1e291df6a_720w.webp" alt="img"></p><p>每个非只读事务在运行过程中会取得一个xid号，在事务提交时会推进CSN，同时会将当前CSN与事务的xid映射关系保存起来（CSNLOG）。图5-12中，实心竖线标识取snapshot（快照）时刻，会获取最新提交CSN（3）的下一个值4。TX1、TX3、TX5已经提交，对应的CSN号分别是1、2、3。TX2、TX4、TX6正在运行，TX7、TX8是未来还未开启的事务。对于当前snapshot而言，严格小于CSN号4的事务提交结果均可见；其余事务提交结果在获取快照时刻还未提交，不可见。</p><p><img src="v2-069ad49a3f3c496a19ea55d64283ceab_720w.webp" alt="img"></p><p>（1） xid大于等于snapshot.xmax时，该事务id不可见。</p><p>（2） xid比snapshot.xmin小时，说明该事务id在本次事务启动以前已经结束，需要去CLOG查询事务的提交状态，并在元组头上设置相应的标记位。</p><p>（3） xid处于snapshot.xmin和snapshot.xmax之间时，需要从CSN-XID映射中读取事务结束的CSN；如果CSN有值且比snapshot.csn小，表示该事务可见，否则不可见。</p><p>提交流程</p><p><img src="https://pic1.zhimg.com/80/v2-2d4109a47c4b4d75be8e9bc9bc9f639c_720w.webp" alt="img"></p><p>（1） 设置CSN-XID映射commit-in-progress标记。</p><p>（2） 原子更新NextCommitSeqNo值。</p><p>（3） 生成redo日志，写CLOG，写CSNLOG。</p><p>（4） 更新PGPROC将对应的事务信息从PGPROC中移除，xid设置为InvalidTransactionId、xmin设置为InvalidTransactionId等。</p><p>多版本快照</p><p>事务结束，快照记录到 环形缓冲区队列内存。别的线程获取快照就不用持有共享锁了，二是原子操作获取最新快照并加引用计数。拷贝完再减。引用计数为0时就可以释放。</p><p>比如我事务结束了。我放进去。只要没有新的版本，就可以留着。这个时候引用了，计数 + 1。然后我又更新，因为引用计数在，所以刷不掉这一项。</p><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>自旋锁（spinlock）、轻量级锁（LWLock，light weight lock）和常规锁（或基于这3种锁的进一步封装）。</p><p>spin用于加锁时间短的场合。编码保证无死锁。尽量用 CAS。</p><p>LWLock轻量锁： 原子操作 + 等待队列 + 信号量。</p><ul><li>两种，共享锁与排他锁</li></ul><p>共享锁可供多个进程；排他锁是独占。</p><p>轻量级锁使线程睡眠阻塞。用于内部临界区操作比较长的场合。</p><p>加锁和解锁可能跨越函数。编码保证不产生死锁。openGauss 提供了检测机制。</p><p>LWLockReleaseAll 事务中出错，会把持有的所有锁全部回滚释放。</p><p>常规锁：哈希表实现。用于业务访问的数据库对象加锁。</p><p>有等待队列，并提供死锁检测。检测到死锁是，选择一个事务回滚。</p><p>提供了8个锁级别分别用于不同的语句并发：1级锁一般用于SELECT查询操作；3级锁一般用于基本的INSERT、UPDATE、DELETE操作；4级锁用于VACUUM、analyze等操作；8级锁一般用于各类DDL语句，具体宏定义及命名代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AccessShareLock 1  <span class="comment">/* SELECT语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowShareLock 2     <span class="comment">/* SELECT FOR UPDATE/FOR SHARE语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowExclusiveLock 3 <span class="comment">/* INSERT, UPDATE, DELETE语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareUpdateExclusiveLock  \</span></span><br><span class="line"><span class="meta">    4 <span class="comment">/* VACUUM (non-FULL),ANALYZE, CREATE INDEX CONCURRENTLY语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareLock 5 <span class="comment">/* CREATE INDEX (WITHOUT CONCURRENTLY)语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareRowExclusiveLock                \</span></span><br><span class="line"><span class="meta">    6 <span class="comment">/* 类似于独占模式, 但是允许ROW SHARE模式并发 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ExclusiveLock                  \</span></span><br><span class="line"><span class="meta">    7 <span class="comment">/* 阻塞ROW SHARE，如SELECT...FOR UPDATE语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessExclusiveLock              \</span></span><br><span class="line"><span class="meta">    8 <span class="comment">/* ALTER TABLE, DROP TABLE, VACUUM FULL, LOCK TABLE语句 */</span></span></span><br></pre></td></tr></table></figure><p><img src="v2-5570aadf455dc9f6168b77ae0137041e_720w.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCKTAG</span> &#123;</span></span><br><span class="line">    uint32 locktag_field1;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint32 locktag_field2;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint32 locktag_field3;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint32 locktag_field4;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint16 locktag_field5;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint8 locktag_type;          <span class="comment">/* 详情见枚举类LockTagType*/</span></span><br><span class="line">    uint8 locktag_lockmethodid; <span class="comment">/* 锁方法类型*/</span></span><br><span class="line">&#125; LOCKTAG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">LockTagType</span> &#123;</span></span><br><span class="line">    LOCKTAG_RELATION, <span class="comment">/* 表关系*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_RELATION的ID信息为所属库的OID+表OID；如果库的OID为0表示此表是共享表，其中OID为openGauss内核通用对象标识符 */</span></span><br><span class="line">    LOCKTAG_RELATION_EXTEND, <span class="comment">/* 扩展表的优先权*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_RELATION_EXTEND的ID信息 */</span></span><br><span class="line">    LOCKTAG_PARTITION,          <span class="comment">/* 分区*/</span></span><br><span class="line">    LOCKTAG_PARTITION_SEQUENCE, <span class="comment">/* 分区序列*/</span></span><br><span class="line">    LOCKTAG_PAGE,               <span class="comment">/* 表中的页*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_PAGE的ID信息为RELATION信息+BlockNumber（页面号）*/</span></span><br><span class="line">    LOCKTAG_TUPLE, <span class="comment">/* 物理元组*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_TUPLE的ID信息为PAGE信息+OffsetNumber（页面上的偏移量） */</span></span><br><span class="line">    LOCKTAG_TRANSACTION, <span class="comment">/* 事务ID (为了等待相应的事务结束) */</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_TRANSACTION的ID信息为事务ID号 */</span></span><br><span class="line">    LOCKTAG_VIRTUALTRANSACTION, <span class="comment">/* 虚拟事务ID */</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_VIRTUALTRANSACTION的ID信息为它的虚拟事务ID号 */</span></span><br><span class="line">    LOCKTAG_OBJECT, <span class="comment">/* 非表关系的数据库对象 */</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_OBJECT的ID信息为数据OID+类OID+对象OID+子ID */</span></span><br><span class="line">    LOCKTAG_CSTORE_FREESPACE, <span class="comment">/* 列存储空闲空间 */</span></span><br><span class="line">    LOCKTAG_USERLOCK, <span class="comment">/* 预留给用户锁的锁对象 */</span></span><br><span class="line">    LOCKTAG_ADVISORY, <span class="comment">/* 用户顾问锁 */</span></span><br><span class="line">    LOCK_EVENT_NUM</span><br><span class="line">&#125; LockTagType;</span><br></pre></td></tr></table></figure><p>5个field 逐级标识被上锁的对象。type 为类型，比如 table, tuple, transaction.  很多很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCK</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 哈希键 */</span></span><br><span class="line">    LOCKTAG tag; <span class="comment">/* 锁对象的唯一标识 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 数据 */</span></span><br><span class="line">    LOCKMASK grantMask;           <span class="comment">/* 已经获取锁对象的位掩码 */</span></span><br><span class="line">    LOCKMASK waitMask;            <span class="comment">/* 等待锁对象的位掩码 */</span></span><br><span class="line">    SHM_QUEUE procLocks;          <span class="comment">/* 与锁关联的PROCLOCK对象链表 */</span></span><br><span class="line">    PROC_QUEUE waitProcs;         <span class="comment">/* 等待锁的PGPROC对象链表 */</span></span><br><span class="line">    <span class="type">int</span> requested[MAX_LOCKMODES]; <span class="comment">/* 请求锁的计数 */</span></span><br><span class="line">    <span class="type">int</span> nRequested;               <span class="comment">/* requested数组总数 */</span></span><br><span class="line">    <span class="type">int</span> granted[MAX_LOCKMODES];   <span class="comment">/* 已获取锁的计数 */</span></span><br><span class="line">    <span class="type">int</span> nGranted;                 <span class="comment">/* granted数组总数 */</span></span><br><span class="line">&#125; LOCK;</span><br></pre></td></tr></table></figure><p>常规锁LOCK结构，tag是常规锁对象的唯一标识，procLocks是将该锁所有的持有、等待线程串联起来的结构体指针。</p><p>死锁检测</p><p>LWLock 有独立监控线程。watchdog + 时间戳。请求进入时记录时间，wait 的默认 timeout 为 5s。如果超过了，就触发真正的死锁检测。避免性能浪费。实际的检测就是根据锁的依赖关系进行线程之间的有向无环图判定。治愈死锁就是从环里调一个线程退出。</p><p>常规锁 冲突时设置定时器，再唤起进行死锁检测。</p><p>事务隔离级别</p><p>在openGauss中,隔离级别的实现基于 MVCC和快照机制,因此这种隔离方式被称为 快 照 隔 离 (Snapshot Isolation,SI)。目 前,openGauss 支 持 读 已 提 交 (Read Committed)和可重复读(Repeatable Read)这两种隔离级别。两者实现上的差别在于在一个事务中获取快照的次数。</p><p>如果采用读已提交的隔离级别,那么在一个事务块中每条语句的执行开始阶段,都会去获取一次最新的快照,从而可以看到那些在本事务块开始以后、在前面语句执行过程中提交的并发事务的效果。如果采用可重复读的隔离级别,那么在一个事务块中,只会在第一条语句的执行开始阶段,获取一次快照,后面执行的所有语句都会采用这个快照,整个事务块中的所有语句均不会看到该快照之后提交的并发事务的效果。</p><p>这三个事务的并发执行顺序可能交错。SELECT - INSERT - SELECT - INSERT - SELECT</p><p>考虑 T3事务三条查询的返回结果。如果采用“读已提交”的隔离级别,那么在第一条查询开始时,首次获取快照,T1和T2均没有提交,因此它们都在快照中,查询结果不会包含它们插入的新记录;在第二条查询开始时,第二次获取快照,T1已经提交,在第二条查询语句的快照中,只有T2,因此可以查询到 T1插入的记录 v1;同理,在第三条查询开始时,第三次获取快照,T1和 T2均已经提交,它们都不在第三条语句的快照中,因此可以查询到它们插入的记录v1和v2。</p><p>另一方面,如果采用可重复读的隔离级别,对于 T3中的三条查询语句,均会采用第一条语句执行开始时的快照,而 T1和 T2均不在该快照中,因此在该隔离级别下,T3的三条查询语句均不会返回v1和v2。</p><h2 id="然后是持久化和故障恢复"><a href="#然后是持久化和故障恢复" class="headerlink" title="然后是持久化和故障恢复"></a>然后是持久化和故障恢复</h2><p>WAL 日志 (write ahead log，预写日志)</p><p>行存储持久化和检查点。</p><p>如果数据库系统在事务提交之后、异步写入磁盘的脏页写入磁盘之前发生宕机，那么需要在数据库再次启动之后，首先把那些宕机之前还没有来得及写入磁盘的脏页上的修改所对应的日志进行回放，使得这些脏页可以恢复到宕机之前的内容。</p><p>基于如上原理，可以得出数据库持久化的一个关键是：在宕机重启的时候，通过某种机制确定从WAL的哪个LSN开始进行恢复；可以保证在该LSN之前的那些日志，它们涉及的数据页面修改已经在宕机之前完成写入磁盘。这个恢复起始的LSN，即是数据库的检查点。</p><p>脏页通过 bgwriter 和 pagewriter（作为唯一消费者） 写入磁盘。采用无锁的全局脏页队列数组记录。</p><p>pagewriter 实际写入磁盘（其实是缓存！）。Checkpointer 线程来 fsync （确保持久化）并推进 LSN。</p><p>故障恢复，从 checkpoint 开始回放 log。日志有多种类型，回放逻辑由各自的资源管理器实现。</p><p>当数据库发生宕机重启之后需要从检查点位置开始回放之后所有的日志。不同类型的日志的回放逻辑由对应的资源管理器来实现。</p><p>当用户业务压力较大时会同时有很多业务线程并发执行事务和日志记录的插入，单位时间内产生的日志量是非常大的。对此openGauss采用多种回放线程组来进行日志的并行回放，各个回放线程组之间采用高效的流水线工作方式，各个回放线程组内采用多线程并行的工作方式，以便保证日志的回放速率不会明显低于日志产生的速率。</p><h2 id="最后是主备同步"><a href="#最后是主备同步" class="headerlink" title="最后是主备同步"></a>最后是主备同步</h2><p>日志复制。备机就回放。</p><p>walsender（主）walreceiver（备）</p><p>主机修改产生日志后，事务commit前需要同步日志到备机。采用Quorum一致性复制协议。多数备机完成日志同步即提交。这个过程中作为事务提交参考的是同步备，其他备机是异步备，作为冗余备份。</p><p>故障切换 failover：只有备机发生，主机异常了。</p><p>计划内切换 switchover： 主机降备，备机 failover。</p><p>leader 负责将自己的日志复制到其他节点，并维持心跳 </p><p>follower 复制接受来自leader的日志，心跳超时时转换为candidate，给其 他candidate投票 </p><p>Pre-Candidate Candidate 发起新任期投票，收集来自其他节点的投票 </p><p>passive 复制接受来自leader的日志 </p><p>logger 复制接受来自leader的日志，给其他candidate投票</p><p>preVote优化：  为防止网络断连导致节点频繁发起选主请求，term持续增加  在Follower变为Candidate前加入pre-candidate状态，发起term不变的 预选举流程，成功后才将term++发起正式选主流程 Lease优化：  Leader与多数派断连主动降备，防止事实双主  在lease时间内不响应term更高的选主消息</p><p>复制流程</p><p>Client：日志复制线程</p><p>调接口，写 Buffer。每次写分配 idx。完事一致之后会有一个异步线程通知它已经多数派承认了，日志已提交。</p><p>进复制队列，工作线程会组包 + 压缩之类，传输到备机</p><p>备机收到后，会通过回放接口通知到数据库内核日志模块，去把日志replay一下。</p><p>日志采用全异步进行发送，不采用一问一答同步方式，提高系统整体吞吐量 Leader发送完一批log之后，直接更新next index，下次发送从这个点持续发送，不等follower响应回来； Follower等落盘线程写完一批log之后，将最新的落盘match_index发送给leader，持续反馈最新的落盘index； Leader通过这个来更新各节点的最新match_index，推进commit_index；</p><p>（多数派把一个Log落盘之后，一个事务就可以commit了）</p><p>总结：</p><p>一个备份级联，备到备是未来的方向。这是社区自己说的</p><p>一个是整体性能很强。AI 优化和多线程优化很猛。到处都是异步。</p><p>社区很活跃。</p><p>这次讲解也只是一点。以单机事务为主。分布事务讲得比较笼统。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI 课程报告草稿</title>
      <link href="/20221124-AI/"/>
      <url>/20221124-AI/</url>
      
        <content type="html"><![CDATA[<p>在感知技术的选择上，我们采用了 SLAM 的策略。SLAM 的概念是：同时进行自身定位与地图构建。因为在当下大多数无人驾驶的场景下，机器人事先并不会有关于地图的全部知识，需要在运动的过程中边建图边决策，并且在建图之后就可以运用旧有的地图知识进行导航而并不需要每一次都重新分析，减小了地图更新的代价。</p><p>SLAM 技术路线按照传感器分类有如下几种：</p><table><thead><tr><th>类型</th><th>适用场景</th><th>特点</th></tr></thead><tbody><tr><td>二维激光SLAM</td><td>室内</td><td>成本低</td></tr><tr><td>三维激光SLAM</td><td>室外</td><td>成本高、信息量较大</td></tr><tr><td>视觉SLAM</td><td>室内室外通用</td><td>信息量丰富</td></tr></tbody></table><p>激光 SLAM 比视觉 SLAM 起步早，在理论、技术与产品上都比较成熟。而视觉 SLAM 现在也有基于 RGBD 的深度摄像机，比如 Kinect。以及基于单目、双目和鱼眼摄像头的。其中 RGBD 深度摄像机具有信息量大的优势，我们可以额外借助颜色信息来判断位姿的变化以及选取参考点，可以更好地帮助我们进行场景相关的决策。另一方面，激光雷达的成本较高，而摄像头的成本就要低很多。</p><p>不过视觉 SLAM 也有一些缺点，一是受环境光的影响较大，在光线较暗的场景或无纹理的区域无法工作。并且运算负荷也比较大，另外在地图构建的时候还存在累计误差。为了解决这一问题，我们需要设计有回环检验的 SLAM 算法。于是我们选择 ORB3-SLAM 框架。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夜里的故事</title>
      <link href="/20221123-tale/"/>
      <url>/20221123-tale/</url>
      
        <content type="html"><![CDATA[<p>我有点糊涂了，竟然在问她为什么如此相信我。我不能这么没有信心。这种冷不丁的话语很容易引起大家突然摸不着头脑，然后就寄了。</p><p>享受当下。</p><p>不过后来话题转到其他方面，转到家庭，又变成她说一些让我震惊的话，然后开始安慰我了。</p><p>人有自由意志吗？我们只是必然性的代理罢了。不过必然性说到底还是我自己的规定性。虽然说法不太一样，但我清楚她是明白这些的。</p><p>分离的结局有那么必然吗？我想不是。至少这个 eventually 的定义还有待发展。只要超越了大学这几年，我认为我很有机会挣脱家庭、传统婚姻的束缚，幸福地走下去。</p><p>不能老伤心吧。天天emo是会被讨厌的。</p><p>这几天有一些任务，大概梳理一下：</p><ul><li>论文报告。这个还有3页，差不多是一大堆要读。。</li><li>出一个项目。参考实现可以省一省</li><li>出AI的报告，wdnmd</li><li>做 opengauss 的报告。下周三讲</li></ul><p>三项就压在这几天。</p><p>不过我明天整完AI一些，带着出项目。后天先是比赛，晚上要出去做爱。</p><p>周六上午天文台，下午合唱团。周日可能去爬山。</p><p>那还做尼玛的报告？</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPL-Tetris</title>
      <link href="/20221121-Tetris/"/>
      <url>/20221121-Tetris/</url>
      
        <content type="html"><![CDATA[<p>题目描述</p><p>“俄罗斯方块”（Tetris）是一个经久不衰的小游戏。我们这就来做一个：</p><p>Tetra 是 4。我们做一个 Extended Edition</p><p>硬性要求：不做掉大分。</p><ul><li><p>掉落的方块，在原游戏基础上增加几种：</p><p>3方块的L 和 l, 5 方块的L。你可以在不影响可玩性的同时加点。</p></li><li><p>容纳方块大小至少为 12 列 16 行。自适应当前终端，如果不够，则不能启动。</p></li><li><p>使用方向键！方向键！方向键！实时控制方块旋转与下落，直到方块的下表面与已有方块接触，则刷出下一个方块</p></li><li><p>旋转前后，如果没有卡上游戏 tick （即向下掉落一格的时刻），方块的最下端高度不应变化</p></li><li><p>输入不合法的字符，不应使你的程序卡顿、崩溃、异常。</p></li><li><p>行填满必须消除。并计分。</p></li><li><p>屏幕内给出操控指示。支持暂停，重新开始等。</p></li></ul><p>软性：</p><ul><li><p>最好打印出较为标准的正方形。比如打印两个黑方块▇▇来组成一个。否则方块旋转后会<del>很丑</del></p></li><li><p>按下 方向下键 时方块速度增加</p></li><li><p>支持计分榜</p></li></ul><p>本实验选题不会奖励写图形界面的同学。如果图形界面有bug还可能导致多的扣分。</p><p>但命令行界面可以适当精致。</p><p>参考实现效果：Tilnel</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Time, Clocks, and the Ordering of Events in a Distributed System</title>
      <link href="/20221120-Lamport1978/"/>
      <url>/20221120-Lamport1978/</url>
      
        <content type="html"><![CDATA[<p>Lamport 原来是马萨诸塞的。</p><p>读文章的目标：搞清楚</p><ul><li>基本模型，基本假设：分布式系统的基本模型往往比较复杂。实际论文中的模型与课本中的模型<br>比，要精细地多。大家需要按照课上讲的框架，把论文中模型的各个纬度都讨论清楚。</li><li>基本问题：是否是经典问题。即使对于经典问题（e.g. consensus），也有很多的变体。把问题全<br>面认识清楚，与解决问题一样重要。对于一些不经典的问题，可以参照课上的学习，将问题全面<br>地认识清楚，解释清楚。</li><li>主要贡献：对于论文贡献的深入解释，往往是一个具体的模型、算法、分析技术。技术的细节不<br>是最重要的，简单copy原文更是大忌。课程看重的是，从课程中所学习的视角进行分析解读，进<br>行原理性的提炼、阐述等。另外，虽然我们是偏理论的课程，但是对于实现、实验、系统的解读<br>也是欢迎的，例如，系统设计、实现的背后，理论建模与分析是如何发挥指导性作用的，等等。</li></ul><p>分布式系统中的时间，时钟，和事件的序关系</p><p>前言</p><p>构造一个“事件发生在另一事件前”的偏序关系。</p><p>提出分布式算法，用以同步一个逻辑时钟系统，实现事件的全序。</p><p>使用一个解决同步问题的方法来刻画全序的作用。</p><p>然后提出一个同步物理时钟的算法特例，给出了时钟偏离同步的上界。</p><p>分布式系统中，时间不同步导致事件之间的序关系不确定。</p><p>我们讨论偏序，然后给一个算法来把偏序扩展成所有事件的满足consistency 的全序。这个算法就对我们实现分布式系统很有帮助。</p><p>之后呢我们会解决一个简单的同步问题，来展示它的用法。</p><p>意外的是，当算法给出的序和用户观察到的不一致的时候，不正常的行为就会发生。我们可以通过引入真实的物理时钟来避免这个问题。我们描述了一个简单的方法来同步这些时钟，并且求出了偏差的上界。</p><p>不用物理时间定义偏序，因为可能不准。</p><p>系统定义：</p><p>假设系统由一堆进程组成。每一个都是事件的序列。一个子程序可以是事件，一条机器指令也可以是时间。假设他们形成一个序关系，</p><blockquote><p>a occurs before b in this sequence if a happens before b</p></blockquote><p>单线程，就是一组事件的全序。</p><p>假设收发消息是一个事件，那么我们可以定义“发生在前”关系（happens before），denoted by <code>-&gt;</code></p><p>Def. The relation “-&gt;”, on the set of events of a system is the smallest relation satisfying the following three conditions:</p><p>(1) If a and b are events in the same process, and a comes before b, then a-&gt;b.</p><p>(2) If a is the sending of a message by one precess and b is the receipt of the same message by another process, then a-&gt;b.</p><p>(3) If a-&gt;b and b-&gt;c then a-&gt;c.</p><p>简单来说：线程内有序；同一消息的收发有序；传递性。</p><p>Concurrent iff not a-&gt;b and not b-&gt;a.</p><p>For all a, not a-&gt;a. Irreflexive</p><p>我们可以画时空图来表明这种序关系。</p><p>我们只考虑已经发送的消息，而不考虑可能将会发送的消息。这是更实际的。</p><p>现在我们引入逻辑时钟。其实就是给每个事件赋一个时间戳。</p><p>对每个进程Pi定义时钟Ci，它可以给进程中的每个事件都发一个时间戳。整个时钟系统就表示为一个函数 C，为事件产生时间数 C<b>.</b></p><p>C<b> &#x3D; Cj<b> 如果 b 是 Pj 的一个事件。现在我们并不对这个时间与物理时间进行关系的假设。所以我们只认为这是逻辑时钟。有可能只是个计数器。</b></b></p><p>现在我们考虑，这个系统的“正确性”到底是什么意思。</p><p>Clock Condition. For any events a, b:</p><p>​if a-&gt;b, then C<a>  &lt;  C<b></b></a></p><p>BUT Reverse not holds:</p><p>Suppose $C\langle a \rangle &lt; C\langle b\rangle \implies a\rightarrow b$</p><p>Then $\neg a\to b \implies \neg C\langle a\rangle &lt; C\langle b \rangle$</p><p>$Concurrence \iff \neg a\to b \and  \neg b\to a$</p><p>$\iff \neg C\langle a\rangle &lt; C\langle b\rangle\and \neg C\langle b\rangle &lt; C\langle a\rangle$</p><p>$\iff C\langle a\rangle &#x3D; C\langle b\rangle$</p><p>但是并发事件并不一定是同时进行。</p><p>时钟序成立，如果：</p><ul><li>C1. If $a$ and $b$ are events in process $P_i$, and $a$ comes before $b$, then $C_i\langle a\rangle &lt; C_i \langle b\rangle$.</li><li>C1. If $a$ is the sending of a message by process $P_i$ and $b$ is the receipt of that message by process $P_j$, then $C_i\langle a\rangle &lt; C_j\langle b\rangle$</li></ul><p>我们从时空图来考虑时钟。想象进程的时钟遍历每一个数字，每两个连续的事件之间都有（可能多次）“拨动”的操作。</p><p>然后对不同的线程，我们把它们相同的tick用虚线连起来。C1 就是说同线程中的两个事件之间必然有一条tick线。C2 则是说每一条消息线必须穿过一条 tick 线。</p><p>tick 线就是 笛卡尔 坐标系上的等时线（space-time）。我们把这玩意捋直了，这就表示了时间顺序了，还不用物理时钟。</p><p>这玩意你把它想象成三维的时空图也行。</p><p>假设线程是算法，事件代表其中的特定行为。</p><p>Pi 的时钟由一个寄存器 Ci 来代表，所以 Ci<a> 就是事件 a 时寄存器的值。寄存器会在事件之间改变，所以这个改变并不构成事件。</a></p><p>为了保证系统满足 Clock Condition，我们要确保 C1, C2。C1 很简单。线程只要遵守这个实现规则：（Implementation Rule）</p><p>IR1. Each process $P_i$ increments $C_i$ between any two successive events.</p><p>C2，我们需要每个消息 m 包含一个时间戳 Tm，为消息发出的时间。然后在收到以 Tm 标识的消息时，进程时钟必须跳到 Tm 以后。更准确的说：</p><p>IR2. (a) If event $a$ is the sending of a message $m$ by process $P_i$, then the message $m$ contains a timestamp $T_m &#x3D; C_i\langle a\rangle$.</p><p>(b) Upon receiving a message $m$, process $P_j$ sets $C_j$ greater than or equal to its present value and greater than $T_m$.</p><p>然后我们就可以排全序啦。</p><p>但是为了避免 ties，我们用一个任意的全序。我们定义关系 $\Rightarrow$:</p><p>if $a$ is an event in process $P_i$ and $b$ is an event in process $P_j$, then $a\Rightarrow b \iff (i) C_i\langle a\rangle &lt; C_j\langle b\rangle \or (ii)C_i\langle a\rangle &#x3D; C_j\langle b\rangle \and P_i \prec P_j$</p><p>什么意思呢？就是我们给线程随便指定一个优先级。然后遇到时间戳相同的事件，就按照他们的线程优先级来排事件的序。</p><p>我们用这玩意来构建一个满足</p><ul><li>互斥</li><li>先到先服务</li><li>Liveness</li></ul><p>的互斥资源请求算法。假设资源一开始已经分配给了一个进程。</p><p>这个并不简单。比如 P1 向 P0 请求后，向 P2 发一个消息。然后 P2 也向 P0 请求。第二个请求可能到的比一个早，这就 violation。</p><p>所以我们需要 IR1 + IR2 构造的一个时钟，来定义事件的全序。那么为了解决上述的问题，我们让每一个进程都了解到全局所有进程的操作。</p><p>简化问题，避免实现细节上的混乱，我们假设：</p><ul><li>固定两个进程之间单向的消息是按序到达的。</li><li>消息一定会送到。</li></ul><p>（我：现在TCP就很方便了。）</p><p>每个进程维护自己的<em>请求队列</em>，对其他进程不可见。一开始队列里存在一个 T0：P0 <em>requests resourse</em> ，即初始时的资源状态。T0比所有时钟都要小。</p><p>现提出5规则的算法，每条规则都包含于一个事件。</p><ol><li><p>请求资源， $P_i$ 发送 $T_m : P_i$ <em>requests resource</em> 给所有的其他进程，并且把这个消息放到自己的请求队列里。</p></li><li><p>$P_j$ 收到请求消息的时候，放到请求队列里，并返回一个带时间戳的 ACK （如果已经发了一个 &gt; Tm 的消息，则不用再返回）</p></li><li><p>释放资源，则从请求队列里弹出，并向其他所有人发送。</p></li><li><p>收到释放，则也弹出。</p></li><li><p>$P_i$ 在下列情况满足时获得资源</p><ul><li>在它自己的队列里，存在 $\Rightarrow$ 关系上的最小消息 $T_m : P_i$ <em>requests resource</em>. （消息的序就取决于其所在的事件的序）</li><li>$P_i$ 收到了所有人的比 $T_m$ 更晚的消息。</li></ul><p>上述两条都是 Thread Local 的条件</p></li></ol><p>这些东西加起来，肯定就满足了互斥、FCFS 和 Liveness。</p><p>5-2 结合按序到达性质，就保证了 $P_i$ 知道了自己的请求之前的所有请求。（我自己弄了一个两线程的实示例。实际上意思就是，假如双向消息的交付不按物理时间序，是交错的，后发消息的线程在另一个线程取得资源之前，是不会收到全部的回复的。也就保证了互斥。）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RAFT I - MIT 6.824</title>
      <link href="/20221118-RAFT/"/>
      <url>/20221118-RAFT/</url>
      
        <content type="html"><![CDATA[<p>Replication system.</p><p>A critical decision on who’s going to be primary?</p><ul><li>Single point failure</li></ul><p>real heart is put in a corner. single entity to decide</p><p>(or split brain)</p><p>Majority Vote</p><p>Irreflexive</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期安排和想法</title>
      <link href="/20221117-arrangement/"/>
      <url>/20221117-arrangement/</url>
      
        <content type="html"><![CDATA[<p>昨天还在这里写自己是试用期男友，现在就已经正式入职了。</p><p>感觉说了很多不得了的话呢。。呜呜</p><p>今天晚上要去答疑。</p><p>明天就去搞人工智能，后天就写写分布式的作业，以及分布式的作业。。。居然是两门</p><p>这两天需要穿插跳远之类的训练的。否则真烂完了。</p><p>邀请女朋友来看比赛吧？</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Primary Backup Replication</title>
      <link href="/20221116-PrimaryBackupReplication/"/>
      <url>/20221116-PrimaryBackupReplication/</url>
      
        <content type="html"><![CDATA[<p>Failures</p><p>​fail-stop failure</p><p>not covered: (software &#x2F; hardware) bugs, design defects.</p><p>Whether its worthwhile. –expensive. it’s an economic question</p><p>Ways of replica</p><p>State transfer</p><ul><li>Primary sends.</li></ul><p>Replicated state machine</p><ul><li><p>send external events. arriving Input. Operation from clients. (otherwise, the executions are deterministic function)</p></li><li><p>usually small</p></li><li><p>complicated. rely on sort of assumptions</p></li></ul><p>How to close sync if primary fails? </p><p>cut-over, anomalies</p><p>new replicas are hard to create.</p><p>What state to replicate?</p><p>application level replication if more efficient</p><p>level of machine? memory &amp; registers.</p><ul><li>downside: slow</li></ul><p>VMware FT</p><p> Non-deterministic-events</p><p>​Inputs-packet-date + interrupt</p><p>​    Weird instructions</p><p>​    Multicore</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>演戏</title>
      <link href="/20221103-daily/"/>
      <url>/20221103-daily/</url>
      
        <content type="html"><![CDATA[<p>生活一如既往地平淡如水。虽说享乐不是我们的主题，但是过于呆板也不好。</p><p>推完千晶线之后，虽然在上帝视角对于她本人一开始的态度并不能接受，但拥有精彩的演技其实是一件好事。偶尔有一些ooc的举动，或者从演技的角度来说，跳脱出自己原有的性格；或者是增强自己原有的性格。这些都是具有戏剧性的，从中我大概能获得平均以上的快感吧？</p><p>我觉得头脑里大概就要有这样的规划。既然大学这个阶段，人与人之间的连结是很少的， 不如在不同的人面前试图维持分裂的形象好了。其实以前也一直在做这样的事，但总是能保持微妙的平衡。矛盾的多面放到一起就非常合理。我不知道打破这样的平衡究竟是对是错，但是至少能给我的生活带来一些波澜，我觉得差不多就可以了。毕竟真正做到千晶那样是不可能的；毕竟我没有观众；毕竟我没有演对手戏的演员。</p><p>而总的来说，将要演的形象必须是正面的；为了保护自己的身心健康，也需要适当地分隔开人物的情感和自己的情感。这些都是理所当然的。</p><p>四季跟我说，他觉得千晶那种时刻在演的状态反而是最本真的。这里面的辩证关系我并不能理清楚。这学期的现代艺术表演课程中也提到过这样的问题，即我们日常生活当中的行为可不可以都将他们看作是一种表演。如果拿到一般的语境中，那么一般会被认为是过度解读。如果稍微接触到一点辩证法，则会采取一种模糊不清的解释方式。。我可能是意会了，但并不是很会。总之理论太难，我选择实践一下？</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GFS (MIT 6.824)</title>
      <link href="/20221103-GFS/"/>
      <url>/20221103-GFS/</url>
      
        <content type="html"><![CDATA[<p>Why is it hard? (Big store system)</p><p>Performance -&gt; Sharding -&gt; constant faults</p><p>Faults -&gt; fault tolerant systems</p><p>Tolerance -&gt; Replication</p><p>Replication -&gt; In consistency</p><p>Consistency -&gt; Low Performance</p><p>Consistency: like talking to one server</p><p>STRONG CONSISTENCY</p><p>Master - mapping : filename, and position</p><p>Chunk server 0</p><p>Chunk server 1</p><p>…</p><p>64MB per chunk</p><p>Master Data:</p><p>2 main tables:   (On ram)</p><ul><li><p>filename -&gt; array of chunk handles (nv)</p></li><li><p>chunk handles -&gt;list of chunk servers (v)</p><p>​version number (nv)</p><p>​                            primary (v)</p><p>​                            lease expiration (v)</p></li></ul><p>Will store some on disk</p><p>LOG, checkpoint(snapshot) - disk</p><p>n - not v - volatile</p><p>restart: recover to snapshot and replay LOG.</p><p>READ</p><ul><li><p>client send filename and offset to mcoinaster</p></li><li><p>master sends handle, list of servers</p><p>(cached. Next time, won’t ask master)</p></li><li><p>client -&gt; chunk servers: find the file</p><ul><li>&lt;- return the data</li></ul></li></ul><p>WRITES</p><p>if NO PRIMARY? - ON MASTER</p><p>find up to date replica (with version number)</p><p>pick primary and secondary</p><p>increment version number</p><p>tells primary, secondary the version number - lease</p><p>master write version number to disk</p><p>primary picks an offset</p><p>all replicas told to write at offset</p><p>if all “yes”, primary “success” -&gt; client</p><p>else “no” -&gt; client, and client reissue</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>稍微注意一下皮肤，谢谢。。</title>
      <link href="/20221101-misc/"/>
      <url>/20221101-misc/</url>
      
        <content type="html"><![CDATA[<p> 脓包、囊肿型痤疮：维A酸，异维A酸，阿达帕林（抑制炎症反应）</p><p>克林霉素磷酸酯、夫西地酸乳膏、过氧化苯甲酰（杀灭痤疮丙酸杆菌）</p><p>保湿，油性皮肤：薇诺娜、芙丽芳丝、倩碧、瑷尔博士</p><p>瑷尔博士微晶水</p><p><img src="image-20221101112606462.png" alt="image-20221101112606462"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC and Threads (MIT 6.824)</title>
      <link href="/20221030-RPCandThreads/"/>
      <url>/20221030-RPCandThreads/</url>
      
        <content type="html"><![CDATA[<p><em>Effective Go</em></p><p>Remote Procedure Call</p><p>Why is thread so important?</p><p>I&#x2F;O concurrency.  Allowing activities waiting and proceeding</p><p>Parallelism. Use all of the cores on your machine</p><p>Convenience. Daemon thread.</p><ul><li>fire a goroutine and send heartbeat pack</li></ul><p>OR event-driven programming. (Asyncronous)</p><p>One problem with the scheme is that is a little bit pain to program.</p><p>And it’s not parallelized.</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Buffer Pools (CMU DataBase Systems 2019 fall)</title>
      <link href="/20221030-BufferPools/"/>
      <url>/20221030-BufferPools/</url>
      
        <content type="html"><![CDATA[<p>DATABASE WORKLOADS</p><p>On-Line Transaction Processing</p><p>On-Line Analytical Processing</p><p>Hybrid Transaction + Analytical Processing</p><p>Spacial control: </p><ul><li>Where to write pages on disk</li><li>The goal is to keep pages that are used together often as physically close together as possible on disk.</li></ul><p>Temporal Control:</p><ul><li>When to read pages to memory, and when to write them to disk.</li><li>The goal is minimize the number of stalls from having to read data from disk.</li></ul><p>TODAY’S AGENDA</p><p>Buffer Pool Manager</p><p>Replacement Policies</p><p>Other Memory Pools</p><p>Memory region organized as an array of fixed-size pages.</p><p>An array entry is called a frame.</p><p>when the DBMS requests a page, an exact copy is places into one of these frame.</p><p>The page table keeps track of pages that are currently in memory</p><p>Also maintains additional meta-data per page:</p><ul><li>Dirty Flag</li><li>Pin&#x2F;Reference Counter</li></ul><p>Locks vs Latches</p><p>Locks:</p><ul><li>Protects the database’s logical contents from other transactions.</li><li>Held for transaction duration.</li><li>Need to be able to rollback changes.</li></ul><p>Latches:   –mutex</p><ul><li>Protects the critical sections of the DBMS’s internal data structure from other threads.</li><li>Held for operation duration.</li><li>Do not need to be able to rollback changes.</li></ul><p>SCAN SHARING</p><p>Queries can reuse data retrieved from storage or operator computations.</p><ul><li>This is different from result caching.</li></ul><p>Allow multiple queries to attach to a single cursor that scans a table.</p><ul><li>Queries do not have to be exactly the same.</li><li>Can also share intermediate results.</li></ul><p>Buffer Replacement Policies</p><ul><li>Least-recently used: Maintain a timestamp of when each page was last accessed</li><li>Clock<ul><li>Approximation of LRU without needing a separate timestamp per page<ul><li>Each Page has a reference bit</li><li>When a page is accessed, set to 1</li></ul></li><li>Organize the pages in a circular buffer with a “clock hand”:<ul><li>Upon sweeping, check if a page’s bit is set to 1.</li><li>If yes, set to zero. If no, then evict.</li></ul></li></ul></li></ul><p>Problems</p><p>LRU and CLOCK replacement policies are susceptible to sequential flooding.</p><ul><li>A query preforms a sequential scan that reads every page.</li><li>This pollutes the buffer pool with pages that are read once and then never again.</li></ul><p>The most recently used page is actually the most unneeded page.</p><p>Better Policies: LRU-K</p><p>Track the history of last K references to each page as timestamps and compute the interval between subsequent accesses.</p><p>The DBMS then uses this history to estimate the next time that page is going to be accessed.</p><p>Better Polices: Localization</p><p>The DBMS chooses which pages to evict on a per txn&#x2F;query basis. This minimizes the pollution of the buffer pool from each query.</p><ul><li>Keep track of the pages that a query has accessed.</li></ul><p>Example: Postgres maintains a small ring buffer that is private to the query.</p><p>Better Policies: Priority Hints</p><p>The  DBMS knows that the context of each page during query execution.</p><p>It can provide hints to the buffer pool on whether a page is important or not.</p><p>DIRTY PAGES</p><p>Fast: If a page in the buffer pool is not dirty, then the DBMS can simply “drop” it.</p><p>SLOW: I f a page is dirty , then the DBMS must write back to disk to ensure that its changes are persisted.</p><p>Trade-off between fast evictions versus dirty writing pages that will not be read again in the future.</p><p>BACKGROUND WRITING</p><p>The DBMS can periodically walk through the page table and write dirty pages to disk.</p><p>when a dirty page is safely written, the DBMS can either evict the page or just unset the dirty flag.</p><p>Need to be careful that we don’t write dirty pages before their log records have been written.</p><p>CONCLUSION</p><p>The DBMS can manage that sweet, sweet memory better then the OS.</p><p>Leverage the semantics about the  query plan to make better decisions:</p><ul><li>Evictions</li><li>Allocations</li><li>Pre-fetching</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Database Storage II (CMU Database Systems 2019 Fall)</title>
      <link href="/20221030-DatabaseStorageII/"/>
      <url>/20221030-DatabaseStorageII/</url>
      
        <content type="html"><![CDATA[<p>Log&#x3D;structured file organization</p><p>Instead of storing tuples in pages , the DBMS only stores log records.</p><p>The system appends log records to the file of how the database was modified:</p><ul><li>inserts store the entire tuple</li><li>Deletes mark the tuple as deleted</li><li>Updates contain the delta of just the attributes that were modified</li></ul><p>why?</p><ul><li>easy to roll   back</li><li>fast</li></ul><p>Obvious downside: reads…</p><p>To read a record, the DBMS scans the log backwards and “recreates” the tuple to find what it needs.</p><p>Build indexed to allow it to jump to locations in the log</p><p>Periodically compact the log.</p><p>Today’s agenda</p><ul><li>Data representation</li><li>system catalogs</li><li>storage models</li></ul><p>Tuple storage</p><p>The DBMS’s catalogs contain the schema information about tables that the system uses to figure out the tuple’s layout.</p><p>INTEGER&#x2F;BIGINT&#x2F;SMALLINT&#x2F;TINYINT</p><ul><li>C&#x2F;C++ Representation</li></ul><p>FLOAT&#x2F;REAL vs. NUMERIC&#x2F;DECIMAL</p><ul><li>IEEE-754 STANDARD &#x2F; Fixed-point Decimals</li></ul><p>VARCHAR&#x2F;VARBINARY&#x2F;TEXT&#x2F;BLOB</p><ul><li>Header with length, followed by data bytes.</li></ul><p>TIME&#x2F;DATE&#x2F;TIMESTAMP</p><ul><li>32&#x2F;64-bit integer of (micro)seconds since Unix epoch</li></ul><p>Fixed precision numbers</p><p>Numeric data types with arbitrary precision and scale. Used when round errors are unacceptable.</p><ul><li>Example: NUMERIC, DECIMAL</li></ul><p>Typically stored in a exact, variable-length binary representation with additional meta-data</p><ul><li>like a varchar but not stored as a string</li></ul><p>Large Values</p><p>Most DBMSs don’t allow a tuple to exceed the size of a single page.</p><p>To store values that are larger than a page, the DBMS uses separate overflow storage pages.</p><ul><li>Postgres: TOAST( &gt; 2 KB)</li><li>MySQL: Overflow (&gt; 1&#x2F;2 size of page)</li><li>SQL Server: Overflow( &gt; size of page)</li></ul><p>To BLOB or Not To BLOB: Large Object Storage in a Database of a Filesystem?</p><p>256 KiB seems to be a division</p><p>System Catalogs</p><p>A DBMS stores meta-data about database in its internal catalogs</p><p>-Tables, columns, indexed, views</p><p>Users, permissions</p><p>Internal statistics</p><p>Almost every DBMS stores their a database’s catalog in itself.</p><ul><li>Wrap object abstraction around tuples</li><li>Specialized code for “bootstrapping” catalog tables.</li></ul><p>You can query the DBMS’s internal INFORMATION_SCHEMA catalog to get info about the database.</p><ul><li>ANSI standard stet of read-only views that provide info about all of the tables, views, columns, and procedures in a database.</li></ul><p>DBMSs also have non-standard shortcuts to retrieve this information.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELSCT <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> table_catalog <span class="operator">=</span> <span class="string">&#x27;&lt;db name&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight postgres"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">DESC &lt;table name&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.schema &lt;table name&gt;;</span><br></pre></td></tr></table></figure><p>observation</p><p>The relational model does not specify that we have to store all of a tuple’s attributes together in a single page.</p><p>This may not actually be the best layout for some workloads…</p><p>OLTP</p><p>Online Transaction Processing:</p><ul><li>Simple queries that read &#x2F; update a small amount of data that is related to a single entity in the database.</li></ul><p>This is usually the kind of application that people build first.</p><p>OLAP</p><p>Online Analytical Processing</p><ul><li>Complex queries that read large portions of the database spanning multiple entities</li><li>You execute these workloads on the data you have collected from your OLTP applications(s).</li></ul><p>N-ARY STORAGE MODEL</p><p>Advantages</p><ul><li>Fast inserts, updates, and deletes.</li><li>Good for queries that need the entire tuple.</li></ul><p>disadvantages</p><ul><li>Not good for scanning large portions of the table and &#x2F; or a subset of the atreibutes.&#x2F;</li></ul><p>DECOMPOSITION STORAGE MODEL(DSM)</p><p>The DBMS stores the values of a single attribute for all tuples contiguously in a page</p><ul><li>Also known as a “column store”.</li></ul><p>Tuple Identification</p><p>Choice #1: fixed-length Offsets</p><ul><li>Each value is the same length for an attribute</li></ul><p>Choice #2: Embedded Tuple Ids</p><ul><li>Each value is stored with its tuple id in a column</li></ul><p>Advantages</p><ul><li>Reduces the amount wasted I&#x2F;O because the DBMS only reads the data that it needs</li><li>Better query processing and data compression (more on this later)</li></ul><p>Disadvantages</p><ul><li>slow for point queries, inserts, updates, and deletes because of tuple splitting&#x2F;stitching</li></ul><p>CONCLUSION</p><p>The storage manager is not entirely independent from the rest of the DBMS.</p><p>It is important to choose the right storage model for the target workload:</p><ul><li>OLTP &#x3D; Row Store</li><li>OLAP &#x3D; Column Store</li></ul><p>![](20221030-DatabaseStorageII.assets&#x2F;屏幕截图 2022-10-30 185728.png)</p><p>Next:</p><ul><li>How the DBMS manages its memory and move data back-and-forth from disk</li></ul><p>MIX OF TWO? engineering overhead too much</p><p>hybrid storage systems</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PXE</title>
      <link href="/20221027-PXE/"/>
      <url>/20221027-PXE/</url>
      
        <content type="html"><![CDATA[<p>Environment:</p><p>Host: Ubuntu 20.04.1, Oracle VM VirtualBox Manager</p><p>第一步，创建一个虚拟机</p><p><code>vboxmanage</code> 没什么好说的，读文档</p><p>首先要创建一个 natnetwork</p><p>然后根据 build.sh 的参数决定虚拟机的名称。创建虚拟磁盘并加载</p><p>第二步，准备 PXE 启动环境</p><p>首先搭一个 tftp 服务器，在里面准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pxelinux.0</span><br><span class="line">pxelinux.cfg/default</span><br><span class="line">jammy/vmlinuz</span><br><span class="line">jammy/initrd</span><br><span class="line">jammy/meta-data</span><br><span class="line">jammy/user-data</span><br></pre></td></tr></table></figure><p>挂一个 http 服务器，在里面准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu.iso</span><br><span class="line">ssh/id_rsa</span><br><span class="line">ssh/id_rsa.pub</span><br><span class="line">id.conf   # 返回机器编号的 nginx configuration</span><br></pre></td></tr></table></figure><p>问题一，我在 Ubuntu 20.04.3 上 <code>apt download pxelinux</code> 解包得到的 <code>pxelinux.0</code> 6.0.4，在 PXE 启动后就中止了，界面停留在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PXELINUX 6.04 PXE 20190223 Copyright (C) 1994-2014 H. Peter Anvin et al</span><br></pre></td></tr></table></figure><p>既不运行，也不报错。无论我如何写 .cfg，也没有用。在经过几小时的反复横跳后，我从 mirror 上随便找了一个 6.03，顺利启动了。。。</p><p>为了让每台机器配置的时候带上自己的机器编号（如 ip 配置所需要的），我把 tftp 服务器下的目录结构又改了一下：</p><p><img src="image-20221028174547322.png" alt="image-20221028174547322"></p><p>每个 vm-id 目录都是在 build.sh id 运行时自动生成。共用的文件用硬链接（tftp不识别软链接），需要修改的配置文件，用一个变量名把需要修改的地方标注，然后用 <code>sed</code> 替换为与各自的 id 相关的字符串。</p><p>自动安装的 user-data，主要是配置 hostname, username, password, ssh 等。以及安装后需要执行的命令。这里用 <code>echo</code> 创建了 systemd service，以及开机自动执行的脚本。</p><p>开机配置 ip 和 ssh 的公私钥，通过 <code>systemd</code> 执行一个脚本。</p><p>返回机器 id 的 http 服务器，我安装了 <code>nginx</code> 。配置文件在自动安装时用 <code>wget</code> 获取了。</p><p><img src="image-20221028180406208.png" alt="image-20221028180406208"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Distributed Algorithm - Partially ordered set and lattice - and applications in Distributed System</title>
      <link href="/20221027-Distrigute_Algorithm_setandlattice/"/>
      <url>/20221027-Distrigute_Algorithm_setandlattice/</url>
      
        <content type="html"><![CDATA[<p>Outline</p><ul><li><p>Partially Ordered Set</p></li><li><p>Lattice</p></li><li><p>Boolean Algebra</p></li><li><p>Global Snapshot Lattice</p></li><li><p>Consistency Model Lattice</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10-27 所想</title>
      <link href="/20221027-daily/"/>
      <url>/20221027-daily/</url>
      
        <content type="html"><![CDATA[<p>最近好像变得很有时间写这一类东西了。。也不是，就是想起来了。倾诉的欲望正在高涨，然而翻翻好友列表，却不会有合适的人选。这到底是因为什么呢？</p><p>昨天实在是忍不了了，在小群里打了个QQ电话，稍微交流了一下。但是作用也不大，因为想要说的不是完全没能说出去嘛。</p><p>最近白学病又犯了，起初好像是为了探寻一下春希作为一个工作狂，到底是为什么能一直不累、一直有动力的。然后又想要借此机会了解一下千晶线。But 在推完了千晶 NE 之后，我的内心实在是不能平静，催促着我去把千晶 TE 也看一看。这下就又花了大把的时间了，昨天晚上一直玩到28点半。。嗯。。。</p><p>其实本来是想集中处理千晶线的，谁知道中间碰到了一个有趣的二连选项。我就是好奇了一下，在这种情况下，我都选一遍的话会发生什么事。</p><p>所以还是进了一次小春线。</p><p>回到千晶，我推到了千晶和雪菜以真是身份友好交流的那一部分。当下的我认为，千晶至少对于春希是一个迷人的女性。但站在玩家的上帝视角来说，并不容易自然地接受这样的一个角色。春希是善良的，出了什么问题都会认为是自己的责任，但我不是。如果我是当事人，也许我。。。就不了了之了。但我是玩家，我很想看看丸户会怎么把春希的情感裂缝给缝合上。</p><p>要上课了，一会儿再回来写。。</p><p>说是这样，其实一整节课都睡过去了呢。。。睡得太少，精神太差。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>行动起来</title>
      <link href="/20221025-Daily/"/>
      <url>/20221025-Daily/</url>
      
        <content type="html"><![CDATA[<p>看了一节数据库系统和一节分布式。今天总算是没有浪费时间。</p><p>接下来要把 MapReduce 理解好，并且做了实验才行。</p><p>虽然我不是党员，但是二十大开完之后我的精神依然为之一振。今年习总应该是69岁，依然奋斗在重要的岗位上。并且从常委的名单来看，接下来的五年将会是剧变的五年。</p><p>那么，就更不能懈怠了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction (MIT 6.824)</title>
      <link href="/20221025-Introduction%20(MIT%206.824)/"/>
      <url>/20221025-Introduction%20(MIT%206.824)/</url>
      
        <content type="html"><![CDATA[<p>Why?</p><p>parallelism</p><p>fault tolerance</p><p>physical reasons</p><p>security goals &#x2F; isolated</p><p><strong>challenges</strong></p><ul><li><p>concurrency</p></li><li><p>partial failure</p></li><li><p>performance</p></li></ul><p>Infrastructure - Abstractions</p><ul><li>Storage</li><li>Communication   more: 6.829</li><li>Computation</li></ul><p>Implementation</p><ul><li>RPC, threads, concurrency control</li></ul><p>Performance</p><p>scalability</p><ul><li>2x computers -&gt; 2x throughput</li></ul><p>Fault Tolerance</p><p>Single Computer can stay up for years</p><p>Scale turns small problem into constant problems. There’s always failures</p><ul><li>Availability<ul><li>keep operating while failure happens</li></ul></li><li>Recoverability</li></ul><p>Consistency</p><p>K-V db</p><p> Put(k, v)  Get(k)-&gt;v</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>consider: word count</p><p>INPUT 1 -&gt; Map -&gt; (a, 1), (b, 1)</p><p>INPUT 2 -&gt; Map -&gt; (b, 1)</p><p>INPUT 3 -&gt; Map -&gt; (a, 1), (c, 1)</p><p>(a, 1), (a, 1) -&gt; Reduce -&gt; a, 2</p><p>…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map(k, v)</span><br><span class="line">  split v into words</span><br><span class="line">  for each word w</span><br><span class="line">  emit(w, &quot;1&quot;)</span><br><span class="line">Reduce(k, v)</span><br><span class="line">  emit(len(v))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Database Storage I (CMU Databases Systems Fall 2019)</title>
      <link href="/20221024-DatabseStorage/"/>
      <url>/20221024-DatabseStorage/</url>
      
        <content type="html"><![CDATA[<p>Query Planning</p><p>Operator Execution</p><p>access Methods</p><p>Buffer Pool Manager</p><p>Disk Manager</p><p>The DBMS’s assumes that the primary storage location of the database is on non-volatile disk.</p><p>The DBMS’s components manage the movement of data between non-volatile and volatile storage.</p><p>Storage hierarchy</p><ul><li>cpu registers</li><li>cpu caches </li><li>dram   &#x2F;&#x2F; Volatile: need contant power</li><li>ssd   &#x2F;&#x2F; Non-Volatile  </li><li>hdd</li><li>network storage</li></ul><p>Intel Optane : Non-Volatile Memory</p><ul><li>Is the future</li><li>not widely available</li></ul><p>System Design Goals</p><p>Allow the DBMS to manage databases that exceed the amount of memory available.</p><p>Reading&#x2F;writing to disk is expansive, so it must be managed carefully to avoid large stall and performance degradation.</p><p>Why not use the os? </p><ul><li>One can use memory mapping(mmap) to store the contents of a file into a  process’ address space</li><li>The OS is responsible for moving data for moving the files’ pages in and out of memory</li></ul><p>What if we allow multiple threads to access the mmap files to hide page fault stalls?</p><p>This works good enough for read-only address. It is complicated when there are multiple writers.</p><p>There are some solutions to this problem:</p><p>madvise: Tell the os how you expect to read certain pages</p><p>mlock: tell the os that memory ranges cannot be paged out</p><p>msync: tell the os to flush memory ranges out to disk</p><p>DBMS (almost) always wants to control things itself and can do a better job at it</p><p>-&gt; flushing dirty pages to disk in the correct order</p><p>-&gt; specialized prefetching</p><p>-&gt; Buffer replacement policy</p><p>-&gt; thread&#x2F;process scheduling</p><p>The OS is <strong>NOT</strong> your friend</p><p>Problem #1: How the DBMS represents the database in files on disk.  &lt;– this lecture</p><p>Problem #2: How the DBMS manages its memory and move back-and-forth from disk</p><h2 id="TODAY’S-AGENDA"><a href="#TODAY’S-AGENDA" class="headerlink" title="TODAY’S AGENDA"></a>TODAY’S AGENDA</h2><p>File Storage</p><p>Page Layout</p><p>Tuple Layout</p><p>The DBMS stores a database as one or more files on disk.</p><ul><li>The OS doesn’t know anything about the contents of these files.</li></ul><p>Different DBMS manage pages in files on disk in different ways</p><ul><li>Heap file organization</li></ul><p>A heap file is an unordered collection of pages where tuples that are stored in random order</p><ul><li>Create&#x2F;Get&#x2F;Write&#x2F;Delete Page</li><li>Must also support iterating over all pages</li></ul><p>Need meta-data to keep track of what pages exist and which ones have free space.</p><ul><li>Linked List</li><li>Page Directory</li></ul><p>The DBMS maintains special pages that tracks the location of data pages in the database files.</p><p>The directory also records the number of free slots per page.</p><p>The DBMS has to make sure that the directory pages are in sync with the data pages.</p><p>Page Layout</p><p>![](20221024-DatabseStorage.assets&#x2F;屏幕截图 2022-10-25 150909.png)</p><p>Tuple Layout</p><p>![](20221024-DatabseStorage.assets&#x2F;屏幕截图 2022-10-25 151039.png)</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Transaction Information System - Chapter 01</title>
      <link href="/20221010-txn-chapter1/"/>
      <url>/20221010-txn-chapter1/</url>
      
        <content type="html"><![CDATA[<p>Foreword</p><p>This book unifies <strong>concurrency control</strong> and <strong>recovery for both the page and object models</strong></p><p>It is likely to become the standard reference in out field for many years to come.</p><p>Preface</p><blockquote><p>Teamwork is essential. It allows you to blame someone else.  –Anonymous (kusa)</p></blockquote><p>Book’s Mission</p><p>For 3 decades transaction procession has been a cornerstone of modern information technology: it is an indispensable asset in banking, stock trading, airlines, travel agencies, and so on.</p><p>Fortunately, the success of the transaction concept does not solely rely on clever system inplementations, but builds on and leverages scientifically rigorous foundations that have been developed in the research community.</p><p>For above reason this book emphasizes scientific fundamentals of long-term validity and value, and does not cover specific system products, which tend to become quickly outdated.</p><h5 id="Organizations"><a href="#Organizations" class="headerlink" title="Organizations"></a>Organizations</h5><p>The two key components of a transaction information system are <strong>concurrency control</strong>, to ensure the correctness of data when many clients simultaneously access shared data, and <strong>recovery</strong>, to protect the data against system failures.</p><p>In addition, the <em>coordination of distributed transactions</em> becomes a vital issue that will be covered in Part IV.</p><h1 id="Chapter-1-What-Is-It-All-About"><a href="#Chapter-1-What-Is-It-All-About" class="headerlink" title="Chapter 1. What Is It All About?"></a>Chapter 1. What Is It All About?</h1><blockquote><p>If I had had more time, I could have written you a shorter letter.</p></blockquote><blockquote><p>There are two mistakes one can make along the road to truth–not going all the way, and not starting. –Buddha</p></blockquote><ul><li>Why transactions are a good idea</li><li>Why transactions form a reasonable abstraction concept for certain classes of real-life data management and related problems</li><li>What can and what cannot be done with the transaction concept</li></ul><p><em>Online transaction processing, OLTP</em></p><p>The key problem that the transaction concept solves in a very elegant way is to cope tith the subtle and often difficult issues of keeping data consistent even in the presence of highly cuncurrent data accesses and despite all sorts of failures.</p><p>An additional key property of transactions is that this is achieved in a generic way that is essentially invisible to the application logic (and to application development), so that application developers are completely freed from the burden of dealing ith such system issues. This is why transactions are an <em>abstract concept</em>, and why this concept is a cornerstone of modern information technology.</p><p>Database System is the most important concrete instantiation of a transactional data server.</p><p>Conceptual properties of a transaction–namely, atomicity, durability, and isolation–together provide the key abstraction that allows application developers to disregard concurrency and failures, yet the transactional server guarantees the consistency of the underlying data and ultimately the correctness of the application.</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Advanced SQL (CMU Databases Systems Fall 2019)</title>
      <link href="/20220925-AdvancedSQL/"/>
      <url>/20220925-AdvancedSQL/</url>
      
        <content type="html"><![CDATA[<p>Relational Languages</p><ul><li>User only needs to specify the answer that they want, not how to compute it.</li><li>The DBMS is responsible for efficient evaluation of the query.<ul><li>Query optimizer: re-orders operations and generates query plan</li></ul></li></ul><p>Originally SEQUEL from IBM’s System R prototype</p><ul><li>Structured English Query Language</li></ul><p>IBM releases DB2 in 1983</p><p>ANSI Standard in 1986. ISO in 1987</p><ul><li>Structured Query Language</li></ul><p>Important: SQL is base on bags (duplicates)</p><p>Aggregations + Group By</p><p>String &#x2F; Date &#x2F; Time Operations</p><p>Output Control + Redirection</p><p>Nested Queries</p><p>Common Table Expressions</p><p>Window Functions</p><p>Aggregates</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVG</span>(col)</span><br><span class="line"><span class="built_in">MIN</span>(col)</span><br><span class="line"><span class="built_in">MAX</span>(col)</span><br><span class="line"><span class="built_in">SUM</span>(col)</span><br><span class="line"><span class="built_in">COUNT</span>(col)</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(login) <span class="keyword">as</span> cnt</span><br><span class="line">  <span class="keyword">from</span> student <span class="keyword">where</span> login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="operator">/</span><span class="operator">/</span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> cnt</span><br><span class="line">  <span class="keyword">from</span> student whare login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line">  </span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line">  <span class="keyword">from</span> student whare login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(s.gpa), e.cid</span><br><span class="line">  <span class="keyword">from</span> enrolled <span class="keyword">as</span> e, student <span class="keyword">as</span> s</span><br><span class="line"> <span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> e.cid</span><br></pre></td></tr></table></figure><p>Non-aggregated values in SELECT output clause must appear in GROUP BY clause</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">not</span> aggr<span class="string">&#x27;d yet</span></span><br><span class="line"><span class="string">select avg(s.gpa) as avg_gpa, e.cid</span></span><br><span class="line"><span class="string">from enrolled as e, student as s</span></span><br><span class="line"><span class="string">where e.sid = sid</span></span><br><span class="line"><span class="string">and avg_gpa &gt; 3.9</span></span><br><span class="line"><span class="string">group by e.cid</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># right</span></span><br><span class="line"><span class="string">select avg(s.gpa) as avg_gpa, e.cid</span></span><br><span class="line"><span class="string">from enrolled as e, student as s</span></span><br><span class="line"><span class="string">where e.sid = sid</span></span><br><span class="line"><span class="string">group by e.cid</span></span><br><span class="line"><span class="string">having avg_gpa &gt; 3.9</span></span><br></pre></td></tr></table></figure><p>Strings</p><p>all strings have to be case sensitive and declared with single quotes ‘’</p><p>sqlite: “” is ok </p><p>mysql is case insensitive</p><p>Like is used for stirng matching.String-matching operators</p><ul><li>‘%’ Matches any substring (including empty strings.)</li><li>‘_’ Match any one character</li></ul><p>SQL-92 defines string functins</p><ul><li>Many DBMSs also have theri onw unique functions</li></ul><p>Can be used ineither output and predicxates</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBSTRING(name, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">UPPER</span>(e.name)</span><br></pre></td></tr></table></figure><p>SQL standartd says to use || operator to concatenate two or ,more stirng together.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;an&#x27; &#x27;dy &#x27; &#x27;pavlo&#x27;;</span><br><span class="line">&gt; andy pavlo  # only mysql</span><br></pre></td></tr></table></figure><p>Date &#x2F; Time operations</p><ul><li>operations to manipulate and mudify date &#x2F; time attributes.</li><li>Can be used in either output and predicates</li><li>Spport &#x2F; syntax varies wildly…</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select NOW();  # current timestamp</span><br><span class="line">select current_timestamp();</span><br><span class="line">select current_timestamp;</span><br></pre></td></tr></table></figure><p>sqlite: no such function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select current_timestamp;  # keyword</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> extract <span class="keyword">day</span>(<span class="keyword">day</span> <span class="keyword">from</span> <span class="type">date</span>(‘<span class="number">2018</span><span class="number">-08</span><span class="number">-29</span><span class="string">&#x27;));  # only pavlo</span></span><br><span class="line"><span class="string">select date(&#x27;</span><span class="number">2919</span><span class="number">-08</span><span class="number">-29</span><span class="string">&#x27;) - date(&#x27;</span><span class="number">2018</span><span class="number">-01</span><span class="number">-01</span><span class="string">&#x27;) as days;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">select round((unix_timestamp(date()) - unix_timestamp(date())) / (60 * 60 * 24), 0) as days</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sqlite</span><br><span class="line">select cast((julianday(current_timestamp) - julianday(&#x27;2018-01-01&#x27;)) as int) as days;</span><br></pre></td></tr></table></figure><p>!!! but sqlite is the most popular</p><p>Photoshop runs sqlite inside</p><p>cause there is no copyright on sqlite. But oracle has mysql</p><p>Output redirection</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">into</span> courseids</span><br><span class="line">  <span class="keyword">from</span> enrolled;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> courseids (</span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> enrolled);</span><br></pre></td></tr></table></figure><p>Don’t take it out for me. Write it to this table.</p><p>Insert tuplesfrom query into another table:</p><ul><li>Inner select must generatge the same columns as the target table.</li><li>dbmss have different options &#x2F; syntax on what to do with duplicates.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> courseids</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> enrolled);</span><br></pre></td></tr></table></figure><p>(implements will vary widely)</p><p>Output control</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, grade <span class="keyword">from</span> enrolled</span><br><span class="line">  <span class="keyword">where</span> cid <span class="operator">=</span> <span class="string">&#x27;15-721&#x27;</span></span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> grade;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line"> whhere cid <span class="operator">=</span> <span class="string">&#x27;15-721&#x27;</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> grade <span class="keyword">desc</span>, sid <span class="keyword">asc</span>;   # grade <span class="keyword">not</span> <span class="keyword">in</span> input but OK</span><br></pre></td></tr></table></figure><p>LIMIT <count> [offset]</count></p><ul><li>limit the # of tuples returned in output.</li><li>can set an offset rto return a “range”</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line"> limit <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line"> limit <span class="number">20</span> <span class="keyword">offset</span> <span class="number">10</span>;    # pagination</span><br></pre></td></tr></table></figure><p>Nested queries</p><ul><li>Queries containing other queries</li><li>They are often difficult to optimize.</li><li>Inner queries can appear (almost)anywhere in query.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> student <span class="keyword">where</span></span><br><span class="line"> sid <span class="keyword">in</span> (<span class="keyword">select</span> sid <span class="keyword">from</span> enrolled);</span><br></pre></td></tr></table></figure><p>WHERE</p><ul><li><p>ALL</p></li><li><p>ANY</p></li><li><p>IN</p></li><li><p>EXISTS</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> student </span><br><span class="line">whiere sid <span class="operator">=</span> <span class="keyword">any</span>(</span><br><span class="line"><span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line"><span class="keyword">where</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> s.name <span class="keyword">from</span> stucent <span class="keyword">as</span> s</span><br><span class="line">         <span class="keyword">where</span> s.sid <span class="operator">=</span> e.sid) <span class="keyword">as</span> sname</span><br><span class="line">  <span class="keyword">from</span> enrolled <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">where</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> sid <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">all</span>(</span><br><span class="line">  <span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line">);</span><br><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> sid <span class="keyword">in</span> (</span><br><span class="line">  <span class="keyword">select</span> <span class="built_in">max</span>(sid) <span class="keyword">from</span> enrolled</span><br><span class="line">);</span><br><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> sid <span class="keyword">in</span> (</span><br><span class="line">  <span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span> sid <span class="keyword">desc</span> limit <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>find all coursed that has no students enrolled in it.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> enrolled</span><br><span class="line">  <span class="keyword">where</span> course.cid <span class="operator">=</span> enrolled.cid</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>window functions</p><ul><li>Performs a calculation across a set of tuples that related to a single row.</li><li>Like an aggregation but tuples are not grouped into a single output tuples.</li></ul><p>Special window functions:</p><ul><li>row_number() -&gt; # of the current row</li><li>rank() -&gt; order position of the current row</li></ul><p>The over keyword specifies how to group together tuples when computing the window function.</p><p>Use partition by to specify group</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select cid, sid,</span><br><span class="line">  row_number() over (partition by sid)</span><br><span class="line"> from enrolled</span><br><span class="line">order by cid;</span><br></pre></td></tr></table></figure><p>Find the student with the highest grade fro each course.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid</span><br><span class="line">                <span class="keyword">order</span> bygrace <span class="keyword">asc</span>)</span><br><span class="line">    <span class="keyword">as</span> rank</span><br><span class="line">   <span class="keyword">from</span> enrolled) <span class="keyword">as</span> ranking</span><br><span class="line"><span class="keyword">where</span> ranking.rank <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>postgres is the only one supports.</p><p>Common table expressions</p><ul><li>provides a way to write auxiliary statements for use in a larger query.<ul><li>think of it like a temp table just for one query.</li></ul></li></ul><p>Alternative to nested queries and views.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ctename (col1, col2) <span class="keyword">as</span> (</span><br><span class="line"> <span class="keyword">select</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> col1 <span class="operator">+</span> col2 <span class="keyword">from</span> ctename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ctesource (maxid) <span class="keyword">as</span> (</span><br><span class="line"> <span class="keyword">select</span> <span class="built_in">max</span>(sid) <span class="keyword">from</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> student, ctesource</span><br><span class="line"> <span class="keyword">where</span> student.sid <span class="operator">=</span> ctesource.max;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># recursion</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> ctesource (counter) <span class="keyword">as</span> (</span><br><span class="line"> (<span class="keyword">select</span> <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"> (<span class="keyword">select</span> counter <span class="operator">+</span> <span class="number">1</span> <span class="keyword">from</span> ctesource</span><br><span class="line">   <span class="keyword">where</span> counter <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ctesource;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Course Introduction Relational Model (CMU Databases Systems Fall 2019)</title>
      <link href="/20220925-DBsystem/"/>
      <url>/20220925-DBsystem/</url>
      
        <content type="html"><![CDATA[<p>TEXTBOOK: Database System Comcepts 7th Edition</p><p>Silberschatz, Korth, &amp; Sudarshan</p><p>Database:</p><ul><li>Organized collextion of inter-related data that models some aspect of the real-world</li></ul><p>E.g. Create a database that models a digital music store to keep track of artists and albums</p><p>Store our database as comma-separated value (CSV) files that we manage in out own code.</p><ul><li>Use a separate file per entity.</li><li>The application has to parse the files each time they want to read &#x2F; update records</li></ul><p>Artist(name, year, country) Album(name, artist ,year)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file</span><br><span class="line">  record = parse(line)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;Ice Cube&quot;</span> == record[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">print</span> <span class="built_in">int</span>(record(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>Flat files: data integrity</p><ul><li>How do we ensure that the artist is the same for each album entry?</li><li>What if somebody overwrites the album year with an invalid string?</li><li>How do we store that there are multiple artists on an album?<ul><li>array or string?</li></ul></li><li>How do you find a particular record?<ul><li>three lines pretty fast</li><li>a Billion?</li></ul></li><li>What if we now want to create a new application that uses the same database?</li><li>What if two threads try to write to the same file at the same time?<ul><li>first writes something, and second overwrites</li></ul></li><li>What if the machine crashes while our program is updating a record?</li><li>What if we want to replicate the database on multiple machines for high availabiility?</li></ul><p>DBMS is software that allows applications to store and analyze information in a database.</p><p>A general-purpose DBMS is designed to allow the definition, creation, querying, update, and administration of databases.</p><ul><li>reuse</li><li>no reinventing wheels</li></ul><p>There’s no courses bout browsers, but there is course about DB.</p><p>So it’s a kind of special software.</p><p>Early DBMSs</p><ul><li>Database application were difficult to build and maintain.</li><li>Tight coupling between logical and physical layers.</li><li>You have to (roughly) know what queries your app would execute before you deployed the database.</li></ul><p>Ted Cotton: people are wasting time write DBMS again and again.</p><p>Database abstraction to avoid this maintenance:</p><ul><li>Store database in simple data structures</li><li>Access data through high-level language.</li><li>Physical storage left up to implementation.</li></ul><p>Noway software can never produce query.</p><p>Physical storage of data is transparent to applications.</p><p>Data Models</p><ul><li>A data model is collecition of concepts for describing the data in a databasde.</li><li>A schema is a description of a particular  colection of data, using a given data model.</li></ul><p>Data Model</p><ul><li>Relational  &lt;- SQL</li><li>Key&#x2F;Value  &lt;- NoSQL</li><li>Graph</li><li>Document</li><li>Column-family</li><li>Array&#x2F;Matrix  &lt;- Machine Learning</li><li>Hierarchical &lt;- Obsolete &#x2F; Rare</li><li>Network</li></ul><p>Relational Mods</p><ul><li>Structure: The definition of relations and their contents.</li><li>Integrity: Ensure the database’s contents satisfy constraints.</li><li>Manipulation: how to access and modify a database’s contents.</li></ul><p>A relation is unordered set that contain the relation ship of attributes that represent entities</p><p>A tuple is a set of atribute values (also known as its domain) in the relation.</p><ul><li>Values are (normally) atomic &#x2F; scalar.</li><li>The special value NULL is a member of every domain.</li></ul><p>A relation’s primary key uniquely identifies a single typle.</p><p>Some DBMSs automatically create an internal primarykley if you don’t define one.</p><p>A foreign key specifils that an attrebute from one relation has to map to a tyuple in another relation.</p><ul><li>Album -&gt; Multiple Artists</li><li>a separate cross reference table ArtistAlbum(artist_id, album_id), both are foreign keys.</li></ul><p>The relational model is independent of any query language implementation.</p><p>SQL is the <em>de facto</em> standard.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span> <span class="keyword">FROM</span> artists</span><br><span class="line">  <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Ice Cuve&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Distributed Algorithm - syllabus</title>
      <link href="/20220922-Distributed_Algorithm_syllabus/"/>
      <url>/20220922-Distributed_Algorithm_syllabus/</url>
      
        <content type="html"><![CDATA[<p>Syllabus</p><p>从基础问题到研究问题，到系统和工具</p><ul><li><p>Model of computation</p><ul><li>Different dimensions in defining a computation model</li></ul></li><li><p>Basic problems</p><ul><li>Basic message-passing algorithms</li><li>Leader election in rings</li><li>Mutual exclusion in shared memory</li><li>Fault-tolerant consensus</li></ul></li><li><p>Research problems</p><ul><li>Distributed algorithms<ul><li>Consensus algorithms: Paxos, Raft, Zab</li><li>Specificaiton, verification, testing</li></ul></li></ul></li><li><p>From algorithms to systems</p><ul><li>Data replication: TPaxos, ParallelRaft (Ali PolarDB)</li><li>Coordination service: Zookeeper (Apache)</li><li>…</li></ul></li></ul><p>Outline</p><ul><li><p>Distrubuted Algorithms (DAs)</p><ul><li>Fundamental concepts</li></ul></li><li><p>Model of computation</p><ul><li>Basic idea</li><li>RAM model for sequential algorithms</li></ul></li><li><p>Model of computationsfor DAs</p><ul><li>Communication medium, Timing model</li><li>Failure model, progress condition</li><li>Correctness condition: specification of the problem</li><li>Simulation among models</li></ul></li><li><p>Algorithms</p><ul><li>Abstract: designed over an abstract machine (the model of computation)</li><li>Formal: rigid mathematical treatments</li></ul></li><li><p>Distributed algotrithms</p><ul><li>Model of distributed computation</li><li>Mathematical proofs, analysis, …</li><li>In relation to other concepts<ul><li>Distributed conputing theory</li><li>Distributed systems</li></ul></li></ul></li></ul><p>Computing and Computer</p><ul><li><p>The computer seems to be able to do anything</p></li><li><p>But something cannot be efficiently done by a computer</p></li><li><p>Computing</p><ul><li>Encoding everything into ‘0’s and ‘1’s</li><li>Operations over ‘1’s and ‘0’s</li><li>Decoding the ‘1’s and ‘0’s</li></ul></li><li><p>Computer</p><ul><li>A set of operations it can do<ul><li>Limited operations, unlimited combinations</li></ul></li><li>Perform specified operations<ul><li>Quickly, inexhaustibly, with no intelligence</li></ul></li></ul></li></ul><p>计算机只能做简单重复的事情。</p><p>Algorithm</p><ul><li><p>Algorithm is the spirit of computing</p><ul><li>To solve a specific problem (so called an algorithmic problem)</li><li>Combination of basic operations<ul><li>in a precise and elegant way</li></ul></li></ul></li><li><p>Essential issues</p><ul><li>Model of computation</li><li>Algorithm design</li><li>Algorithm analysis</li></ul></li></ul><p>Model of Computation</p><ul><li><p>Problem 1</p><ul><li>Why the algorithms we learn can run almost everywhere?</li></ul></li><li><p>Problem 2</p><ul><li>Why the algorithms we learn can be implemented in any language?</li></ul></li><li><p>Machine-independent algorithms run on an abstract machine</p><ul><li>Turing machine: over-qualify</li><li>RAM model: simple but powerful</li></ul></li></ul><p>Turing Machine</p><ul><li><p>Tape in</p><ul><li>Encoding the input</li></ul></li><li><p>Tape out</p><ul><li>Recording the output</li></ul></li><li><p>Control of the read-write head</p><ul><li>Operations the machine can do</li></ul></li></ul><p>RAM Model</p><ul><li><p>Each simple operation takes one time step</p><ul><li>E.g., key comparison, +&#x2F;-, memory access, …</li></ul></li><li><p>Complex operations shoule be decomposed</p><ul><li>Loop, Subroutine</li></ul></li><li><p>Memory</p><ul><li>Memory access is a simple operation</li><li>Unlimited memory</li></ul></li></ul><p>Model of Computation for DAs</p><p>Communicaion medium: message passing &amp; shared memory</p><p>Progess method: synchronous &amp; asynchronous</p><p>Why one model can’t cover DA?</p><ul><li><p>Single serialized machine: low complexity to cover</p></li><li><p>Distributed systems vary</p></li></ul><p>Message-passing Model</p><ul><li><p>Processors</p><ul><li>p_0, p_1, …, p_n-1 are nodes of the graph</li><li>Each modeled as a state machine</li></ul></li><li><p>Channel from p_i to p_j</p><ul><li>outbuf variable of p_i (physical channel)</li><li>inbuf variable of p_j (incoming message queue)</li></ul></li></ul><p>Comfiguraition of the System</p><ul><li><p>A snapshot of the entire system</p><ul><li>Processor states</li><li>Channels states</li></ul></li><li><p>Formally, a vector of </p><ul><li>Local variables</li><li>Incoming message queues</li><li>outbufs</li></ul></li></ul><p>Event: Delivery (送达)</p><ul><li>Moves a message from sender’s outbuf to receiver’s inbuf<ul><li>Message will be abailable next time receiver takes a step</li></ul></li></ul><p>Event: Computation</p><ul><li><p>Start with old accessible state</p><ul><li>Local vars + incoming messages</li></ul></li><li><p>Apply the state machine transition function</p><ul><li>Handle all incoming messages</li></ul></li><li><p>End with new accessible state</p><ul><li>Empty inbufs</li><li>New outgoing messages</li></ul></li></ul><p>Asynchronous Execution</p><ul><li><p>System execution</p><ul><li>&lt;config, event, config, event, config, …&gt;</li></ul></li><li><p>Initial configuration</p><ul><li>Esch processor is in its initial state</li><li>All inbufs are empty</li></ul></li><li><p>System progress</p><ul><li>&lt;config_old, event, config_new&gt;<ul><li>config_new is the same as config_old except:<ul><li>a) if delivery (msgReceive) event<ul><li>Spedified msg is transgerred from sender’s outbur to receiver’s inbuf</li></ul></li><li>b) if computation event<ul><li>Specified processor’s state (including outbufs) change according to transition function</li></ul></li></ul></li></ul></li></ul></li><li><p>An execution is admissible in a (reliable) asynchronous model if</p><ul><li>Every message in an outbuf is eventually delivered</li><li>Every processor takes an infinite number of steps</li><li>No constraints on when these events take place<ul><li>Arbitrary message delays</li><li>Relative processor speeds</li></ul></li></ul></li><li><p>Reliability lies in that</p><ul><li>No message is lost</li><li>No processor stops working</li></ul></li></ul><p>Complexity Measures</p><ul><li>Message complexity (发多少消息才能完成这件事)<ul><li>Maximum number of messages sent in any admissible execution</li></ul></li><li>Time complexity<ul><li>Maximum “time” until all processes terminalte in any admissible execution</li><li>How to measure time in an asynchronous execurion?<ul><li>Produce a timed execution by assigning non-decreading real times to events so that time between sengding and receiving any message is at most  1.</li><li>Time complexity: maximum time until termination in any timed admissible execution.</li></ul></li></ul></li></ul><p>Synchronous Executions</p><ul><li>Admissible execution<ul><li>An infinite sequence of rounds<ul><li>A round is a sequence of deliver events moving all messages in transit into inbufs, followed by a sequence of computation events, one for each processor</li></ul></li><li>Progress in lockstep<ul><li>Every message sent is delivered</li><li>Every processor takes an infinite number of steps</li></ul></li></ul></li><li>Time complexity<ul><li>The number of rounds until termination</li></ul></li></ul><p>Shared Memory Model</p><ul><li>Processors communicate via a set of shared variables (also called shared registers)<ul><li>Each shared variable has a type, defining a set of primitive operations (performed atomiacally)</li></ul></li><li>Shared variables<ul><li>read, write</li><li>compare &amp; swap (CAS)</li><li>read-modify-write (RMW)</li></ul></li></ul><p>Execution</p><ul><li><p>Configuration</p><p>(q0, q1, …, qn-1, r0, r1, …, rm-1)</p><p> process states      shared variables</p></li><li><p>Events</p><ul><li>Computation steps taken by the process</li><li>At each computation step, the shared variable is accessed</li></ul></li><li><p>Admissible execution</p><ul><li>An execution is admissible if evety processor takes infinite number of steps</li></ul></li><li><p>Shared variable access</p><ul><li><p>At each computation step by p_i, the following happen atomically:</p><p>a) p_i chooses a ashared variable to access with a specific operation, based on p_i’s current state;</p><p>b) The specified operation is performed on the shared variable;</p><p>c) p_i’s state changes according to p_i’s transition function, based on p_i’s current state and the value the shared memory operation performed.</p></li></ul></li></ul><p>Complexity Measures</p><ul><li>Shared variables<ul><li>Number of distinct shared variables required</li></ul></li><li>Shared space<ul><li>Amount of shared space</li><li>E.g, # of bits, # of distinct values, …</li></ul></li></ul><p>Changes from the MSG Model</p><ul><li>Communication medium changes<ul><li>No inbuf and outbuf state components</li><li>Configuration includes values for shared variables</li></ul></li><li>Execution manner changes<ul><li>One event type: one computation step by a process<ul><li>p_i’s state in old configuration specifies whith shared variable is to be accessed and with which primitive</li><li>shared variable’s value in the new configuration changes according to the primitive’s semantics</li><li>p_i’s state in the new configuration changes according to its old state and the result of the primitive</li></ul></li></ul></li></ul><p>Google: data center as a computer</p><p>Correctness Condition</p><ul><li>How to specify an algorithmic problem?<ul><li>E.g., GCD(Euclid), Sorting</li></ul></li><li>How to speicify a distributed-algorithmic problem?<ul><li>A reactive system</li><li>Safety</li><li>Liveness</li></ul></li></ul><p>DAs are always running.</p><p>不同模型可以互相模拟</p><p>Simulation among MoCs</p><ul><li>Example 1: Synchronizer<ul><li>Illusion of synchronous rounds</li><li>Over asynchronous communication</li></ul></li><li>2: Distributed Shared Memory (DSM)<ul><li>Illusion of a shared memory</li><li>Over message passing</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>克服焦虑 - 慢慢改</title>
      <link href="/20220911-rest/"/>
      <url>/20220911-rest/</url>
      
        <content type="html"><![CDATA[<p>现在是白天。</p><p>之前没有仔细想。生活状态的转换应该还是要慢慢来？很多要求就一个个去满足就好了。比如先把作息和饮食调整好，再想训练的事。一开始不用一下子全都做好。</p><p>也许，把桌面收拾好，慢慢保持住；把衣柜整理整理。都是值得做出的改变。</p><p>随便摘一首诗</p><p>西江月·井冈山</p><p>山下旌旗在望，三头鼓角相闻。敌军围困千万重，我自岿然不动。</p><p>早已森严壁垒，更加众志成城。黄洋界上炮声隆，报道敌军霄遁。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>焦虑</title>
      <link href="/20220911-postmidAutumn/"/>
      <url>/20220911-postmidAutumn/</url>
      
        <content type="html"><![CDATA[<p>中秋节后夜。</p><p>如同我自己感觉到的，每到此时，心中便会生出焦虑，仿佛这一天仍有未尽之事宜。实际上原本就没有做安排。正因为任务模糊不清，而整日又无所事事，才产生了如此的心情。</p><p>我自己分明是有事可做的，且</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>答问：随着时间我会释怀吗？</title>
      <link href="/20220407-relief/"/>
      <url>/20220407-relief/</url>
      
        <content type="html"><![CDATA[<p>让人释怀的，并不是时间。</p><p>借用别人的理解，释怀就是：对过去的事，不再怀念；对离开的人，不再纠缠；对做不到的，不再自责；对得不到的，不再留恋。</p><p>我的总结就是：得过且过，放过自己。</p><p>以我的这种解法，每一次“释怀”，都一定会在心里打一个疙瘩。它一点也不痛，我很少为之烦恼。只是有一点点，一点点膈应罢了。偶尔会想，“要是这件事的结果好一点，那我的人生就变得更完美了”。但是也并不极力追求完美。就像是身上长了一个不痛不痒的疙瘩，虽然没感觉，但是时不时地就想去摸两下，然后就作罢了。偶尔也在想，就算这些疙瘩当初没产生，也必然会有别的什么新的问题…</p><p>对于我而言，比较激烈的情绪没有隔夜的。一个让我难受的想法想了一周之后也就烦了。我是一个热爱现实的人，我愿意把精力更多地放在自己的能力范围之内，而不是空耗在自己所不能触及的地方。我谈政治，学哲学，但最多的还是想今天吃什么，做什么，与他人进行何种交流。当把精力放在自己能够触及的地方，便觉得世界是具体的可把握的；当精力放在够不到的地方，则只能看到虚假的世界中无力的自己。在时空上已经远离我们的那些人和事，本应对我们很难造成实际的影响，而我们却很容易高估了他们。</p><p>把握好自己能把握的领域，是唯一的出路。过多地把精力放在那些已经离你远去的人和事上，不管过了多长时间，都不会释怀，并且会非常受挫。</p><p>初中喜欢了3年的女生，我们之间发生过很多矛盾（我犯的错），然后又在一段时间的冷静后，我们能够正常地做朋友——当然现在也是像普通朋友一样渐行渐远。我无数次好奇她最后对我到底是什么样的看法，但始终没有发消息去问。现在我只是不时看一看她的朋友圈，就像是身上哪里长了一个不痛不痒的疙瘩，时不时就想起来摸一摸。</p><p>高中曾有其他学校的女生向我敞开怀抱，并且还是两次，我沉溺于这种暧昧的感觉，每一次都接受了。我对她是喜欢的，但也非常混蛋。我不敢相信，就像是永尾完治遇上赤名莉香，对于女生的主动，反而无所适从，并且怀疑对方对自己的感情。也很多次想要向她确证。但有两个完全相反的想法共同阻拦着我：一方面认为这样优秀、人际关系良好的女生根本不可能喜欢上我；另一方面认为她明明是在明示我，如果我再去问会显得很蠢，说不定还会让她生气。我逃避了，我与其他人恋爱，我错过了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于三界的描述</title>
      <link href="/20220304-cite/"/>
      <url>/20220304-cite/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知道是从哪里抄的</p></blockquote><p>象征界与想象界甚至可以说是作为实在界的马赛克而存在的。主体通过象征界与想象界而无需直接面对实在界。实在界本身喻示了语言的无力、欲望的虚假等等诸多“真实”。主体无法控制自身的一切，自我是被捏造的虚假存在，一切的最终都是毫无意义的。</p><p>作为欲望与焦虑的小客体a</p><p>把他者的欲望看作是自己的欲望终究只是主体的欲望的幻象。其在主体身上引发的与其说是欲望的满足，不如说是焦虑，因为那个作为欲望之原因的小a根本上是一个欠缺，是主体实在界打开的一个空洞……我们总是以他者的欲望来规定自己的欲望，总之，我们的欲望并非我们自己的，而是在他者中且通过他者被结构的。可是，他者究竟欲望什么？主体对此完全不知，他者的欲望之谜令主体焦虑不已，在他者欲望的煎逼之下，在欲望满足的失败中，主体一次又一次遭遇到自身的残余性。</p><p>于是，焦虑的原因就显得明了了，主体并非因为欲望对象远离与推迟而感到焦虑，而是因为过分靠近对象本身感到创伤性焦虑。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如梦如幻的周末</title>
      <link href="/20220304-yumemitai/"/>
      <url>/20220304-yumemitai/</url>
      
        <content type="html"><![CDATA[<p>我走在一组团路上，想到的是，这样梦幻的日子，我还能过多久？</p><p>周五晚上群里照常，又是赵佩璇和安禹赫小组出去喝酒了，开始夺舍对方的qq号。但很快，佩璇开始诉说苦恼：想要早点死。</p><p>我与赵佩璇是在大二下学期第一回见，是我还留着长头发的时候。是典型的大城市、富裕家庭来的孩子，尤其是早年经历这方面至少比我这个从南京这个小城出来的要丰富很多。由于种种原因不喜欢在北京待着，恰好高考分数高，才来到南京大学。给人的印象就是非常非常开朗，什么都不在意的类型。</p><p>于是我很惊讶。虽然外表看起来开朗的人，内心多少也会有点小疙瘩，但是觉得人生活腻了，一心寻死的，还是从来没有见过。她又补充到，非常担心大家讨厌她。更是奇怪。</p><p>在我的脑子里，一直就有这样一个三人组：赵佩璇、安禹赫、翟竞波。他们分别来自北京、天津、新疆，但是到了这里，很快成为了非常非常要好的朋友。至少表面很要好吧。。。佩璇自己都承认，他俩对她真的很好。但时不时仍然怀疑他们讨厌自己。</p><p>你也知道，我见不得美少女伤心，就随便和她聊俩句试图开导一下。我看她没胆子寻死就放心了， 然后她给我留了个线索，说了解她的过去就知道为什么现在这样了。</p><p>第二天晚上我就奔运动场去了。清风阵阵，绿树围绕着跑道，天色晚得深蓝，佩璇独自坐在看台上。认出我来，打个招呼。我们聊了一点过去，大致是：初高中同学纷纷表示对她不喜欢，好朋友当面关系好却要应和大家以至于不能确定是否是真好朋友。对于不受欢迎的原因完全无处了解，总结起来为“就是不喜欢这个人”。我深受震撼，原来连人际关系都与我的经历大相径庭。应该说，找不到第二个相同的。事后重新思考的时候，私以为隐瞒了很多重要的情节。只知道一两条信息是分析不出结果的，一定要从头到尾理顺了。（在写的时候，我深深感到佩璇大概知道自己到底是什么问题，但隐藏了）</p><p>佩璇，我，安禹赫，顾天纬四人，为了不回宿舍，在外面干等了一夜。我就这样掉进坑里。</p><p>我们前半夜聊天，什么都聊。院里不喜欢谁，谁的八卦，</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面纱</title>
      <link href="/20211129-veil/"/>
      <url>/20211129-veil/</url>
      
        <content type="html"><![CDATA[<p>一周一度的电脑没电时间。</p><p>我常常会因为不懂辩证法而感到与世界格格不入。</p><p>这一周没学到什么新的，不过有一个表象与本质的辩证关系。提问：表象的背后是什么？</p><p>是虚无吗？“无”作为一种规定性是抹平全部差异的巨大力量。Nothing is expensive。</p><p>是自我吗？这代表了一种自我的二分。里面外面全都是“我”，这是在本体论上无法操控的，也就变成了一种他者。</p><p>是表象吗？表象后永远是表象，意味着真实的东西永远不会到来，这是一种危险的玩味。</p><p>是本质吗？当然本质仍然有一个本质。于是本质变成了表象之表象。</p><p>都对，都不对。答案是一个合题。</p><p>爱情是遮蔽在“见色起意”之上的一层“painted veil”。它是一个美丽的幌子，而且你还揭不开——它就是本质，本质就是你的冲动。这里没有高尚和低俗的二分。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>身体状况</title>
      <link href="/20211124-sick/"/>
      <url>/20211124-sick/</url>
      
        <content type="html"><![CDATA[<p>身体状况变差了。</p><p>昨晚心血来潮跑个步，夜里睡眠质量急剧下降：0530醒了一次，很久才睡着。做的梦也不是很友好。</p><p>检查一下手环，发现夜里有异常心率。身体上也感觉到肺内吸足气时胸口有点酸痛。上次这种感觉还是在高中强度最高的时候。类似的状况其实是调理可以恢复的，不过要不要今天就去测一下血压呢。。</p><p>身体重要。不过睡眠质量稍微有点无解，这似乎也和夜间心率状况有点关系。最低的心率能到40，感觉不太寻常。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>凝视</title>
      <link href="/20211123-gaze/"/>
      <url>/20211123-gaze/</url>
      
        <content type="html"><![CDATA[<p>当我对任何人的凝视都感到无所谓的时候我才是真的变强了。</p><p>仿佛在感知着他人的目光，只是感知，而不是在事实上确认到的那一瞬间，主体作为客体而存在了。</p><p>第一时间不是感受到自己的情绪，而是一个矮化的那个 “Tilnel”。自己的丑态浮现在自己的头脑中。</p><p>所以人真能完全无视那种眼神吗？</p><p>也许有两条路径。一是感知不到，二是感知到了但不去思考。第一条主要又是不要自动把第一人称视角改成第三人称。第二条恐怕就是摆烂了，或者是相信自己不会有任何丑态被捕捉到。真的能这么自信吗？</p><p>第一条有点像是对抗一种刻在DNA中的本能。第二条则不是什么实事求是的姿态，而是诉诸于臆想，只是对自己不忠诚。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Universality of Consensus</title>
      <link href="/20211121_Consensus/"/>
      <url>/20211121_Consensus/</url>
      
        <content type="html"><![CDATA[<p>Universality of Consensus</p><p>How to prove statements of the form “there is no wait-free implementation of $X$ by $Y$”?</p><h3 id="6-2-Universality"><a href="#6-2-Universality" class="headerlink" title="6.2 Universality"></a>6.2 Universality</h3><p>A class $C$ is <em>universal</em> if one can construct a wait-free implementation of any object from some number of objects of $C$ and some number of read-write registers.</p><h3 id="6-3-A-Lock-Free-Universal-Construction"><a href="#6-3-A-Lock-Free-Universal-Construction" class="headerlink" title="6.3 A Lock-Free Universal Construction"></a>6.3 A Lock-Free Universal Construction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SeqObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Response <span class="title function_">apply</span><span class="params">(Invocation invoc)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(the <code>apply()</code> method applies the invocation and returns a response).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Invoc invoc;</span><br><span class="line">    <span class="keyword">public</span> Consensus&lt;Node&gt; decideNext;<span class="comment">// decide next Node in list</span></span><br><span class="line">    <span class="keyword">public</span> Node next;<span class="comment">// the next node</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> seq;<span class="comment">// sequence number</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Invoc invoc)</span> &#123;</span><br><span class="line">        invoc = invoc;</span><br><span class="line">        decideNext = <span class="keyword">new</span> <span class="title class_">Consensus</span>&lt;Node&gt;();</span><br><span class="line">        seq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">max</span><span class="params">(Node[] array)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (max.seq &lt; array[i].seq)</span><br><span class="line">                max = array[i];</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This shows a universal construction that transforms any sequential object into a lock-free linearizable concurrent object. This construction assumes that sequential objects are <em>deterministic</em>: if we apply a method to an object in a particular state, then there is only one possible response, and one possible new object state. We can represent any object as a combination of a sequential object in its initial state and a <em>log</em>: a linked list of nodes representing the sequence of method calls applied to the object (and hence the object’s sequence of state transitions).</p><p>我们只要存下调用序列就可以知道状态了。</p><p>那么怎么让它并发呢？也就是 <code>apply()</code> 能够并发地被调用。</p><p>只要在调用 <code>apply()</code> 的时候，都创建一个 <code>node</code>，通过一个 $n$-线程的共识协议来竞争哪一个节点被添加到调用序列当中。</p><p>赢者得到执行（什么达尔文），它把对象复制到本地，然后顺序执行（真的不计内存消耗了？）最后返回自己的结果。</p><p>败者就必须继续竞争（所以不是 wait-free）</p><p>详细的暂时不看了。</p><h3 id="6-4-A-Wait-Free-Universal-Construction"><a href="#6-4-A-Wait-Free-Universal-Construction" class="headerlink" title="6.4 A Wait-Free Universal Construction"></a>6.4 A Wait-Free Universal Construction</h3><p>Core: help less fortunate threads to complete their calls. <em><strong>helping</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Universal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] announce;<span class="comment">// array added to coordinate helping</span></span><br><span class="line">    <span class="keyword">private</span> Node[] head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">node</span>(); tail.seq = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; head[j] = tail; announce[j] = tail; &#125;</span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">apply</span><span class="params">(Invoc invoc)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">        announce[i] = <span class="keyword">new</span> <span class="title class_">Node</span>(invoc);</span><br><span class="line">        head[i] = Node.max(head);</span><br><span class="line">        <span class="keyword">while</span> (announce[i].seq == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">before</span> <span class="operator">=</span> head[i];</span><br><span class="line">            <span class="type">Node</span> <span class="variable">help</span> <span class="operator">=</span> announce[(before.seq + <span class="number">1</span> % n)];</span><br><span class="line">            <span class="keyword">if</span> (help.seq == <span class="number">0</span>)</span><br><span class="line">                prefer = help;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prefer = announce[i];</span><br><span class="line">            after = before.decideNext.decide(prefer);</span><br><span class="line">            before.next = after;</span><br><span class="line">            after.seq = before.seq + <span class="number">1</span>;</span><br><span class="line">            head[i] = after;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SeqObject</span> <span class="variable">MyObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqObject</span>();</span><br><span class="line">        current = tail.next;</span><br><span class="line">        <span class="keyword">while</span> (current != announce[i]) &#123;</span><br><span class="line">            MyObject.apply(current.invoc);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head[i] = announce[i];</span><br><span class="line">        <span class="keyword">return</span> MyObject.apply(current.invoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的智商不够看懂这个（懒）</p><p>7 就是 spinlock 了，终于有锁了，流下了激动的眼泪。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - The Relative Power of Primitive Synchronization Operations</title>
      <link href="/20211121_sync_op/"/>
      <url>/20211121_sync_op/</url>
      
        <content type="html"><![CDATA[<p>Consensus Numbers</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consensus</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">decide</span><span class="params">(T value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>consistent: all threads decide the same value,</li><li>valid: the common decision value is some thread’s input.</li></ul><p><em>Def 5.1.1</em> A class <em>C</em> solves $n$-thread consensus if there exist a consensus protocol using any number of objects of class <em>C</em> and any number of atomic registers.</p><p><em>Def 5.1.2</em> The <em>consensus number</em> of a class <em>C</em> is the largest $n$ for which that class solves $n$-thread consensus. If no largest $n$ exists, we say the consensus number of the class if <em>infinite</em>.</p><p><em>Corollary 5.1.1</em> Suppose one can implement an object of class <em>C</em> from one or more objects of class <em>D</em>, together with some number of atomic registers. If class <em>C</em> solves $n$-consensus, then so does class <em>D</em>.</p><p>A protocol state is <em>critical</em> if:</p><ul><li>It is bivalent, and</li><li>if any thread moves, the protocol state becomes univalent.</li></ul><p><em>Lemma</em> 5.1.3. Every wait-free consensus protocol has a critical state.</p><h3 id="5-2-Atomic-Registers"><a href="#5-2-Atomic-Registers" class="headerlink" title="5.2 Atomic Registers"></a>5.2 Atomic Registers</h3><blockquote><p>Whether we can solve consensus using atomic registers?</p><p>– no</p></blockquote><p>There is no binary consensus protocol for two threads.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ConsensusProtocol</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Consensus</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> T[] proposed = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[N];</span><br><span class="line">    <span class="comment">// announce my input value to the other threads</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">propose</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        proposed[ThreadID.get()] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// figure out which thread was first</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> T <span class="title function_">decide</span><span class="params">(T value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是，你都有互斥的 Queue 了，那不是等同于作弊么</p><h3 id="5-4-FIFO-Queues"><a href="#5-4-FIFO-Queues" class="headerlink" title="5.4 FIFO Queues"></a>5.4 FIFO Queues</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueConsensus</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ConsensusProtocol</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WIN</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// first thread</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOSE</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// second thread</span></span><br><span class="line">    Queue queue;</span><br><span class="line">    <span class="comment">// initialize queue with two items</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueConsensus</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">        queue.enq(WIN);</span><br><span class="line">        queue.enq(LOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// figure out which thread was first</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">decide</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        propose(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> queue.deq();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">        <span class="keyword">if</span> (status == WIN) <span class="keyword">return</span> proposed[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> proposed[<span class="number">1</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Corollary</em> 5.4.1 It is impossible to construct a wait-free implementation of a queue, stack, priority queue, set, or list from a set of atomic registers.</p><h3 id="5-5-Multiple-Assignment-Objects"><a href="#5-5-Multiple-Assignment-Objects" class="headerlink" title="5.5 Multiple Assignment Objects"></a>5.5 Multiple Assignment Objects</h3><h3 id="5-6-Read-Modify-Write-Operations"><a href="#5-6-Read-Modify-Write-Operations" class="headerlink" title="5.6 Read-Modify-Write Operations"></a>5.6 Read-Modify-Write Operations</h3><p>Many, if not all, of the classical synchronization operations provided by multiprocessors in hardware can be expressed as <em>read-modify-write</em> (RMW) operations, or, as they are called in their object form, <em>read-modify-write registers</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getAndSet(v);</span><br><span class="line">getAndIncrement();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RMWConsensus</span> <span class="keyword">extends</span> <span class="title class_">ConsensusProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// initialize to v such that f(v) != v</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RMWRegister</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMWRegister</span>(v);</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">decide</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    propose(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> - i;</span><br><span class="line">        <span class="keyword">if</span> (r.rmw() == v)</span><br><span class="line">            <span class="keyword">return</span> proposed[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Foundations of Shared Memory</title>
      <link href="/20211121-shared_memory/"/>
      <url>/20211121-shared_memory/</url>
      
        <content type="html"><![CDATA[<p>Foundations of Shared Memory</p><p>At the hardware level, threads communicate by reading and writing shared memory.</p><p>How to implement linearizable read and write register for multiple readers and writers?</p><p>Can any data structure implemented from the most powerful registers we define also be implemented from the weakest?</p><p>The weakest form of persistent synchronization if (arguably) the ability to set a single persistent bit in shared memory, and the weakest form of synchronization is (unarguably) none at all: if the act of setting a bit does not overlap the act of reading that bit, then the value read is the same as the value written Otherwise, a read overlapping a write would return any value.</p><p>A single-writer, multi-reader register implementation is <em>safe</em> if –</p><ul><li>A <code>read()</code> call that does not overlap a <code>write()</code> call returns the value written by the most recent <code>write()</code> call.</li><li>Otherwise, if a <code>read()</code> call overlaps a <code>write()</code> call, then the <code>read()</code> call may return any value within the register’s allowed range of values (for example, $0$ to $M - 1$ for an $M$-valued register)</li></ul><p>The term <em>safe</em> is a historical accident. Because they provide such weak guarantees, “safe” registers are actually quite unsafe.</p><p><img src="image-20211121200633192.png" alt="image-20211121200633192"></p><p>我至今还是不知道为什么 Boolean 不是 Regular 而只能是 safe。这真的能返回出奇怪的值吗？</p><p>我想跳过这个了</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Concurrent Objects</title>
      <link href="/20211121-object/"/>
      <url>/20211121-object/</url>
      
        <content type="html"><![CDATA[<p>Concurrent Objects</p><p>有锁数据结构真好写</p><h5 id="Sequence-Consistency"><a href="#Sequence-Consistency" class="headerlink" title="Sequence Consistency"></a>Sequence Consistency</h5><p><img src="image-20211121164314180.png" alt="image-20211121164314180"></p><p>p 和 q 都是顺序一致的。（可以平移）</p><p>但是这个执行过程并不是顺序一致的（有环）</p><h4 id="Linearizability"><a href="#Linearizability" class="headerlink" title="Linearizability"></a>Linearizability</h4><p>顺序一致性不可合成。</p><p><em>Principle</em>: Each method call should appear to take effect instantaneously at some moment between its invocation and response.</p><p>Every linearizable execution is sequentially consistent, but not vice versa.</p><p>The usual way to show that a concurrent object implementation is linearizable is to identify for each method a <em>linearization</em> point where the method takes effect.</p><p>For lock-based implementations, each method’s critical section can serve as its linearization point. For implementations that do not use locking, the linearization point is typically a single step where the effects of the method call become visible to other method calls.</p><p><img src="image-20211121181745189.png" alt="image-20211121181745189"></p><p>看懂了没？</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Mutual Exclusion</title>
      <link href="/20211121-mutex/"/>
      <url>/20211121-mutex/</url>
      
        <content type="html"><![CDATA[<p>Mutual Exclusion</p><p>Reasoning about concurrent computation is mostly about time. Reason about complicated conditions involving how multiple time intervals can overlap, or, sometimes, how they cannot.</p><p>A thread is a <em>state machine</em>, and its state transitions are called <em>events</em>.</p><p>Events are <em>instantaneous</em></p><p>j-th occurence of an event a_i: a_i^j</p><p>a <em>precedes</em> b: a\to b</p><p>The <em>precedence</em> relation “\to” is a total order on events.</p><p>Interval I_A &#x3D;(a_0, a_1), I_B &#x3D; (b_0, b_1), I_A\to I_B if a_1\to b_0.</p><p><strong>Mutual Exclusion</strong> Critical sections of different threads do not overlap. For threads A and B, and integers j and k, either CS_A^k \to CS_B^j or CS_B^j \to CS_A^k.</p><p><strong>Freedom from Deadlock</strong> If some thread attempts to acquire the lock, then some thread will succeed in acquiring the lock. If thread A calls <code>lock()</code> but never acquires the lock, then other threads must be completing an infinite number of critical sections.</p><p><strong>Freedom from Starvations</strong> Every thread that attempts to acquire the lock eventually succeeds. Every call to <code>lock()</code> eventually returns. This property is sometimes called <em>lockout freedom</em>.</p><p>NOTE that starvation freedom implies deadlock freedom.</p><h2 id="2-3-2-Thread-Solutions"><a href="#2-3-2-Thread-Solutions" class="headerlink" title="2.3 2-Thread Solutions"></a>2.3 2-Thread Solutions</h2><h5 id="LockOne"><a href="#LockOne" class="headerlink" title="LockOne"></a>LockOne</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LockOne implements Lock &#123;</span><br><span class="line">    private boolean[] flag = new boolean[2];</span><br><span class="line">    // thread-local index, 0 or 1</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        int j = 1 - i;</span><br><span class="line">        flag[i] = true;</span><br><span class="line">        while (flag[j]) &#123;&#125;  // wait</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        flag[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutual excluded but deadlock.</p><h5 id="LockTwo"><a href="#LockTwo" class="headerlink" title="LockTwo"></a>LockTwo</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class LockTwo implements Lock &#123;</span><br><span class="line">    private volatile int victim;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        victim = i;</span><br><span class="line">        while (victim == i) ()</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="The-Peterson-Lock"><a href="#The-Peterson-Lock" class="headerlink" title="The Peterson Lock"></a>The Peterson Lock</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Peterson implements Lock &#123;</span><br><span class="line">    // thread-local index, 0 or 1</span><br><span class="line">    private volatile boolean[] flag = new boolean[2];</span><br><span class="line">    private volatile int victim;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        int j = 1 - i;</span><br><span class="line">        flag[i] = true; // I&#x27;m interested</span><br><span class="line">        victim = i; // you go first</span><br><span class="line">        while (flag[j] &amp;&amp; victim == i) &#123;&#125;; // wait</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        flag[i] = false;    // I&#x27;m not interested</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutual excluded and starvation free</p><p>Work for n threads: </p><h5 id="The-Filter-Lock"><a href="#The-Filter-Lock" class="headerlink" title="The Filter Lock"></a>The Filter Lock</h5><p><em>a direct generalization of Peterson lock to multipe threads</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Filter implements Lock &#123;</span><br><span class="line">    int[] level; </span><br><span class="line">    int[] victim;</span><br><span class="line">    public Filter(int n) &#123;</span><br><span class="line">        level = new int[n];</span><br><span class="line">        victim = new int[n]; // use 1..n - 1</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            level[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int me = ThreadID.get();</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;   // attempt level 1</span><br><span class="line">            level[me] = i;</span><br><span class="line">            victim[i] = me;</span><br><span class="line">            // spin while comflicts exist</span><br><span class="line">            while ((\exist k != me)(level[k] &gt;= i &amp;&amp; victim[i] == me)) &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int me = ThreadID.get();</span><br><span class="line">        level[me] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Threads run through levels, until 1 level (CS)</p><h5 id="Lamport’s-Bakery-Algorithm"><a href="#Lamport’s-Bakery-Algorithm" class="headerlink" title="Lamport’s Bakery Algorithm"></a>Lamport’s Bakery Algorithm</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Bakery implements Lock &#123;</span><br><span class="line">    boolean[] flag;</span><br><span class="line">    Label[] label;</span><br><span class="line">    public Bakery(int n) &#123;</span><br><span class="line">        flag = new boolean[n];</span><br><span class="line">        lavel = new Label[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            flag[i] = false; label[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        flag[i] = true;</span><br><span class="line">        label[i] = max(label[i], ..., label[n - 1]) + 1;</span><br><span class="line">        while ((\exist k != i)(flag[k] &amp;&amp; (label[k], k) &lt;&lt; (label[i], i))) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        flag[ThreadID.get()] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lexicographical ordering &lt;&lt; （字典序）, to break symmetry caused by same label.</p><p>In the waiting part, a thread repeatedly rereads the labels one after the other in some arbitrary order until it determines that no thread with a raised flag has a lexicographically smaller label&#x2F;id pair.</p><p>Each thread’s labels are strictly increasing.</p><p>本质上就是排队，先到先执行。</p><p>Any algorithm that is both deadlock-free and <em>first-come-first-served</em> is also starvation-free.</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回忆乐怡</title>
      <link href="/20211101-jly/"/>
      <url>/20211101-jly/</url>
      
        <content type="html"><![CDATA[<p>我是很想不明白为什么要把爱情看得那么复杂的。所谓“一段好的感情一定要互相使对方成为更好的人”啦之类的。。顾虑？（录者：这可能不是一种顾虑，而是一种贪婪）</p><p>都是人类的情感，你不去掌握它，却要让它来掌控你，凭什么？感情的好坏是通过社会关系合乎理性的方式来决定的吗？</p><p>最近很容易想起金乐怡。我在金陵中学，她在南师附中，我已经不记得我们初见到底是怎么回事了，但可能先是在网上认识的。某天去学而思上课，我脑子一热就穿着汉服出街了，高中生还真是有这些闲心思。于是在王绳慧的数学课上我就认识了她。似乎从那以后，我就变成了穿汉服的“小哥哥”。到这里我有点受宠若惊，不过一想到她似乎和所有人的关系都能处得很友好，甚至是亲密，我只能认为这也许只是她的行事风格。（录者：赤名莉香并感）</p><p>我们一边在网络上聊天，却在现实中难得见面。高二美食节展台的背后，我在准备候场，而她也来到我们学校，在那里找到了我。她向我张开双臂，我立即会意，像是很熟悉一样迎了上去。没有预告、没有暗示，甚至没有情感流露。我已经不记得说了什么，但拥抱的感觉…我也记不太清了。</p><p>感觉还是很浑蛋。我的确不相信这里包含了什么多余的感情。对方和我才几面之缘，而且说到底各方面都比我强，我没理由认为人家喜欢我的。我笃信她原本就是如此热情的人。后来就是她小高考失利，逐渐没在网络上出现了。我也隐隐约约地有了一切其他牵绊。在烦恼中，竞赛也打完，回归了高考，于是产生更多的烦恼，直到一天早上。</p><p>我们的英语口语考试在南大附中考点，碰巧南师附中也是，只是比我们早一个时间段。我们一大早就在考点门口等着。当时也算是冬天，我拎着袋子搓着手坐在学校对面的小公园，也并没有和朋友们聚着聊天，眼神有些飘忽。我在焦虑，也在寻找着她。我预感自己一定会遇到她。</p><p>起身转悠，却首先被她发现。我已经忘记当时我是怎么打招呼的了，但好像……我们一见面就不管不顾地抱在一起。我的心思可能并不单纯，在于我有点希望同班的女生也看见这副场景。事后诸葛亮的话，这可能是最优情况，但是没有发生这样的事情。</p><p>但当时附近只有她的同学。她只是对着金乐怡会心一笑，而金乐怡可能是羞涩着否认了一下吧。我们有一搭没一搭地交谈，但也许很开心。</p><p>没了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生活回到正轨</title>
      <link href="/20211027_back_on_track/"/>
      <url>/20211027_back_on_track/</url>
      
        <content type="html"><![CDATA[<p>一周的奔波忙碌，为了一张身份证跑了两个下午。顺路回家吃了了顿饭。。。</p><p>本来第二次晚上也是回家吃饭的，但是我想到自己还和同事约好了帮他看电脑，所以和家里说回学校了。结果人家和同学去海底捞“讨论课程前景”，只能在宿舍坐着，晚上9点去便利店随便吃点。。。</p><p>周二下午从十字街派出所往回走的时候，我的内心差不多是绝望的。一想到自己只是个学生，还未经世事，但仅仅是这样一点小事就害得自己白跑一下午，不知道以后成为真正的社会人以后还会有多少这样的事情发生。这件事情其实也是坏在自己想当然，什么都没带就往办事处跑，又出发得晚，没有多少时间给我纠错。这样想想仿佛不应该怨天尤人。但这样想一想，心情会变得更加差。所以我直接进行一个家的回。特别是一个月没有回家的这个时间点，也不算是想家，就算是和父母互相看着都能变得更加顺眼一点。</p><p>回家把米一淘，妈回来了，出门弄只烤鸭；爸回来了，拎着一盆酸菜鱼。临时凑出一桌好饭好菜，有吃有聊，聊的都是些老话，但一来一回总归是很舒服：不要动脑子，没有压迫感，家人都支持你。心情不好的时候回家就可以充满电。</p><p>但是我想，经常回家的条件恐怕是越来越没有了。往后只会越来越忙，但是充电桩只有一个。而且其实我也有很多事情没有办法和家里说，毕竟是21岁的男人，渐渐地该反过来让家里依靠自己了。我何尝不想谈对象呢？平时我说，实在不行就单身到30岁然后慢慢相亲去，总是不至于没有婚结。爱情什么的早就体验过了。。吧。暧昧的有过，确认关系的也有过，几段经历加起来，除了没有临门一脚以外，似乎…没什么能够期待的？c</p><p>当然有。我认为缺少的部分是从爱情向亲情的升华。首先真的是升华吗？缺少论证。这个过程的特点其实就是热情消退，剩下的是稳固、平和的另一种东西。从短时间的冲动转变为一种长久的、甚至永恒的平淡啊。那么到底哪一个更好？我觉得这里是没有定论的。这应该由每个人自己来决定。那么我到底认为什么重要？</p><p>我一度认为我是更加需要亲情，但写到这里我发现我是错的：我可能只是作为一个平凡人，已经把热情、激情这种同样本真的东西自我阉割了，因为发现自己得不到，而这一空缺就在那个位置存在着，非常折磨。我不相信自己能够拥有。</p><p>发送版：</p><p>爱情是属于人类的本真的情感。也就是说，这玩意神秘个屁，根本就是没有门槛的。你想像它有什么神圣的、崇高的背面，没有！你一想爱情这么圣洁，自己是什么寄吧，自己一定得不到。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>白给周报 1-types-io</title>
      <link href="/20211025-baigei_week1/"/>
      <url>/20211025-baigei_week1/</url>
      
        <content type="html"><![CDATA[<p>视角：Tilnel</p><p>小心<strong>匿名处刑</strong></p><p>同步发布于 <a href="http://blog.tilnel.com/">blog</a></p><p>[toc]</p><h2 id="Ascii"><a href="#Ascii" class="headerlink" title="Ascii"></a>Ascii</h2><p>非常和平的签到题，一点问题都没有。</p><h2 id="Change"><a href="#Change" class="headerlink" title="Change"></a>Change</h2><p>贪心思想，先用最大的，直到用不了再换小一点的…</p><p>看到 std 的做法，突发脑溢血：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n%d\n&quot;</span>, n / <span class="number">20</span>, (n % <span class="number">20</span>) / <span class="number">10</span>, ((n % <span class="number">20</span>) % <span class="number">10</span>) / <span class="number">5</span>, (((n % <span class="number">20</span>) % <span class="number">10</span>) % <span class="number">5</span>));</span><br></pre></td></tr></table></figure><blockquote><p>直接 n % 5 不好吗，为什么要 (((n % 20) % 10) % 5) …</p></blockquote><p><strong>更脑溢血的写法</strong>：从 0 张 20 元开始，用 <code>for</code> 循环一张一张累加，直到超了，换成 10 元继续累加…</p><blockquote><p>这份代码的作者处理 10 元的时候还弄错了，导致 1 元必须累加到超过 <code>INT_MAX</code> 变成某个负数才能停止循环，于是时间超限了。</p></blockquote><h2 id="Equation"><a href="#Equation" class="headerlink" title="Equation"></a>Equation</h2><p>&#x3D;&#x3D;重灾区&#x3D;&#x3D;</p><p>主要问题：爆完 <code>int</code> 爆 <code>long long</code>。因为 <code>a</code>, <code>c</code> 在 <code>int</code> 范围，故有可能出现 $4 \times a \times c$ 也超过了 <code>int64_t</code> 范围的情况。解决办法是全都用 <code>double</code>。</p><p>double 的精度是十进制的15位左右，本题求一个小数点后 3 位只能说是绰绰有余。</p><p>白给示例：</p><p><img src="QQ%E5%9B%BE%E7%89%8720211025011332.jpg" alt="1"></p><h2 id="Gray"><a href="#Gray" class="headerlink" title="Gray"></a>Gray</h2><p>提交通过率达到惊人的 56.3%</p><h2 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h2><p>这题数据出锅了，后来题面补了前导零的描述。</p><h2 id="Pi"><a href="#Pi" class="headerlink" title="Pi"></a>Pi</h2><p>最大的问题是有人不使用百度，直接在代码里写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi_1 = <span class="number">16</span> * arctan(<span class="number">0.2</span>) - <span class="number">4</span> * arctan(<span class="number">1.0</span> / <span class="number">239</span>);</span><br></pre></td></tr></table></figure><p>然后非常自然地得到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pi.c: In function ‘main’:</span><br><span class="line">pi.c:5:22: warning: implicit declaration of function ‘arctan’; did you mean ‘atan’? [-Wimplicit-function-declaration]</span><br><span class="line">    5 |   double pi_1 = 16 * arctan(0.2) - 4 * atan(1.0 / 239);</span><br><span class="line">      |                      ^~~~~~</span><br><span class="line">      |                      atan</span><br><span class="line">/usr/bin/ld: /tmp/ccC2GESl.o: in function `main&#x27;:</span><br><span class="line">pi.c:(.text+0x1a): undefined reference to `arctan&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>但是又不会看 warning，其实编译器已经问你是不是 <code>atan</code> 了。</p><p>第二个问题还是 <strong>数据类型溢出</strong>。</p><ul><li><p>当你在 C 里写下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">640320</span> * <span class="number">640320</span> * <span class="number">640320</span>;</span><br></pre></td></tr></table></figure><p>时，640320 被自动认为是 <code>int</code> 类型。而这整个乘法算式的 3 个数字都是 <code>int</code> 类型，所以表达式的结果也将会是 <code>int</code> 类型。显然是装不下的。</p></li><li><p>但凡写出一个 <code>640320.0</code>，这个计算的性质就变了：</p><p>根据 <a href="https://baike.baidu.com/item/%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87/2635753">类型提升规则</a>，因为 640320.0 的类型是 <code>double</code>，所以它参与的运算的结果也被提升成了 <code>double</code> 类型。</p></li></ul><p>什么时候不提升：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2147483648</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">1.0</span> + a * a;</span><br></pre></td></tr></table></figure><p>由于运算优先级的关系，这里首先执行 <code>a * a</code>，两者都是 <code>int</code> 类型，于是得出了一个溢出的 <code>int</code> 类型结果，再与 1.0 相加（而不是先被提升成 <code>double</code> 类型再相乘。</p><h3 id="白给示范"><a href="#白给示范" class="headerlink" title="白给示范"></a>白给示范</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> pi_1 = <span class="number">16</span> * atanf(<span class="number">0.2</span>) - <span class="number">4</span> * atanf(<span class="number">1.0</span> / <span class="number">239</span>);</span><br><span class="line">  <span class="type">double</span> pi_2 = <span class="built_in">log</span>(<span class="number">1.0</span> * <span class="number">640320</span> * <span class="number">640320</span> * <span class="number">640320</span> + <span class="number">744</span>) / <span class="built_in">sqrt</span>(<span class="number">163</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.15lf\n%.15lf\n&quot;</span>, pi_1, pi_2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.141592741012573</span><br><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure><blockquote><p>为什么差这么多？</p></blockquote><p><img src="image-20211025012134558.png" alt="2"></p><p><code>double</code> 的精度比起 <code>float</code> 不知道高到哪里去了。。。</p><h2 id="Planck"><a href="#Planck" class="headerlink" title="Planck"></a>Planck</h2><p>错误点比较集中，许多同学误用 <code>%.3g</code> ，但这个输出格式：</p><ul><li>并不都输出科学计数法</li><li>还会砍末尾 0 造成有效数字位数不对</li></ul><p>手册描述为证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 <span class="built_in">printf</span></span><br></pre></td></tr></table></figure><p><img src="image-20211025013753854.png" alt="image-20211025013753854"></p><blockquote><p>double 类型的参数会以 f 或 e 格式输出。数字指定有效数字位数，默认 6 位；如果指定 0 为，则输出 1 位。如果指数 &lt; -4 或 &gt;&#x3D; 精度则以 e 格式输出。<strong>分数部分的结尾 0 会被移除</strong>。小数点只会在其后至少跟随 1 位数字时出现。</p></blockquote><p>正确的做法：使用 <code>%.2e</code></p><h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p>常见错：没有把题目指定的所有输出格式都实现，可能是因为年份前补 0 会显得非常奇怪。</p><p>奇怪错误1：strncpy 并不自动添加字符串末尾 0，字符串又开小了，导致字符串全连在一起。示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> weekday[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> w[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, weekday);</span><br><span class="line">    <span class="built_in">strncpy</span>(w, weekday, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="image-20211025014855566.png" alt="image-20211025014855566"></p><p>以下讲解看不懂也没关系：</p><p>函数执行的时候，局部变量占用的是栈区内存。而栈区内存的使用是从高地址向低地址。所以先创建的变量就排在后创建变量的后面。</p><p>比如我们假定栈的空间是从（十六进制） 0x100 开始，那么定义了 <code>char weekday[10]</code> 后，它占用 10 字节，于是我们往前推 10，<code>weekday</code> 字符串的起始位置就是 0x100 - 10 &#x3D; 0xf6。</p><p>定义 <code>char w[3]</code> 则 <code>w</code> 的起始位置是 0xf3。</p><p>此时内存的状态是这样的，空格代表内容未知：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line"> f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff  100</span><br><span class="line">|     w     |                weekday                |</span><br></pre></td></tr></table></figure><p>读入了 <code>weekday</code> 之后，则是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   |   |   | S | u | n | d | a | y |\0 |   |   |   |   |</span><br><span class="line"> f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff  100</span><br><span class="line">|     w     |                weekday                |</span><br></pre></td></tr></table></figure><p>在进行了 <code>strncpy</code> 之后，由于 <code>strncpy</code> 没有添加末尾 \0 的行为，则变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| S | u | n | S | u | n | d | a | y |\0 |   |   |   |   |</span><br><span class="line"> f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff  100</span><br><span class="line">|     w     |                weekday                |</span><br></pre></td></tr></table></figure><p>而对于 <code>printf</code> 来说，判断一个字符串结束的方式是遇 \0 则停止。于是输出了 ‘SunSunday’ 这样的结果。</p><p>为了避免，我们只要：</p><ul><li>定义 w[4]，留出末尾 0 的空间</li><li>手动设置 w[3] &#x3D; 0</li></ul><p>关于字符串的末尾 0，在第二周的作业中出现的错误则更是重量级。</p><h2 id="Weekday"><a href="#Weekday" class="headerlink" title="Weekday"></a>Weekday</h2><p>提交通过率最低的一题，仅 18.3%。</p><blockquote><p>这题有我们的失误，一是一开始数据出错了，二是我们假定了年份是 4 位数的。对于 3 位数年份，前两位则不是 Y &#x2F; 100 了。</p></blockquote><p>主要的问题是看漏题目的一个条件导致运算错误。</p><p>常出现的错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w = ...; <span class="comment">// a long formula</span></span><br><span class="line"><span class="keyword">if</span> (w &lt; <span class="number">0</span>) w += <span class="number">7</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, w % <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>这里注意到了条件，试图解决，但解得不是很决。<code>w += 7</code> 后，<code>w</code> 依然可能是负数。那么 <code>w % 7</code> 就依然是负数。</p><h3 id="重量级代码"><a href="#重量级代码" class="headerlink" title="重量级代码"></a>重量级代码</h3><p>足足写了 4 KB</p><img src="image-20211025021128332.png" alt="image-20211025021128332" style="zoom:33%;"><p>学计算机的目标就是让计算机替我们做事。这里完全可以写得更加简洁。比如 214、245 这种数字是根本不需要自己去计算的。</p><h2 id="Quine"><a href="#Quine" class="headerlink" title="Quine"></a>Quine</h2><p>在排除了各种偷鸡写法之后，现在只能在已知的正确代码上修改才能得到一份 <strong>事实上错误 但 判题机答案正确</strong> 的代码。</p><p>具体的评测思路是：将你的 output 放到 .c 文件中，再编译运行一遍得到新的输出。这个新的输出应该与你的输出也保持一致。（你的代码正确的必要不充分条件）</p><p>这里贴出 Special Judge 的源码。欢迎<strong>有闲工夫的人</strong>想点别的花样来绕过这个评测，如果对这份代码理解上有问题请戳作者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Author: Tilnel</span></span><br><span class="line"><span class="comment">   Date: 2021-10-14 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> code[<span class="number">4096</span>];</span><br><span class="line"><span class="type">char</span> output[<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// inf out ans</span></span><br><span class="line">    FILE *ouf = fopen(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(ouf)) != <span class="number">-1</span>)</span><br><span class="line">        code[i++] = ch;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    code[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> dir[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(dir, <span class="string">&quot;test-XXXXXX&quot;</span>);</span><br><span class="line">    mkdtemp(dir);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> file[<span class="number">24</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;%s/main.c&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(file, O_CREAT | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">    write(fd, code, i);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;gcc -D__FILE__=NULL %s -o %s.out&quot;</span>, file, dir); <span class="comment">// 卡掉了使用 __FILE__ 的做法</span></span><br><span class="line">    <span class="type">char</span> out[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(out, <span class="string">&quot;./%s.out&quot;</span>, dir);</span><br><span class="line">    </span><br><span class="line">    system(cmd);</span><br><span class="line">    FILE *fp = popen(out, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(output, i, <span class="number">1</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(code, output, i)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为自己献上鲜花</title>
      <link href="/20210611-buy_flower_for_me/"/>
      <url>/20210611-buy_flower_for_me/</url>
      
        <content type="html"><![CDATA[<p>昨下午3点开始听卡门，躺在床上，以为自己至少能听到爱情像只自由鸟的唱段，但刚听到街童合唱那里就完全昏睡过去了。差不多五点的时候被新东方一个电话吵醒，强撑着不耐烦应付完之后（我他妈怎么就不知道可以挂电话呢，rnm）一看手机，已经开到第三幕了。</p><p>这下午本来的计划是要骑车出去散散心的。昨天晚上骑车出去了，晃荡了半天，唯一见到的新景色还是因为脑子抽了绕着金鹰的周围走，第一次到达金鹰湖的那一头。实在不是很满意，仙林大道的景色一成不变，骑车都快要看腻了。结果下午一场雨给我浇灭了，直接回宿舍躺着去了。</p><p>我们的女主人公昨天收到了一束满天星并大方地在朋友圈和空间都展示了。合理推测是女同学送的，但是性别无所谓，就算某天我被告知她和女同学相爱了我也毫不意外。于是这束花在我这里就坐实了是爱情的表示。这让人怎么可能痛快得起来！赶紧出去溜达去！这就有了昨晚散心一事。</p><p>骑在路上我问问自己说，要不要自己也买一束表示自己逝去的爱情（AC娘_扇子笑）带回学校去，挂到路灯上让大家自己一人取一枝。想到这里突然觉得还有点浪漫的，然后严词拒绝了自己，为啥花这冤枉钱<del>（明天就要花这冤枉钱了）</del>。</p><p>我从床上爬起来，跑到菜市场去，切了30块钱牛肉，拿了4块烧饼准备当晚饭。看到菜市场里的花店，我还是不由自主地往那边瞟了几眼。我想，我不送花，要么为自己插点花？就当是美化一下宿舍。挑了一把Carnation，挑了一个绿瓶子，一共花了50（败家）。</p><p>========转一下视角========</p><p>男孩背着包，提着装着花瓶和花的红色塑料袋一路骑车回到学校。似乎为了向大家展示这美丽的花，不惜绕路去了好几个地方。他走进超市，超市里的每一双眼睛都多少被男孩手里的几支花所吸引。在这学校里，鲜花兴许还是太少了！男孩这么想。</p><p>========我果然不会写东西，还是爬了========</p><p>突然不想写，放个图吧。无奖竞猜，sbw这几支花能活多久：</p><p><img src="2021-06-11-IMG_20210611_075703-1.jpg" alt="IMG_20210611_075703-1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逃向大他者</title>
      <link href="/20210609_escape_to_big_other/"/>
      <url>/20210609_escape_to_big_other/</url>
      
        <content type="html"><![CDATA[<p>她对我说，“不用了”。</p><p>我反复品尝着这句话。既干脆，又委婉，表面拒绝的是一次邀请，实际上也拒绝了我。我期待她再说点什么，但是十分钟过去，聊天窗口并没有一点变化。</p><p>于是我回：那行，就不打扰了。</p><p>我抱着从此当一个死人的心态关掉了聊天窗口。但也有点担心以后万一老在罗森碰头要怎么办。各种奇怪的架空场景在我脑海里一遍遍地演习着，就像是真的会发生一样。</p><p>“够了！”我打住了所有的思维，潜进qq群里，吼了一声。我下定决心，今晚要喝个痛快。</p><p>是忙碌的周二。以为能有一两位哥出来光喝酒吹吹牛逼就差不多了。也预想可能就是沉默地坐着，时不时默契地端起杯喝两口闷酒，然后归于沉默，就这样熬到11点。我完全不害怕这样的可能性，毕竟几个男生凑在一起又能干点啥呢？在体育场上键政真人快打？我习惯了在各种社交场合当中沉默，甚至对于沉默感到有些亲切。</p><p>我同样是耐不住寂寞的。也有不少人对我的评价是，一旦兴头起来了情绪就会变得很激动。在我的会议里，有特别激动的时候，就是金陵中学130周年校庆的时候，黄洪瑞从一中赶过来。那时候的我可真是开心，放开了大嗓门和化竞的同学谈笑风生，吵得不可开交。我到现在也还是一样地情绪化，遇到特别开心的事情还是压不住嗓门，乍乍乎乎的。</p><p>不成想，没一会儿就有几位哥回应了。波波、yuls、zt、zht、ljr。就因为突然的一句话，六个人凑在了一块。</p><p>我带着酒和花生，波波买了吃的，zt背着桌游，以前进四的速度奔向炜华运动场。</p><p>桌游很好玩，Asahi很好喝，Kirin的苦味突然能够接受了；波波带的串也很香，但是鸭翅鸭脖就不是很方便用手去抓着吃。这一两小时我什么都忘了，啥事也都没担心，大脑里什么都不剩了。美中不足就是，啤酒这玩意，喝多了只会让人想上厕所，玩桌游就得让哥几个等着，相当过意不去。</p><p>等到了11点，和大家挥手了，觉得没喝痛快，跑到Lawson又整了两罐。这大晚上11点，我倒开始担心她突然出现了。她似乎常来这里。</p><p>周日，合唱团的演出结束，吃了结团的蛋糕，换回自己衣服出了准备室，看到一队人扛着国旗出门。必然是国旗班了，大晚上九点半了还要训练。我决心跟过去看看，一看就看到11点，可算是结束了，我和她打了招呼后到她宿舍附近的地方等她。</p><p>“我就不拐弯抹角的了。嗯……我觉得你挺棒。”我以一个自认为还比较合适的方法表达了我的感情。</p><p>她转头，并没有立即回应这件事。“我先去罗森买点吃的。”我就在门外等着。</p><p>等着的这一分钟，大脑也没有闲着。有在想，她出来会怎么回答我；失败的预想多于成功的预想，算是自己给自己打预防针。她出来之后，我就跟在后面走到她宿舍的门口。</p><p>“那个，我先回去了……”她看起来也有些不知所措。我稍微有点着急：“你不打算回答点什么吗？”她想了一会儿，我又觉得我好像造成了一些奇怪的压迫感，于是说：“那你再想想，今天先回去吧！”她也这样同意了。</p><p>我跨上我的小车，一路唱着小曲，站着骑回去了。我仿佛感到自已有了一些勇气，能够面对我的“little object a”了。</p><p>但今晚，我这点勇气又消磨殆尽。我疯狂地逃向Big Other，逃向那个想象中的但实际上并不存在的共同体。这一刻我觉得我是撕裂的：理性上认识到了符号秩序、性化秩序的荒谬，但情感又受到这套荒谬秩序的支配。</p><p>挑了两罐酒，其中就有刚才没有喝到的Pilsner，并没有碰到她。大老远的跑到香雪海，坐在亭子里，掏出还没开封的一袋花生，嘴里却感到前所未有的苦。</p><p>以前的我甚至喝不下Kirin。高中某日回家，从超市买了一罐Kirin，到走到家，其苦味让我喝了大半罐，最后一点直接丢掉了。后来都喝清爽型的啤酒，为此还很久都没有喝过青岛啤酒。而今天这罐Pilsner让我回想起了那时的感觉。</p><p>二话不说，啥味道也不尝，直接吨吨吨往里灌就完事了。灌了大半，肚子开始胀。我就劝自己：“别他妈搁着虐待自己了，赶紧扔了回去吧。”</p><p>2公斤下去，这下骑车真是酒驾了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对于招生宣传节奏的一点看法</title>
      <link href="/20210608_tower/"/>
      <url>/20210608_tower/</url>
      
        <content type="html"><![CDATA[<p>核心争议：为什么总是由女性作为“被审美的对象”；为什么用女性的审美形象来代表NJU的审美形象</p><p>首先文案必然是欠考虑。不必看微博，只要看看这件事在校内引起的争议，听听认识的女性的真实想法就能理解这样的抗议是完全正当的</p><p>虽然有节奏，但是诉求的表达并不够。表达“不适”，顶多让学校撤销一次文案。但是对审美对象的需求是无法避免的，未来一定还会面临一样的情况</p><p>所以：要把男性拉下水，成为被审美的对象</p><p>使用例：我推荐大帅比 yls 也去拍两张海报为学校代言（（</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OS MiniLab2 Libco实验感想</title>
      <link href="/20210531_minilab2/"/>
      <url>/20210531_minilab2/</url>
      
        <content type="html"><![CDATA[<p>Libco真是个好实验啊（迫真）</p><p>详尽的框架代码（指hello world）</p><p>不过实验讲义写的还是很清楚</p><p>最终采用的方案：</p><ul><li>类似于操作系统的进程切换，任何进程之间切换都必须要经过主进程，并且强制运行一次 <code>co_wait()</code> 中的循环</li><li>用 <code>malloc()</code> 和 .bss 方式分配栈空间在 OJ 上未见明显差异（但是有个坑，下面细说）</li><li>完全随机调度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当前工作环境的维护问题</title>
      <link href="/20210519_maintenance/"/>
      <url>/20210519_maintenance/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">ArchLinux System Maintenance Guide</a></p><p>感觉上来说，这个学期我工作的主线就一直是这件事。不断地配置环境啊，折腾备份、同步的东西。但是主要的工作感觉迟迟没有展开。磨刀磨了一学期，感觉快要开始了（快要结束了）。</p><p>谈谈系统维护，首先是从grub命令行引导进ArchLinux，这个已经演习了一万遍了。不过未来要是没有一个grub命令行给我操作的话，估计就要插入安装介质了。</p><p>恢复进系统以后就：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-install --efi-directory=/efi --bootloader-id=ArchLinux</span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>这样把grub装上就好 <del>下次还非正常关机，继续丢引导</del></p><p>其实Arch的配置并没有什么好讨论的，只要所有的包啊都在就行了。这里就贴出那个README</p><p>Update lists: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qqe &gt; Archpkglist.txt</span><br></pre></td></tr></table></figure><p>Install packages from the list:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S --needed - &lt; Archpkglist.txt</span><br></pre></td></tr></table></figure><p>Filter out AUR packages</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S needed $(<span class="built_in">comm</span> -12 &lt; (pacman -Slq | <span class="built_in">sort</span>) &lt; (<span class="built_in">sort</span> Archpkglist.txt))</span><br></pre></td></tr></table></figure><p>Gitlab backup script</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># need sudo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $(<span class="built_in">whoami</span>) != <span class="string">&quot;root&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Need run as root</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Gitlab</span></span><br><span class="line"><span class="built_in">rm</span> /var/opt/gitlab/backups/*.tar</span><br><span class="line">gitlab-rake gitlab:backup:create</span><br><span class="line"><span class="built_in">cp</span> /var/opt/gitlab/backups/*.tar /mnt/e/Gitlab/</span><br><span class="line"><span class="built_in">cp</span> -r /etc/gitlab /mnt/e/Gitlab/</span><br><span class="line"><span class="built_in">chown</span> -R kaguya:kaguya /mnt/e/Gitlab</span><br></pre></td></tr></table></figure><p>Gitlab recover</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># need sudo</span></span><br><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br><span class="line"></span><br><span class="line"><span class="comment"># need package under /var/opt/gitlab/backups/*.tar</span></span><br><span class="line">gitlab-rake gitlab:backup:restore BACKUP=<span class="variable">$TIMESTAMP</span><span class="comment"># TIMESTAMP TBD</span></span><br><span class="line"><span class="comment">## OR</span></span><br><span class="line">gitlab-rake gitlab:backup:restore<span class="comment"># only have one bak</span></span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$GITLABCFG</span> /etc/gitlab</span><br><span class="line"></span><br><span class="line">gitlab-ctl start</span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>另外有 Ubuntu 服务器主机的每周备份：</p><p>Ubuntu backup: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> time tar cvpjf /mnt/e/$(<span class="built_in">date</span> -I)_backup.tar.bz2 --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/dev --exclude=/snap --exclude=/usr/var/lib --exclude=/home/kaguya/PicUploader/uploads/WHITE\ ALBUM2\ ～closing\ chapter～\ \[汉化硬盘版\].zip / 1&gt;/mnt/e/sysbak.log 2&gt;/mnt/e/sysbak.err &amp;</span><br></pre></td></tr></table></figure><p>排除 &#x2F;dev &#x2F;mnt &#x2F;sys &#x2F;proc &#x2F;tmp &#x2F;lost+found 之类的分区（mnt根本就打不下）</p><p>恢复就是把包copy一下，然后解包到 &#x2F;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> time tar cvpzf *.tar.bz2 -C /</span><br></pre></td></tr></table></figure><p>这个认为其实可以不在一个完整系统下做。只需要有一个ext4盘，挂到安装介质的 &#x2F;mnt 就可以开恢复了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklost+found</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对一个月的展望</title>
      <link href="/20210516_foresee_on_may16/"/>
      <url>/20210516_foresee_on_may16/</url>
      
        <content type="html"><![CDATA[<p>这一个月基本上是这一学期有效学习的最后一个月。满打满算也就是4周。6.16之后估计就要开始期末考试之类的，所以绝对不能放松了。</p><p>来看看我都挖下了什么天坑（</p><p>1、本次总结的最大头：</p><p>操作系统</p><ul><li>Lab0</li><li>Lab1</li><li>Lab2</li><li>M2</li><li>M3</li><li>M4</li></ul><p><del>我好勇哦</del> 还不赶快去补天。。</p><p>2、问题求解</p><p>事实上只有1次作业</p><p>但是前面的知识基本没怎么学会。。。</p><p>3、概率论与数理统计</p><p>建议整本重新学</p><p>4、数理逻辑</p><p>这个好像不太要担心的？按照我的突击速度，期中好像只花了一夜时间就结束了。</p><p><del>5、没有5</del></p><p>这些几乎就是全部了。MiniLab是好解决的，那么Lab要按照比一周一个还快的速度推进（你可千万不要真的拿一周时间来写Lab0）</p><p>下面是一些个人要求。</p><p>5、身体素质</p><p>2400米测试迫在眉睫，我还是建议自己要好好睡觉。今天已经通宵了，但是白天决不能睡觉。（我也没时间睡）。趁热打铁解决了OJ，然后去参加下午的训练，晚上去赴约就OK了。赴约回来切记好好睡觉。</p><p>之后每天就要逐步加练，基本隔天跑一个3km，以14min为目标这样子。初始的速度可以挂在16min，慢慢加就完事了。如果计算没有问题，最后考试是可以11.2min解决问题。</p><p>健身的话，在跑步的隔天来做。证每周3回，胸背腿就好。不熟悉可以去4组团。</p><p>6、欲望的虚无的核</p><p>每天完成洗衣服这件事；</p><p>每天必到图书馆坐一小时或看书或别的，就算没做什么事光思考也行。。。</p><p>7、自学任务</p><p>学会python和rust，这俩要到能写OJ的程度</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>未子劝学：为什么要好好学专业课</title>
      <link href="/20210516_weiziquanxue/"/>
      <url>/20210516_weiziquanxue/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Sh411S7Kk">原视频</a></p><p>有家长向未子反映，小孩看了wmz的视频以后不愿意读书上学了。故有这一期未子劝学。</p><p>核心的思想有几点：</p><ul><li>应试教育学的95%东西是必须的。这些东西能够锻炼人的能力，并且是能够运用上的。</li><li>在应试教育中取得成绩，事实上是用12年换取发展权和未来60年内的自由时间。</li><li>人的智力是可以一直保持、一直发展的。马克思直到晚年的思想都很猛。</li><li>学哲学的，要有聪明头脑。难道还学不会应试教育的知识吗？</li><li>应试教育的东西是必须的。如果因为其中的一些糟粕而舍弃掉必须的东西，那这个筛子的设计者不就得逞了吗？</li><li>语文锻炼你辨别假话的能力、给你一个情感宣泄&#x2F;释放的窗口（读诗写诗）；数学是文明的源语言，将可以动员为工程师；英语解锁了国际学术共同体、技术共同体…通过学英语去点开很多技能，是成为左翼理论家必备的。</li><li>理论能力、设计能力、编程能力、工程能力、组织能力、宣传能力、行动能力（体力）、公关能力。</li></ul><p>作为掌握了先进思想的左翼，更要对自己严格要求，将学习作为自己的首要任务。</p><p>列宁：我们一定要给自己提出这样的任务:第一,学习,第二是学习,第三还是学习。</p><p>我说：学习！学习！他妈的还是学习！</p><p>人才越来越多，声量越来越大，才能对革命作出贡献。</p><p>保存自己才能消灭敌人。</p><hr><p>我根本不认识你，也不懂得如何认同你。你们为何却都认得我？因我是水气中的尘土，助你们这些毫无瓜葛的匪类们凝结了么？云、泥都能够汇聚水，却无法令它们流动与坚硬。<br>而我不过是空中的一粒微尘罢了！<br>不必向我汇聚，要向着自己，汇聚为澄澈与完全的自己，然后，让我们在地面见，在山川、河流、平原、深谷，在大海见，在沙漠见！<br>至于天空？我们既可重逢，即刻冲锋。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毛选分享发言</title>
      <link href="/20210514_maoist/"/>
      <url>/20210514_maoist/</url>
      
        <content type="html"><![CDATA[<p>我的读书分享，是要分享《毛泽东选集》这本书。</p><p>这本书一共分为五卷，其中第五卷是社会主义革命和社会建设时期的著作。1967年7月中共中央决定出版第五卷，直指当时文化大革命的政治现实。1982年因该版本与《关于建国以来党的若干历史问题的决议》和当时实行的改革开放政策不符，第五卷已停止发行，后续各卷也从未出版。</p><p>为什么停止发行？因为第五卷是大“屠龙术”。你学会了里面的思想，估计立马就要反对现行的某些政策。所以不让看啊。</p><p>毛泽东思想是马克思列宁主义的一个合法分支。（另一个分支是托洛茨基主义）。</p><p>毛主义者认为，毛泽东思想的贡献包括：矛盾论，知识论；群众路线；新民主主义理论，殖民地半殖民地的革命道路，三大法宝——党的建设、人民军队和统一战线；持久人民战争理论和军事战争原则的发展；无产阶级政党的组织原则的发展（通过对路线斗争的认识），整风运动，批评和自我批评；正确处理社会主义过渡时期的矛盾；&#x3D;&#x3D;最后也是最重要的是&#x3D;&#x3D;，为巩固社会主义、反对现代修正主义和防止资本主义复辟，而发展出的无产阶级专政下&#x3D;&#x3D;继续革命&#x3D;&#x3D;的理论与实践。</p><p>什么是继续革命？</p><p>一个无产阶级专政的社会主义国家建立了，难道内部的敌人就不存在了吗？在《一九五七年夏季的形势》中，毛泽东说：“这一次批判资产阶级右派的意义，不要估计小了。这是一个在&#x3D;&#x3D;政治战线上和思想战线&#x3D;&#x3D;上的伟大的社会主义革命。单有一九五六年在&#x3D;&#x3D;经济战线&#x3D;&#x3D;上（在生产资料所有制上）的社会主义革命，是不够的，并且是不巩固的。匈牙利事件就是证明。必须还有一个政治战线上和一个思想战线上的彻底的社会主义革命。共产党在民主党派、知识界和工商界的一部分人（右派）中当然不可能有领导权，因为他们是敌人；在多数人（中间派）中的领导权不巩固；有些文教单位还根本没有建立党的领导。必须建立对中间派的巩固的领导权，并且尽可能早日巩固起来。资产阶级和资产阶级知识分子对共产党不心服，他们中的右派分子决心要同我们较量一下。较量了，他们失败了，他们才懂得他们的大势已去，没有希望了。只有在这时，他们中的多数人（中间派及一部分右派）才会逐渐老实起来，把自己的资产阶级立场逐渐抛弃，站到无产阶级方面来，下决心依靠无产阶级吃饭。少数人至死不改，只好让他们把他们的反动观点带到棺材里去。”</p><p>毛泽东认为，任何社会主义革命都有可能失败，因为社会主义是一个过渡阶段，因此仍然是一个阶级斗争时期，革命阶级还在试图完成其霸权（hegemony）。我们也懂得，革命是经常会失败的，哪怕是在社会主义阶段前。这并不是因为革命者缺乏对布尔什维主义的真正理解，也不是因为他们缺少一个有着魔法般的真正的民主集中制的政党，而是因为&#x3D;&#x3D;资本主义复辟本身就内禀于（immanent）社会主义革命的矛盾中&#x3D;&#x3D;。&#x3D;&#x3D;党本身也有路线斗争&#x3D;&#x3D;，有时最能代表资本主义道路的路线反而会胜利。</p><p>阶级斗争在无产阶级专政下继续进行的理论既解释了斯大林时期的失败，也解释了赫鲁晓夫时期的修正主义。斯大林不明白作为社会主义革命天然组成部分的资本主义复辟的可能性，也就是说，社会主义仍然是阶级社会，反革命的政治路线来自于仍保留在上层建筑中的资产阶级（甚至半封建）意识形态。因此，围绕斯大林聚集起来的力量，&#x3D;&#x3D;并不把那些在党内和苏联社会中可能或可能没有采取资产阶级政治路线的人看作是社会主义条件下必然发生的事情&#x3D;&#x3D;，而是简单地把这些个人、团体和思想看作是外国渗透或蓄意叛国的结果。此外，他们没有认识到&#x3D;&#x3D;党本身将是一个有机的路线斗争的战场&#x3D;&#x3D;。这反映了在社会主义条件下的阶级斗争的主导地位，&#x3D;&#x3D;党的领导层往往会存留资产阶级意识形态&#x3D;&#x3D;。这个理论最能解释为什么斯大林选择的继任者赫鲁晓夫也可以是修正主义者，尽管赫鲁晓夫最初很乐意在斯大林时期执行肃反和政治监察政策。这不是因为他是外国特务（如“斯大林主义”会假设的那样），也不是因为他是官僚（如托洛茨基主义会假设的那样），而是因为&#x3D;&#x3D;资产阶级意识形态和由此而来的修正主义总是具有强烈吸引力&#x3D;&#x3D;——特别是对处于党的领导职位上的人。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>想读书</title>
      <link href="/20210509_to_read/"/>
      <url>/20210509_to_read/</url>
      
        <content type="html"><![CDATA[<p>最近一直处于“整点没用的”的状态：不管做什么事情，都和当下必须要做的事情没有任何关系。而且在这基础上，兴趣点也远离了计算机。</p><p>造成我突然想读书的主要原因，是过于长时间的压抑。曾经我把没有好好读书归结于“时间都花在一些没什么用的事情上了”。而最近发现的是：摸鱼是不可避免的。</p><p>精神力是有限的，而做多少事就要消耗多少精神力。在精神力消耗完的情况下还要再凭空抽出来满足一些极需要精神力的课余活动，本身就不现实。所以恰恰是真的没有精力去面对严肃的书本。</p><p>而今天事情发生了变化：反正已经不想在专业学习上花费精力了，不如暂时把这些精力花在想做的事情上。比如没有读的旧书，也可以捡起来读一读；想写的东西，可以学着写一写。</p><p>还有两件事：一是为了写一篇文章，我感到自己的水平实在是低，需要学习一些文学方面的东西；另一是为了未明子的《面纱》的解读，去读一读英文版的原作。</p><p>在这篇文章开始之前，我在发疯一样地在宿舍找我的Kindle。手头弄了一堆电子书，正要把电子书装进去慢慢看。但我估计我这学期是没把Kindle带过来。这时我才意识到，自己实在是个傻子——我就身处学校。为什么我不去学校的图书馆看一看呢？有什么书是南京大学图书馆都没有的？</p><p>这下找到一条明路了。一直把图书馆当作自习的地方，从根本上就错了。图书馆就应该是读书的地方！</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的表达欲</title>
      <link href="/20210506-before_os_midterm/"/>
      <url>/20210506-before_os_midterm/</url>
      
        <content type="html"><![CDATA[<p>这学期在社交网络上的行为发生了一些变化，总结下来有这样几条：</p><ul><li>发言的频次稳定下来</li><li>发言的质量在上升</li><li>总的来说表达欲是被克制的</li></ul><p>表达欲这种事，不仅要看社交网络上的行为，还要看实际生活当中。譬如我现在的状态是一天下来根本说不了几句话。一般的调查认为，普通男性一天下来要说2000-4000个字，但是对于我来说，仅计算发出声音的说话，这个数字可以&lt;1000。</p><p>如果一天和舍友没有什么能唠的，那就纯不怎么说话；至于外出独来独往根本不太需要。</p><p>现实生活中说话少了，难免要找出口。于是网络就成了表达欲的主要发泄方式。无论是QQ里水群，发空间，发推特，还是像现在这样码博客。</p><p>要论哪种途径更能起到发泄的效果，应当是碎片化、时效性强的朋友圈式社交媒体比较合适。但人多眼杂，发文字的时候要照顾到看的人的心情，还要照顾到自己的心情：给话里添点趣味，讨好别人，再叫别人来讨好自己。不似在这里絮絮叨叨，想到哪里就写到哪里。玩朋友圈的，混久了，很多工作容易变成刻意地装点门面，说白了就是做给别人看的。慢慢地就失去了表达的本意。</p><p>写长文章絮叨有一个好：没人乐意看你搁着瞎bb，随手点个叉就走了，就能说得自由点。也有一个坏，就是没人会看。没人看也不叫表达。所以这个小博客，我是既希望有人来看，又不希望有很多人来看，更不希望某些人来看。这和锁空间、屏蔽朋友圈是一个道理。</p><p>但是我的空间是不锁的。很久以前我就在想，凭什么要锁呢？在保护好自己隐私的情况下，不就是应该亮出自己要表达的东西么？</p><p>最近有人给我留了QQ小号，空间里面有点东西，我一看，差不多是类似于小孩子的秘密基地那种。也许里面藏着什么秘密，但是我看了感觉没啥。我空间里也发过一些东西，写得不怎么样，而且文字里的当事人一眼都能看明白那种。咬咬牙发出去了，最后发现根本没什么。</p><p>说白了，说出来的能叫心里话不？以前对这句话嗤之以鼻，现在想想，所谓说出来是要有听者。既有听者，说话必然相当克制。但凡有一点怂了，就根本不用担心什么说漏嘴，因为自己心里那道防线就过不去。</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>眠れない、そしてJKを見ました。</title>
      <link href="/20210505_nemurenai_soshitejk/"/>
      <url>/20210505_nemurenai_soshitejk/</url>
      
        <content type="html"><![CDATA[<p>昨天夜里实在是没睡什么觉。要说原因可能就是因为我11点的时候主观上想睡觉，客观上我一直在看未明子、刷推。 本来到两点钟就应该睡觉了，然而谁知道我哪根筋搭错了，跑去看了看这几天有没有什么消息没有回。</p><p>结果您猜怎么着，还真就有一条5月2号的消息没有回，是一条学妹的消息。回想当天，我凌晨5点睡到11点，然后下午在床上就嗯躺着， 抱着笔记本以龟速在写一点点文字。吃完晚饭就又陷入了长达16小时的昏睡。</p><p>想想这时间跨度，不禁受到了一点惊吓，赶紧朝对方回复了，尽管是时隔三日。</p><p>平时我都是一个比较弧的人，回消息基本上都是随缘。平时发生这种事情我都是不当回事。坏就坏在这次学妹发的消息非同一般。要我比喻的话，就是<em><strong>小木曾</strong></em>在公园的秋千旁对<em><strong>北原春希</strong></em>说，“今晚让你见识一下真正的小木曾”。</p><p>我的DNA立马就动了起来，我可是资深白学家。这句话充分引起了我的兴趣，我本该第一时间就能够得到真相。但是没想到——因为高强度睡觉+玩疯了，我的回复来的很迟。对方毕竟是高中生，不能天天带着手机，意味着我至少要到周末才能得到回复，这也算是我弧人的报应吧。</p><p>事情坏起来了。可能是白色相簿玩多了，我一闭上眼睛就开始想象后续的剧情 ，这下睡不着了。😅</p><p>说起学妹，我们本来是没有机会认识的，因为她入学那年，我刚刚好就毕业了。所以应该是在她这届入学的一个学习经验讲谈的时候，有那么几个同学找我来要QQ号的其中一个。从低我3个年级这个意义上来说，也很像是<em><strong>杉浦小春</strong></em>（</p><p><strong>====先更到这里====</strong></p><p>接着写点：</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不想干活所以随便写点东西，一直写了4天才发出来</title>
      <link href="/20210505_retire/"/>
      <url>/20210505_retire/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说到底还是条懒狗</p></blockquote><p>1号3号和初中的hxd出去胡吃海喝，在karaoke合唱了一些经典曲目，包括但不限于薔薇より美しい、Never Gonna Give You Up、届かない恋。</p><p><img src="2021-05-02-IMG_20210502_153030.jpg" alt="eat"></p><p><img src="2021-05-02--63ef7a57fb7dd640.jpg" alt="p2"></p><p><strong>恰肉还是爽啊</strong></p><p>4号又和高中同学出去剧本杀，跑了一个又混乱又狗血的本子，4个半小时，我受不了力，最后全员自爆才结束了游戏。</p><hr><h2 id="工作方面的事"><a href="#工作方面的事" class="headerlink" title="工作方面的事"></a>工作方面的事</h2><p>上个月要交给CS的东西才刚刚开了一个头。干活是不可能干的，这一个月基本上都是在摸鱼，OSlab的进度落下了，问题求解的Lab也是，OOP根本学不会。</p><p>与此相对的，上个月净在整一些不太有用的东西，比如blog，比如gitlab（开了仓库，但是却不上传代码，xswl），再比如聊天室（危）。</p><p>虽然看起来弄了不少东西，但都不太正经。而且说实在的，搞这些东西还是在逃避真正重要的任务。就算是认真地做了重要的事情，也不会没有时间来搞定这点小事。</p><p><del>世界上只有一种英雄主义，就是工作压到双膝了，水淹到脖子了，还能抓紧时间摸个鱼。</del></p><h2 id="关于意识形态"><a href="#关于意识形态" class="headerlink" title="关于意识形态"></a>关于意识形态</h2><p>主要进展有两个，</p><p>一是弄清楚了，在实现自由解放的路上，极权作为手段的重要性。极权终会在自我否定中消灭。</p><p>二是看未师的视频，确定了自己对性别的态度。以前我也是持有类似的想法的，但是被搞对立的人整得有些动摇。这次听取了一个理论上的解释，使我自己信服了这件事。</p><p><a href="https://www.bilibili.com/video/BV1YZ4y1F7ve">【性的政治学】男权主义必然失败：“只有一种性别存在”——性多元主义与女性主义的联合之路</a></p><p>大意：</p><p>只有一种性别：+</p><p>死硬的男权主义者：认为自己的性别认同有形而上的依据，却以形而下的“阳具”作为实物载体，并且依托这个形而下的载体，划分出Masculine及其对立面Femiline，要求Femiline配合其形成这样的性别认同。</p><p>具体的体现：女性承担审美对象的功能。</p><p>为什么会有女权：女性的审美对象是女性本身，自我产生性别认同。</p><p>虚假的女权：把认同双方换个位置，继续玩这个荒谬的游戏。</p><p>真正的女权主义者：+</p><p>怎么做：拉拢不是“死硬的Capitalist”，让他们也成为审美的对象。</p><h2 id="再说回自身"><a href="#再说回自身" class="headerlink" title="再说回自身"></a>再说回自身</h2><p>差点想磕提升专注力的药。但是朝葵姐和我说这玩意会成瘾，而且还不如早睡早起建立身体机制来的靠谱，毕竟精力是不可能凭空跑出来的。这是很有道理。</p><p>回想起来其实这学期，一没怎么喝酒，二根本就没有喝过咖啡，三也没太喝过Monster。确实有可能是上个学期留下来的一点后遗症。。当然现在是要保持比较健康的状态了，不能这么年轻的时候就没有精神。</p><p>这学期其实本来是想到教室学习的，但是不知道我的大脑出现了什么问题。我感觉这次不能归结于单纯懒，应该找点更加深层次的原因才行。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>我们先来看一下5.3-5.5的手机屏幕时间统计信息：</p><p>QQ：7小时11分钟</p><p>twitter：之前卸掉了所以没显示，但是应该和QQ用的时间差不多久</p><p>bilibili：4小时31分钟</p><p>知乎：1小时49分钟</p><p>国际象棋：1小时26分钟</p><p>微信：1小时3分钟</p><p>Tape：这个居然有40分钟，但是已经没有人给我发过问题了，感觉匪夷所思</p><p>其实这些说是3天，可以说是两天。因为我是在5.5的上午写到这里的。现在由于通宵有一点小晕。。</p><p>事情就很明显了，主要问题就是水群刷推。这些是比较表面的。</p><p>具体到我到底看了点什么，包括以下：</p><p>1、qq主要水求问题解和20级匡院的群，主要话题是数码、摸鱼、ghs、政治</p><p>2、twitter则主要是看一些政治话题，另外搞点hs</p><p>问题主要是政治看得有点多。但是看完了以后学到了什么呢？我认为在经过中推圈几轮翻滚之后，对我有益的信息应该变少了。接下来应该主要以未明子的哲学视频为主，完善政治哲学方面的知识。</p><p>另外就是，水的很多数码、技术上面的事，其实根本就是同义反复（），所以尽量不要去跟这些话题。</p><p>到这里，还是非常的现象。我为什么会不停地看这些，但是根本不干活呢？</p><p><del>太jb烦了</del> 编程Lab令人头疼是真的。所以一直难以开始动工就是了。然后就落下的比较多了。</p><p>再往深入想一想，是不是根本就没有什么学习的动机？没有一点紧迫感是最要命的。近如现在是期中考试之前，我还是拿不出什么干劲来，甚至在考试前倒数第二夜通宵而什么都没有干。这种东西一旦松懈了，真的保不准什么时候才能把自己拉回正轨。</p><hr><h3 id="我给出的一点临时性的解决方案："><a href="#我给出的一点临时性的解决方案：" class="headerlink" title="我给出的一点临时性的解决方案："></a>我给出的一点临时性的解决方案：</h3><p>一是不用手机刷推特了。也不要再水群了，每天在20级群里面发个图就遁了。</p><p>二是期中考试过后就要好好睡觉，建立身体机制来保持较为良好的精神力。</p><ul><li>这可一点都不简单。有的时候自己想搞东西搞上头了，但是也要收住。我们在哲学上说，有限性是一个非常powerful的东西，甚至资本主义的秩序都是建立在各种有限性上的。</li></ul><p>三是为了免受各种消息的打扰，少发点动态吧，省得几秒就上去看一眼。。</p><hr><h3 id="一些长期性的东西："><a href="#一些长期性的东西：" class="headerlink" title="一些长期性的东西："></a>一些长期性的东西：</h3><p>一是多给自己上上紧箍咒。你难道没看到，五一出去玩的时候，wsy还在复习免疫学么？这样放松对自我的要求，怎么好意思待在南大呢？</p><p>二是要坚持哲学的学习。一方面审视自己，找出自身有什么毛病；另一方面坚定思想信念，获得精神上的动力。</p><p>三是，做任何事情都不要懒散；不要有一点不舒服就开始休息，要拿出顽强的意志力。多想想自己高考那阵子是怎么拼的，为什么现在不行？不要拿自己的年龄增长来说事，多鞭策自己。</p><p>四是要给自己创造良好的工作环境。有任何不舒服的地方短期要忍，但是长期的阻力不可估量。要多多改善环境，这才能保证高效。</p><p>比如，我现在虽然在打这段文字的时候感到有些疲倦，很想睡觉，但是还是能够坚持下来。不要一感到困就去睡觉，而是要和睡意的敌人搏斗。一上阵就缴械，感觉自己就不配叫合格的左翼。谨防在对待自己的事情的时候就变成右倾机会主义垃圾。</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于自由和极权的正确观点（转载）</title>
      <link href="/20210429_left_right_liberty_authority/"/>
      <url>/20210429_left_right_liberty_authority/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自知乎 <a href="https://www.zhihu.com/people/zhou-bo-wen-40">周博文</a> 的回答：<a href="https://www.zhihu.com/question/327694043/answer/1448756553">极左、极右到底是什么意思，看了好多网络搜索越看越迷糊，有通俗的解释吗？</a><br>转载许可：</p></blockquote><img src="https://files.tilnel.xyz/uploads/2021-04-29-repost.png" alt="repost.png" style="zoom: 80%;"><blockquote><p>所拟的标题，其原因在于答主阐述了“变革”的矛盾在于其自由目的与极权手段。以此将变革与“极权主义”所区别，击破保守的自由主义对于左派的“变革”力量的污名化。</p></blockquote><hr><p><strong>左&#x3D;激进</strong></p><p><strong>右&#x3D;保守</strong></p><p>极左&#x3D;极端激进</p><p>极右&#x3D;极端保守</p><p>直接代入公式不会错。</p><p>想通俗地稍微深入一点，往下看。</p><p><strong>左&#x3D;激进&#x3D;变革力量&#x3D;推动社会发展</strong></p><p><strong>右&#x3D;保守&#x3D;稳定力量&#x3D;保持社会稳定</strong></p><p>两者是矛盾的、冲突的，</p><p>两者又同时被社会需要。</p><p>就像开车一样，开得太快容易翻车，开得太慢又到不了终点。</p><p>说到这里，左和右，保守和激进的主体就很清晰了。“车”就是社会，“开车”就是社会运动（Social Movement），所谓左和右，就是车速快慢，即社会阶段运动。</p><p>那么这个速度是谁定的？</p><p>客观来说，是车的性能，也就是社会发展阶段，或者说生产力发展水平。</p><p>主观来说，是驾驶员，也就是占据统治地位的阶级。</p><p>在这个意义上，主观应该符合客观，而不是客观符合主观。驾驶员要就着车的性能开，一辆老旧破皮卡硬要开到200公里，那是会散架的，同理，柯尼塞格在八车道高速公路开20公里，无疑是一种极大地浪费。</p><p>问题是社会运动的进程，<strong>车能开多快、应该开多快，不同人有不同的理解</strong>。</p><p>有人认为120公里时太慢，有人认为80公里时太快，莫衷一是。好在按照正态分布，中间的人数是最多的，越极端（包括越激进和越保守）人数就越少。以多数人的观点为基准，比他们激进的就是左派，比他保守的就是右派。举个例子，10个人里8个觉得应该开100公里，1个觉得开120公里，1个觉得开80公里，那么在这10个人里面，120公里派就是左派，80公里派就是右派。如果有人觉得要开200公里，很简单，那他就是极端左派。</p><p>用上世纪的红色运动举例：</p><p>陈独秀右倾投降主义，说的是陈独秀对革命形势的估计过于保守，认为红色力量无法战胜白色政权，因此选择了放弃抵抗。他认为红色的车只能开20公里，旁边白色车虽然破破烂烂，但能开到60公里，还是可以的，所以自动让出了驾驶员的位置，加入白色车队。</p><p>王明左倾冒进主义，说的是王明对革命形势过于激进和乐观，认为红色力量能够快速夺取全国政权，立即实现社会变革，因此他组织红军进攻大城市。他觉得红色的车能开160公里，就开车跟白色车竞速，结果没开到80公里就散架了。</p><p>一般的左派和右派讨论仅止于此。</p><p>如果想继续深入，那就要从历史进程看了。</p><p>仔细想，大部分人觉得车能开到100公里，是不是说车真的就能开到100公里？</p><p>不是。</p><p>这就是主观和客观的不一致，而且是大众认知与实际情况的不一致，社会主流意识与历史发展水平的不一致。事实上，主观与客观完全符合的概率，是零，就像你从设计速度20-200公里中任选一个速度，刚好选到100公里的可能性虽然存在，但概率为零。何况你无法验证。</p><p>假如大众认为车能开到100公里，实际上车能开到120公里，那么其中大多数人才是右派，80公里派就成了极端右派，120公里派才是符合客观的现实派。又或者他们没有意识到自己开的不是车而是飞机，时速其实能达到1000公里时以上（这种情况并非不存在），那么所有人都是右派，而且都是极端右派。同理，也存在大多数人觉得车能开160公里但其性能只能达到100公里的情况，比如公社化运动。</p><p>这里的划分，与平时讨论的左右派是不同的。</p><p>平时说的左派和右派是以多数人的观点为基准的。虽然多数人的观点无法被确认，但是一时一地一群体的观点，还是能够大致被验证的。然而上面说的左派和右派不是以大众的观点为基准的，而是以社会运动的实际进程为基准的。<strong>前者是社会的左右派，后者是历史的左右派。</strong>但历史的派别无法参与讨论，因为它是历史的，激进派、保守派、极端左派、极端右派、中间派，每一派都认为自己是正确的，每一派都想证明自己代表历史的进程，是历史的现实派。然而谁才是历史的代表，只能被历史本身所证明。一辆车到底能开多快、应该开多快，只有到下一个阶段检修时才能被确认。</p><p>如果觉得我说清楚了，发出一个终极之问供你思考：</p><p>左和右讨论了激进和保守，那么方式和目的呢？</p><p><strong>你们一直在讨论车速，那用什么保证方向是正确的呢？</strong></p><p>答案是没有办法保证。</p><p>别说方向，就连目的地都没有办法保证。</p><p>所以你会看到无数主张不同车速、不同路线和不同驾驶方法的不同主义，同一个意识形态里都存在目的、方向和途径都完全不同的阵营。举个例子，如果你觉得红色高棉和TG只是车速不同，那就太天真了。反正对大部分人而言只是乘员，车总要往前开的，而我们都是中途下车，只要不是明天给你开下悬崖，目的地很重要吗？</p><p>很重要。</p><p>每一次的（社会运动概念上的）更迭、改良、革命，都是对目标和途径的一次审视。</p><p>人虽然无法确保目的和方向和正确性，却能感知大致的目的地从而规划路径，方法就是从人性中寻找。<strong>越符合人的天性，其主张和道德就越普适、越恒久，越能被坚持；越违背人的天性，其主张和道德就越狭隘、越短暂，越快速被抛弃。</strong>从人的天性中寻找普适恒久的特性，以当前历史和现实为基准加以修正，是我们接近目的地的最佳方式。</p><h2><a href="#yi-dian-mi-si-bu-zai-han-tong-su-jie-shi" class="header-anchor">#</a><span id="yi-dian-mi-si-bu-zai-han-tong-su-jie-shi">一点迷思（不再含通俗解释）</span></h2><h3><a href="#1-zi-you-x3d-you-pai" class="header-anchor">#</a><span id="1-zi-you-x3d-you-pai"><strong>1.自由&#x3D;右派？</strong></span></h3><p>自由和左派和右派没有必然联系。</p><p>高票的树神彧说极左是极端追求平等，极右是极端追求自由。这不能说是准确的。</p><p>左派和右派是一个对子，自由和极权是一个对子，两两之间只有特殊的或然的从属关系，没有普遍的必然的从属关系。如果一定要概括，那就是：<strong>从整个人类社会的历史看，自由为左派所有；从具体的历史时期看，自由大多为右派所有</strong>。</p><p>要说清楚这个问题是真的不简单。</p><p>对前一个命题，一句话解释即：<strong>自由是人性恒久的追求，是社会变革的目的和归宿。</strong></p><p>此处借用马克思的人性解放论作论证：马克思认为，人的全面发展即人的劳动能力的全面发展，是一种才能、素质、道德品质的充分的全面的发展。人的天性的规定了人对自由全面发展的追求，这种追求过程就是人性解放的过程。而在对立面，资本主义的劳动成为一种商品，剩余价值被粉饰为经营利润，作为再生产的基础；劳动对个体劳动者而言从内在特质，转变为一种外在过程，也就是说被异化了。当再生产成为劳动的唯一目的，不用于再生产的项目将不能占据任何时间维度（此处的“时间”是社会学意义的时间），劳动者的自由被剥夺了。</p><p>正是由于自由是人的天性，是人的内在追求，因此自由的剥夺与人的异化必定被暴力反对。<strong>任何社会变革，都是反对当前社会系统中违反人性的部分，支持和弘扬合乎人性的部分，其主张归根结底都是实现更高的人性</strong>（自由、平等），所以说自由是变革的最终目的和归宿。人们对自由、平等的质疑，更多是认为过于激进（车速问题），即当前的社会历史条件和生产力发展水平，还不足以支持和适应那些左派所鼓吹的那种程度的自由和平等，并不是说对自由和平等（以及美好人性）的追求是错误的。很少有人过于悲观地否认人类对人性解放和全面发展的追求能到达更高的阶段。因此自由是变革的目的。由此我们论证得出第一个命题：<strong>从整个人类社会的历史看，自由为左派所有</strong>。</p><p>但是我们还必须认识到，从具体的历史时期看，自由大多为右派所有。</p><p>为什么呢？</p><p>因为变革本身是矛盾的——<strong>变革的目的是自由，变革的手段是极权</strong>，<strong>左派在推动社会变革时，大力鼓吹自由的未来；右派在阻遏社会变革的同时，大力鼓吹自由的当下</strong>。而自由在手段上是无法战胜极权的，因此必须无论是左派还是右派，都必须以极权战胜极权。正如教员所说：</p><blockquote><p>战争——这个人类互相残杀的怪物，人类社会的发展终究要把它消灭的，而且就在不远的将来会要把它消灭的。但是消灭它的方法只有一个，<strong>就是用战争反对战争。</strong></p></blockquote><p>由于变革必以极权，因此其性质是暴力的，非极权的暴力无以扫清政治道路的障碍。“变革”，只在障碍既除、政治目的得以实现时才结束，变革的实现是以破坏现存的部分甚至全部生产关系为手段，其暴力程度比反对变革的镇压手段暴力程度更甚、严酷程度更甚。简单说就是为了实现更高自由，那就必须先取缔当前的自由。</p><p>举个例子，18世纪末被称为自由派的左派，随着革命进程的深入，变得越来越极权和恐怖，其顶峰就是以罗伯斯庇尔为首的雅各宾派，特长是吊路灯和斩首，在巴黎疯狂地处决旧贵族、右派，甚至是不够激进的左派，极左内部政见不合者。在当时，相比采取过激和恐怖政策的雅各宾派，右派的保守党如热月党人反而成为自由的支持者。</p><p>同理，当前世界的英美资本主义，其右派通常是保守的自由主义者，亦称资本主义式自由者，比如支持个人持枪、反对管制和反对外在分配。其主张是无疑是自由派的。但要清醒地看到：自由是其反对社会变革的借口，当政府推行自由和平等的改革时，他们是持枪来反对的。</p><p>结论：正如辩证法既为唯物主义所有又为唯心主义所有一样，自由和极权作为对子，不为左派或右派所独有。</p><h3><a href="#2-ji-zuo-de-gui-su" class="header-anchor">#</a><span id="2-ji-zuo-de-gui-su"><strong>2. 极左的归宿</strong></span></h3><p>对于极左的问题，教员在湖南农民运动考察报告开篇就说了：每个农村都<strong>必须造成一个短时间的恐怖现象</strong>，非如此不能镇压农村反革命派的活动，决不能打倒绅权。这是因为：</p><blockquote><p>革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。</p></blockquote><p><strong>矫枉必须过正，非过正不能矫枉</strong>。这句话概括历史以来极左与极右的斗争。</p><p>从人类历史的进程看，左和右对立统一，寓于社会运动的进程中。这个进程是螺旋上升的过程、循环往复的过程，左是上升，右是螺旋，或者说保守是常态，激进是非常态。他们不存在天然的平衡状态，要么是左压倒右，要么是右压倒左，原因就在于矫枉必须过正。从王朝更迭的进程看，既得利益者天然反对变革（得利即右倾），利益的积累同样有加速过程，会随时间向上集中；但这并非单向的，在利益向上集中的同时，变革力量也在向下沉淀（失利即左倾），普通的改良不能逆转只能延缓这个过程。任何试图逆转利益流向的行为都会被既得利益者暴力镇压，即：变革力量在彻底战胜镇压力量之前，变革派的利益诉求都会被压制，不会得到满足。最终，当变革力量超越镇压力量时，更迭就爆发了，正如为了抵御洪水而不断加高堤坝，那么当洪水最终摧毁一切障碍时，必定是长驱千里，绝无半点温和可言。</p><p>极左由于代表变革诉求，内在和本质决定了其不断加速的特点。只是随着社会文明程度变高，手段变得更温和，在清理进程中从倾向肉体毁灭进化为人格毁灭而已。在法国大革命中，作为发起者的吉伦特派就是典型左派，是信奉自由主义工商业阶层，他们联合无套裤汉组成反封建政权，以推翻国王为目标，与封建右派作斗争，应该说是自由激进的。然而随着革命进程的深化，左派提出的主张愈发激进，吉伦特派的主张已经无法满足下层人士的需求，他们主张的是一定限度的经济自由和管制，对现状感到满意；而下层人士要求完全的经济自由和社会平等，继续革命。此时，在“要不要继续革命”的问题上，大革命发起者吉伦特党人就从左倾变为右倾，吉伦特派已无法驾驭自己调动起来的变革力量，或者说他们被革命抛弃了，于是更激进的雅各宾派上台。为了清扫政治障碍，把大量吉伦特派支持者送上断头台。由此，左派将被极左击败，激进将被更激进击败。（广义的雅各宾俱乐部包含甚众，吉伦特派本身就属于雅各宾党，但我们通常所说的雅各宾派是指从雅各宾俱乐部中与吉伦特对立的山岳派发展出来的、以罗伯斯庇尔为首的极左团体）。</p><p>雅各宾各党派对于革命应该进行到什么程度的分歧极大（在此最激进者当属巴黎公社“不断革命直到社会主义的实现”，与此类似，红色时期的中国托派主张也被简化为“革命到鸭绿江边”）。这一方面为了集中力量打击反革命势力，保证革命成果不被篡夺，另一方面则是要把革命的领导权牢牢地掌握在本派别手中，保证自身不被更激进的革命党人清洗。当变革进入到极左自我清洗的程度，其手段是极其严肃和恐怖的，其内部斗争的惨烈程度远高于外部斗争。因此在丹东派提出放松恐怖政治时，埃贝儿派主张更严厉的恐怖政策（明面上说的是“对保皇党和反革命势力更彻底的制裁和打击”），于是丹东派迅速失势，其上层被处决。而埃贝儿派和巴黎公社又被更激进的罗伯斯庇尔打倒，他提出的“制裁人民公敌”的法令可以令所有自称极左的人汗颜：取消其他刑罚，判决成立一律处死；没有预审，只有终审，不允许辩护；判决无需证据，法官判定一律生效。于是法令颁布后48天内，巴黎断头台下砍死接近1400个人。</p><p>当左派决意集中一切力量去推动社会变革和攻击反对变革的右派时，这股力量必然会被极端的左派利用，进而被最极端地左派掌握，进而成为最极端左派中专政者专权的手段，成为排斥政见不合者甚至是屠杀异己的工具。</p><h3><a href="#3-ru-he-che-di-da-dao-you-pai" class="header-anchor">#</a><span id="3-ru-he-che-di-da-dao-you-pai"><strong>3.如何彻底打倒右派</strong></span></h3><p>我们要从极左的归宿和右派的开始说起。</p><p>左派代表的是进步的未来，天然地不被怀念。因为成功的变革就是使社会向人性之善更进一步，而这种变化由于合乎人性，会被变革后的世界认为是理所当然，没有丝毫的不适。而变革过程中的恐怖却会深刻地铭于社会意识，成为集体无意识的一部分。左派在不断加速中，以极权打击了反对变革的分子，维护了自身的领导权和变革的纯洁性，与此同时也在将自己送入极左的道路，不断与社会大众剥离，成为“孤家寡人”。其结局只有一个，就是在威权结束之时迎来右派的大反扑。</p><p>人不能怀念将来，只能怀念过去。极左的归宿，就是右派的开始。罗伯斯庇尔可以称得上是全人类历史上最激进的左派，但正因为他的激进无人能及，他的统治也极其短暂。在恐怖法令持续仅仅一个月后，他就被右派的热月党人用断头台斩杀，和斩断1400人脖子的断头台大概是同一个。临行的他突然发现自己早已成了少数派，连送他上路的人都零零星星。保皇党由此复辟，法国陷入长达百年的左右派的反复拉锯。</p><p>在这种你压倒我、我压倒你的拉锯中，右派是有锚点的，而左派没有，左派只有前进一途，换句话说右派知道自己想回到什么样的过去，左派不知道自己到达什么样的未来。做个思维实验：如果你问“人工智能发展起来了吗？”现在很多人大概会说还没有。但事实上，人工智能在上世纪80年代就已经取得长足的发展，你手机里的自动响应程序、聊天机器人、游戏里的AI玩家都是弱人工智能，只不过你在生活中接触到时，已经不认为它们是人工智能，人工智能一直是“很新的东西”。1997年深蓝战胜卡斯帕罗夫震惊世界，彼时深蓝还是两层楼高的大家伙；到了2007年，连一部普通民用手机的内置软件都能打败卡斯帕罗夫，人们却觉得理所应当。世事如此，变革亦然。新世界的人类对变革的成果和进步视为理所当然，他们对“过去”不心存恐惧和厌恶，反而有怀恋和不切实际的向往。</p><p><strong>变革过程中右派的失势是暂时的，只有变革过后旧右派的失势才是永远的。右派曾经掌握着社会的权力和秩序，代表着旧世界的记忆和影子，因此他们拥有极为强大的强大的潜在势力，随时会发起反扑，直到这种能量被完全消耗殆尽</strong>，外在表现为顽固与反复。</p><p>对于如何彻底打倒右派，变革者作出了无数尝试。其中最有效、最开明、最王道、最根本的方法，是把生产力发展水平提高到右派秩序无法容纳和适应的程度，让右派失去社会的历史的基础，再无立足之地。就像铁器和农具的推广，彻底摧毁了盘踞中国两千年以上的奴隶制。在TG的社会主义改革中，大炼钢铁等跃进运动，恐怕也有类似的考虑。再做一个极端的假设，假如今天核聚变技术研究成功，十年内恐怕现存的所有落后体制都会灰飞烟灭。这叫降维打击，<strong>当右派代表的生产关系与生产力脱节太过分，他们会自动被埋葬在历史的尘埃之中，由历史亲自动手</strong>。</p><p>然而大部分的左派，他们的先进性还不足以让右派自绝于历史，甚至有时他们本身就比右派更不符合历史发展的水平，此时打倒右派就只能采取一般的斗争方法：宣传、集权、肉体消灭、人格毁灭，请对号入座。当然这一套方法右派也能用，不过由于右派代表当前的社会秩序和保守的变革观，对宣传进步思想和发动人民有天然的恐惧。比如针对外来侵略，唤醒民众意识、开展人民战争是有效对策，但右派常常对此持有消极态度，不敢发动群众。因为“唤起民众”对左右双方的意义是不同的，对左派而言，叫散播火种，对右派而言，是为自己掘墓。何况维持社会稳定和秩序是右派的天性（“在乎些坛坛罐罐”），这不允许他们在体制上采取比左派更激进的手段，但凡在这一点上作死的右派都在实质上加速旧秩序的崩溃。</p><h3><a href="#4-xue-hui-xian-shou-di-kou-shang-mao-zi" class="header-anchor">#</a><span id="4-xue-hui-xian-shou-di-kou-shang-mao-zi"><strong>4.学会娴熟地扣上帽子</strong></span></h3><p>左派和右派的反复拉锯，不独法国大革命，中国也普遍存在，其中时间最持久的当属春秋战国的百家争鸣。百家争鸣成体系的学说很多，归类比较困难，如果你能以左右派的视角作出分析，就会发现其观点主张分野异常清晰。</p><p>以简单粗暴的左右观来划分，四大显学中（严格意义的显学特指儒家和墨家），儒家是右派，道家是极右，法家是左派，墨家是极左。以此剖析其学派性质和主张异常有效。</p><p>首先，从生产力与生产关系、经济基础和上层建筑的基本情况上看，春秋战国处于社会转型和阶段性运动时期，奴隶制的生产关系和社会关系，已不适应当前的生产力水平，导致政治动荡和战乱频发。因此，社会变革将持续进行，直到生产力发展的要求被大致满足为止。<strong>儒墨道法的不同主张，直接动机是结束乱世，实质目的是为社会变革提出一个方向和程度的指导。</strong></p><p>其中儒家是右派，观点偏向保守，他们主张的是上一个时代的统治秩序，这个制度的外在表现是“礼”和“乐”，内在核心是等级阶层；他们认为乱世之乱，根源在于“礼坏乐崩”，所以我们要“克己复礼”，回到过去。这种观点是保守的和反动的（反对社会运动，或者说反对变革），他们没有注意到生产力已经发展到旧的生产关系无法容纳和适应的程度，提倡旧的生产关系已不可能，所以儒家在当前结束乱世的任务中他失败了。（以后他们会因为右倾的特点而复辟）</p><p>道家相比儒家，更反动、更保守，儒家克复的对象是周礼，道家克复的对象，是自然。他们反对人类社会一路以来建立的秩序、阶层和组织，主张回到三代以前的原始生活状态，小国寡民、无为而治、自由恣意。这种回卷已经极端到了近乎消极的地步，因此他们只是宣称回到自然的状态就会由乱而治，甚至没有在推行自己的主张上做过太多努力。这倒是和资本主义的田园派类似，反对一切工业成就，主张回到田园生活。只不过这种类型的极右太消极，连反对变革的力量都不具备，只能从个体内部着手，寻求自我的超脱。</p><p>儒道两家的克复，有一个精神的幌子，叫“三代以前”——尧舜禹，或者说尧舜。他们认为世道每况愈下、风气愈古愈纯的理论支柱，就是上古存在一个理想世界。但我们从社会历史的角度分析，那个上古的理想世界其实就和伊甸园一样根本不存在，实际上如果尧舜真的存在，他们的人们肯定以部落群居，通过半采集半耕种的方式挣扎求生，一部分茹毛饮血、时猎时迁，一部分尝试改良作物、驯养禽畜。和这种基本生存无法保障、每日都处于死亡边缘的上古时期相比，在井田里当农奴也算得上天堂了吧。儒家设想的大同社会，绝不可能存在于生产力极其落后的上古，只能存在于生产力极度发达的未来，这个未来只能通过漫长而反复的变革达成。通过反对变革，使社会倒退，回卷到理想的大同状态，那就是四个字：<strong>南辕北辙</strong>。</p><p>再说下左派。</p><p>很多人肯定会不理解，为什么法家是左派，而墨家是极左，不是应该反过来吗？</p><p>此处我必须引用一下自己：</p><blockquote><p>左&#x3D;激进<br>右&#x3D;保守<br>极左&#x3D;极端激进<br>极右&#x3D;极端保守<br>直接代入公式不会错。</p></blockquote><p><strong>判断左和右、极左和极右的标准只有一个，即其主张是激进还是保守。</strong>主张指向目的，这是根本，而手段不是。法家的手段确实极权和恐怖到了极点，但是在观点主张的激进性上，他们比墨家差得太远了。</p><p>法家主张“以法治国”。不过这个以法治国，从概念上和观念上，都和今天的“依法治国”完全不同。否则我可以直接把他打成极左派（笑）。法家的法，是刑罚（或赏罚）的意思，以法治国，就是用刑罚治理人民：你不按我说的做，我就收拾你，不管你是谁，我都要收拾（法不阿贵,绳不挠曲，刑过不避大臣，赏善不遗匹夫），我说得出做得到（徙木为信）。他本质上是统治者凌驾被统治者的一种手段，是驭民之术、权谋之术，在今天看来是相当落后、反动和反人性的，但在当时他是进步的、正动的，符合生产力发展水平和时代变革要求，所以他成功了。法家至少做到了几件事：</p><p>第一，打破了绝对的阶级和威权（打仗立功封爵，旧贵族的身份垄断被打破）；第二，极大地解放了生产力（废除井田、奖励耕战、赏赐耕地，土地私有后耕作积极性提高了）；第三，完成了新生产关系下的集权（其他国家很早就开始废井田、开阡陌，不过生产关系已经革新、上层建筑还是旧的，君主无法集权）。而且法家特别反对克复回卷，坚持治道不法古。做到了以上几件事，旧贵族很快死到了一边去。可以说法家是战国时社会的左派、历史的现实派，活该他成功。</p><p>不过法家无论是个人还是集团，都承受了右派强烈而漫长的反扑，直到将近200年后才基本平息。这里多说一句，军队是最适宜法家推行的地方，赏罚分明、令行禁止，不讲人性道德，只讲规则服从。这种机械的赏罚观持续了近两千年，到教员的手里才被打破。教员在红军里废除军饷制时，许多人（包括朱总、林总、彭总）都强烈反对，许多人都觉得他疯了。改革结果是军队管束不靠打骂，从士兵到将官不领粮饷，从战斗员到一般指挥员甚至司令员，吃一样的，用一样的，都可以参与政治和军事的讨论，此时人们才发现超越时代的体制原来是这样的。在这个领域，教员可以说是极左中的极左，然而军队和社会不同，是可以片面地极左和极右的，所以这支军队不仅能存在，而且能对伪现代军队实现降维打击。</p><p>法家的思想虽然进步，但糟粕也很多，像什么提倡肉刑、严刑峻法、什伍连坐之类的，在当时还好，现在看来保守落后野蛮之极。春秋战国说极左，还得看墨家。墨家的左，左到两千两百年后的我们看还觉得不切实际。孔子说仁爱，那还是一种有差别的爱，它的底层是等级和亲疏；墨子说兼爱，那就是无差别的爱了，它是反对阶层、等级、亲疏的，底层是平等。问题来了，对当时的社会而言，韩非的理论都算进步，墨家的兼爱得激进到什么程度！那时的社会历史条件，能支持墨家实践兼爱吗？显然不能。</p><p>墨子看到了自身主张的空想性。因此，他从兼爱出发，精心设计了墨家十律，为兼爱的理想提供具体的、实践上的指导，要求墨家门徒（墨者）身体力行。深入分析十律，其进步性和实践性固而有之，但从底层上还是在靠极权体制和集权手段在强推。尚贤和尚同，实际就是墨家倡导组织政权的形式：选举出天下最“贤”的人，大家与他保持一致。为什么墨家非要“一致”不可，“尚同”能不能妥协？这就问到问题的关键了，墨子说不能。如果说兼爱是墨子理论的核心，尚同才是实现兼爱和平等的手段，尚贤只不过是为尚同指明方向而已（至于非命、节用、节藏等，就更加是细枝末节了）。尚同提出的是下级同于上级，上级同于更上级，逐渐上同，最终天下同于“贤”，再由“贤”推行兼爱，实现墨家的终极理想。所以墨家的组织和纪律十分森严，集团内部实行一定程度的公共财产和共同劳作制，儒家形容墨者“摩顶放踵，而利天下”；钜子拥有非常大的权力，是墨家门徒精神和物理的双重领袖，法家形容墨者“赴汤蹈刃、死不旋踵”（也有为自己的“法”背书的目的）。相比儒家、道家，墨家更像一个中古时期的宗教，钜子在设计上代表了此世所有“贤”的集合，是贤的顶点、理想的化身，不尚同就是不尚贤。在外部，你不尚贤，墨者让你尚贤（墨辩）：钜子已经是最贤的人，你还不跟他保持一致，难道要我们跟你保持一致吗。在内部，你不尚贤，墨者帮你尚贤（墨法）。</p><p>墨家失败的原因，很简单就是太左了，也太理想了。这导致当时的生产力水平完全无法支持他主张的社会变革、生产关系和理想，注意到这个问题的墨子一面进行提高生产力的尝试，一面开始用组织约束力强行推动变革。但还是留下了尚同和尚贤的隐患，在墨子在世的时候这个问题还不大，他本人类似于耶稣行走，但其接班人又有什么能力和品行自称贤、让墨者同呢？所以墨子死后，墨家集团迅速分裂并且分崩离析，出现多位钜子，他们都只能说是一个墨家小团体的首领，再没有一位全天下墨者共同的钜子了。墨家的下场也是比较惨的，因为领先时代太多，右派毫不费力就将其湮灭在历史中，而封建王朝右倾的统治路线决定了极左的墨家没有任何利用价值，在两千年的更迭进程中再没有墨子学说的任何位置。</p><h3><a href="#5-dang-shuang-biao-gou-zuo-liang-mian-ren" class="header-anchor">#</a><span id="5-dang-shuang-biao-gou-zuo-liang-mian-ren"><strong>5.当双标狗，做两面人</strong></span></h3><p>高票答主培根煎蛋说了一个很有趣的观点，让我引用一下：</p><blockquote><p>在2020年的今天，有一些很明显的判断标准：<br>·左派认为不应该分国籍和人种，外国人和少数族裔应该享受相同权利，而右派坚持自国主流族裔优先。<br>·左派支持LGBT，女权，废除死刑等较新的社会意识，而右派坚持传统价值观。<br>·左派希望财富分配能够照顾到底层人民，右派却觉得多劳多得，自己不努力不要怪社会。<br>但是实际上这个标准并不通用，因为人类的本质是双标狗……所以划分左派右派是很没有意义的，因为一个人不可能保证他无论在地球任何地方，任何时间都是主流人群，所以每个人都会有成为少群弱势群体的时刻，针对社会议题的倾向也会改变，我称之为“左右派混合态”。</p></blockquote><p>按这个说法，一般人是无法被划分左派和右派的，或者说这个划分没有意。</p><p>是不是这样呢？</p><p>我认为不是，这个说法不能说是准确的。第一是他把实质和表征搞混了，第二是他把极端和少弱搞混了。</p><p><strong>政治观点只是表征，社会阶层利益才是实质，所在阶层的得利或失利程度决定激进或保守程度，大致地决定了个人的左和右的位置。</strong>也正是因此，观点分左右，个人也可以持有左右不同的观点——只要合乎自身利益。或者反过来说，个人决定观点时永远先从利益和目的出发，而不会考虑观点本身是激进还是保守。但人不能同时是左派和右派。</p><p>一个人不能同时是左派和右派，一个人不会因为同时持有左派的观点和右派的观点就变成左右混合派或者骑墙派。即使一个人持有九十九种右派观点和一种左派观点，他也不一定是右派，有可能是左派，甚至极左。如果你从表征（观点）分析，你永远弄不清楚一个人的派别，你只有从实质分析，才能确定，也正唯有这点能决定他是左派还是右派。</p><p>那么这个“激进保守程度”是由什么决定的？有很多因素，但起决定作用的是所处社会阶段所代表的利益（还是利益），规律也很简单，越穷越左，越富越右。得利者总是希望维护现有体制而反对变革，失利者总是希望打破或至少改良现有的体制而推动变革，这种情况在社会总体稳定、政治清明之下会演变为毫厘必较，而虹吸效应加剧了利益极端化的速度，使变革力量迅速增长，这是封建王朝由盛转衰的关键节点——健全而完善的体制下利益向上集中反而是加速的，资源优势者无论是向上发展和向下盘剥，无论是承受风险还是玩弄规则，都比下层娴熟多了。这也是答主培根煎蛋说得不太准确地第二点，少弱群体和极端没有必然关联，极端在于得到和失去利益的严重程度。少群（minority）被认为是易损失利益者（vulnerable)，因此被默认为左派，但实质上在少群在被保证话语权力的情况下，更像是披着左派的外衣的右倾者。从世界的历史的情况看少群对进步的革新的追求和实质努力，我觉得要打一个呵呵的问号。</p><p>由此，判断一个人是左派和右派，直接考察其所处阶层代表的利益，是大致准确的。虽然由于个体的经历、观念、理想、信仰等，会出现与所处阶级利益相差甚远乃至完全背离的情况，但一来这需要具体情况具体分析，二来完全背离本阶级利益后他实质上已不属于原阶级了，三来是这种情况并不多见。当此分析上升到群体，个人的特点就被完全抹平，剩下的就是赤裸裸的阶级利益，这过程如同从事物的普遍性中寻求特殊性一样。而且这个群体是紧紧跟随阶级利益的，不因其中个体的观念和志趣而转移。举个例子，解放战争时期的城市工商业者，他们本来是变革的反对者和现有秩序的维护者，在金圆券发行、民国政府信用破产之后，大部迅速左倾。无论你喜欢什么颜色，现在都变成红色了。</p><p>有了解题思路，我们来做一下答主培根煎蛋的题：</p><ul><li><p>一个生活在美国的华人直男，他可能希望改变亚洲人作为少数族裔的地位，但是同时又对LGBT极其厌恶。</p></li><li><p>一个生活在中国的女权主义者，她可能想要改变男权社会附加在女性身上的枷锁，但同时觉得底层男性比蝼蚁还没价值。</p></li></ul><p>信息非常有限，因为没有他和她的社会阶层情况，无法展开利益分析。</p><p>但我可以鲁莽地判断，前者在美国、后者在中国，都轻度右倾，属于小右派。</p><p>为什么？因为他们的诉求停留在个人志趣和直接群体的基础上，是对大的利益分配中的小利益的小修小补。从诉求表述上，看似激进实则十分保守，很可能属于既得利益者但得利十分轻微。在实际的社会变革中，他们往往被忽视、被要求保持中立，不具有被争取的价值。</p><p>真正要求变革的人和真正积蓄着变革力量的群体，真正保守并拥有着镇压力量的人，因极端而获得力量，他们的诉求不是这样的。</p><p>最后，我提供一下几个人的出身和阶级利益，供分析参考。</p><p>老子：前朝大贵族；分封型奴隶主。</p><p>孔子：小贵族；旧贵族（士大夫）。</p><p>韩非：小贵族；新贵族。</p><p>墨子：农民；农民，手工业者。</p><hr><h2><a href="#guan-yu-yi-xie-zhi-yi-de-ji-zhong-hui-ying-li-bian-er-ming" class="header-anchor">#</a><span id="guan-yu-yi-xie-zhi-yi-de-ji-zhong-hui-ying-li-bian-er-ming">关于一些质疑的集中回应。理辨而明。</span></h2><p><a href="http://www.zhihu.com/people/8967ba474f3a30cd9eb786ea4bf08134">@朱成蹊</a></p><p><img src="https://files.tilnel.xyz/uploads/2021-04-29-question1.jpg" alt="question1.jpg"></p><p>由于这段话的逻辑比较混乱，我们<strong>首先提取他驳论的观点：</strong></p><p>\1. 【没有单独存在的“左、右”的政治概念】</p><p>\2. 【没有任何参考语境的“左”或“右”的见解是对政治系谱的简化粗糙的认知】</p><p>\1. 对于第一点驳论的驳论：文章中从来没有提出过所谓“单独存在的左右”，非但如此我更强调左和右是相反相成、对立统一。区分左派和右派的方法，天然具有参考系的（即社会与历史的）；</p><p>\2. 对于第二点驳论的驳论：既然左和右是基于社会大众认知或给予历史认知的，我们就可以基于社会和历史作出判断。左与右本身有政治意义，否认政治学上的左与右的内涵，把规律视为现象，才是粗糙的认知。</p><p><strong>其次，我们驳斥他的主要论点。</strong>论者认为，左和右本身是没有意义的，只有赋予到具体的政治学称谓才有意义。<strong>简单地概括，论者认为必须具体地定义“左派、右派、左翼、右翼、左倾、右倾、极左、极右”，而不能从左和右的语义去理解它。</strong>可惜这个观点是完全错误的，不仅左与右本身有内涵语义，而且“左翼、右翼、左倾、右倾、极左、极右”都是从左和右的语义场中延伸的，是本源和派生的关系，下文将论证。</p><p>我们再分析他的所谓的“定义”：</p><blockquote><p>\1. 左派和右派的国际标准定义是倾向变革者和倾向保守者；<br>2.左翼和右翼是右派的内部进步亦或滞后的划分；<br>\3. 左倾和右倾指的是在思想组织上和行动上倾向于盲斗或妥协；<br>\4. 极左或极右分别指的是在政治斗争和思想辩论上打倒一切，毫无顾忌，和在政治斗争和思想辩论上主张维护传统社会制度和保护一切既得利益者的传统利益。</p></blockquote><p>【若忽略定义中明显的谬误和疏漏】，仅用文中提出的：“左&#x3D;激进&#x3D;变革力量&#x3D;推动社会发展，右&#x3D;保守&#x3D;稳定力量&#x3D;保持社会稳定”的观点去理解他们，有明显不符或不适合吗？没有。</p><p>所以论者等于把文中主张的分析思路重复了一遍，实在看不出他是在反对自己还是支持本人。而从正向角度走，这些被他认为只能单独定义和划分，不能用左右内涵“简单粗糙”理解的词语，实际上是由左右历史而来的。</p><p><strong>最后，我们指出语段中的谬误：</strong></p><p>\1.  【左派和右派的国际标准定义是倾向变革者和倾向保守者】</p><p>根本不存在国际标准定义（ISD），左派和右派的指称是约定俗成的，和语言任意性一样。</p><p>\2. 【左翼和右翼是右派的内部进步亦或滞后的划分】</p><p>完全是瞎定义。</p><p>左翼和右翼不从属于右派。通俗点，左翼和右翼不是包含在右派里面的，也不是他想象的、右派里进步团体是左翼，滞后的是右翼。<strong>左翼和右翼，左派和右派，在实质上的等同的</strong>。左翼&#x3D;左派，右翼&#x3D;右派，不区分语用时可以混用。</p><p>那么严格来说有什么不同？语义指向上左右翼更专有，原因是“the Left Wing”的用语源自法国大革命中的山岳派（与雅典民主时期的山地党异曲同工）。他们坐在议会左首，自称Liberal Left Wing，因此与之对立的团体被称为the Right Wing。此概念在东亚首先被日本翻译，通常限于议会政治中，是党争浓度比较高的用语，所以不及左派和右派泛用，但在议会政治以外并非不可以。举个例子，左翼进步作家团体。</p><p><strong>按论者的说法，“左翼和右翼是右派内部进步亦或滞后的划分”，那周树人的左翼作家联盟，本质上岂非是右派？</strong>容我一笑。</p><p>将左翼和右翼当成是右派中的两个小群体，显示出论者实在缺乏基本政治概念，也是我之前看到这里觉得有点乏力的原因。</p><p>\3. 【左倾和右倾指的是在思想组织上和行动上倾向于盲斗或妥协】</p><p>完全是瞎定义。</p><p>论者可能是看了我对陈独秀主义和王明主义的论述仿写出来的，如果不是，这种理解的解离破碎度也太高了点。左倾和右倾，指的是表现出来对左和右的态度和发展倾向，即支持变革和反对变革的倾向。举个明白的例子：</p><blockquote><p>以上海为例，美国灯泡在上海的售价为法币200元，而国产灯泡仅成本就在400元以上，美制六尺车床的售价为20万元，而国产成本却要120万元。所以46年上海工厂倒闭了四分之三，47年沈阳3000家工厂倒闭超过2000家，48年青岛所有工厂全部倒闭，平津两地倒闭的工厂数达到四分之三。<strong>本来民族资产阶级是中间派，这时候迅速左倾，成为左翼，纷纷开始反对国民党走上缓则的道路</strong>。</p></blockquote><p><strong>按论者的定义，“左倾指的是在思想组织上和行动上倾向于盲斗”，那民族资产阶级迅速左倾岂不是说民族资产阶级迅速盲斗化？岂不是说左翼民族资产阶级倾向于盲斗？</strong></p><p>\4. 【极左或极右分别指的是在政治斗争和思想辩论上打倒一切，毫无顾忌，和在政治斗争和思想辩论上主张维护传统社会制度和保护一切既得利益者的传统利益】</p><p>基本上瞎定义。</p><p>我们先忽略“保护一切既得利益者的传统利益”和文中观点的相似程度，从行为上定义极左和极右，这是走入歧途。由人组成的派别中，人的行为主张千形万状，不可穷述，因而对群体行为进行归纳，才能接近实质（关键点我已经说了，激进、保守）。</p><p><strong>极左，按照论者的说法，“要打倒一切，毫无顾忌”，那么极左的巴黎公社，他们要不要打倒自己TG主义最高理想？他们要不要顾忌雅各宾俱乐部各派别上层，要不要顾忌保皇党人反扑，要不要顾忌内外清洗的社会影响？</strong></p><p><strong>极右，按照论者定义，“主张维护传统社会制度和保护一切既得利益者的传统利益”，那么既得利益者有没有非传统的利益？要不要保护他们的非传统利益？保护一切既得利益者是不是意味不可放弃轻微得利者？</strong></p><p>这些所谓定义，认真起来稍一深究，都是千疮百孔，无法自圆其说的。</p><p>从论者对“左派、右派，左翼、右翼，左倾、右倾，极左、极右”四对概念的定义，每一个都有严重谬误看，就能知道作出标准定义的难度。<strong>像论者这样的机械式解释，恐怕才是对政治系谱的简化粗糙的认知。</strong></p><p><a href="http://www.zhihu.com/people/be4f35eea59b96d9229ed1cb19a4c9d3">@靜水微瀾</a></p><p><img src="https://files.tilnel.xyz/uploads/2021-04-29-question2.jpg" alt="question2.jpg"></p><p>对于不看文章直接反驳的情况，无力感Max。教员说我们不能自以为老子天下第一，你们都是错的，要虚心听取别人观点。一直以来我都以此自勉。提取观点，开工。</p><p><strong>一、</strong>【在中国，左和右的含义又不一样，比如右派一半（原文如此，应为“一般”）是指自由主义者，这可不能说是保守】【实际上在中国语境的左右含义就是有所不同，不能套进你的那个公式】</p><ol><li><strong>谁说的在中国右派一般是是指自由主义者？</strong></li></ol><p>反动右派指的是自由主义者，还是革命反对者和社会运动逆向者？</p><p>打倒右派的指向目的是打倒自由主义者还是打倒反革命分子？</p><p>按论者的说法，反对右派岂不是自由主义者？打倒右派岂不是打倒自由主义？</p><p>问题来了：从1957年TG中央《划分右派分子的标准》到1978《关于全部摘掉右派分子帽子的请示报告》，从反右和反反右，自由主义什么时候跟右派绑定在一起了？这可是最具中国特色和中国语境的文件，那么右派分子怎么和自由主义者联系在一起？如果</p><p>“右派一般指自由主义者”，这句话如果反过来再放在世界范围说，“自由主义者一般是右派”，我还姑且承认有正确性。说“在中国，右派一般指自由主义者”根本就是无稽之谈。在中国，右派一般且广泛地指称是反革命者，反对改革者，反对社会运动者。反右时期由于教员研判当前是建成社会主义社会的时期，因此资、修、民资一律等社会的右派一律被打成反革命。连这一点都不理解，就妄谈中国语境。</p><p><strong>2. 谁说的自由主义者不能是保守？</strong></p><p>我文中已详述，论者不看，我就再重复一次。</p><blockquote><p><strong>自由和左派、右派没有没有普遍的必然的从属关系。</strong><br>变革的目的是自由，变革的手段是极权，<strong>左派在推动社会变革时，大力鼓吹自由的未来；右派在阻遏社会变革的同时，大力鼓吹自由的当下。</strong><br><strong>当前世界的英美资本主义，其右派通常是保守的自由主义者，亦称资本主义式自由者，比如支持个人持枪、反对管制和反对外在分配。其主张是无疑是自由派的。</strong></p></blockquote><p><strong>“右派一般是指自由主义者，这可不能说是保守”这句话荒谬到什么程度？在政治派别的分野中，一向存在保守自由主义派。</strong>法国民主公民运、丹麦自由党、波兰新右会、德国自由民主党，都是典型的保守自由政党，甚至广泛意义上美国共和党也是保守的自由主义。在主张上，他们的主张兼具“社会道德的保守”和“经济活动的自由”，以此延展到“法律法规的保守”和“公民生活的自由”。至于他们政治诉求的本质，用引文的一句话破解即可：右派在阻遏社会变革的同时，大力鼓吹自由的当下。所谓的经济自由，是既得利益者用以排斥公权力干预利益分配的口号，所谓社会道德和法律法规的保守，是既得利益者利用公权力阻碍变革的借口。自由主义和保守主义，天然地就可以结合在一起，连这一点都不理解，怎么能对右派作保守和激进的判断呢？</p><p><strong>二、【变革必以极权？世界史的反例也有不少，不是只有大革命，也还有光荣革命那种东西】</strong></p><ol><li>为什么一直举法国大革命的例子？</li></ol><p>当然不是世界上只有法国大革命，而是因为：左和右的分野本身就滥觞于法国大革命，而且其进程太典型而易于分析。当然只要严格社会历史条件，我们可以用左和右的观点去对左右概念还未出现的社会运动作剖析，我也是这么做的，比如春秋战国的阶级分析。</p><p><strong>2. 为什么说论者对光荣革命本身缺乏认识？</strong></p><p>当然不是我在人身攻击。</p><p>光荣革命属于十七世纪英国议会革命的一个进程，也是终章。如果要类比，就是”英国议会革命对应法国大革命，光荣革命对应法兰西第三共和国建立（1870年资产阶级共和派与保皇党，在上院握手言和，共建法兰西第三共和国）把英国光荣革命单拎出来，以为革命可以不经过流血和斗争，以为民众自发的力量足以推翻阶级威权，这种想法是很天真的。</p><p>英国议会革命，在进入光荣革命之前，同样是经过左右派的反复拉扯的：从国王查理一世被断头，极左独裁者克伦威尔专政（一个罗伯斯庇尔式的人物），到护国公克伦威尔倒台枭首，詹姆士二世复辟；再到詹姆士二世倒行逆施，实行极度保守的右倾政策并迫害清教徒，到最终詹姆士二世被锐“民众”推翻，流亡法国，资产阶级新贵族取得阶段性胜利。每一次压倒都迎来反扑，每一个强权都最终妥协。</p><p>为什么光荣革命不流血？因为之前已经流太多的血了，统计一下从新贵族反乱到詹姆士二世垮台之间七十年，打过多少内外战争。遥相照应，法国大革命时期也是外战不断，左派上位的一个很有力的支持，是相比保皇党的软弱，他们外战能力更强。</p><p>为什么英国议会革命进程比法国大革命短？因为法国是因为启蒙运动作为先导，思想进步性更强，天赋人权、平等自由的观念深入人心。英国则是资产新贵自发的为争取权益而发动的革命，自觉程度低而妥协程度较高。孰优孰劣实在不好评判，时至今日，法国可以宣扬人人平等，英国则是女皇在上。</p><p><strong>那么英国议会革命，以及光荣革命，真的是非极权的变革吗？</strong>不是。</p><p>即使不考虑英国议会革命的总进程，单从光荣革命本身来看，其推行都是以极权手段，而且是高度的极权。如果说极权的典型标志就是公权力对于社会生活的介入和公民生活的规制，那么代表新资产阶级利益的清教徒则完全主张规制个人宗教生活，是极权者的代表。极权手段，被用以清除国教中天主教残余，这是英国新贵族对抗宗教旧贵族在思想上的一种斗争形式。而清教徒，毫无疑问是光荣革命乃至整个英国议会革命的主力。如果真的了解这一点，怎么可能用光荣革命来反驳“变革必以极权”这句话呢？</p><p><strong>3. 为什么说极权手段不等于极权主义？</strong></p><p>变革要以极权手段开展，并不是说变革者本身是极权主义者，两者有本质的差别</p><p>对于极权主义者，绝对的权力和管制就是制度的本质和目的，统治者或者公权力拥有者为了实现全能威权而建立绝对权力体制，反过来绝对权力的体制又赋予了全能威权以控制和镇压能力。正如韩非的“法”不是规范社会秩序的守则，是统治者摆弄权谋的工具，极权主义政权的全能威权不过是维系统治的强力管制，“没有一个极权主义制度不在肉体上和精神上惩罚它的公民，而且比民主社会严酷得多”。</p><p>变革者则相反，任何变革者都是反极权主义的，极权只是实现变革的工具，是通向民主自由的短暂阶段。教员在湖南农民运动考察报告中提出“每个农村都必须造成一个短时间的恐怖现象”，在中国的红色政权为什么能够存在中提出对边界割据的清算方略，同时他在井冈山的斗争、中国革命的战略问题、为争取千百万群众进入抗日民族统一战线等文章，贯穿整个民主革命时期，都在强调“民主”本身，强调“不论什么情况，民主的口号都能适应，民主对于中国人是缺乏而不是多余”。可见论者对我的指责：“只要存在任何暴力成分或者权力制约的因素就可以用‘极权’来概括”，这句话本身是多么荒谬。如果连极权手段、极权主义、暴力和管制的概念都搞不清楚，怎么理解变革本身？所以我才说，他对变革的理解十分有限。</p><p>回到光荣革命本身，这不是论者想象的完全反极权、无暴力的斗争。作为新贵族和王权派（大土地所有者）的最终妥协，他就和1870议会和解一样，不是看上去那么风平浪静的。他以为光荣革命是反对王权独裁的人为了民主权利，成群结队前往伦敦集会，逼迫詹姆士二世退位，实质上呢？是英国新贵族（议会党魁）、资产阶级大商人、新教信徒（天主教反对派、清教徒等等）联合威廉三世（国家视角就叫勾结外部势力）共同推翻现任国王的行动。游行民众不是自发前往首都的，而是经过大贵族、大资产阶级的严密组织，而游行队伍能直奔伦敦，并不是詹姆士二世已经众叛亲离到连暴力驱散平民的力量都没有，而是威廉三世的军队在托尔湾枕戈待旦，而右派势力王权党和左派秘密妥协，将詹姆士二世出卖了。后者之所以能保住性命流亡，也是右派努力的结果。即使是不流血的革命，光荣革命恐怕也和“非暴力”、“反极权”拉不上任何关系。</p>]]></content>
      
      
      <categories>
          
          <category> 政治 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>由软链接/var/lib导致的snap安装时的挂载权限问题</title>
      <link href="/20210428_snap_mount_permission/"/>
      <url>/20210428_snap_mount_permission/</url>
      
        <content type="html"><![CDATA[<p>上篇文章说到，我为了空出 <code>/var</code> 的空间，把 <code>/var/lib</code> 制作成了软链接，一切看起来都非常的和平。直到今天：</p><p><img src="2021-04-28-can_yuls_can.png" alt="can_yuls_can.png"></p><p>于是我萌生了一个想法：既然TX不给玩，就自己弄一个IM吧！（指白嫖开源项目）</p><p>在Github上面找了一会儿，发现 <a href="https://github.com/RocketChat/Rocket.Chat">Rocket.Chat</a> 这个项目看起来比较靠谱。兴冲冲地 <code>sudo snap install rocketchat-server</code>。</p><p><img src="2021-04-28-snap_mount_permission_denied.png" alt="snap_mount_permission_denied.png"></p><p>发现，snap 作为沙盒化的软件包格式，单独挂载了自己的文件系统。如果 <code>/var/lib</code> 是软链接的话，就没有办法用 <code>mount --rbind</code> 来挂载了。</p><p><img src="2021-04-28-linked_var_lib.png" alt="linked_var_lib.png"></p><p>既然可以挂载目录到另一个目录，那我岂不是也可以把 <code>/usr/var/lib</code> 挂载到 <code>/var/lib</code> ?</p><p>说着，首先试了一波，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> /usr/var/lib/ /var/lib2</span><br><span class="line"><span class="built_in">ls</span> /var/lib2</span><br></pre></td></tr></table></figure><p><img src="2021-04-28-mount_diectory.png" alt="mount_diectory.png"></p><p>可以看到，目录被挂载过来，所有的文件都可以正常显示了。</p><p>这样，我们就可以把这个挂载项加进 <code>/etc/fstab</code> 让它开机自动挂载：</p><p><img src="2021-04-28-add_in_fstab.png" alt="add_in_fstab.png"></p><p>保存时候，用 <code>mount -fav</code> 测试一下写得对不对：</p><ul><li>-f, –fakedry run; skip the mount(2) syscall</li><li>-a, –allmount all filesystems mentioned in fstab</li><li>-v, –verbosesay what is being done</li></ul><p>得到以下输出：</p><p><img src="2021-04-28-test_automount.png" alt="test_automount.png"></p><p>这说明最后一项可以成功挂载。重启之后，重新运行安装：</p><p><img src="2021-04-28-snap_succesfully_installed.png" alt="snap_succesfully_installed.png"></p><p>成功！</p><div style="display: none"> 搜索优化：error: cannot perform the following tasks:- Run install hook of "rocketchat-server" snap if present (run hook "install": cannot perform operation: mount --rbind /var/lib/snapd /tmp/snap.rootfs_NhCo2X//var/lib/snapd: Permission denied) </div><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>crontab定时任务神秘失效，原来是$PATH的锅</title>
      <link href="/20210417_crontab/"/>
      <url>/20210417_crontab/</url>
      
        <content type="html"><![CDATA[<h5 id="前摇"><a href="#前摇" class="headerlink" title="前摇"></a><del>前摇</del></h5><blockquote><p> <strong>与问题只有时间上的先后关系，不一定有因果关系</strong></p></blockquote><p>昨天晚上<del>因为想发涩图</del>，给服务器的<a href="http://file.tilnel.com/">PicUploader</a>（<a href="http://172.26.41.176:4001/">校园网点此访问比较快</a>）上传了一张30MB的文件，然后卡住了。检查了一下log，提示我：</p><p><img src="2021-04-27-no_enouph_space.png" alt="no_enouph_space.png"></p><p>于是用<code>df -h</code>检查了一下硬盘空间，发现 &#x2F;var 分区只剩下 2.5 MB，存不下上传创建的临时文件了。。。</p><p>由于历史问题（其实就是当时脑瘫），分区的时候，只给 &#x2F;var 分了 9GB （后来才知道其实根本不用单独分区），直接导致了本次事件。</p><p>由于对于脑瘫分区的不满，我尝试把&#x2F;var, &#x2F;tmp, &#x2F;usr, &#x2F;boot 全都合并到根目录下，但是看到一系列危险操作的时候还是怂了。。。</p><p>看了看整个 &#x2F;var 分区，光 lib 目录就占了 6GB，好，就你了！登录到root，kill掉普通用户，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /var/lib /usr/var/</span><br><span class="line"><span class="built_in">ln</span> /usr/var/lib /var/lib</span><br></pre></td></tr></table></figure><p>把lib移动到别的地方然后创建了软链接。重新启动，一切正常。BW上传了涩图，心满意足地回去睡觉了。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>第二天晚上，BW发现，自己的博客访问不了了。</p><blockquote><p>由于hexo常常被神秘kill，BW创建了一个cronjob，每分钟运行一次检查hexo服务器运行状态的脚本。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ !$(pstree | grep hexo) ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">cd</span> ~/blog</span><br><span class="line">hexo server &gt;&gt; <span class="built_in">log</span> 2&gt;&gt; <span class="built_in">log</span> &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>原来，cron是能正常地维护hexo运行的。但是今天不知道抽了什么风，从<code>service cron status</code>能看到cron运行了这个脚本，但是hexo并没有被启动。</p><p>查看脚本的log，发现：</p><p><img src="2021-04-27-hexo_not_found.png" alt="hexo_not_found.png"></p><p>hexo命令就没找到。在脚本里加了一句<code>echo $PATH</code>，得到的结果居然是：</p><p><img src="2021-04-27-print_path.png" alt="print_path.png"></p><p>PATH神秘地不正常了。我检查了运行账户和 root 的 PATH, 都没有发现不正常的地方。甚至如果直接运行脚本，都是可以启动的。但唯独由 cron 运行的时候，PATH 就变了。</p><p>Google 了一下，发现 cron 本身会忽略 <font color="red">&#x2F;etc&#x2F;environment</font> 文件（但是为什么之前不会呢，小声逼逼）</p><p>于是给定时脚本的头部重新声明了 PATH …</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何看待讨论政治然后群被爆破同学被封号</title>
      <link href="/20210426_The_Banned_Group/"/>
      <url>/20210426_The_Banned_Group/</url>
      
        <content type="html"><![CDATA[<p><del>（还是太闲了）</del></p><p>中午搁群里讨论两岸问题和 Highest-Leader，提到Putin，也提到教员，一位同学（我现在已经查不到他说了什么了）参与比较积极。到晚饭的时候，可能是被大数据扫描到了，很快啊，群就无了。</p><p>据说有这么回事：</p><p><img src="2021-04-26-Politics_on_Keyboard_Forbidden.jpg" alt="Politics_on_Keyboard_Forbidden.jpg"></p><p>如何看待：</p><blockquote><p>我们的民主传统今年是一个很大的发展，以后要把大鸣、大放、大辩论、大字报这种形式传下去。这种形式充分发挥了社会主义民主。这种民主，只有社会主义国家才能有，资本主义国家不可能有。在这样的民主基础上，不是削弱集中，而是更加巩固了集中制，加强了无产阶级专政。因为无产阶级专政要靠广大的同盟军，单是无产阶级一个阶级不行。中国无产阶级数量少，只有一千多万人，它要靠几亿人口的贫农、下中农、城市贫民、贫苦的手工业者和革命知识分子，才能实行专政，不然是不可能的。我们现在发动了他们的积极性，无产阶级专政就巩固起来了。</p><p align="right">——《毛泽东选集》第五卷</p></blockquote><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高强度使用Seagate机械硬盘的悲惨下场</title>
      <link href="/20210426_HDDtragedy/"/>
      <url>/20210426_HDDtragedy/</url>
      
        <content type="html"><![CDATA[<p>省流大师：虽然本文没有发生任何悲剧，但数据无价，重要数据至少要有3份的冷备份。</p><p>不一定正确的个人观点：</p><p>机械盘不一定靠谱，要靠谱的机械盘至少得是黑盘吧。5年质保可以体现厂家对产品的信心。</p><p>固态放数据没那么容易死，颗粒是很耐艹的，主要是主控问题，如果能修主控，这玩意甚至能当传家宝。</p><p>固态太贵啦，一般建议上黑盘。</p><p>辣鸡硬盘raid1也不错。</p><hr><p>标题的“高强度使用”说得太轻了，机械盘上NTFS分区对4000个文件排序简直是雷普磁头。</p><hr><p>就在凌晨3点钟，BW为了找到聊天记录里的一张图，费了老鼻子劲翻QQ的文件，并试图对其按日期进行排序。4000个文件的一个文件夹，M$愣是卡了一个多小时，BW把它丢到后台了。</p><p>在某一个时刻，突然QQ卡了；QQ关不掉了；用任务管理器关QQ；任务管理器卡了；uTorrent卡了；v2ray卡了。</p><p>于是BW想都没想反手一个重新启动，结果关机卡了。</p><p><img src="2021-04-26-chubbycat.jpg" alt="chubbycat.jpg"></p><p>按主机上的 reset 按键，结果开机也卡在 Windows 转圈加载的地方。</p><p>伴随的是机箱上的硬盘灯常亮，BW一下就知道肯定是年纪最大的D盘出问题了。于是拔掉硬盘，果然开机。</p><p>等到白天，查了一下发现一条热知识：</p><blockquote><h3 id="SATA-可以热插拔"><a href="#SATA-可以热插拔" class="headerlink" title="SATA 可以热插拔"></a>SATA 可以热插拔</h3></blockquote><p>于是开着机<del>（冒着被电死的风险）</del>插上了SATA线，此时可以正常识别到并且挂载。至于当时开机不能开是因为有D盘上的启动项就是前文提的 utorrent 和 v2ray，挪到C盘发生过神秘错误于是就犯了懒。</p><p>经过3个小时的坏道检测，得到了如下结果：</p><p><a href="https://files.tilnel.xyz/uploads/2021-04-25-2021-04-25.png"><img src="http://file.tilnel.com/uploads/2021-04-25-2021-04-25.png" alt="2021-04-25.png"></a></p><p>备份了一波数据然后修好了，但只能好一点：</p><p><img src="2021-04-26-recovered.png" alt="recovered.png"></p><p>随后就正常开机了。</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v2ray配置代理服务器</title>
      <link href="/20210425_v2ray_school_proxy/"/>
      <url>/20210425_v2ray_school_proxy/</url>
      
        <content type="html"><![CDATA[<p>清明节回老家一趟，没有校园网。本以为用南大提供的<code>EasyConnect</code>服务就可以从公网登上校园网做OJ，没想到这个软件在Android手机上可以以极慢的速度连接，在Windows上一直连接不上，在Linux上…甚至安装不了。</p><p>最后我的办法：在手机上看题；在电脑上写代码；发到手机上，复制粘贴提交。对于Lab这种要git的……我只能骂这个学校VPN到底是个什么$hit。</p><p><img src="2021-04-25-wdnmd.jpg" alt="wdnmd.jpg"></p><p>在那之后我的新机计划正式启动了，这就给了我极大的施展空间<del>（所以说这台主机到底够我氵多少篇博客）</del></p><p>从校外访问OJ，第一个方案是端口映射</p><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>上篇文章中介绍了proxyer，我们用proxyer将114.212.10.47:8085映射到公网服务器上的8085端口，然后尝试访问，Boom！成功了！</p><p><img src="2021-04-25-access.png" alt="access.png"></p><p>但是点开<code>login</code>，就会看到：</p><p><img src="2021-04-25-error.png" alt="error.png"></p><p>由于某些原因（<del>Aunt讲了但是我忘了</del>），这种访问方式无法获得OAuth的授权。</p><p>于是把目光转向了v2Ray代理，从校内主机访问网站总不可能被拒绝吧？</p><h2 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h2><p>因为时间隔了半个月，所以自己也不知道当时配置的时候到底踩了哪些坑了，就当做一个正确的流程来参考吧。</p><p>首先是安装v2ray。对于ArchLinux而言，直接<code>sudo pacman -S v2ray</code>就完事了。</p><p>其他的开发版就直接参考<a href="https://www.v2fly.org/guide/install.html">项目文档</a>。</p><p>关于v2ray的详细配置教学，可以参考<a href="https://toutyrater.github.io/">这个文档</a>。</p><p>安装完成之后，我的配置文件在<code>/etc/v2ray/config.json</code>，先上配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;loglevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;warning&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/v2acc.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/v2err.log&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">1234</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;***此处需要自行生成任意UUID***&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;alterId&quot;</span><span class="punctuation">:</span> <span class="number">64</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freedom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blackhole&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blocked&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;geoip:private&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blocked&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>首先，<code>log</code>是指定日志文件的路径；</p><p>v2ray 使用 inbound 和 outbound 的传入和传出的结构，代表数据包的流动方向。我们就可以把 v2ray 当作一个盒子。inbound 接受来自客户端的请求，outbound 则将数据包发到目标去。</p><p><code>inbounds</code> 入站规则，依次配置端口号、协议、对客户端的约定。其中 <code>id</code> 字段只需要自己随便生成一个UUID往里填就完事了。使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/random/uuid</span><br></pre></td></tr></table></figure><p><img src="2021-04-25-uuid.png" alt="uuid.png"></p><p><code>outbound</code> 出站规则，第一个为默认规则，配置协议为 freedom，即为直连。</p><p>保存配置文件，<code>v2ray &amp;</code> 启动代理。用 proxyer 工具将刚才配置填写的端口映射到公网服务器上的任意端口，服务端的建设就算是完成了。</p><p>客户端，以安卓端的 V2rayNG 为例，选择手动输入[Vmess]，依次填入服务器地址，端口号，刚才生成的UUID。alterId 填4，加密方式 auto，传输协议 TCP。保存并连接。这里注意，如果是要访问内网ip，在路由模式上就要选择全局代理，而不是绕过局域网地址。</p><p>然后就可以正常登录上 Online Judging 啦！</p><p>yls的肯定：</p><p><img src="2021-04-25-IMG_20210425_022245.jpg" alt="ylsnoadmit"></p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>青年男性花了8个月才将他的博客投入使用，这是他心态发生的变化</title>
      <link href="/20210423_firstpost/"/>
      <url>/20210423_firstpost/</url>
      
        <content type="html"><![CDATA[<p><del><strong>BW</strong> is a 20-year-old young man, presenting to the emergency room, dead on arrival.</del></p><p>事情是这样的：</p><p>去年（20年）8月份<del>考完期末没事干</del>整了一台阿里云的主机，想说搭个博客玩玩，花了几天的时间成功上线了（仅WordPress的默认主题页面）。后来这个人嫌主题太丑了一直懒得维护博客，一篇文章都没有发。</p><p><img src="1.png" alt="img"></p><p>时隔几个月，服务器从阿里换成了2C4G的腾讯（感谢群友的推荐，6M带宽真良心，当场就买了4年）。又得益于<del>脑子坏了</del>升级了一下主机，把旧的CPU和一些二手部件凑成了一台新的小主机（如图）。加上端口映射服务，服务器喜沦为端口映射工具，几乎所有的服务都跑在本地了，6C12T 16G的本地服务器它不香吗？</p><p><img src="image-20210423133158354.png" alt="image-20210423133158354"></p><p>屑BW连库都没删，直接让原来的阿里云主机自动释放就跑路了。</p><p>本来开了几个html和css的教程，想自己设计一个UI，最后<del>懒得学JS</del>。于是就有了这个基于HEXO框架的网页。</p><p><del>啊，现成的框架真香。</del>（懒人发言）</p><p>现在跑起来的：</p><p><a href="http://blog.tilnel.com/">hexo静态blog</a> （本站）</p><p><a href="https://git.tilnel.com/">gitlab</a>（开放注册，本地服务器内存随便吃）</p><p>vmess校园网代理（可以从校外访问校园网，yls用了都说好）</p><p><a href="https://github.com/khvysofq/proxyer">proxyer端口映射</a> （为公网IP省了一大笔钱，虽然速率受到服务器带宽限制）</p><p><img src="image-20210423134612284.png" alt="image-20210423134612284"></p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在蒋炎岩的 Office Hour</title>
      <link href="/20201015-jyyofficehour/"/>
      <url>/20201015-jyyofficehour/</url>
      
        <content type="html"><![CDATA[<p>今天在蒋炎岩的office hour 厚颜无耻地过去咨询了一波。</p><p>大概问了这样一些问题：</p><p>问题求解学不好怎么办？</p><ul><li>基础的逻辑和离散数学去找两本书看看就行了</li><li>OJ方面，去刷Leetcode上面适合自己水平的难度的题目。其实问题求解课的OJ难度过高了，（教学事故！）</li></ul><p>计算机系统基础学不好怎么办？</p><ul><li>学习的初期会有低投入但是高回报的阶段，利用好这个阶段来找找信心。比如说，去看一些vim的比较短的tutorial，然后尽快地应用到PA当中。之后就慢慢升级就好了。</li><li>如果觉得PA比较难的话，就去学一学基础的C语言。</li></ul><p>时间管理。。。</p><p>然后就坐在那里听了一会儿蒋炎岩的组会。具体就是每个人把一周以来的工作都介绍一下。还有工作里出现的问题都讨论讨论。主要有几个内容：</p><ul><li><p>编译器优化\逻辑相关</p></li><li><p>QEMU 相关</p></li><li><p>还有一些PPT, 论文等</p></li></ul><p>和蒋炎岩聊天还是很舒适的。蒋炎岩并不会把事情怪在学生得头上，而是提出非常中肯的建议。</p><p>在组会的过程当中，也会和学生聊一些“家常”，这样就显得很亲切，不愧是老大哥(</p><p>会夸学生想出的方法是good idea</p><p>蒋炎岩的学生的思维也很活跃，我觉得我会喜欢这样的地方。不像是匡院内部，总觉得死气沉沉的，非常闷。虽然大家都很有才，也没人会yygq，但就是喜欢不起来这个地方，也许都是老社恐了吧(</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间管理</title>
      <link href="/20201009-time_manage/"/>
      <url>/20201009-time_manage/</url>
      
        <content type="html"><![CDATA[<h3 id="一、高效的时间管理-x3D-高效率-高效能"><a href="#一、高效的时间管理-x3D-高效率-高效能" class="headerlink" title="一、高效的时间管理 &#x3D; 高效率 + 高效能"></a>一、高效的时间管理 &#x3D; 高效率 + 高效能</h3><ul><li>高效率：同样的事情，比别人效率更高，用更少的时间完成</li><li>高效能：做同样的事情，获得更高的回报</li></ul><h5 id="在平时学习与工作中，注意避免不确定的因素，进而提升执行速度"><a href="#在平时学习与工作中，注意避免不确定的因素，进而提升执行速度" class="headerlink" title="在平时学习与工作中，注意避免不确定的因素，进而提升执行速度"></a>在平时学习与工作中，注意避免不确定的因素，进而提升执行速度</h5><h5 id="为什么计划总是完不成？"><a href="#为什么计划总是完不成？" class="headerlink" title="为什么计划总是完不成？"></a>为什么计划总是完不成？</h5><p>不确定的因素：要做的事情不甚明晰，驱动力不够</p><h4 id="3W原则："><a href="#3W原则：" class="headerlink" title="3W原则："></a>3W原则：</h4><p>WhenWhereWhat</p><p>明确在什么样的场景，什么时间点做什么事情，提前确定有计划，又行动清单的具体性落实计划</p><h3 id="二、只需一个行为，提升时间注意力"><a href="#二、只需一个行为，提升时间注意力" class="headerlink" title="二、只需一个行为，提升时间注意力"></a>二、只需一个行为，提升时间注意力</h3><h4 id="本子-笔"><a href="#本子-笔" class="headerlink" title="本子 + 笔"></a>本子 + 笔</h4><h5 id="专注做一件事情的时候，把手机放在离自己比较远的地方"><a href="#专注做一件事情的时候，把手机放在离自己比较远的地方" class="headerlink" title="专注做一件事情的时候，把手机放在离自己比较远的地方"></a>专注做一件事情的时候，把手机放在离自己比较远的地方</h5><p>一旦头脑中产生 任何和目前事情不想关的想法，就用笔记下来。只要有想法就马上先记下来。</p><p>及时记录下来，这些想法就不会反复跳出来，影响之后的进度。</p><h5 id="可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事"><a href="#可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事" class="headerlink" title="可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事"></a>可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事</h5><h3 id="三、善用时间进度条"><a href="#三、善用时间进度条" class="headerlink" title="三、善用时间进度条"></a>三、善用时间进度条</h3><h5 id="相对好用的方法"><a href="#相对好用的方法" class="headerlink" title="相对好用的方法"></a>相对好用的方法</h5><p>先制定一个限定时间，然后项目拆分成一个个小任务，如ABCDE计划，如果在A上花费很长时间没有结果的时候，跳过A任务，进入B任务。大脑在遇到问题的时候一般会进入死循环。这时候就需要自己去做一个 <code>Break;</code></p><p>完成另一件事之后，人的情绪也会得到释放</p><h4 id="树立一个观念：完成比完美更重要！！"><a href="#树立一个观念：完成比完美更重要！！" class="headerlink" title="树立一个观念：完成比完美更重要！！"></a>树立一个观念：完成比完美更重要！！</h4><p>比如说，为了完成一个文章，找一个开头素材就找了两个小时。或者说配置工作环境就配置了一整天。其实在不影响整体工作效率的时候，可以把这些细节的问题单独留下来，之后再安排时间来处理。这样比穿插其中效率要高。</p><h3 id="四、长久坚持一件事，寻找最短的时间路径"><a href="#四、长久坚持一件事，寻找最短的时间路径" class="headerlink" title="四、长久坚持一件事，寻找最短的时间路径"></a>四、长久坚持一件事，寻找最短的时间路径</h3><p>如何在短时间内获得最好的效果？</p><h4 id="三个维度"><a href="#三个维度" class="headerlink" title="三个维度"></a>三个维度</h4><h5 id="1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍"><a href="#1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍" class="headerlink" title="1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍"></a>1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍</h5><p>比如想早起晨跑，就前一晚准备好跑步的衣服和鞋子</p><h5 id="2、意义多维：赋予一件事有意义"><a href="#2、意义多维：赋予一件事有意义" class="headerlink" title="2、意义多维：赋予一件事有意义"></a>2、意义多维：赋予一件事有意义</h5><p>例如：跑步时可以听书或者听音乐，所以在前一晚准备好适合跑步的印品，适合跑步时间及节律的。</p><h5 id="3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话"><a href="#3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话" class="headerlink" title="3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话"></a>3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话</h5><p>比如，从一开始想要跑步的时候，早起的时候自我提问：今天要不要跑步，往往就会冒出抗拒的想法。</p><p>后来换一种思维方式对话：我今天是要跑3公里还是5公里，这样思想的负担就感觉减轻了。</p><p>时间长了就会条件反射，跑步就是习惯的自然而然的事情了。</p><h3 id="五、把重要事件从紧急事件中去掉"><a href="#五、把重要事件从紧急事件中去掉" class="headerlink" title="五、把重要事件从紧急事件中去掉"></a>五、把重要事件从紧急事件中去掉</h3><h4 id="1、列重要事件清单"><a href="#1、列重要事件清单" class="headerlink" title="1、列重要事件清单"></a>1、列重要事件清单</h4><p>很多事候列出了重要的事情，都因为拖延的习惯变成了重要饮酒的事情</p><p>其实重要的事情需要提前做好准备。反复练习重要清单，避免拖拉，如果拖拉最后就会变成重要紧急的事件，让自己处于被动当中。</p><p>尽量在时间节点前很久就把事情做好，而不是等到最后一刻。</p><p>2、逐渐增加每天做重复时间的比例，直到50%</p><p>清单里面要增加重要但不紧急的时间，每天增加做一些，不往后拖，逐渐养成规律的习惯。</p><p>3、在重要的时间提前做重要的事情</p><p>写出自己的黄金时间，做重要的事件。其他时间从清单里挑重要非紧急事件，而不是重要紧急清单里的。注重养成做重要非紧急事件的习惯。</p><p>当你的清单里，常做的是重要非紧急的事件的时候，会慢慢地感觉到人生的掌控感。</p><h4 id="GTD的核心原则"><a href="#GTD的核心原则" class="headerlink" title="GTD的核心原则"></a>GTD的核心原则</h4><ul><li>收集：把任务从大脑里清出来，形成待办列表</li><li>整理：整理待办任务、分类任务</li><li>组织：下一步行动、形成项目、等待处理、将来处理</li><li>回顾：按日回顾、周回顾、月回顾来总结GTD系统</li><li>执行：Do it! 没什么好说的</li></ul><h3 id="六、每天精进一点点：日行动-周复盘-月度计划"><a href="#六、每天精进一点点：日行动-周复盘-月度计划" class="headerlink" title="六、每天精进一点点：日行动-周复盘-月度计划"></a>六、每天精进一点点：日行动-周复盘-月度计划</h3><p>定期总结与反思，有利于了解自己的不足，促进进步。</p><p>每天落实计划行动，每周进行复盘，分类总结的习惯。同时也要有月季花，并且是切实可行的行动计划。</p><p>每天临睡前都把第二天要做的事情写出来，并分类在各个象限里。每周进行一个小小的回顾，工作-学习-生活几个大模块进行复盘。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记 919</title>
      <link href="/20200922-for919/"/>
      <url>/20200922-for919/</url>
      
        <content type="html"><![CDATA[<p>​刚知道吴琳老师只比我的父亲大两岁，虽然老师的白头发很多，但用精神矍铄来形容显然不合适。初见吴琳是高一参加竞赛，第一年侥幸获得了参加初赛的资格，在省强化班上有幸聆听吴琳老师讲的有机课。白衬衫搭黑色西裤，永远挺直的高而瘦削的身板，俨然一翩翩君子。上课节奏之快让我直呼跟不上，但那些有机扎实的学生都非常爱听。</p><p>再见时是第二年的强化班，吴老装束未变，风度不减。自习一年有机后再听一遍合成课，每一步的思路都很顺畅，收获颇丰。</p><p>大一上纠结学业方向的时候，又前去听了几节课。节奏不似竞赛课上那样紧张，课堂问答时也是难得地看到了吴琳老师的笑容。</p><p>我对吴琳老师的记忆仅限于此。摘录知乎中的评价：</p><p>作者：杨涵<br>链接：<a href="https://www.zhihu.com/question/26620131/answer/45797384">https://www.zhihu.com/question/26620131/answer/45797384</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>接下来就是化院不得不提的少有的另无数学妹颤抖的男神老师吴琳了，大二教一部分人一年的《有机化学》（那一半，男神不爱你们，你们哭去吧）。没上大学之前，我以为大学老师都应该是那种，上课带个茶杯，把书往桌子上一扔，拿起粉笔一讲一节课的人，靠PPT的是什么鬼？可是上了大学才发现，其实很多老师还是很水的，拿着甚至不是自己做的PPT，然后念一个学期。而我心里面多希望的那种老师也遇到过，可大多数是文科的，理工科的就只见过吴琳男神了。</p><p>男神上课，从不看书，各种键能键角，信手拈来。跟着男神搞一年机，发现基本上邢大本真的能记得差不多，而且完全没有那种刻意去背的感觉。可是我现在早已都还给男神了<br>男神考核，木有平时成绩，不算期中考试成绩，第一学期期末考试默认考整个学期内容，第二学期期末默认考整个学年内容。考多少是多少（我就问你慌不慌！！）。真叫一个洒脱。</p><p>深耕于教学的老师，如今是副教授。</p><p>建议再翻翻耿柳娜的简历对比。</p><p>我要气死了</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一次去酒吧</title>
      <link href="/20200920_firsttimeinbar/"/>
      <url>/20200920_firsttimeinbar/</url>
      
        <content type="html"><![CDATA[<h6 id="记第一次独自去酒吧（给自己看-晨起写下的昨晚事"><a href="#记第一次独自去酒吧（给自己看-晨起写下的昨晚事" class="headerlink" title="记第一次独自去酒吧（给自己看)  晨起写下的昨晚事"></a>记第一次独自去酒吧（给自己看)  晨起写下的昨晚事</h6><p>​最近突然想起在附近转一转，找点一个人消遣的好地方。这就骑车跑到了仙林中心的金鹰附近。</p><p>​本来是想看一眼胡桃林那家怎么样的，可是到了跟前我踌躇了。且不说单看MENU这本质上只是一家餐馆，我看见一个中年男人抱着2岁大的幼儿出来，就觉得这里不是我要找的地方。当然更多还是因为我不敢往人这么多的地方走，老社恐了。</p><p>​一个人坐在树边的椅子上，像是和朋友约好出来玩却临时被人放鸽子一样划着手机，在找有没有下一个适合我的地方。看到大成里刚好有两三家。和金鹰不同，大成坐落在这个湖的角落，楼栋和金鹰广场的流光溢彩相比实属暗淡无光。如果说金鹰前的这片湖是情侣们约会的好地方，那么角落里灰头土脸的大成或多或少杀了一下风景。</p><p>​我非常诚实地动起了双腿，迅速绕过成群结对的人们，到达了湖对岸的大成。</p><p>​对面是公厕的布局摆明了这是一个很老的地方。走过附近时还能闻到垃圾桶散发的酸臭，我却分明看到有两个人坐在附近的长椅上，我有些惶恐。走进大成的小门，第一个看见的是一个图文工作室，里面几个大学生模样的人在忙些什么。旁边一家店里只有店主一个人，他注视着我。我对于这目光感到不适，于是赶紧上楼了。到了二楼，周围比一楼更加冷清，令我吃惊的是在这里姑且还开了一点服装店。原先想找的2楼酒馆，望了一圈竟发现一张催缴物业费的条子贴在被大长锁封印的铁门上。相比这么冷清的地方，跑路也是很正常的。</p><p>​我有点失落地下了楼，发现刚才那家店竟然同样是一家酒馆，只是在地图上哪里都看不见。抱着试一试的心态想要走进去。店主从玻璃墙里注视着我进了店门。</p><p>​我们从进门一直对到我因为心神不宁而找了一个地方坐下。“我是第一次来这种地方。”<br>​“你能找到这里也是挺厉害的。我们店一直都是低调宣传，来的基本上是熟客。”</p><p>​店主脸庞瘦削，头发像是天生的卷发，笑起来两颗门牙可见像只兔子。他顺手递了一根烟，摆手说不抽。一番攀谈了解到店主是附近南中医的学生，用业余时间在经营这家酒馆。现在已经开了3年了，而他本人也已经大四。他说他有点想要读个研，为了把这家酒馆继续开下去。</p><p>​环顾四周，能看见一些音响设备，和一架KeyBoard。电视机里放的是某摇滚主题的电影。这家店可以说是纯粹为了兴趣而开的，从照片墙上可以看见这里曾整过许多音乐活动，大家都是兴趣相投的人。这和很多快餐式的以约炮为目的的地方并不一样。店主给我拿了一瓶雪碧，告诉我曾经也有一个南大来到了这个地方，一直疯玩，最后；辍学去做中介了。听到这里我不禁对来到这里的自己的未来产生怀疑。或许我要步他的后尘，亦或者我被前人警醒。</p><p>​少过片刻，一位身材魁梧，胡须浓密的大哥背着挎包来了。刚一进门就说道：</p><p>​“我真羡慕你这长头发，我想留的结果被女朋友逼着剪了。”</p><p>​我和店主都笑了出来。这位是店主的合伙人，一进来就在捣鼓各种设备。不一会儿，音乐有了，这算是做好了开张的准备。</p><p>​人逐渐多了，进来了两个毛头小子，在一边摇骰作乐，聒噪不休。一伙男的带着一票女的走进店门。这真的是纯粹的地方吗？原来无关地方，不纯粹的始终都只有人而已。我开始感到有些不适，于是坐到吧台那儿去，边上是一位梳着背头，打扮颇为体面的酒客，看起来和这里的店主都互相熟悉。请技术员兼调酒狮为我推荐了一种酒。啤酒的沫满溢着玻璃杯，我正要举，边上的酒客这就与我碰了一杯，稍微有点不知所措但还是立刻摆出了笑容并且作领会状，小口啜饮着短梦中炽热的狂乐。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>发生了什么？</title>
      <link href="/20200728-chat/"/>
      <url>/20200728-chat/</url>
      
        <content type="html"><![CDATA[<p>王舒宇来找我聊了两次，说实话我是不太懂的。</p><p>“说不定我哪天想不开去学而思上班”</p><p>“上了大学发现上大学也没啥用”</p><p>“我读书读累了”</p><p>第二天又是</p><p>“话说，你一般几点睡”</p><p>我的错觉又来了。不过后来我们也没再说什么话。这样真的好么？我不知道她现在和王亦辰是什么状况了。</p><p>我真的怀疑，但是如果怀疑错了，那就没有朋友做了。怀疑的成本很高，还是装糊涂算了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.1 个小目标</title>
      <link href="/20200727-fire/"/>
      <url>/20200727-fire/</url>
      
        <content type="html"><![CDATA[<p>FIRE。在知乎上看到了这样的设想。Finalcial Independence Retire Early。尽早逃离费时费力的工作，然后享受人生。</p><p>基本逻辑：无论赚多少钱，都要过极简的生活，以求储蓄率达到 50% 甚至更高。攒够一年生活费的 25 倍后，就可以退休了。提早过上用被动收入覆盖所有开支的生活。</p><p>在 35 - 40 岁前安排好被动现金流，通过长期的金融工具来达成。如保险、股票与指数基金。可以在不受金钱的驱动下做自己认为更有意义的终身职业。</p><p>可能遇到的问题：</p><ul><li>房贷。只能说要考虑清楚。</li><li>通胀。飙升可能性不大。</li><li>负利率。配置长期锁定利率的产品。</li><li>黑天鹅风险。建立家庭保障系统。<ul><li>成年人：定期寿险 + 意外险 + 重疾险 + 医疗险</li><li>小孩：定期重疾险 + 意外险 + 意外险</li><li>老人：优先医疗险 + 意外险。有余力则重疾险 + 终身寿险</li></ul></li></ul><p>达成手段</p><p>读完研究生，那就要到 2026 年 6 月，25 周岁的时候。如果在这之前实习、兼职，每月存款顶天是 1-2k 原的情况下，最多有 100k 存款。显然是没有多大用处。</p><p>考虑到开销、买房买车，需要的年薪达到了恐怖的 2m。所以肯定是要把重心放在主业上，在领域内作出一些成绩。</p><p>不过，我还认为要设置另外一重标准：读大学期间是否能够攒到 1m。提前积累工作经验是好的。</p><p>那就要强化自己的能力了。当时想的是成为内容创作者。但是首先：要有内容。然后也可以运营网站。</p><p>为了大方向上的顺利执行，必须要改变日常的计划。<br>首先是要多以学业成绩为优先。也不是说放弃活动，而是要减少一些无所谓的娱乐和无所事事的额时间。要在提升自己这件事上更加地讲效率。以计算机专业课为重。</p><p>多学习开发相关的知识，要尽量全能一点。着手开发产品、制作渲染视频，可能能够提供不通的收入思路。</p><p>另外要多看书，提升思想。</p><p>平时消费注意开源节流，早日租房自己住。</p><p>养成良好的习惯。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回忆三哥</title>
      <link href="/20200309-memories/"/>
      <url>/20200309-memories/</url>
      
        <content type="html"><![CDATA[<p>关于王舒宇的一些回忆。</p><p>高一的时候，印象可能并不深刻。传说喜欢过江海洋，后来江本人也是认证了这个传闻。江海洋也是传奇人物。</p><p>后来分班和她分在一起，感觉还挺幸运。那个时候属于稍微接近一点就有好感的阶段。高二下她过生日的时候随便挑了个礼物送。</p><p>然后呢，然后呢？后来她就疯狂学习。一个人坐在教室后面埋头苦干。</p><p>有节语文课前的演讲她做了个关于天赋与努力的题材。我记得当时还是挺受鼓舞的。不过我至今也没有搞清楚自己到底是天赋型的还是努力型的。因为我平时不算顺利，那时候也不摆烂。天赋不如 wyc，努力不如 wsy，一半对一半，我是运气型。</p><p>现在她去了南医大，她已经努力惯了，对她来说虽然艰难但也得心应手吧。</p><p>每到不如意的时候就会回忆往事，然后继续不行动。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梦</title>
      <link href="/20200308-yume/"/>
      <url>/20200308-yume/</url>
      
        <content type="html"><![CDATA[<p>梦见自己停下大学的学业回金陵中学复读重考。最近感觉自己完全失去了学习的动力，总感觉实在是应付差事，没有积极性可言。可能是感到和想象中不太一样？</p><p>如果要从上学期的表现中找出一点端倪的话，那就是什么都图方便省事，最终是降低了学习效率，实际上是一种不思进取的感觉。</p><p>同时也是失去了一个拥有良好关系，互相爱惜的竞争对手，失去了老师一般的人物，现在没有这种人在背后注视我（录者注：凝视）。但是，总算不能被那家伙嘲笑呗。至少要一样强大才可以，否则就只能说是我的运气比她好。</p><p>我记得<br>你给我讲过的解析几何题<br>回南京高铁上的美梦<br>考前倒数第二天我们忍着热气在教室外面写完的试卷 - 为什么你也会出来呢？<br>你在运动会上的坚持<br>坐在教室后面，沉默的压迫感</p><p>かずさ、見つけた。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二月的尾巴</title>
      <link href="/20200229-mahjong/"/>
      <url>/20200229-mahjong/</url>
      
        <content type="html"><![CDATA[<p>今天是要自学物理然后写很多作业的一天。以及问求作业。。。</p><p>昨天买了 97 天的天凤有料，然后狂打 12 个半庄。1 + 4 + 5 + 2，非常难受。</p><p>没错，这种防守在特上肯定是要被打爆的。然后雪菜给我指明了这个问题，但我不太懂防守细节以及。。。手模切记不住啊。。。</p><p>想舒坦地打天凤就赶紧去做物理作业啊。。。</p><p>中午又吃了两个四，付出了 150pt 的惨痛代价，这样怎么才能升 7 ？</p><p>打着打着又不专心了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我又在闹笑话</title>
      <link href="/20200116-joke/"/>
      <url>/20200116-joke/</url>
      
        <content type="html"><![CDATA[<p>所以乐怡 17 岁到底爱上的是谁呢？她现在已经 18 岁了。</p><p>我想真的可能是我吧。但她现在有新的男朋友了。祝她幸福。</p><p>做了个梦，梦见擦伤了去医务室，小姐姐看上去没比我大多少。她帮我清理伤口，很舒服，我忍不住吻了她，她没有抗拒。之后，她甚至主动发起进攻。但正在沉醉的时候，她不见了。</p><p>（。。？该怎么说，录这段的时候完全不知道当时在想什么）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>期末了。。。</title>
      <link href="/20200105-final/"/>
      <url>/20200105-final/</url>
      
        <content type="html"><![CDATA[<p>果然充实，不过是在 12 点起床的基础上的充实。</p><p>于是昨天也只学了没多久吧。。下午一直写 OJ 了。</p><p>今天下午 2 点到 4 点考试的话，那大概学到十一点半去吃饭，再看一小时就要去考场了。</p><p>还有思修、生物和微电子，烂完了。最重要的是生物还有作业。</p><p>没事，只要晚上不熬到两点半，还是有希望考好的。睡就睡了呗。懒得再碰类似的游戏了。。。</p><p>回顾一下过去的美食节。还是能够触动我的内心的。之后和同学在市中心转，但是没有一个地方能容得下我们玩的。跨年夜人也太多了。不过搜到了 royal 清吧，以后可以来玩玩。</p><p>有了一个新年愿望：想成为出色的内容创作者，想为美食节拍个纪录片。或许可以穿着校服混进来？待一整天可还行。或者说，要待好几天才对。</p><p>因此，要学习拍摄、剪辑、配音、写分镜、台本，并且准备好相关的器材。</p><p>为了获得足够的收益，可能需要先制作一点其他的内容。</p><p>不要无心复习啊。。还得考试呢。。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>舞台</title>
      <link href="/20191221-stage/"/>
      <url>/20191221-stage/</url>
      
        <content type="html"><![CDATA[<p>我果然是热爱舞台的。</p><p>上周的朗诵巨赞。我还是有点紧张，在恩玲这种大舞台上。但我并没有感到渺小，而是觉得台下其实也并没有那么大，没有什么怯场的感觉。</p><p>唱歌的时候虽然担心，但是也算从容。享受音乐，享受舞台的感觉。最近也是体会到了一些歌词的美妙：</p><p>“因为誓言不敢听，因为承诺不敢信。所以放心着你的沉默，去说服明天的命运。<br>没有风雨躲得过，没有坎坷不必走。所以安心地牵你的手，不去想该不该回头。”</p><p>还有一些歌词甚至能想象到画面：</p><p>“金色的城池，银色的港湾，我走过了多多少少”</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>沉思录 课堂随记</title>
      <link href="/20191211-Notes/"/>
      <url>/20191211-Notes/</url>
      
        <content type="html"><![CDATA[<p>课上就记得不太工整，各种缺失。只是打发时间做的。</p><p>但是是胡大平讲诶。我后来才知道他牛逼。</p><p>一、希腊晚期哲学<br>二、斯多葛主义<br>三、奥勒留：生平与思想<br>四、讨论</p><p>核心思想？选项是四个流派<br>A. 幸福就是过一种德性的生活</p><p>BC 322 - AD 524 . 从 Alestrote 逝世开始。</p><p>背景：城邦 - 塞琉古、托勒密、马其顿 - 罗马帝国</p><p>城邦公民 - 世界公民</p><p>时期： 希腊化时期&#x2F;罗马时期</p><p>特征： 伦理转向，世界主义，宗教因素</p><p>流派： 伊比鸠鲁主义，怀疑主义，新柏拉图主义，斯多葛主义</p><p>城邦制被取代，建立起超越城邦的王国，产生哲学的转向。</p><p>公民：具有自我意识的主观性这一重要意义。没有着落、根基的世界感。</p><p>伦理转向：从以思辨形而上学为主，到服务于伦理实践，做一个何样的人，怎样在世界中安定自身</p><p>宗教：过渡到中世纪。主要是新柏拉图主义。</p><p>伊比鸠鲁主义</p><ul><li>原子论 为本体论，由微粒组成，存在虚空。改造，非机械的，自由的</li><li>感觉主义 感觉统率理智、理性。感觉是第一性的，最可靠的。理性反而是有错的</li><li>快乐主义 身体性的是低级快乐。追求精神内心的宁静、平和</li></ul><p>新柏拉图主义 普罗提诺</p><ul><li>太一 最高最完满的存在 游离出时空</li><li>努斯 一种影子、摹写</li><li>人处于可感世界。灵魂向上，肉体向下</li><li>实现完满：观照</li></ul><p>怀疑主义 皮浪 悬搁判断 不动心</p><p>斯多葛主义 Stoa</p><ul><li>提翁的芝诺（晚一点的）</li></ul><p>中期：共和国时期 巴内修斯，西塞罗</p><p>晚期：罗马帝国</p><p>此时，斯多葛派学说几乎成为“官方学说”</p><p>越晚期，越低沉，越消极，贴近宿命论。</p><p>逻辑学：篱笆<br>伦理学：庄稼<br>物理学：土壤、树木</p><p>三者是一个整体，核心是伦理学，如何安身立命</p><p>自然哲学（物理学）</p><p>赫拉克利特 （形式与质料）<br>两种本源，主动的（形式），理性、“逻各斯”、尺度、神。被动的（Alestrote 式的质料）<br>微观层次：元素，火-气-水-土-火，一切由火的运动变化而成</p><p>伦理学</p><p>早期：德性知识论，善的目的论<br>顺从命运、禁欲主义、贤人政治、世界主义</p><p>马可・奥勒留 121-180 五贤帝时期，被立为储君，而传位给自己的儿子。<br>罗马由盛转衰。《爵斗士》</p><p>沉思录写在与日耳曼人作战期间，日记式的，碎片话，只是写给自己看的感悟。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑配置</title>
      <link href="/20191211-deleted/"/>
      <url>/20191211-deleted/</url>
      
        <content type="html"><![CDATA[<p>最终确定的是：</p><p>AMD Ryzen 2600<br>MSI B450M Mortar<br>Kingston 骇客神条 8GB<br>Kingston SSD 240GB<br>先马 机箱<br>爱国者 电源<br>亮机卡暂无</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于英语老师提问没答出来这档事</title>
      <link href="/20191210-loser/"/>
      <url>/20191210-loser/</url>
      
        <content type="html"><![CDATA[<p>怎么办呢，英语差就差了，阿 Q 一下吧。。。</p><p>我不喜欢无谓的提问。不知道为什么这些老师都喜欢问这种问题，就是“你有什么问题？”我表示没问题。讲清了就是讲清了，提问很没必要。</p><p>不过我站起来什么都没说的样子真的有够靓仔，脑子没有办法照着英文的逻辑去想。</p><p>不过大概没什么事，这种英语教育我反正是不用再接受了。大概讲日语会更自然一点。我就发现很多场合下我想不起一些很简单的英文。或者说不敢说？</p><p>关于过去的事情，就过去了吧。珍视就好了。想抽出一段时间写个回忆录，不然全忘了真的奥。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>葛院开会</title>
      <link href="/20191204-extreme/"/>
      <url>/20191204-extreme/</url>
      
        <content type="html"><![CDATA[<p>葛院找我们开会，问说大家都参加了几个社团。我谎称两个，仍然属组内最多。院长不免要关心关心我的学习情况，不过他是先问我参不参加校园歌手比赛，听了我说“大一不准备参加，不能影响学习”之后才像是放下心来。</p><p>没想到直到大学还会有长辈亲切地指导我要把学习放在首位。不过还是要细细听这番说法：<br>“就算你们别的方面再不好，学习肯定比别人要好啊！”</p><p>虽然不否认这句话，但是未免把学生的价值观看得过于单一。读书是一条保险的道路，却不一定是最精彩的道路。实话说，日常各种极限操作，加上各种社团的加成，我的生活算得上是丰富。我却仍然觉得它少了灵魂。</p><p>有人批评华晨宇的唱法不科学，容易毁嗓，华晨宇说，有的人通过科学的唱法可以唱到老，但他就是要用独特的唱法，在有限的生命周期里达到自身最高的艺术效果。持续的平淡有什么意思呢？我很敬Toby Ballentine，他凭一己之力在学生时代就游了欧洲许多国家。他在课上问我们，万一哪天成为了富翁，想要过simple life还是fancy life。那我自然是选fancy life的。Simple life 自然很好，我多半也会很羡慕，但它就是不对我胃口。</p><p>那么说回这个灵魂，可以说就是冒险吧。我倒确实不想搞坏自己的身体，并不想冒着损害身体健康的风险。但是年龄增长阅历增加，不能失去的东西变得越来越多。冒着险的同时还要小心翼翼地保护这些东西，这本就不是我能做到的。</p><p>躲避风险这倒不是来自于院长的教诲，而是人的本能，加上我本就胆小，又贪心，直至今日有些事情还是让我抖抖豁豁的。有时争取一个又要保全另一个。这就把自己搞得很累，再精彩的生活也变成权衡权衡权衡，乏味至极。可惜我终究不能冒着丢失的风险，要么逼自己累的像条狗，要么就放弃了争取。</p><p>这12月又将是我极限操作的一个月。首先希望诸事顺利吧。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>热爱的事</title>
      <link href="/20191128-zeal/"/>
      <url>/20191128-zeal/</url>
      
        <content type="html"><![CDATA[<p>已经不需要了。因为已经没有了。</p><p>老师给我们开完会后，我突然想搞好自己的 GPA 了。只要时间利用得当，兼顾成绩和娱乐其实是比较容易的。但就是架不住浪费呗。</p><p>就不轻率地谈恋爱了吧。感觉要认真地交心已经相当困难了。</p><p>上微电子课的时候我有那么一瞬间领悟到了自己的热爱。</p><p>（灵感转瞬即逝，我全忘了）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期活动</title>
      <link href="/20191127-activities/"/>
      <url>/20191127-activities/</url>
      
        <content type="html"><![CDATA[<p>很骄傲的是，和严格的吴经纬学长联系了一阵子后，我在正式演出时发挥良好。当然也有一段歌词进早了，不过由于声音不是很大，就没出什么问题，也算是从容处理。</p><p>小邹同学架子鼓表演成功的时候，也有些激动。希望以后能够更多地经历这样的舞台。在台上的感觉实在是很惬意，有一种错觉是自己其实是为舞台而生的。</p><p>今天也拿到了主持人队的队徽，还有季学长寄语的明信片。希望之后成为能够独当一面的人。因为可以去依赖的人已经越来越远了。。。毕竟当初没有作出那个选择。（录者：？是谁？是什么选择？我怎么不知道？）</p><p>结果比起所谓的前女友，更让我无法忘却的还是同学。。我们从未表过意，却大概有一种默契。那肯定不是巧合。</p><p>不过我唯一笃定的并非巧合的事也就只有与她的明示暗示。</p><p>有关 tsung 的事，我的判断从来就没有准过；关于乐怡，我自己都抱有怀疑。看来这次选择题又选错了吧。</p><p>以前我选择自立。现在就由不得我选了，必须要能够独当一面。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>期中考试总结</title>
      <link href="/20191119-exam/"/>
      <url>/20191119-exam/</url>
      
        <content type="html"><![CDATA[<p>感觉微积分考得还行，但是生物基本就是不及格水平了。</p><p>莫谈学事。最近搞了一些资源，一是音乐。想现学一点声学的知识再去理解 DSD 这种东西。今晚可以稍微听一听差异。二是写真集，嗯就是擦边的那种。以前觉得看 Cosplay 和写真没什么意思，现在才能理解其中的性感之处。拍摄角度、人物动作，包括暗示之类的。。。</p><p>啊感觉真是色情。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>补番列表</title>
      <link href="/20191107-bangumilist/"/>
      <url>/20191107-bangumilist/</url>
      
        <content type="html"><![CDATA[<p>写一个补番名单。（这里可能是看了什么动漫杂谈之类的）</p><p>鬼灭之刃 （already）</p><p>花开伊吕波 （一话弃。女主挺好看但是类型不对味）</p><p>未闻花名</p><p>有你的小镇</p><p>黑礁</p><p>绝对双刃</p><p>JOJO （already）</p><p>恋爱研究所</p><p>只有我不存在的街道</p><p>在地下城寻求邂逅是否搞错了什么</p><p>世纪末超自然学园</p><p>祝福的钟声</p><p>少女编号 （不喜欢的类型）</p><p>日常系的异能战斗</p><p>CHAOS; CHILD</p><p>游戏：想要传达给你的爱恋（？什么白学同人）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>体测记录</title>
      <link href="/20191106-test/"/>
      <url>/20191106-test/</url>
      
        <content type="html"><![CDATA[<p>引体向上：不标准的 10 个</p><p>50m：7.0s</p><p>立定跳远：2.59m</p><p>1000m：3min44s</p><p>什么时候 1000m 能跑到 3 分以内啊。。。。（是人吗？</p><p>今天晨跑的时候没看到方圆，不乐</p><p>想到了一种理解他人说话的方式：为什么这句话的言说如此理所当然？可能经历了什么？</p><p>（这都哪跟哪？）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计划</title>
      <link href="/20191105-plans/"/>
      <url>/20191105-plans/</url>
      
        <content type="html"><![CDATA[<p> 填上上面的格子吧，这样会有一点点仪式感（指日记本上面的天气、星期。。。）</p><p>另外我感觉鞋子应当要规范但不拘束，也就是不要太小气。那就把字体写得大点，写成行楷就好了。</p><p>目前有一些急于要做的事</p><ul><li>确定下要买的衣服</li><li>买个行书的字帖（直到现在我还不会写行书）</li><li>确定下自己的 Routine</li><li>日程表，手写或打印</li></ul><p>DDL 当前，不得不养成习惯来适应这种生活。</p><p>最近想要去重庆看一看 tsung。有点想。不过。。（咦，我当时为什么想去找？）</p><p>院内的事：最近萌生了想要导演明年新生晚会的想法。看了 CS 的迎新，我感觉我们院的晚会弱爆了。</p><p>顺便说说盛宇坤。印象是家境比较好。性格上和我有一点相似，我挺敬仰他，他应该是个当领导者的料，敢说敢做。</p><p>关于陈旭对我空间的造访，我怀疑当初提的分手可能不是真实的。但我不会回头，我没能力认真爱一个人，只能投入自己了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Preface - 复盘大学新开的第一本日记本</title>
      <link href="/20191105-preface/"/>
      <url>/20191105-preface/</url>
      
        <content type="html"><![CDATA[<blockquote><p>是写在纸质的东西上的。我尽量克服羞耻感还原当时的写法。</p></blockquote><p>比较喜感地开始写这一本日记本，主要还是为了练字。老的那本放在家了，想拿过来。。。估计总会忘记。</p><p>其实很久都在纠结是该用电脑写还是写成纸质的，感觉用电脑写还是会分心。</p><p>这个本子在格式上不打算做其他任何要求，只有一点，那就是字一定要认真写才行。是时候回归练字这件事了。自从高中以来，已经放纵很久了。</p><p>另外一件事就是 Routine &amp; Habits。怪惭愧的，很多事情都半途而废了。想要把自己变成一个丰富的人。那就和自己做个约定吧！就算一次又一次地爽约，也定下约定吧。</p><p>我也有意要保研清北，当然显然是更加中意 PKU，不过现在还不知道自己最终会选择什么专业呢。</p><blockquote><p>录者注：最后摆烂整4年留在本校了。当时其实还在犹豫计算机还是化学。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定点规矩</title>
      <link href="/20191105-rules/"/>
      <url>/20191105-rules/</url>
      
        <content type="html"><![CDATA[<ul><li>要为了理想而奋斗，坚定信念</li><li>不做无结果的辩论（我还是很喜欢和人吵）不干涉他人表达，表达不被人干涉</li><li>课上有事干，闲事也是事</li><li>少熬夜；早起；多运动</li><li>困就直线滚去休息；不要久坐</li><li>练唱</li><li>少说没有用的话</li><li>要找女朋友的话，就去结识新朋友</li><li>静若处子，动若脱兔</li><li>以王舒宇为榜样</li><li>依赖你自己</li><li>活得丰富，不要浪费时间（我在这里录日记不是浪费时间？）<ul><li>直奔主题，不要 round about</li></ul></li><li>不管多么痛苦，都不要轻易逃到更轻松的一边</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
