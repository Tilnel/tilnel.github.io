<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>序</title>
      <link href="/20991231-top/"/>
      <url>/20991231-top/</url>
      
        <content type="html"><![CDATA[<p>最近来看的人变多了，正好随手调整一下内容。</p><p>人无法对他写下的文字完全忠实。事实上我最近在录入以前的手写稿时，也有大量删改。19-22的册子看起来写了不少，但最终进入到这里的只有寥寥几篇：写的时候完全不讲究，事后自己去读的时候只有捂脸。这也算我本人这一时期的特色了。然而我还是希望“尽量忠实”，尤其是最近一年我觉得我在这方面做得不错。23年8月-24年7月的手写部分，除了一些涉及他人隐私的地方我不得不使用代号以外我几乎是原封不动地录入了。有可能是因为距离现在的我并不遥远所以我对这些文字大体上满意。</p><p>随手浏览一下文章列表，偶然会有几个月的沉寂期。19年以前的部分在考虑补，高中写的东西的确不少；20春-22春夏我的个人生活几乎是停滞的，因为那段时间包含了我状态最差的时候，最繁忙的时候，以及最无所事事的时候，所以就连纸质日记也没有几篇。仔细想来，爆发期其实就是22年秋冬的一段dramatic的感情，之后几乎每个月都有思考和记录。</p><p>介绍完博客的概况，该介绍一下自己了。如你所见这里有很多计算机相关的内容，偶尔也谈点哲学。然而相比于理性世界，我更在乎感性直观的冲击：视觉、味觉、嗅觉、听觉。所以正在努力成为味觉与嗅觉的美学家，从一个调酒师开始，探索饮品的各种可能。其他的成分只要再略读一两篇文字就明了了。</p><p>那么，如果您看到喜欢的文字并且愿意，可以在社交媒体上联系我（评论区并不会及时通知到我个人），这些反馈都会对我有很大帮助。</p><p>Tilnel 2024-10-23 06:42:15</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重力</title>
      <link href="/20241110-gravity/"/>
      <url>/20241110-gravity/</url>
      
        <content type="html"><![CDATA[<p>桌游组里的重力系疑似有点太多了。可怕。是不是大家身上的负担都太重了？</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客、Hexo、Valine评论头像 备忘</title>
      <link href="/20241110-blog/"/>
      <url>/20241110-blog/</url>
      
        <content type="html"><![CDATA[<p>Valine 评论区在移动设备上可能刷不出来。应该是浏览器的问题。</p><p>Valine 评论是可以设置头像的，前提是留下一个邮箱，并且这个邮箱注册了 <a href="https://gravatar.com/">Gravatar</a> 然后设置了头像。一次注册到处使用。</p><img src="image-20241110171001041.png" alt="头像" style="zoom: 67%;"><p>砍掉了博客的文章摘要。改成了 Archive 的页面。</p><p>砍掉了文章列表分页，力求原始简单。</p><p>砍掉了回到顶部按钮，总共也不会多长。</p><p>终于启用了 jQuery 站内搜索，现在可以搜索关键字了。</p><p>更新了 About 的内容。省略了很多网络社交不需要的东西。</p><p>更新了几个友链，虽然我们并没有交换，就当是博主推荐了。</p><p>启用了访问统计(busuanzi)。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Highway to Hell</title>
      <link href="/20241108-trip/"/>
      <url>/20241108-trip/</url>
      
        <content type="html"><![CDATA[<p>Preface</p><p>11月7日，骑了很远的路。游记参考祁念的记录。似乎我也没有什么实际的情节需要补充。</p><p>为什么会做这样看起来疯狂且没头脑的事情，我已经忘记了很久——并非。</p><p>如果没有可以互动的对象，那么回家&#x2F;宿舍&#x2F;工位将会是一件非常乏味的事。看起来工作室的各位都不是十分愿意离开人群。与人在一起这件事本身包含了一种力量，似乎是“收到反馈”的权力。人做任何事、说任何话的背后都隐藏着一种期待，或是说一种欲望，即将这些话语和行为的意义进行锚定，以防止这些内容在产生意义之前就散失了。呃说人话：一种“回应”是人们所期待的，回应这件事使得自我的主动表达得到了ACK。于是就可以对行为的意义进行自己的判断。这一判断就是依据回应生成的。</p><p>可能这样说并不精准。回应并不是“判断”的内容的充分依据，它充其量是一种直接原因。因为回应到了，我们搜索自己的意识，产生新的行为以应对那个回应。</p><p>“≥3”是一个并不充分的条件。大多数情况下，3个人的活动可以产生足够多的plot以供所有人咀嚼，产生回应，引发一种“消息风暴”。2个人的活动就会大打折扣了。</p><p>我在说<strong>二人关系是乏味的</strong>，听起来有点危险。</p><hr><p>其实应该写游记的，但是祁老师已经写了主要情节，我就偷个懒搬来好了（）</p><p>一切的起因都要从一顿饭吃完回来已经过了十二点开始。</p><p>@祁念←半夜不好意思敲醒阿姨回宿舍的人<br>@茶栗←有人建议就会很乐意夜骑&#x2F;唱唱的人<br>@洗先生（Tilnel）←一件随机刷新的活动有≥3（含自己）就容易参与的人<br>三人成组，踏上行程准备，在玄武湖和晓庄中间选择了更近的目的地。</p><p>《自行车篇》<br>洗杯子先生记起来自己其实还有一辆被自己遗忘在宿舍门前数月的公路自行车，作为没有哈啰月卡又没办法骑电动车出校的人，选择回去看看公路车是否可用——结果当然是不可用的，从车山车海中把车举起来放出来的下一秒，车的瘪后胎就说明了自己不堪大用。于是选择了（看上去）更适合当天行程的价值8.6元的哈啰七天卡，此处是一个伏笔。</p><p>在出门的过程中，洗杯子先生认为自己的车需要重买，于是以五十块把车当场抛售给了乐得如此的cj——至于cj要花多少个五十块才能修好这辆车，此乃后话。</p><p>骑至金鹰附近借洗手间休整后，洗杯子先生突然发现，七天卡的权益不同于高贵的两小时无限次的月卡，单次最长时间其实只有30min——发现这件事的时候，已经37min后了，于是支出+1元。</p><p>此后订了闹钟，每半小时休整一次更新哈啰时间，最终在数次导航cj的偏航之后抵达了目的地——某不知名的夜不落食物街道。尽管当时已经近凌晨四点，街边小摊和相当多的临街店铺还在营业。随机选择了一家幸运早餐店作为补给。虽然选择了这家店的cj并没有吃，价格算得上低廉，味道也不差。</p><p>吃饱喝足之后再次上路，弹出的消息却是“您的哈啰权益已过期”，经过仔细确认和休整次数的回忆，三人惊喜的发现没有麻麻的哈啰的七天卡，是七天五次，反复开关最终提前刷爆了额度——不过其实还有三次助力车，但是南京压根没有助力车。于是洗杯子先生进入了今日第不知道几绷并表达了对哈啰的亲切问候。</p><p>尽管如此，限于有人骑自己的车来，还是没办法打车，又“骑都骑了”，最终继续选择哈啰上路。“这次要不你就全程开得了别开卡了？”“开了，因为我发现续卡只要4.1元。”——这 绝 对 是 消 费 陷 阱。</p><p>返程途中还是继续保持三十分钟一停的规律……吗？在某个三十分钟后试图休整的洗杯子先生遇到了全新的滑铁卢，哈啰单车颇为别出心裁将运营区挖了个洞——尽管来时我们走过相同的路，但是来时恰巧避开了这里休整。此处我们位于洞中，最近的回运营区重置时长的方式是倒车，但显然，倒车对于这种骑行还是太残忍了，最终骑到了路线经过的下一个运营区，换句话说，支出+1元。</p><p>总之最终先到了KFC吃cj的早餐，又到了金鹰711与起得早得过头的kakaa会合进行了一波消费。消费过后，尽管kakaa的后座仍可以坐人，但是一方面，“既然追求骑行，不如贯彻到底”，cj和洗杯子先生还是选择骑行；另一方面“自己的不爽固然令人难受，但同行人的舒适更加令人揪心”，被cj和洗杯子先生否决了“骑一辆更舒适的车这样自己可以顺势坐kakaa后座”的提议的祁念同学终究继续骑行。</p><p>最终四人从西门进校，进校后的第一件事是更换至自己具有高贵的电动车小蓝月卡的座驾，并放言“现在有两个人舒服了”。</p><p>舒服挺好，如果剩下的六次助力车次数能在七天内用完就更好了（笑）</p><blockquote><p>祁念: 其实返程cj提过从南京站走从钟山南侧回来，被两个人同时否了</p><p>洗先生: *绝对会死的*</p><p>祁念: *绝对会死的*</p></blockquote><hr><p>《厕所篇》<br>不知道为什么当天在厕所处的笑点如此之多，大概人类还是需要厕所。</p><p>在去查看洗杯子先生的公路车近况之前，cj提过一次用教学楼洗手间，可能是公路车的现况太过好笑且震撼，也可能是被冷风把脑壳吹不清醒了，三人直接出门前往晓庄了。</p><p>鉴于出门前校内711恐怖长队现状，祁念提出可去金鹰711逛一圈看看情况，于是稍微变更了一下路线经由金鹰前往目的地。抵达711并购入水补给之后，询问711店员附近的洗手间，店员答曰海底捞，于是出门前往海底捞借用厕所。</p><p>洗杯子先生认为金鹰有一家营业的酒店，上次的23：00左右他仍然有走过南侧的某条路。而具有丰富的阴间时间金鹰海底捞经验的cj认为不然，曾经有幸体验阴间时间海底捞的祁念也认为不然。于是前往金鹰北侧，提车后，洗杯子先生于此时发现哈啰七天卡权益打骨折，祁念同学正在看热闹。</p><p>一抬头cj已然消失，然而东北侧门实则已锁，并不熟悉夜半金鹰的二人确认了半天此路不通，跟着一般通过的路人，找到了略靠西北侧的可用门，并在电梯间遇到了已经用过厕所下楼的cj。什么叫做经验丰富啊[战术后仰.jpg]总之略等了一手之后，三人继续踏上行程。</p><p>在中途的某次停车休整时，路旁十字路口拐角有一间装修十分厕所的建筑，但是它的气味不足又弥补了这一部分。适逢cj正在查询消费记录和地图，好奇心绕行半圈以后发现，这确实是公共厕所，并且门前还有貌似已经收摊的夜市。[如果一间建筑长得像厕所，位置像厕所，那它就是厕所.jpg]</p><p>时间一路快进到抵达大成名店的KFC吃完早餐之后，cj惊喜发现此间KFC的厕所是坏的。在KFC店员和大成名店内部员工的指路下找到了大成名店一楼的厕所——尽管在数米开外，奇妙的气味已经让人有了敬而远之的想法。于是祁念和洗杯子同学一同在外等候cj，而cj在出来以后分享了自己与鼠鼠（rat而非mouse版）在厕所相见的趣闻。</p><p>还好没去。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>性别意识-理性 allegro</title>
      <link href="/20241104-relationship/"/>
      <url>/20241104-relationship/</url>
      
        <content type="html"><![CDATA[<p>正是在对于差异的认知当中——此处的差异指的是对具体交际当中的人而非一种概念上的认识的差异——人才在交往中寻见一种乐趣。因为其中包含了一种事物发展方向的潜能。</p><p>而其中最乐见的恐怕是性别差异。古往今来有不少女扮男装并在长久的相处之后对性别进行重新发现的故事。例如梁祝；例如木兰辞。谜底揭晓的一刻，新的可能性，或者说得更加物化一点，新的选项就出现了。</p><p>其中所暗喻的是什么？长久相处这个环节只是故事当中使用的夸张手段，以凸显出那个性别意识的到来的震惊。事实上性别意识是无处不在涌现的。我想这些故事中都包含了这样一层意思：如果直白地告诉你有一个女性在你的面前，然后你意识到那是一个女性，这样稀松平常的事情并不会引发你对“性别意识”这件事的反思；那好，我就先告诉你她是个男的，再给出真相。这样性别意识涌现的瞬间就被放大了，人的态度会在一瞬间发生变化。</p><p>如果看到这里您应激了，想说自己根本不会有任何波澜，自己对男性女性是一视同仁的，那么您一定是完全未经性化的主体，也就不会成为这篇文章的读者。反过来说，您非常害怕自己被人指出无法对男女性别一视同仁，只能通过反驳的方式自我标榜一下。</p><p>写这段也是终于意识到我有一小撮读者了，会考虑读者对我有期待，而我对读者也有预期，预期读者会是尚未进化掉动物性的 Homo Sapiens Sapiens (现代人类)。为什么动物性如此重要？我临时想到一个简单的二分法，但是刀法不是很精湛：社会化的部分是工具理性，是世界机器运转的关节；未社会化的剩余（欲望）是驱动力，是根本的目的。</p><p>不过这听起来很掉价。不是想说人根本就是为了生物冲动才活在这世界上，我始终认为意识是物质世界将其自身溶化为一种理智的中介，人一定会追求理性当中的无条件者，即一切观念存在的原因。这不仅是一项崇高的事业，也是人的生物本能的一种高阶的表现。理性就这样从“看似的”非理性当中孕育出来。</p><p>更进一步，Willingness 当然是一种理性。婴儿哭哭啼啼需要人哄，也是理性的作用。类比的话，我们无法在非图灵完备的机器上实现一种图灵完备的语言。从非理性上能长出理性来吗？人能够产生理性，只能说明生物冲动虽然看起来是非理性的，但其中含有完整的“理性的潜能”。简单的晶体管几乎什么都不能做，但它们堆起来并且输入程序，仿佛就能思考。</p><p>我缝完了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11月4日纸质稿遗失的②。密码是88888888</title>
      <link href="/20241104-disappeared/"/>
      <url>/20241104-disappeared/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d294e764122956503f89c311d2568bd54be370c97d5ffbd262052ac5580c2e4">346518f25371ed5bd356f6b975c718b10b447f069f24e3eb1dff358858fbb02e6132f4398a81a590a39cf23c0e7e477e5a10f54bce3d5ba6675fd96e8932c25c9ab0440beb9bfe3e5b2fe134c00fa1f0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摸</title>
      <link href="/20241104-slacking/"/>
      <url>/20241104-slacking/</url>
      
        <content type="html"><![CDATA[<p>科研处于一种停滞的状态。我就说真不应该读这个研究生。接下来一段时间要有实质性的进展，但这真的可能吗，在得了痴呆症的情况下？</p><p>我也不知道我的心思到底在哪里，总之飘着。可能是怕手头这点东西到最后并不会有好的成效，也可能是怕不能按照预期的方式工作。但总而言之我不想做这个。我并不想处理这类复杂的要高强度动脑的知识。可能只想唱唱歌，做做数独——甚至有的时候做数独都会感觉累；养养花，看点好看的，吃点好吃的，体验很多不一样的事情。比待在实验室里撸代码更有成就感。</p><p>大概是哪怕平时感到微不足道的成就也大于在科研上做出了什么，毕竟与人交互的反馈是大于与物质世界交互的反馈的。</p><p>我认为我心理上是健康的，但是一提到工作就不太健康了，这是我的困境。反过来说如果我希望工作有所进展的话，是不是就需要自觉放弃一点心理健康程度？</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于穿衣这件事情，有一些不成熟的想法</title>
      <link href="/20241024-night/"/>
      <url>/20241024-night/</url>
      
        <content type="html"><![CDATA[<p>自从看了 JOJO 时尚考之后，我就再也停不下来关注这些时装品牌了。虽然现在还很不容易看出一场show的主题，也说不出每个look到底有哪些设计元素，但总之能够看到服装，尤其是男装，并不是以前所想的那么沉闷的主体。当然到了这里也应当说，也许女装当中的设计随便抖一抖撒到男装上，都能做出许多新鲜的东西了。</p><p>第一推荐的时尚博主是 <a href="https://space.bilibili.com/353368172">AHALOLO-Bilibili</a>。也许是在中文互联网上最容易接触到的最前沿的，并且是解读过的时装咨询。两位主持人自身无论是知识素养还是外形条件都足够打了。</p><p>当然作为学生党肯定是买不起奢侈品的。但是也有不少方法可以借鉴，而不会停留在观看</p><ul><li><p>挑选认为好看，有意思的单品，并去找平替</p></li><li><p>一些小细节&#x2F;装饰可以从基础款手动改出来</p></li><li><p>看一场秀&#x2F;一件单品的思路，然后在自己搭配时反复强调</p></li></ul><p>有的时候也许重要的不是喜欢什么风格，喜欢什么单品。而是“我”如何让这件单品在我身上变得更合理。从衣服装饰人变成人去配合衣服，听起来不可思议，但对于卖衣服的人来说，在他们拿到成衣设计的时候，这是一个基本思路。</p><p>买衣服一定要挑模特。首先没有模特效果图的衣服要慎买。但是为什么对于消费者来说，选择好的模特比选择看起来不那么专业的模特，也是合理的？如果模特本身的素质很牛逼，套个麻袋都好看，是不是容易让自己造成误判？</p><p>我的思路是这样的：对于同一家店，选模特与摄影的审美（能力）与其服装设计的审美（能力）几乎是匹配的。这意味着如果模特图的效果就很差，那么一定是在某个审美的环节除了问题。这样你还能够相信他们的衣服吗？假如衣服确是设计得精良，那么设计者一定不会允许在最终呈现效果上打了折扣。</p><p>对于时装品牌，除了衣服本身的素质以外，秀场也会非常在乎 styling。现代的模特们已经几乎不走台步了，然而谁也都能感受到，每一场每一场之间，随着主题的不同，模特们的步伐，神态etc都是贴着场景的需要走的。</p><p>穿衣这件事情，其目的本身就是去呈现一种感觉。服装设计是固定的，因而最大的变量还是人本身。</p><p>「观察」是掌握美的第一能力。</p>]]></content>
      
      
      <categories>
          
          <category> 时尚 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>和 Blue 的聊天记录</title>
      <link href="/20241023-chat/"/>
      <url>/20241023-chat/</url>
      
        <content type="html"><![CDATA[<p>Blue 0:07:47 我好喜欢半夜在外面乱转啊 完全不想上楼回家</p><p>Tilnel 0:08:18 无数次夜游玄武湖了 回家&#x2F;回宿舍好无聊</p><p>Blue 0:11:05 昨天&#x2F;前天去了四种宗教的宗教场所（门口）</p><p>Blue 0:16:19</p><blockquote><p>Boss 0:09:11 哎 我真的活着吗</p></blockquote><p>连我都活着 您可比我热爱生活多了</p><p>Blue 0:16:49 我想 如果能被人感知到的话 大概是确实活在世上的</p><p>Blue 0:17:44 比如要是我说话没人理的话 我的存在就弱一分</p><p>Blushed 0:18:01 我配热爱生活吗</p><p>Blue 0:18:12 您在做对世界产生变化的事</p><p>Blue 0:18:28 说明您激烈地欲继续生活</p><p>Boss 0:18:59 我现在不想变化了</p><p>Blushed 0:19:03 也许只是激烈地想证明自己活着，或者一些其他事情</p><p>Blue 0:20:15 您还在关注世界</p><p>Blue 0:21:02 说明您大概还想深入生活的更多可能性</p><p>Blue 0:22:00 （天哪 不躺着的半夜真是有魔力吧 我这辈子讲过这么积极的话吗</p><p>Blushed 0:22:16</p><blockquote><p>Blue 0:21:02 说明您大概还想深入生活的更多可能性</p></blockquote><p>我不关注这个世界，也不胆敢深入什么可能性。我只是由于感到一些责任或者牵绊，还不能就此放手。</p><p>Blue 0:23:11 我此刻竟觉得 如果我在过去的某些时候能说这些话 或许我的生命能有翻天覆地的变化呢</p><p>Tilnel 0:24:40 每个人的生命是有自己的节奏的</p><p>Tilnel 0:25:11 有些事情就是会迟到，您可能会因此觉得有点委屈</p><p>Blue 0:25:29</p><blockquote><p>我不关注这个世界，也不胆敢深入什么可能性。我只是由于感到一些责任或者牵绊，还不能就此放手。</p></blockquote><p>我很多时候想着 我要爱这些牵绊 这样我就暂时没有必要惶恐 仅仅一刻也好 我只是想要顺从他们 让他们把我安全地缚在这地上</p><p>Tilnel 0:26:55 这样是对的</p><hr><p>Blue 0:27:57 我有点开心了</p><p>Blue 0:28:12 去便利店看看有什么啤酒</p><p>Tilnel 0:29:20 我们来到这里都是为了寻找更多的羁绊。我们享受这种受迫而不得不做某些事的感觉，因为我们自己是从来没有什么必须要做的事的</p><p>Blushed 0:30:10 为什么开心的时候要饮用酒精呢</p><p>Blushed 0:30:23 为什么难过的时候要饮用酒精呢</p><p>Blue 0:31:18 不知道</p><p>Blue 0:31:30 但是喝啥呢</p><p>Tilnel 0:31:32 为了去见邪恶的酒神！</p><p>Blue 0:31:38<br><img src="image-20241023044758338.png" alt="image-20241023044758338" style="zoom:50%;"></p><p>Tilnel 0:31:39 喝Asahi</p><p>Blue 0:32:24 我记得21年夏天我在摇联的活动上喝asahi</p><p>Blue 0:32:55 有个老哥叫我别一个人喝闷酒</p><p>Blue 0:33:47 然后我就混入了他们其中</p><p>Blue 0:33:58 开始乱叫乱跳</p><p>Blue 0:34:46 现在想想感觉就像那个一夜情</p><p>Blue 0:35:03 后来我也从来没有认识过他们其中的任何人</p><p>Blushed 0:36:10 人生也许就是这样子的</p><p>Blushed 0:36:26 会在某段时间和一些人聚在一起做某些事情</p><p>Blushed 0:36:48 后来再也没有认识甚至见过他们其中的任何人了</p><p>Blushed 0:37:21 最后认识的人也会不认识，见过的人也不会再见</p><p>Blue 0:37:32 有什么不好呢</p><hr><p>Blushed 0:38:42 我为什么戒酒呢？</p><p>Tilnel 0:39:27 不想度过一个荒唐的夜晚</p><p>Tilnel 0:39:44 但其实不喝酒的每天也都是很荒唐的</p><p>Blue 0:40:16 我手里这罐asahi是500ml的</p><p>Blue 0:40:33 我记得那年我喝的是1500的</p><p>Blue 0:40:45 别人都倒出来分着喝的</p><p>Blue 0:40:58 但是我对嘴了</p><p>Blue 0:41:11 而且也没有和我分酒喝的人</p><p>Blushed 0:41:22 因为如果我主动找酒喝且酒足够的话，我一定会喝醉。因为那就是我想要的。但是失去意识的时候并不会停止讲话或者做事。</p><p>Blushed 0:41:44 我难以承受这些无意识行为带来的后果</p><p>Tilnel 0:43:10 没被朋友拍成大型纪录片就不错了（</p><p>Blushed 0:43:12 我可以有意识地去做荒唐的事情，那是我选择的；但我害怕无意识地去做荒唐的事情，因为我没有经历过程，却不得不接受后果</p><p>Blushed 0:43:27 也许已经被拍成大型纪录片了</p><p>Blue 0:43:44 真的不得不接受后果吗</p><p>Tilnel 0:44:08 我认为无意识地表达点什么也挺好的</p><p>Tilnel 0:44:27 如果有所记录的话你还可以用来解读自己</p><p>Blue 0:44:50 我其实挺期待看到无意识的自己的</p><p>Blushed 0:44:56 但是我并不是自言自语</p><p>Blushed 0:45:05 我是在和别人说话</p><p>Blue 0:45:32 听我爸妈说我睡着了之后就像是死了 不会动当然也不会说话</p><p>Blue 0:45:41 我觉得挺没意思的</p><hr><p>Blushed 0:46:27 当我输出一些给自己看的文本的时候，我发现充满了情绪垃圾</p><p>Blushed 0:47:10 我曾经向某人展示过我的精神废料，后来人家就再也没有理我了</p><p>Blue 0:48:09 我常常觉得我不知道什么是我</p><p>Blushed 0:48:15 与其说我的写作能力在下降，毋宁说大学以来我作为人的能力就在退化</p><p>Tilnel 0:48:18 写blog吧（</p><p>Tilnel 0:48:39 被动地展示精神废料</p><p>Blue 0:48:45 我想如果把理智剥离的话 我或许能知道什么是我吧</p><p>Blushed 0:48:47 说实话，我并不知道技术上怎么去维护blog</p><p>Blushed 0:49:02 我不知道如何搭建个人主页</p><p>Tilnel 0:49:07 开个博客园，etc</p><p>Tilnel 0:49:51 然后在一些角落里若无其事地挂个链接</p><p>Blue 0:50:16 我没啥写作能力</p><p>Blue 0:50:37 积了很多很多500字的东西</p><p>Blue 0:50:51 最多也就能连续写2000</p><p>Blushed 0:50:53 好久没有写作了</p><p>Tilnel 0:51:05 我的博客大多都是笔在纸上滑到哪里算哪里，然后照着敲进电脑</p><p>Tilnel 0:51:15 大多都是零散的</p><p>Tilnel 0:51:34 重要的不是连续的文字生成</p><p>Blue 0:51:43 而且我还喜欢讲事情之前前摇</p><p>Tilnel 0:51:43 而是你写文字当中的犹豫和沉默</p><p>Blue 0:52:02 所以基本还没摇完就不想写了</p><p>Blue 0:52:15 我感觉我比较适合发微博</p><p>Blue 0:52:26 一句话暴论</p><p>Blue 0:52:45 妈的 想把手机扔进河里</p><p>Tilnel 0:53:10 我也常有一些暴力冲动（</p><p>Tilnel 0:53:20 比如躺床上就会想着把床板拍烂</p><p>Blushed 0:53:31 也许确实可以考虑搭建一个个人主页了</p><p>Blushed 0:53:46 有一些protocol还没有系统地整理</p><p>Blushed 0:54:10 一直没有动力去做这件事情</p><p>Blue 0:54:12 我躺床上的时候总想被钉在床上</p><p>Blushed 0:54:19 常常感觉自己是个废物</p><p>Blue 0:54:40 很简单的</p><p>Blue 0:55:43 github.io</p><p>Tilnel 0:56:43 写一些markdown放在github里我觉得都够了（</p><p>Tilnel 0:57:10 讲究一个形式</p><p>Tilnel 0:57:49 甚至可以提issue评论</p><p>Blue 1:00:51</p><blockquote><p>Blue 1:00:51 我躺床上的时候总想被钉在床上</p></blockquote><p>想象被什么长兵贯穿心脏钉住</p><p>Tilnel 1:02:34</p><blockquote><p>Blue 1:00:51 想象被什么长兵贯穿心脏钉住 </p></blockquote><p>想保持对生活的热情可能真的需要自觉地去当一个剧情发动机</p><p>Blue 1:02:53 啊 月亮露出来了</p><p>Blue 1:03:10 云层上的风看起来很大</p><p>Tilnel 1:03:51 生活需要一点dramatic</p><p>Blue 1:04:15 唉 走路有点晃了 上楼喝吧</p><p>Tilnel 1:04:22 陪一杯（</p><p>Tilnel 1:06:27 我躺在床上会被恶灵附身</p><p>Blue 1:06:31 家里只有酸奶</p><p>Blue 1:06:31 啊 在电梯里喝没了</p><p>Boss 1:06:35 我在玉玉什么</p><p>Boss 1:06:36 我不知道</p><p>Tilnel 1:06:52 你在嫉妒</p><p>Tilnel 1:07:06 你在委屈</p><p>Tilnel 1:07:08 你在。。。</p><hr><p>Blue 1:09:48 我中学的时候晚上回家 我妈都会让我快吃饭 但是我从来就更喜欢用睡觉来抵抗饥饿</p><p>Blue 1:10:02 或者我其实根本感觉不到饥饿吧</p><p>Tilnel 1:10:10 我就不行，因为白天耗能太高了</p><p>Tilnel 1:10:15 中学的时候</p><p>Tilnel 1:10:30 我们中学的食堂又是一坨</p><p>Tilnel 1:10:39 经常夜里回家狼吞虎咽</p><p>Blue 1:11:12 哈哈 我中学食堂也</p><p>Tilnel 1:11:15 现在想想还是很神奇，也许高中才是人最脆弱的时候</p><p>Blue 1:11:21 甚至小学食堂也</p><p>Tilnel 1:11:37 我会因为被早饭粥烫到了就大哭（</p><p>Blue 1:11:47 所以我大概中午也不怎么吃</p><p>Blue 1:12:02 后来我妈退休了 他就天天中午给我送饭</p><p>Tilnel 1:12:57 真好，我得自带</p><p>Tilnel 1:13:55 高中只是强度大，但是现在事情实在变得复杂</p><p>Blue 1:14:12 唉</p><p>Tilnel 1:14:17 我真希望不带脑子生活</p><p>Blue 1:14:26 我大概是不配聊高中的</p><p>Blue 1:14:46 闭麦了</p><p>Tilnel 1:15:02 怎么寸止了</p><p>Tilnel 1:15:21 那就不聊高中！</p><p>Qin 1:15:28 大概是觉得保送生有点开</p><p>Twist 1:15:43 sbw的名字终于有我喝过的了</p><p>Tilnel 1:15:58 有喝过我做的这款吗</p><p>Blue 1:16:11 我也喝过</p><p>Tilnel 1:16:12 大言不惭，但是全南京第一</p><p>Blue 1:16:18 群友调的</p><p>Tilnel 1:17:01 所以为什么要摆摊呢</p><p>Qin 1:17:13 不是好玩吗</p><p>Tilnel 1:17:17 大概是我想主动当一个剧情发动机了</p><p>Blue 1:21:51 唉 躺下之后就不想说话了</p><p>Tilnel 1:22:01 您躺下之后会想什么</p><p>Blue 1:22:08 感觉我是个不称职的社畜</p><p>Tilnel 1:22:33 称不称职不是自己该考虑的（</p><p>Tilnel 1:22:44 老板觉得你好就是好</p><p>Blue 1:23:03 嗯</p><p>Blue 1:23:32 社畜一般都啥时候睡觉呢</p><p>Tilnel 1:23:52 这个点，或者两三点</p><p>Tilnel 1:24:04 要不问问吉良</p><p>Blue 1:24:06 五六点睡吧</p><p>Tilnel 1:24:14 吉良11点</p><p>Blue 1:25:31 上半年的时候 我在南京睡不好觉吃不下饭 在上海还行</p><p>Blue 1:25:44 现在在上海也不太行了</p><p>Blue 1:26:09 之前吃了一罐褪黑素软糖</p><p>Blue 1:26:14 真好吃啊</p><p>Tilnel 1:26:19 我感觉褪黑素这玩意</p><p>Blue 1:26:21 所以不敢吃了</p><p>Tilnel 1:26:27 让我睡醒之后也没精神</p><p>Tilnel 1:26:36 所以用了一次之后就再也没用过了</p><p>Tilnel 1:26:59 主要还是连吃两粒也没睡着</p><p>Blue 1:27:03</p><blockquote><p>Blue 1:26:14 真好吃啊</p></blockquote><p>“您真的没overdose吗？”</p><p>Blue 1:27:10 哈哈</p><p>Tilnel 1:27:15 不要碰od</p><p>Blue 1:27:19 我连着吃6粒</p><p>Tilnel 1:27:57 我买的是汤臣那个</p><p>Blue 1:28:04 但是旺仔qq糖真没他好吃</p><p>Tilnel 1:28:04 应该是没什么味道</p><p>Tilnel 1:28:32</p><blockquote><p>Tilnel 1:27:15 不要碰od</p></blockquote><p>算了我也不好说</p><p>Tilnel 1:28:38 我这是不是一种酒精od</p><p>Blue 1:29:07 唉 感觉我现在可能有点癫 所以说这些话</p><p>Tilnel 1:29:15 癫好</p><p>Tilnel 1:29:47 如果我能保持100g酒精的微醺状态并且不用开车，我觉得我身边的人都会幸福一点（</p><p>Tilnel 1:30:13 小嘴嘎嘎能讲</p><p>Qin 1:31:21 作为不喝酒精神状态就已经不太正常的选手</p><p>Blue 1:31:37 我不喝酒的时候精神状态很正常吗</p><p>Qin 1:31:43 我觉得还是不要再用酒精挑战我的精神状态下限</p><p>Blue 1:32:06 我想有些群友大概一直都能发现我不太正常</p><p>Blue 1:32:21 说到底 什么是正常呢</p><p>Tilnel 1:32:23 什么是正常</p><p>Qin 1:32:29 什么是正常呢</p><p>Tilnel 1:33:15 自己觉得好的状态就是好的</p><hr><p>Qin 1:34:29 一点半把宿管喊醒编个ID</p><p>Tilnel 1:34:50 其实真实ID也不会怎样</p><p>Otaku 1:35:35 哦对 您可以去计科楼824</p><p>Tilnel 1:35:54 824－9有一张可以躺的椅子（</p><p>Otaku 1:36:00 还有纸质读物</p><p>Qin 1:36:17</p><blockquote><p>Otaku 1:36:00 还有纸质读物</p></blockquote><p> 这下想去了</p><p>Tilnel 1:37:39 我恭维的纸质读物大多已经被我录进博客了</p><p>Tilnel 1:37:44 工位*</p><p>Qin 1:38:07 不对吧，中间有一段blog断更说是记笔记了</p><p>Tilnel 1:38:21 噢对</p><p>Qin 1:38:25 不会首字母缩写连连看确实缺乏一些乐趣（</p><p>Tilnel 1:38:27 也在工位上</p><p>Tilnel 1:38:41 您要盒谁我可以直接告诉您（</p><p>Qin 1:38:50 太诚实了以至于完全就是诱饵</p><p>Tilnel 1:39:09 诚实吗</p><p>Tilnel 1:39:23 我觉得还差一点</p><p>Qin 1:39:43 真有人能对自己的文字完全诚实吗</p><p>Tilnel 1:39:55 说出来的和想的事情之间有一道无法逾越的鸿沟</p><p>Tilnel 1:40:05 更别提发布版了</p><p>Tilnel 1:40:12 但我在尽量诚实</p><p>Qin 1:40:18 我不写这种东西的原因就是我对自己的文字大概不诚实</p><p>Tilnel 1:41:12 其实写作的最终的玩法就是咀嚼自己写作过程中犹豫不决的，避而不谈的部分</p><p>Tilnel 1:41:32 当然阅读的最终玩法也是这样（</p><p>Qin 1:42:13</p><blockquote><p>Tilnel 1:41:12 其实写作的最终的玩法就是咀嚼自己写作过程中犹豫不决的，避而不谈的部分</p></blockquote><p>问题是自己都没办法把真正犹豫不决的东西付诸纸上（</p><p>Tilnel 1:42:13 “你为什么没说，必定有诈！”</p><p>Tilnel 1:43:26</p><blockquote><p>Qin 1:42:13 问题是自己都没办法把真正犹豫不决的东西付诸纸上（</p></blockquote><p>只是走这样一个过程而已。那些平时没意识到但是写的时候犹豫不决的东西会在自己的心里留下痕迹</p><p>Tilnel 1:43:36 一种自我诊断法</p><p>Tilnel 1:43:55 真正有用的从来不是静态的文字</p><p>Tilnel 1:45:09 看到一道裂谷的时候，第一个想的会是裂谷是如何形成的，而不是周边的平原</p><p>Tilnel 1:47:06 因为人天生知道，这道惊为天人的奇观底下才蕴含着地球内部活动的最大动力</p><hr><p>Blue 1:47:34 谢谢大家 给我发了6年钥匙扣</p><p>Tilnel 1:48:07 唉 zijingbt</p><p>Tilnel 1:48:19 今天还在品鉴紫荆的遗产</p><p>Blue 1:51:51 这么多年了 还没真的看完girl’s guide</p><p>Tilnel 1:52:07 有这个，可惜用不上</p><p>Tilnel 1:52:16 因为不是 girl</p><p>Tilnel 1:53:09 当时紫荆预告关服，然后我匆忙地下载了很多资源，填满了所有的机械硬盘</p><p>Tilnel 1:54:04 可能信息量最大的还是一堆kindle的电子书合集</p><p>Tilnel 1:54:42 你说，我手里掌握了一辈子都读不完的精神文明，但是却觉得自己依然精神匮乏</p><p>Tilnel 1:54:51 是怎么回事呢</p><p>Qin 1:55:42</p><blockquote><p>Tilnel 1:54:42 你说，我手里掌握了一辈子都读不完的精神文明，但是却觉得自己依然精神匮乏</p></blockquote><p>应聘图书馆管理员能让自己变得精神富足吗</p><p>Tilnel 1:55:54 对啊，这是怎么回事呢（</p><p>Tilnel 1:57:56 关站的时候我还传了一份白色相簿2的游戏然后被拒了（</p><p>Blue 2:00:23 即使都读了 很多时候也只是六经注我 只能读到我能懂的东西</p><p>Tilnel 2:00:40 那我觉得没什么问题</p><p>Tilnel 2:00:53 很多东西就是单纯的没读</p><p>Tilnel 2:01:07 我借图书馆的书已经超期了</p><p>Blue 2:01:15 我也不知道 人从什么时候开始就接受不了新的思想了呢</p><p>Tilnel 2:01:16 9天</p><p>Blue 2:02:15 如果这个世界上所有尚未属于我的事物都已经不再能被我所认识 那我就觉得确实起离死不远了</p><p>Tilnel 2:03:32</p><blockquote><p>Blue 2:02:15<br>如果这个世界上所有尚未属于我的事物都已经不再能被我所认识 那我就觉得确实起离死不远了</p></blockquote><p>我现在已经改变目标了</p><p>Tilnel 2:03:41 我想要各种 好看的东西</p><p>Tilnel 2:04:08 胜过某种新奇的认识</p><p>Blue 2:04:46 我其实觉得新奇的认识是精神自虐</p><p>Tilnel 2:04:50 也许应该学服装设计</p><p>Blue 2:04:53 我大概喜欢这个</p><p>Tilnel 2:04:58 计科只是planB</p><p>Blue 2:05:21 喜欢把自己置于一个痛苦的位置上</p><p>Tilnel 2:05:44 明白。。。</p><p>Blue 2:05:55 然后对自己说 这都是你活该 思想配得上苦难</p><p>Tilnel 2:05:59 认识到新的东西是有阵痛的</p><p>Tilnel 2:06:22 很多曾经笃信的东西都打碎了重新考量</p><p>Tilnel 2:06:37 然后不接受退缩的自己，也不接受新的</p><p>Blue 2:07:02 我确实有许多没来由的信条</p><p>Tilnel 2:07:05 所以，《彷徨》</p><p>Blue 2:07:17 但是大部分时间我还是</p><p>Blue 2:07:30 痛于自己失去了信仰的能力</p><p>Blue 2:08:53 如果能甘愿顺从于一种神圣力量的话 大概能生活地更简单吧</p><p>Tilnel 2:08:58 现在处于一种，悬置的状态</p><p>Blue 2:09:09 甚至能感觉到被爱呢</p><p>Tilnel 2:09:11 没法判断任何东西</p><p>Tilnel 2:09:52 相应地，对于很多事情的接受度也虚假地提高了</p><p>Blue 2:10:03 我中学附近的基督新教教堂的匾上就写着类似于爱与信仰的事情</p><p>Blue 2:10:15 唉</p><p>Blue 2:10:40 论爱欲也没看完 pending一个多月了</p><p>Blue 2:10:51 我天天都在干什么</p><p>Tilnel 2:11:53 您可千万别</p><p>Tilnel 2:12:04 算了，我希望你不要</p><p>Blue 2:12:27 没事</p><p>Blue 2:12:38 我大概现在并不知道我在说啥</p><p>Tilnel 2:12:40 至少我希望我不要</p><p>Tilnel 2:13:11 总之我希望自己有一种信仰的能力，但是不要信仰任何东西</p><p>Tilnel 2:13:30 这样能保留一种潜能</p><hr><p>Blue 2:13:46 应该就是没在思考了 只是在把自己想过的事情读出来而已</p><p>Tilnel 2:14:05 我也是啊</p><p>Tilnel 2:14:27 还坐在阳台上喝呢</p><p>Tilnel 2:14:58 我可能已经复读这些东西一两年了</p><p>Blue 2:15:12 嗯</p><p>Blue 2:15:15 我也是吧</p><p>Blue 2:15:29 我不相信我这些话是没说过的</p><p>Tilnel 2:16:00 但总之我还相信一件事</p><p>Tilnel 2:16:20 就是这些话背后的原因可能就是非常简单的一件事</p><p>Tilnel 2:16:29 对于这些课题大概微不足道</p><p>Tilnel 2:17:10 那也许“幸福”就是微不足道的</p><hr><p>Blue 2:17:17</p><blockquote><p>Blue 2:15:29 我不相信我这些话是没说过的</p></blockquote><p>但是我挺好奇的 我在什么时候什么地点说什么话能得到谁的回应呢</p><p>Blue 2:17:48 毕竟大部分时候 是没有回应的</p><p>Tilnel 2:18:57 我会暗自期望一种没有回应的分支</p><p>Tilnel 2:19:25 任何形式上的回应可能都会触发一种短路</p><p>Tilnel 2:19:52 于是此处的答案就不是我自己的了</p><p>Tilnel 2:20:04 或者说，此处我就没有思考的机会了</p><p>Blue 2:20:15</p><blockquote><p>Tilnel 2:18:57 我会暗自期望一种没有回应的分支</p></blockquote><p>我也</p><p>Qin 2:20:21 那您期待的是自己说着说着想明白了吗</p><p>Blue 2:20:31 我想我说话的结局一定是不再说话</p><p>Tilnel 2:20:32 yep</p><p>Blue 2:20:44 但是我比较懦弱</p><p>Blue 2:21:21 我会想 如果是有强制力命令我不再说话就好了</p><p>Tilnel 2:21:33 我有一个暴论</p><p>Tilnel 2:21:47 就是人其实是畏惧自由的</p><p>Blue 2:21:48 这样我就可以把自己摆在受害者的位置上</p><p>Tilnel 2:21:59 因为自由代表自甘风险</p><p>Tilnel 2:22:08</p><blockquote><p>Blue 2:21:48 这样我就可以把自己摆在受害者的位置上</p></blockquote><p>和你这句差不多</p><p>Tilnel 2:22:50 如果遵从某种命令，那么错误就可以归咎于某种异己的力量</p><p>Tilnel 2:23:09 完全的自由就是另一回事</p><p>Blue 2:23:10</p><blockquote><p>Blue 2024&#x2F;8&#x2F;8 22:39:49 我就是想要得到一个貌似权威的、先验正确的规范 然后他全然地战胜了我 我就能轻松地放弃思考 屈服于他 并把不思考的罪孽和逃避的责任推给他…</p></blockquote><p>。</p><hr><p>Tilnel 2:23:25 唉</p><p>Tilnel 2:23:31 所以我是M（</p><p>Tilnel 2:23:41 而且这世界上M多S少</p><p>Blue 2:23:48 我是m吗</p><p>Blue 2:23:51 我不知道</p><p>Blue 2:24:02 也有群友说过我是s</p><p>Blue 2:24:22 还有群友说过什么别的</p><p>Tilnel 2:26:47 S其实是世界的M</p><p>Tilnel 2:27:05 祂是世界施虐的代行者</p><p>Tilnel 2:27:34 所有人都是M罢了（</p><p>Blue 2:27:46 唉</p><p>Tilnel 2:27:49 感觉说得有点多了</p><p>Tilnel 2:28:06 喝得也有点多了</p><p>Blue 2:28:15 想起昨天早上 明明起得很早</p><p>Qin 2:28:34</p><blockquote><p>Tilnel 2:27:34 所有人都是M罢了（</p></blockquote><p>前两天和朋友聊过，我觉得这种逻辑推完了所有人都是M，反过来讲所有人都不是M</p><p>Blue 2:28:42 还是把自己按在床上做了20min清明梦</p><p>Tilnel 2:28:56</p><blockquote><p>Qin 2:28:34 前两天和朋友聊过，我觉得这种逻辑推完了所有人都是M，反过来讲所有人都不是M</p></blockquote><p>完全可以这么说</p><p>Blue 2:29:05 上班的路上整个人都还是恍惚的</p><p>Tilnel 2:29:46 所以是“逻辑”自身有问题</p><hr><p>Blue 2:29:57</p><blockquote><p>Blue 2:28:42 还是把自己按在床上做了20min清明梦</p></blockquote><p>虽然这很亵渎但是 我实在喜欢做神的感觉</p><p>Tilnel 2:29:58 我在说什么</p><p>Blue 2:30:25 但是又觉得作为人是不能贪恋这个的</p><p>Blue 2:30:29 这是危险的</p><p>Tilnel 2:30:34 好</p><p>Qin 2:30:37 没事，你有一半的意思是酒精代驾的</p><p>Qin 2:30:54 适合文艺创作的状态</p><p>Qin 2:31:01</p><blockquote><p>Qin 2:30:37 没事，你有一半的意思是酒精代驾的</p></blockquote><p>意识*</p><p>Tilnel 2:31:06 酒精可能不是代驾</p><p>Tilnel 2:31:22 我才是代驾（</p><p>Blue 2:31:29</p><blockquote><p>Blue 2:29:57 虽然这很亵渎但是 我实在喜欢做神的感觉</p></blockquote><p>我太自大了</p><p>Tilnel 2:31:35 是我替世界说</p><p>Tilnel 2:31:52 感觉好糟糕啊</p><hr><p>Qin 2:32:13 自大的人会说自己自大吗</p><p>Tilnel 2:32:18</p><blockquote><p>Blue 2:31:29 我太自大了</p></blockquote><p>我倒挺羡慕的？</p><p>Blue 2:33:01 我有一个信念吧</p><p>Blue 2:33:12 唯有矛盾的才是真实的</p><p>Blue 2:33:36 所以因为我是自卑的所以我是自大的</p><p>Qin 2:34:03 我认可自卑自大二象性</p><p>Blue 2:34:06 因为我的自我意识过强 所以我欲抹掉我的存在</p><p>Blue 2:34:35 他们只能同时为真 虽然看上去是矛盾的</p><p>Tilnel 2:35:00 抹平是不符合能量最低原则的（</p><p>Blue 2:35:07 唉 我觉得我并不是酒精代驾</p><p>Blue 2:35:25 我和不少人平时说话估计就这样</p><p>Tilnel 2:35:59 有一个差异蹦出来才是最自然的</p><p>Tilnel 2:36:29 你已经完成一种循环了</p><p>Sakuran 2:37:14</p><blockquote><p>Qin 2:32:13 自大的人会说自己自大吗</p></blockquote><p>或许会的</p><p>Sakuran 2:37:25 自大的人不一定认识不自己自大</p><p>Sakuran 2:37:52 有的时候会意识到自己的自大，但在无意识间又会让自己的自大气氛弥散出来</p><p>Tilnel 2:38:01 但是一个自大的人只认识得到自己的自大这件事是不可能的</p><p>Tilnel 2:38:13 因为认识到自己的自大的同时就已经蕴含了自卑了（</p><p>Blue 2:38:26 唉</p><p>Tilnel 2:38:30 就是，我在这里装什么呢</p><p>Tilnel 2:38:36 这种感觉</p><p>Blue 2:38:46 好想今天早上也做清明梦</p><p>Tilnel 2:38:57 他同时认识到的是自己是一只纸老虎</p><p>Sakuran 2:40:28</p><blockquote><p>Tilnel 2:38:30 就是，我在这里装什么呢</p></blockquote><p>太对了</p><p>Tilnel 2:40:53 恰如此时此刻（</p><p>Blue 2:40:56 我刚把钟补回来 迟到还得补</p><p>Blue 2:41:32</p><blockquote><p>Tilnel 2:38:57<br>他同时认识到的是自己是一只纸老虎</p></blockquote><p>怎么说呢</p><p>Tilnel 2:41:39</p><blockquote><p>Blue 2:40:56 我刚把钟补回来 迟到还得补</p></blockquote><p>我觉得就算放您沉默了您还得再想几个钟头</p><p>Tilnel 2:41:43 所以干脆继续聊</p><p>Blue 2:41:49 世界上谁不是纸老虎呢</p><p>Tilnel 2:42:15</p><blockquote><p>Blue 2:41:49 世界上谁不是纸老虎呢</p></blockquote><p>我也会这样想</p><p>Blue 2:42:16 唉</p><p>Blue 2:42:30 我想展示一下我的输入法</p><p>Tilnel 2:42:45 但是人与人直接相对的时候就很容易被击倒（</p><p>Blue 2:43:03 有神秘的联想词</p><p><img src="image-20241023051500751.png" alt="image-20241023051500751" style="zoom:25%;"><img src="image-20241023051513574.png" alt="image-20241023051513574" style="zoom:25%;"></p><p>Tilnel 2:43:42 哈哈哈哈</p><p>Sakuran 2:43:42</p><blockquote><p>Tilnel 2:42:45 但是人与人直接相对的时候就很容易被击倒（</p></blockquote><p>而我常常是被击倒的</p><p>Sakuran 2:44:03 我应该少讲点b话显然</p><p>Tilnel 2:44:06</p><blockquote><p>Sakuran 2:43:42 而我常常是被击倒的</p></blockquote><p>也许是双方都被击倒</p><p>Tilnel 2:44:20 我偶尔觉得您的态度挺好的</p><p>Tilnel 2:44:34 就是一种能一直说下去的感觉</p><p>Tilnel 2:44:54 不管不顾</p><p>Blue 2:44:57 我挺嫉妒Sakuran桑的 我猜</p><p>Tilnel 2:45:02 我要是这样会有多开朗</p><p>Tilnel 2:45:08 不敢相信</p><p>Tilnel 2:45:26 哪怕冷场</p><p>Tilnel 2:45:48</p><blockquote><p>Tilnel 2:44:20 我偶尔觉得您的态度挺好的</p></blockquote><p>不是偶尔，是骤然</p><p>Sakuran 2:46:26 我发觉这是我在线上的社交在进了大学后奇迹般地搬运到了线下</p><p>Blue 2:46:32 我猜我对各位群友的任何负面情绪其实都是酸 而已</p><p>Tilnel 2:46:40</p><blockquote><p>Blue 2:46:32 我猜我对各位群友的任何负面情绪其实都是酸 而已</p></blockquote><p>我觉得没问题</p><p>Tilnel 2:46:44 我一直认为</p><p>Sakuran 2:46:53 因为我在高中时线下呈现出这样的状态是难以置信的</p><p>Tilnel 2:46:54 嫉妒，是我活下去的第一推动力（</p><p>Blue 2:46:58 但是我其实生活得客观上很幸福了</p><p>Blue 2:47:09 所以我好像也没资格酸</p><p>Sakuran 2:47:25 我不知道我的动力是啥，或许是享乐吧</p><hr><p>Tilnel 2:47:55</p><blockquote><p>Blue 2:46:58 但是我其实生活得客观上很幸福了</p></blockquote><p>你们难道都是完全的唯物主义者吗</p><p>Blue 2:48:11 您觉得我难道是吗？</p><p>Tilnel 2:48:13 至少我感觉我是主观唯心的</p><p>Tilnel 2:48:30</p><blockquote><p>Blue 2:48:11<br>您觉得我难道是吗？</p></blockquote><p>大概不是</p><p>Tilnel 2:48:59 所以提出一个客观视角的判断有点难以接受</p><p>Tilnel 2:49:48 然而在一个客观视角上看我其实也有点窘迫</p><p>Tilnel 2:51:06 所以我可能希望身边的所有我喜欢的人都尽量能逃离窘境</p><p>Tilnel 2:51:33 也就是尽力支援一下</p><p>Qin 2:52:50</p><blockquote><p>Tilnel 2:49:48 然而在一个客观视角上看我其实也有点窘迫</p></blockquote><p>怎么个客观法</p><p>Blue 2:52:56 我觉得我没有陷入过窘境</p><p>Blue 2:53:08 或者说我宁愿这样认为</p><p>Tilnel 2:53:20</p><blockquote><p>Qin 2:52:50 怎么个客观法</p></blockquote><p>纯主观的客观法（</p><p>Tilnel 2:53:33 自己评判自己</p><p>Blue 2:53:41 可是然后我依然是忧虑的</p><p>Blue 2:54:13 唉</p><p>Sakuran 2:54:57 我没有真的陷入过较大程度上（何为较大程度？）的窘境，但却常常会幻想自己在近未来即将落入这样的窘境</p><p>Sakuran 2:55:16 但我又不真的有动力去为避免之做出努力</p><p>Tilnel 2:55:23 我觉得很小的危机也是一种危机</p><p>Blue 2:55:27 我丝毫没有行动能力</p><p>Sakuran 2:55:35 焦虑与懒惰的伴生是致命的</p><p>Tilnel 2:55:36 就是一个细节可能对别人毫无影响</p><p>Tilnel 2:55:43 但是对自己就至关重要</p><p>Sakuran 2:55:49 是可以杀死人的，或许</p><p>Blue 2:56:07 所以我的一部分会以看戏的心态坐等我的毁灭</p><p>Sakuran 2:56:09 单独的焦虑和单独的懒惰杀伤力尚不足惧</p><p>Blue 2:56:26 但是一直以来 最后都无事发生</p><p>Tilnel 2:56:28 每个人希望能达到自己心中所想的那个状态</p><p>Tilnel 2:56:35 但是可能总是差一点</p><p>Sakuran 2:56:49 丧了 可那并不奇怪</p><p>Tilnel 2:56:51 所以要是能补上那一点也就好了</p><p>Sakuran 2:57:11 这是一种贪婪吗</p><p>Tilnel 2:57:13 但是换一个角度来说，差的那一点正好是一个人发展的动力</p><p>Tilnel 2:57:18</p><blockquote><p>Sakuran 2:57:11 这是一种贪婪吗</p></blockquote><p>不是</p><p>Blue 2:57:28</p><blockquote><p>Blue 2:56:26 但是一直以来 最后都无事发生</p></blockquote><p>所以只剩下可悲的嬉笑而已</p><p>Tilnel 2:58:12</p><blockquote><p>Sakuran 2:57:11 这是一种贪婪吗</p></blockquote><p>也许是世界给你植入的思想钢印</p><hr><p>Sakuran 2:58:30 像是窗外总有阴霾</p><p>Sakuran 2:58:42 嘲笑 可笑的 oh my</p><p>Blue 2:58:43 我不知我是否看起来很焦虑</p><p>Tilnel 2:58:44 <em>不完美</em></p><p>Tilnel 2:58:50 您看起来很焦虑</p><p>Sakuran 2:58:53 心有不甘</p><p>Sakuran 2:59:01 力所不逮</p><p>Qin 2:59:02 感觉晚上的这聊天可以拿去写术力口歌词</p><p>Sakuran 2:59:16 无怪</p><p>Tilnel 2:59:20 非要术力口吗</p><p>Sakuran 2:59:22 世界照常运转</p><p>Sakuran 2:59:31 没有惊喜</p><p>Blue 2:59:32 我妈说我看起来很焦虑 所以他们早就不敢碰我了</p><p>Sakuran 2:59:33 没有意外</p><p>Sakuran 2:59:41 渺小</p><p>Sakuran 2:59:48 那是一种常态</p><p>Sakuran 2:59:58 多么（忘了）</p><p>Blue 3:00:06 我不知道各位看见我的时候我是表现成什么样子</p><p>Tilnel 3:00:24 我觉得我喝酒之后也许是最佳状态</p><p>Sakuran 3:00:27 不用再去奋勇地失败</p><p>Blue 3:00:31 我不知道是否还有机会让各位看见我</p><p>Tilnel 3:00:41 这可能是饮酒的根源</p><p>Sakuran 3:00:48 酒精混搭烟草 爱与梦全部点燃</p><p>Tilnel 3:00:54 草</p><p>Tilnel 3:01:00 开始作词</p><p>Sakuran 3:01:06 我在烟雾中寻找期待</p><p>Tilnel 3:01:20 您这歌不是给赛博丁真唱的吧</p><p>Blue 3:01:24 开始唱唱了</p><p>Sakuran 3:01:29 手心紧握哪怕只是一片虚幻</p><p>Blue 3:01:39 这是背歌词呢</p><p>Tilnel 3:01:48 我狂笑了</p><p>Tilnel 3:01:59 还是在阳台上</p><p>Tilnel 3:03:02 这种时候大笑一声真中断思路了</p><p>Qin 3:03:33 酷</p><p>Tilnel 3:03:43 cool</p><p>Sakuran 3:03:57 所以，我想要说的，前人全都说过了</p><p>Tilnel 3:04:09 前人之述备矣</p><p>Sakuran 3:04:15 我想要做的</p><p>Sakuran 3:04:20 有钱人都做过了</p><p>Qin 3:04:23</p><blockquote><p>Qin 2:59:02 感觉晚上的这聊天可以拿去写术力口歌词</p></blockquote><p>但是bw的某几句真的很适合写歌词（</p><p>Blue 3:04:48 如果我不去看前人的工作</p><p>Tilnel 3:05:12 哪几句</p><p>Blue 3:05:12 我觉得我还可以装作我的思考是有意义的</p><p>Tilnel 3:05:15 没有意识到</p><p>Tilnel 3:05:25</p><blockquote><p>Blue 3:05:12 我觉得我还可以装作我的思考是有意义的</p></blockquote><p>不用装作</p><p>Tilnel 3:05:30 就是有</p><p>Tilnel 3:06:07 他人的思想被你思想了，那就是有意义的</p><hr><p>Tilnel 3:07:03</p><blockquote><p>Blue 3:00:31 我不知道是否还有机会让各位看见我</p></blockquote><p>我也想再见见</p><p>Tilnel 3:07:24 大概只见过一次？</p><p>Tilnel 3:08:12 见过的那一次甚至是有点悲伤的日子</p><p>Blue 3:08:37 没事 我大概一直都这样</p><p>Tilnel 3:09:00 我这样可不容易</p><p>Blue 3:11:09 唉 虽然我住哪里大伙都知道</p><p>Blue 3:11:21 但是最好还是和我打个招呼</p><p>Blue 3:11:44 我有点怕见人的 真的</p><p>Tilnel 3:11:51 您需要的话可以call</p><p>Tilnel 3:12:07 虽然我知道您的性格很难主动call人</p><p>Tilnel 3:13:27 其实我也无所谓</p><p>Tilnel 3:13:44 我甚至希望有人能突然闯上门</p><p>Tilnel 3:14:25 谁突然到12栋门口说要喝点啥我也不会有意见的（</p><p>Tilnel 3:14:40 我可能特别喜欢不确定性</p><p>Tilnel 3:15:16 因为会有非常丰富的心理活动发生</p><p>Tilnel 3:15:39 比如今天我说不会在工作室待很久</p><p>Tilnel 3:15:50 转头开了三集电视剧</p><p>Blue 3:17:29</p><blockquote><p>Tilnel 3:12:07 虽然我知道您的性格很难主动call人</p></blockquote><p>我什么性格呢</p><p>Blue 3:17:39 有些事情我很惊讶</p><p>Blue 3:18:06 比如 并不是每个人都能发现我是内向的人</p><p>Tilnel 3:18:15 比如上次我说您别说怪话之后直接自己禁言了</p><p>Tilnel 3:18:21</p><blockquote><p>Blue 3:18:06 比如 并不是每个人都能发现我是内向的人</p></blockquote><p>这还挺明显（</p><p>Blue 3:18:40 甚至有不少人在我如此声称之后还一直表示不信</p><p>Blue 3:18:56 我觉得这甚至不需要“发现”吧</p><p>Tilnel 3:19:40 的确</p><p>Tilnel 3:20:35</p><blockquote><p>Tilnel 2:16:29 对于这些课题大概微不足道</p></blockquote><p>我没喝酒的时候的脑回路就是这样</p><p>Tilnel 3:21:01 一些“微不足道”的郁闷就该直接说出来</p><p>Tilnel 3:21:37 就算输了也认了（</p><p>Blue 3:22:29</p><blockquote><p>Tilnel 3:18:15 比如上次我说您别说怪话之后直接自己禁言了</p></blockquote><p>我不知道</p><p>Blue 3:22:53 或许我不记得了 或许这是您的误解</p><p>Tilnel 3:23:42</p><blockquote><p>Blue 3:22:53 或许我不记得了 或许这是您的误解</p></blockquote><p>我记得您回答说认为并不是怪话，但是认为有人说看不懂是好的</p><p>Blue 3:24:40 我转的我的那几句话是我想时时告诫自己的</p><p>Blue 3:25:06 然后现实一点的原因是…</p><p>Blue 3:26:39 我与群友不共享生活 我观察生活有点看烦了</p><p>Blue 3:27:58 我就想起“不调查就没有发言权”的事</p><p>Blue 3:28:45 然后我就是觉得我早就应该（甚至主动地）fade away</p><p>Tilnel 3:29:32</p><blockquote><p>Blue 3:28:45 然后我就是觉得我早就应该（甚至主动地）fade away</p></blockquote><p>希望您能不fade away</p><p>Tilnel 3:29:53 我真的觉得应该想说就说</p><p>Tilnel 3:29:57 虽然我也这样（</p><p>Blue 3:30:09 原来我没被群友们屏蔽 或者说没被所有群友屏蔽吧</p><p>Tilnel 3:30:18 但我也很不喜欢看人脸色说话</p><p>Blue 3:30:49 我不知道 我觉得我其实和群友没什么话可说</p><p>Tilnel 3:31:11 前文亦有记载 我羡慕一个人能够自大</p><p>Blue 3:32:03 而且我其实是不敢说话的</p><p>Blue 3:32:12 尤其是打字</p><p>Blue 3:32:33 会永远被人翻出来的</p><p>Blue 3:32:43 我怎么可能敢说话呢？</p><p>Tilnel 3:33:09 instant message害的</p><p>Tilnel 3:33:34 我以前会有点想回到只能寻呼机的时代</p><p>Blue 3:35:02 所以我只有想着“也不会有人看到吧” 甚至是“别扯了 他人根本就是不存在的”才敢打点字呢</p><p>Tilnel 3:35:17 那我觉得这是真的</p><p>Qin 3:35:36 被完全地忘记是一件大概不太好的事情</p><p>Blue 3:35:44 why</p><p>Qin 3:35:53 所以被惦记大概有助于多一点和这个世界的联系</p><p>Blue 3:36:04 我也不止听您这样讲</p><p>Qin 3:36:05</p><blockquote><p>Blue 3:35:44 why</p></blockquote><p>因为我朴素地觉得活着更好</p><p>Tilnel 3:36:08 说明你活了一世但是完全没有影响力（</p><p>Qin 3:36:22 被忘记不太利于活着</p><p>Tilnel 3:36:25 我总觉得应该留下点什么</p><p>Blue 3:36:55 但是我并不信仰着这种朴素的认识</p><hr><p>Tilnel 3:37:01 影响力也是演化的一环</p><p>Tilnel 3:38:01 曾经是基因，现在可能是思想和知识</p><p>Tilnel 3:39:12 可能总会有一种奢望，就是人类应该往何处去</p><p>Blue 3:40:35 我自我意识过强了 竟觉得世界会因为我的行为改变 我害怕世界变化的责任担在我的肩上 从而想着最好不要行动了</p><p>Blue 3:42:31 我又是自卑的 所以想要磨灭我的存在</p><p>Blue 3:43:55 唉 感觉都是陈词滥调</p><p>Tilnel 3:44:07 那也有可能你感受到的目的就是这样</p><p>Tilnel 3:44:15 我也就不多说什么了</p><p>Tilnel 3:44:29 虽然有点神棍</p><p>Tilnel 3:44:57 但是我总认为世界是会降临它的意志到人的头上的</p><p>Tilnel 3:45:33 你去履行它也不构成任何问题</p><p>Blue 3:46:12</p><blockquote><p>Tilnel 3:44:57 但是我总认为世界是会降临它的意志到人的头上的</p></blockquote><p>即使我是祂的先知 我也是无力的</p><p>Tilnel 3:46:49 最后就是一个平凡的论点，每个人的目标都是不同的</p><p>Tilnel 3:47:26 所以只能等待你感受到祂</p><p>Blue 3:47:34</p><blockquote><p>Tilnel 2:38:31 就是，我在这里装什么呢</p></blockquote><p>唉 我感觉我也是这个</p><p>Tilnel 3:47:47 然后做出你所希望的变化</p><p>Tilnel 3:47:56 或者确实就这样了</p><p>Tilnel 3:48:26 但是我不会觉得你的做法有任何问题</p><p>Tilnel 3:48:57 如果你坚信世界需要自己做这一件事</p><p>Tilnel 3:49:00 那就去做</p><p>Blue 3:49:28 好像也没有</p><p>Tilnel 3:49:38 我是whatever肯定bot</p><p>Blue 3:49:56 在我的生命里发生更多的是… 我做与不做都一样</p><p>Blue 3:50:11 甚至我故意不做 他还是降临了</p><p>Blue 3:50:41 我不明白哪里来的这种恩赐</p><p>Tilnel 3:51:06 换言之你只需要实行自己的想法</p><p>Blue 3:51:13 或者说其实这是陷阱？是我太愚钝了看不出来？</p><p>Tilnel 3:51:34 可能说决定论是比较悲观的</p><p>Tilnel 3:52:08 只能诉诸荒木飞吕彦了</p><p>Tilnel 3:52:46 即使知晓命运，也会去反抗的勇气</p><p>Tilnel 3:53:02 不一定是反抗，也可能是代行</p><p>Blue 3:54:05 然后为了让我自己不那么惶恐 我就猜想 我的生活其实没那么幸运 只是我降低了期待而已</p><p>Blue 3:54:30 但我这样想 又怕自己不知满足</p><p>Tilnel 3:54:52 一个行为造成的结果，其影响是回溯性地论断的</p><p>Tilnel 3:55:37 没有未来就没有一个历史事件的论断</p><hr><p>Tilnel 3:57:48</p><blockquote><p>Blue 3:54:30 但我这样想 又怕自己不知满足</p></blockquote><p>我恐怕没有足够的精力去评判这个微观的事件</p><p>Tilnel 3:58:14 一来是喝多了</p><p>Blue 3:58:23 也不能说是微观的吧 唉</p><p>Tilnel 3:59:10 但是你总是立足于宏观的影响去判断自己的生活</p><p>Tilnel 3:59:56 似乎世界的意志是否被满足才决定了你的幸福</p><p>Blue 4:00:14 嗯… 确实</p><p>Tilnel 4:00:25 这早就是一种宗教信仰了</p><p>Blue 4:00:42 其实只不过是我不知道什么是幸福</p><p>Blue 4:01:11 所以我才会说“客观上的幸福”</p><p>Tilnel 4:01:33 那不妨再主观一点</p><p>Tilnel 4:02:49 但我也做不到</p><hr><p>Blue 4:03:03 唉</p><p>Blue 4:03:13 想起群友说</p><p>Blue 4:03:19 “需要性解放”</p><p>Blue 4:03:42 或许想了半天最后也还是这个</p><p>Blue 4:04:21 但是我其实挺怀疑的</p><p>Tilnel 4:04:38 解放的状态大概是全部人类顷其生命周期才能完成（消灭）的</p><p>Tilnel 4:05:45 用极限的逼近去形容有点庸俗，但也就是这样</p><p>Tilnel 4:06:18 毕竟完美这个词并不归属于人类</p><p>Blue 4:06:49 是的</p><p>Tilnel 4:10:59 假如你还心有不甘</p><p>Tilnel 4:11:08 请务必不被消灭</p><p>Blue 4:11:36 谢谢</p><hr><p>Tilnel 4:11:51 唉，都是复读</p><p>Blue 4:12:05 其实 当然毕竟是世俗的人</p><p>Tilnel 4:12:08 我说的你100%都想过</p><p>Tilnel 4:13:29 有一个被我复读过114514次的论调，就是嫉妒使人活着（</p><p>Blue 4:15:03 我也不知道 是应该去喜欢听自己听得懂（早已在自己之中）的话呢？ 还是要去努力听自己没想过或者避免去想所以听不懂的话呢</p><p>Blue 4:15:21</p><blockquote><p>Tilnel 4:13:29 有一个被我复读过114514次的论调，就是嫉妒使人活着（</p></blockquote><p>谢谢</p><p>Blue 4:15:49 看来我说的话看上去是陷入存在主义危机了</p><p>Blue 4:16:16 我肯定是会活着的 大可放心</p><p>Tilnel 4:16:27</p><blockquote><p>Blue 4:15:03 我也不知道 是应该去喜欢听自己听得懂（早已在自己之中）的话呢？ 还是要去努力听自己没想过或者避免去想所以听不懂的话呢</p></blockquote><p>感觉没有”应该”</p><p>Blue 4:16:58 因为我认为生死并非是凡人应该决定的</p><p>Tilnel 4:17:31 AB二选一的最优解永远是选C</p><p>Tilnel 4:18:41</p><blockquote><p>Blue 4:16:58 因为我认为生死并非是凡人应该决定的</p></blockquote><p>那我觉得是保留这一选择的能力</p><p>Tilnel 4:19:45 谁让你生，谁又让你死</p><p>Tilnel 4:20:04 通通干掉</p><p>Tilnel 4:20:12 滚！</p>]]></content>
      
      
      <categories>
          
          <category> 喜剧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中期考核</title>
      <link href="/20241018-mid/"/>
      <url>/20241018-mid/</url>
      
        <content type="html"><![CDATA[<p>  在拖延了半个月之后，我终于开工了。也没什么别的原因，主要是因为时间只剩下8个小时了。</p><p><strong>个人陈述（学术创新类）</strong></p><p><strong>（一）</strong> <strong>科研选题的前沿性和独创性</strong>（结合科技前沿和学科领域发展动态，论述选题的研究意义、拟解决的关键科学问题；附相应参考文献）</p><p>科研选题：针对分布式系统实际代码实现的模型检测方法。</p><p>分布式系统运行的过程中往往会出现大量不确定性的因素。在多个节点上运行的进程协同工作，会产生通信、调度上的偶然变化，构造分布式系统的时候往往无法穷举这些情况，程序的异常处理不完善导致系统潜在的崩溃可能。并且在错误发生之后，引发问题的执行路径通常难以还原，导致最终定位不到问题所在。</p><p>面对分布式系统的验证问题，通常的做法是模型检测。模型检测是一种形式化的自动化验证技术，用于验证系统模型是否满足要求。通过将系统的行为建模为一系列状态转换，检查系统的所有可能状态，以确保系统在任何可能状态下都满足特定的属性或规范。如果某个状态违反了规范，模型检测将报错，并提供有关不符合规范的状态的信息，帮助系统设计人员识别和解决问题。</p><p>传统的模型检测是使用 TLA+ 等形式化验证工具对分布式算法进行建模。然而，面对真实而复杂的系统实现，强行使用形式化的方法进行建模则面临着困难的约简：约简过多，则与实际系统偏差越远；约简越少，则状态转换的分支越多，容易出现“状态爆炸”的问题。</p><p>然而，为真实代码构建模型是非常困难的。传统的模型检测通常假设系统设计是在较高层次完成的，并抽象掉了实际实现的许多细节。要验证实际代码需要从代码中重建这些抽象描述，这一过程涉及大量的手工操作，阻碍了模型检测在实际系统中的应用。此外，人为在手动抽象过程中犯的错误可能会导致误报或漏报。这些错误可能发生在模型构建阶段，也可能在系统演变过程中发生。</p><p>为了规避传统模型检测中的模型“漂移”问题，前人也提出了各类方法。CMC 是一个 stateful 的模型检测工具，能够对 C 代码直接进行模型检测，被用于检测网络协议和文件系统（FiSC）。但是 CMC 的检测需要侵入式地修改源程序代码，以使得被测程序运行在 CMC 的地址空间内。同时，它要求被测系统具有明显的事件驱动的特征，并不能适应更广泛的实际系统实现的需求。</p><p>MaceMC 使用深度优先搜索和随机行走来检测网络协议实现中的 liveness 问题，但是被测系统限定于使用 Mace 语言生成的 C&#x2F;C++ 实现。Yabandeh 等人基于 MaceMC 提出的 CrystalBall 中增加了 Steering Execution，在运行的过程中分析未来的错误状态，并通过控制执行来避免走入错误状态。</p><p>Junfeng Yang 等人提出了 eXplode 对文件系统进行穷举式的测试。后提出了一个在 Windows 上对实现级的分布式系统进行透明的模型检验的 MoDist 框架。但是由于商业原因，并未开源其实现。</p><p>为了弥补这些方法的不足，我的科研选题是提出一种通过系统调用截停的方式，不侵入性地修改代码而操纵实际实现的分布式系统执行，以达到对分布式系统的实际代码实现进行模型检测的方法。由于直接从系统调用层面进行操作，因而不需要进行代码插桩操作，并且对于被测系统的要求较为宽松，适应面更广。</p><p><strong>（二）</strong> <strong>代表性成果的理论、方法或技术创新亮点</strong>（重点阐述研究生个人取得的代表性成果的创新性、引用和评价情况、国内外获奖情况等）</p><p>对于选题“针对分布式系统实际代码实现的模型检测方法”，个人已经开发了一套测试框架，代码量约 4000 行。目前应用于 Raft 共识协议的 C 语言实现的验证上，已经证明了其有效性。</p><p>1、工作简介</p><p>计算机中的一个进程所作的事情无非是两件事情，一部分是图灵机一样的确定性的计算，另一部分是通过系统调用与外部世界进行交互。系统调用是单一进程的全部不确定性的来源。对于分布式系统而言，我们将其由于进程间执行的先后顺序造成的执行结果差异称为调度不确定性；将进程受系统调用结果变化造成的差异称为环境不确定性。由此，我们只需要控制好分布式系统运行中的每一个不确定性，并且对于状态做相应的管理，就可以任意地探索分布式系统执行的状态空间。</p><p>因而，为了实现这样的框架，我们必须解决的问题有：</p><ul><li>如何完整地保存进程状态，并且在需要的时候将保存下来的状态恢复成运行中的进程？进而实现整个分布式系统的状态快照保存恢复。</li><li>如何自由地控制分布式系统中的各个不确定性，以实现对执行路径的完全操控？</li><li>如何从分布式系统的实际实现中提取其需要的不确定性，如由随机数&#x2F;时钟超时决定的不同操作？</li><li>如何对分布式系统的状态合法性进行检查？</li></ul><p>2、技术路线</p><p>Linux 中的 ptrace 系统调用提供了对于进程的观察以及控制执行的能力。</p><p>对于测试框架，我的最终实现形式类似于 gdb。一个控制进程（下称 tracer）和多个被控进程（下称 tracee）组成。tracee 为设定好的被测程序，由 tracer 创建新进程并启动被测程序，根据分布式系统的需要，传递节点信息等各自不同的参数。通过 ptrace 系统调用对多个 tracee 进程施加控制，统一运行到有意义的用户代码之前， 作为分布式系统的初始状态。</p><p>此时，每一个进程都停止在一个系统调用之前。由 tracer 将所有进程的状态储存下来，包括每个进程的：1、内存地址映射；2、可读写的内存地址空间（堆、栈、数据段等） 3、文件描述符表。并保存所有的环境状态，包括每个进程占用的文件和网络中滞留的数据包等。</p><p>以此作为初始状态，分别对每一个 tracee，通过 ptrace 控制其执行一个系统调用后保存新的状态，并恢复旧的状态，最后将初始状态标记为“已遍历”并存盘。对新产生的状态继续执行上述操作。如此即可搜索分布式系统运行中产生的所有可能状态。</p><p>新的状态产生后，通过 dwarf 调试信息，提取其进程地址空间中与分布式系统状态相关的变量的值，验证分布式系统的状态断言是否满足，并报告给测试人员。</p><p>3、验证分析</p><p>框架最初成型时，我将测试框架应用于 Bakery 锁算法的经典错误写法，能检测出其中错误，验证了技术路线的可行性。经过完善后，将其用于某开源的 C 语言 Raft 共识协议实现，复现了已有工作检测到的多项 bug，证明这项技术对于实际生产应用中的系统是具有检测能力的。</p><p><strong>（三）</strong> <strong>其它研究成果</strong>（除上述学术创新成果外，简要阐述研究生个人在面向国家需求的自主原创系统研发，或产生实际经济社会效益的应用转化方面作出的贡献，如无可不填）</p><p>研究生期间，本人持续对 C 语言程序设计课程的在线评测系统进行开发与维护，支撑了 2023 与 2024 级技术科学实验班与软件学院新生的教学工作（每级约800人）。同时保障了 2024 年软件学院保研夏令营、2024年南京大学计算机学科体验专题营的机试系统正常运行。</p><h3 id="1-2-ptrace-简介"><a href="#1-2-ptrace-简介" class="headerlink" title="1.2 ptrace 简介"></a>1.2 ptrace 简介</h3><p>ptrace 是 Linux 内核提供的进程跟踪的系统调用，它允许父进程检查和替换子进程的内核镜像（包括寄存器）的值。</p><p>子进程调用 ptrace(PTRACE_TRACEME) 且父进程调用 ptrace(PTRACE_SEIZE) 后，父进程即可对子进程的执行进行控制：在子进程进行系统调用前或系统调用返回后停止；获取子进程系统调用信息；读写子进程内存和寄存器的值；模拟系统调用执行等。通过几种基本操作，能够实现程序的确定性执行。</p><h2 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2 系统设计"></a>2 系统设计</h2><p>单线程程序从一个特定的状态出发，其状态转换分为两类。一是进行系统调用，对操作系统对象进行创建、删除、读写；二是系统调用以外的运算逻辑。对于第二类而言，其代表的状态转换是确定性的，即给定进程状态和代码，执行代码达到的目标状态是唯一确定的；对于第一类而言，则状态转换还要取决于操作系统对象的状态。比如同样执行 read() 系统调用，如果文件的内容正同时被其他进程改变，则产生的结果不确定。</p><p>在多线程程序以及分布式系统中，由于其由多个独立执行的程序组成，因而其执行路径还受到各执行流之间的调度的影响。 </p><p>因此，为了对分布式系统进行模型检验，首先需要穷尽系统调用的可能结果；同时穷尽系统所有节点的各操作执行的先后顺序。</p><h3 id="2-1-整体框架"><a href="#2-1-整体框架" class="headerlink" title="2.1 整体框架"></a>2.1 整体框架</h3><p>对于 n 个节点的分布式系统，我们用 n + 1 个进程进行整个系统的操控执行：</p><ul><li>一个 tracer 进程，用以控制所有的进程</li><li>n 个 tracee 节点进程，即受控运行的分布式系统</li></ul><p>以 3 个节点为例，对于一个运行中的分布式系统，其状态为 $S&#x3D; &lt;Env, Node1, Node2, Node3&gt;$，其中：</p><p>$Node$N$ 代表节点的状态，包括节点的堆、栈、寄存器。</p><p>$Env$ 代表节点之外的环境，包括被节点使用的操作系统对象的状态，如网络消息，系统时间，打开的文件等。</p><p>在分布式系统执行的过程中，能够引发状态不确定性的分歧操作包括：消息的先后顺序，消息是否到达，以及消息等待是否超时。</p><p>tracer 进程每次从一个状态 $S$ 开始控制其中一个节点，运行到下一个分歧操作前，即：消息发送前，消息接受前，以及请求系统时间之前。之后对于每一个节点，都由 Choose() 函数根据运行时的上下文决定下一个分歧操作可能的状态转换集合$Transfer$，且对于每一种可能性 $t \in Transfer$，生成如下的“转换边”：  $(Node$N.t(), &lt;Env, Node1, Node2, Node3)&gt;)$ </p><p>它表示，状态的下一次转换从状态四元组出发，通过 $Node$N$ 执行 $p()$ 所代表的转换可达到下一个状态：</p><p>$(Node$1.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’, Node1’, Node2, Node3)&gt;$ </p><p>$(Node$2.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’, Node1, Node2’, Node3)&gt;$ </p><p>$(Node$3.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’’, Node1, Node2, Node3’)&gt;$ </p><p>总的工作流程是：设置一个状态转换边的队列；每一次从中取出一条边并执行达到新的状态，在新的状态的基础上，生成新的转换边并入队。</p><p>对于 DMCK 的实现有两种，一种是 stateful，即通过保存和恢复节点的内存、寄存器等信息来重现状态；一种是 stateless，通过重放记录的执行路径来重现状态。我们的工作主要是 stateful 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S = &lt;Env, Node1, Node2, Node3&gt;</span><br><span class="line"></span><br><span class="line">q.add(Edge(skip, S))</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">    edge = q.deque()</span><br><span class="line">    S&#x27; = edge.transfer()</span><br><span class="line">    forall (node in Nodes) &#123;</span><br><span class="line">        // 只根据 node 的状态就可以算出当前执行上下文了</span><br><span class="line">    Transfers = Choose(node)    </span><br><span class="line">    forall (t in Transfers) &#123;</span><br><span class="line">    q.add(Edge(t, S&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def transfer(edge) &#123;</span><br><span class="line">S = edge.getState()</span><br><span class="line">t = edge.getTransfer()</span><br><span class="line">node = t.getNode()</span><br><span class="line">nodeState = S.getNodeState(node)</span><br><span class="line">nodeState.t()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- </p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应该忘记什么</title>
      <link href="/20241018-wasureta/"/>
      <url>/20241018-wasureta/</url>
      
        <content type="html"><![CDATA[<p>我记得的东西太多了。负担太多了。也许应该忘记一些事情。</p><p>曾经我认为，往事就算想忘记也是无法忘记的，说忘记只是自欺欺人。因而并不需要做这样的努力，只要不去想就好了。就像一个伤口你告诉自己不要去摸但是最后还是经常去摸一样。</p><p>这样度过了很久很久。我以为这就是万全的方法。</p><p>现在，似乎应该去做一点“蒸馏”。虽然我觉得很多事情就是会记一辈子，客观上记这些东西只会害了我。但是似乎还是有办法能淡忘。大概就是决定去忘记。。。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么时候才能长大呢</title>
      <link href="/20241017-shiriai/"/>
      <url>/20241017-shiriai/</url>
      
        <content type="html"><![CDATA[<p>熬夜的原因找到了。一躺上床就只有负面的心情，所以不愿意躺上床，就会拖；好不容易躺下了，脑子里面就是那些事翻过来倒过去。</p><p>晚上聊天有一个说得很好。高中给那个还是傻小子的我带来的确实是快乐。但是想明白了很多事情之后再回味，其实并不是什么好地方，也并没有发生什么好事，只会觉得各种不是滋味。</p><p>获得的教训是千万不要没事翻旧相识的朋友圈。那都是比起我而言更配得上幸福的人，为什么非要自讨苦吃呢。。。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不要承认那个名字</title>
      <link href="/20241009-cite/"/>
      <url>/20241009-cite/</url>
      
        <content type="html"><![CDATA[<blockquote><p>忘了是从哪里抄的了，应该是今年上半年抄的。总之原文写得很好，拿来用用</p></blockquote><blockquote><p>谁规定人不能畏怯敏锐，不能沉郁昂扬？那正是我的疾病，也是我的天赋；是我的宝藏，也是我的残缺。</p></blockquote><p>fine，我承认，用一种有名有姓的病症来定义生活十分诱人——它可以解释我的一切疑虑：嘴角上扬，是躁狂症发作；眼泪决堤，则是抑郁作祟。如果做错事情，那千万不会是我的问题——看嘛，那些行为可是清清白白地写在医学论文里。</p><p>这诱人的定义将现代医学移情为一种神学意识形态：化验单便是赎罪券，同无力改变的人们一起，求助于圣母、耶稣、佛祖、科学……什么都好，什么都不重要，因为错误已经被忏悔，可以心安理得地原谅自己。</p><p>福柯在《疯癫与文明》里讲，正常与不正常，本就是被话语与文化界定，是一种社会建构的概念，是社会空间中的一个知觉对象。况且，现代医学本身也还没搞明白双相的成因——只是狡猾地用「十分可能」「也许」来假定一种缺陷遗传基因或脑部病变。</p><p>&lt;后面或许有，但是我只抄到了这里&gt;</p><p>update: 我找到原文了</p><p><a href="https://coink.wang/bipolar-disorder.html">疯癫絮语 | Coink DO BOOM!</a></p><p>我不想把药物治疗当作阿鼻地狱里唯一的那根蛛丝。诺洛西汀、碳酸锂的确能够帮助患者社会意义上地「恢复正常」。但，病毒可以由刻意转录的药剂杀灭，心境稳定剂只是堪堪钝化人的感官。我知道它有效，只是我现在用不着。</p><p>谁规定人不能畏怯敏锐，不能沉郁昂扬？</p><p>「那正是我的疾病也是我的天赋，是我的宝藏也是我的残缺」(蒙马特遗书)</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>这下看懂了</title>
      <link href="/20241002-yarareta/"/>
      <url>/20241002-yarareta/</url>
      
        <content type="html"><![CDATA[<p>早上起来随手翻了翻斯嘉丽的小号，很多当时没看懂的东西现在看懂了。总之足以说明她在这方面并不算纯粹，或者说“朴素的善良”。可能我以前真的疏于了解吧。</p><p>卧床不起的心情一定不是很好；下来走走，然后稍微收拾一下就是另一种精神面貌。所谓的总结研究并没有开始进行，因为好累。我怕累，所以一直在这里写着，这是一种延宕。</p><p>其实写这些就是为了拖拖时间罢了，我自己也知道。不想立刻投身到新的节奏当中去。也许是那种「野草」式的自恋。</p><p>“感觉”这种事真是捉摸不定，但我也没有任何必要、任何义务对其进行预判。或者说那是一件纯粹存活于当下的物质——物质所创建出的一种临时性。</p><p>我也许需要适当地发一点精神病。只要对碎碎念这种事情脱敏，也就会对那种“精神病”式地发言脱敏。那才是我能无障碍地言说的时刻。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间大步向前走</title>
      <link href="/20240923-yarareta/"/>
      <url>/20240923-yarareta/</url>
      
        <content type="html"><![CDATA[<p>好不容易迈出这一步，决定放弃。至于为什么？我只想说，我简短的人生经验告诉我，如果保持这份偏执不放，一定会被标记为究极傻逼。哪有人相信这么荒唐的东西，愚蠢也得有个度。</p><p>总之必须忘记，不得不忘记。要彻底地转变态度，不要心存幻想。如果以后有机会再说话的话，一定要好好告别。</p><p>我也不是想不到各种可能性，只是我无法判断是该相信还是该质疑。写到这里我又忘记刚才的思路了。总之她应该也没必要对我使个坏，而只是为了恶心我一下。</p><p>人要做一件事，或是产生某种反应必然有其原因，而不是无缘无故的。如果我承认她比我要强，那么大概率她能够做到她想要做的事情。也就是说，当前的局面就是她所希望达到的效果。</p><p>效果&#x3D;目的。这也说明最初她其实就在劝退我，或是表达过不感兴趣。但我并没有捕捉到这一点，两个月没有回消息其实已经是一个明显的讯号。之后才有了“旧林羁鸟”之说。</p><p>也许是为了避免麻烦或对于“体面”的执念，对方并未直言相阻，而是引入一个更深的套路再予以重击。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>秋分日</title>
      <link href="/20240922-yarareta/"/>
      <url>/20240922-yarareta/</url>
      
        <content type="html"><![CDATA[<p>我是一个极容易动摇的人，偏偏这点从来就没有学好。</p><p>緒方理奈和赤名リカ其实是一个模子里刻出来的人物，我对她们两位都非常喜欢。不止是因为她们敢于表达爱，更是因为她们“有进退”。</p><p>对，不是“知进退”，谁知道离开是不是最好的决定？谁也不能说得上来，事情到底会怎样发展。但是她们可以坚决地离开，创造自己的新的生活。</p><p>也许回去之后仍然会偷偷抹眼泪，即便如此在转身的时候也毫不动摇。</p><p>所以，「恋爱世纪」虽然是 Happy Ending，却是平庸的，是大多数故事的结局；而「东京爱情故事」是 Normal Ending，但是其中展现出的人物选择却有着科幻片一样的觉悟。</p><p>所以，动画的 White Album 1 是科幻片，而 WA2 是写实的。</p><p>即使写到这里，我的态度依旧存疑。</p><p>至于斯嘉丽是怎么想的，已经不怎么重要了。曾经有个人，如果与她聊天，就可以稳定地获得一种安心的感觉。而现在情况为之一变，我自己会动摇起来。</p><p> Thank you. Good-bye!</p><p>当然我还是不明白，为什么偏执与动摇会出现在同一个人身上共存得如此不和谐。</p><p>我偏执的可能是，希望就算离开，也尽可能留下一个帅气的背影。</p><p> 当你想说任何话做任何事的时候，发现这些对于对方来说其实根本就无从谈起。这简直像在静止的时间里有人向你丢来数十把飞刀一样恐怖。</p><p>来即招之，去即挥之，此乃树的本分。</p><p>我不一定在乎别人的感受，但是一定在乎别人是不是喜欢我。所以也许很自私。</p><p>总之，不脆弱，但是动摇；不会倒下，但是很容易受到影响。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当我在学赤名リカ的时候，我到底在学什么</title>
      <link href="/20240921-yarareta/"/>
      <url>/20240921-yarareta/</url>
      
        <content type="html"><![CDATA[<p>夜里姑且还是问了一下对方的态度，结果是什么“说来话长”的一眼就像是在糊弄人的说法。我也很难相信。姑且认为她其实是保持礼貌并且赶我走。不过，何至于此。</p><p>对于一个志虑忠纯的人来说，怀疑是不是最恶劣的侮辱？所以我轻易不去表达对一个人的怀疑。所以她是这样的人吗？</p><p>只要不进入对方的节奏，我可能也是正常的。或许我做不到真正的冷漠。我又没有在人际关系这方面的聪明才智。也许是这样，我才被淘汰了。其实也没什么。</p><p>每次死心也都能活过来，猫有九条命，人只要肉身不死就可以无限重来。</p><p>我到底学赤名リカ学到哪里去了？希望自己能像女主那样，处处学她，却处处学不像。</p><p>天啊我不想再微笑了。每到痛苦的时候，嘴角都会自发地上扬，这是不是一种苦笑？我是没法接着当作无事发生了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>擅作主张的不安</title>
      <link href="/20240920-upset/"/>
      <url>/20240920-upset/</url>
      
        <content type="html"><![CDATA[<p>人类是一种傲娇生物吗？我不太确定。</p><p>但是至少人是一种极其需要承认的生物。不管是正面的承认，还是反面的不承认也好，总归是确立了他作为一个能动的主体，进而有能力得到这个世界的反馈。</p><p>人与人之间相交往，到底有什么难度呢？接下来我所提出的说法是有一个天生的漏洞的，但是我先提出来好了，然后再来考虑这个漏洞应当怎么解释。</p><p>如果一个人喃喃自语，喋喋不休，那么他大概会被认为是疯子；事实上，这样的人最吊诡的地方是他不需要收到反馈就可以持续地进行这样的活动。对于一般人而言，如果说了很多话都没有得到回应的话，他便也不再说。</p><p>话与话之间的沉默是一片充满焦急的区域。那里是一些由于焦虑得不到回应而自动产生的擅作主张的不安。没有人能在交际中将这些不安一股脑地倒出来。  </p><p>就是这样。 </p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>何尝不是一种 Rick Roll</title>
      <link href="/20240920-yarareta/"/>
      <url>/20240920-yarareta/</url>
      
        <content type="html"><![CDATA[<p> 看电影也有点耽误我想事情了。本来想边看边写的。</p><p>很久没有静下心来像这样写两个字。</p><p>我的特点，是我的优点，也是我的缺点。我的生命力是顽强的，心态是健壮的。我虽然有一点见识，但并不明白人心。我并不聪明，并不敏感&#x2F;敏锐，甚至有一种刻意而为之的执拗&#x2F;迟钝。</p><p>“人在火炉旁是很难感受不到温暖的。”</p><p>主观意愿与客观效果是一对辩证统一。如果你受到冷落，其实这很难是由于一种无意之举。就算不说是刻意的，也一定是因为有必然的不方便的原因，从而不符合对方自身的意志。</p><p>因而，不仅不得不放弃，更加不得不体谅，不得不反省。自己提出了也许是无理取闹的要求，而对方假如不是出于天性或恶意欺骗，也可以说是出于有适于体面的礼貌。</p><p>留给我的只有用于冷静的时间。只能摇摇头了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>务虚</title>
      <link href="/20240729-briefing/"/>
      <url>/20240729-briefing/</url>
      
        <content type="html"><![CDATA[<p>其实状态还是没有调整好。心态不对，态度不对，行动上看，几乎可以说是完蛋。轻松不自如，有千钧重负。</p><p>也可以说是泰山崩于前而死性不改。一方面我是真的没有什么冲劲了。</p><p>想一想也是无所依靠，没有寄托。每天可以不说一句话，不同一个人来往，这无疑是危险的</p><p>没有什么特别在意的人，在意的人也不懂如何与她若无其事地说两三句话。松懈了也就松懈了，除了不能好好向老板交代以外，也就没有了。</p><p>这不是食粮的事。不是任何作品能够扭转的状况。出问题的不是思想观念，而是生活本身。</p><p>Too hard to change.</p><p>榜样的力量其实是很薄弱的。无需赘言。追比圣贤作为一种理想，并不是能够长久地坚持下去的动力。很多时候，只是望洋兴叹，能人背后有能人。</p><p>尽管没有解决的办法，但该裱糊的，表面工作还得做。</p><p>我最近似乎有点开窍，似乎也没有。偶然思念谁，偶然又幻想碰见谁。如今是没有任何意义的。我在人类这个领域可能只有这点天分，与非人类打交道是一般的擅长，与人交往的表现可以说是灾难性的。</p><p>晚上来了。白天睡过去的时间就用通宵来解决。</p><p>完全没征兆的摆烂。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>干沉默了</title>
      <link href="/20240729-work/"/>
      <url>/20240729-work/</url>
      
        <content type="html"><![CDATA[<p> 不确定，再看看</p><p>把小桌板拿到桌上架起来，刚好够上显示器的底部高度。现在可以站着办公了。</p><p>不过我说，这周我没少做事，但是又根本没干正事。周五老板给我发消息，下周开小会。结果我这周都干了什么呢：睡觉，翻译视频，调一个没头脑的 netdata bug；玩 PXE，网络启动；调 dotoj 的 bug；写新的 profiler。劲都没使在正事上。</p><p>这一周的作息也基本上处于一个完犊子的状态。本来想往前调，结果每天在宿舍起床之后吃个晚饭回来，晚上准备早点睡。然后就开始折腾各种玩意，最后都是拖到早上，7点，9点。周六我寻思干脆这晚上在工位通宵算了，结果好家伙，又写了一个没什么大用的东西之后，开始猛刷视频。本来想着直接一波熬到晚上，这样还能调正过来。没想到吃完午饭回宿舍还是累了，睡了一觉，又是晚上到工位。</p><p>。。。</p><p>其实这种状态真的挺好的，只要我不用干活不用上班，那就是绝妙。可惜事情还是得做的。</p><p>虽然也没少想心思，但是已经比以前好多了。身边也没那么多事，况且前面去了一次 BSK 之后直接给我了一点小小的震撼，一段时间里可能都会处于比较佛系的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>制作视频汉化字幕</title>
      <link href="/20240722-script/"/>
      <url>/20240722-script/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近想搬两个视频到 B 站。所以学习一下如何制作汉化字幕。</p><p><a href="https://www.bilibili.com/read/cv35618868/">经验总结：汉化字幕的生产流程简介 - 哔哩哔哩 </a></p></blockquote><p>请注意，此文大部分是个人经验，每个字幕组的工作流程和具体内容都不大一样，仅供大家参考，可能不具有代表性。</p><p> 我自己做的字幕比较多的是：动画片、各类创作者访谈、电影幕后视频，有时候会自己一个人从头到尾做完一个视频，有时候也跟组里的伙伴们一起合作，所以啥的都会搞一点。就按照我做的这几个工种结合字幕制作流程中的顺序来说：</p><p>一、片源</p><p>首先是片源获取，这个分情况，大家都知道做字幕这个灰色地带，如果影视剧的话，第一时间肯定是到各大论坛、种子站或者DC++源之类的地方找资源，也有一些字幕组的片源帝是直接自购（流媒体or碟）然后扒出来的，总之这是个各显神通的环节。扒下来的片源往往被称作“生肉”，相对于做好字幕的片子“熟肉”，字幕组就是一个厨房团队。</p><p>接下来工作到了这里就有分别，最重要的一点是，片源有没有自带字幕，带的是什么语。</p><p>二、需不需要听写？听译？</p><p>如果没有自带字幕，就需要听写+翻译或者听译了（看组里翻译的能力水准，需要听写+翻译合作，还是一个人可以完成听译），我以前一个人翻那些YouTube上面扒下来的访谈视频就是靠硬听硬翻的，有时候一句没听懂，翻来覆去听，为了翻译一句话能搞一天。主要还是需求听的人对这个片源的常用语言、文化环境里的各类梗、说话人的口音等等有很详细的了解。</p><p>不过现在听译的需求越来越少了，有各类AI语音识别软件，连时间轴都帮你打好了，原片的语言如果没有特别重的口音，基本上AI都能识别出来，像YouTube甚至有自带的语音识别转字幕功能，轴都帮你打好了，虽然有时候打轴的断句有点奇怪。</p><p>如果片源有自带字幕，那就轻松很多，不用听写，而且轴打得都比较标准，可以直接进到翻译阶段。</p><p>三、打时间轴</p><p>上面说的“打轴”，啥意思呢，就是给这个字幕做上时间轴，这个时候我一般会先用最基础的字母格式：srt格式的文件（听写软件和YouTube自动生成的字幕一般也会导出这种格式）。srt不含任何字幕格式（字体大小、颜色、位置甚至更高级的特效等等），只有单纯的两个信息：1、某一段字幕在视频哪个时间点出现，又在哪个时间点消失；2、这段字幕的文字内容。</p><p>打轴是一个挺枯燥的活儿，你需要精确到毫秒，保证字幕和语音能完全对上。早年的软件不大好用，后来我发现了大家都在用的神器aegisub，这个软件能把音频波形、视频画面和字幕放在同一个窗口下，同步播放，并且可以用可视化的UI直接划取某一段音频波形打轴，工作效率高了很多。</p><p><img src="https://i0.hdslb.com/bfs/article/fbb33a979a1461f4890b3db4212a2752572604.png" alt="aegisub的界面示例，这是我翻译IGN《未来蝙蝠侠》幕后纪录片的截图"></p><p>四、翻译</p><p>翻译这个阶段，也是比较复杂的一个阶段，得分几个小点讲讲。</p><p>弄懂原文当然还是基础，视频翻译中可能更会容易出现俚语、俗语、典故、时代性表达等等，翻译虽然也是再创作，但是理解原文的基础上译者才能进行自己的发挥，这点对于所有类型的翻译都是一样的要求。</p><p>字幕翻译和书面翻译不同，其实更接近口译一点，字幕展示时间是被片中人说话的速度所固定的，观众并不像书的读者那样有反复回读的时间，所以对于译文更会要求短、准确、易于理解。一行中文字幕一般来说在15个字是观众能够兼顾看画面+读字幕的极限了，如果能在10个字以内更好了——当然这和这句话出现在屏幕上的时间也有关系，如果说得慢、时间长，那也可以适当放宽。这就反过来涉及到和上面打轴流程之间的冲突，不同语言之间的信息量不同，一句话长短可能区别很大，所以翻译的时候再次调整断句和时间轴是再常见不过的事情了。</p><p>还有和其他翻译形式共通的一个点，就是说话人的语气、用词等等，在时间允许的情况下，多多琢磨，如何用中文更好地把原文中特殊格式、隐含的意思表达出来。这些东西我有详细在经验总结：美漫汉化时要注意什么？这里说过。</p><p>四、注释</p><p>这是一个比较特殊的点，正式影视引进的字幕里，按照工作标准，是没有注释的，有带注释的都是我们这类民间字幕组。特别是我们翻译美漫采访、动画这类，典故、梗比较多的东西，有些东西就会想注释下，方便刚入坑的萌新更好理解，也是一个去对接多元宇宙里其他作品的跳板。在其他情况下也会有注释的情况，比如历史类、科技类、文化类等等纪录片、传记片之类的，很可能要出现注释一些背景知识的情况。但是一定要注意的是，注释时候不要过于自我陶醉了，克制一点，简短一点，观众是来看这个片子本身的~</p><p>五、校对</p><p>校对不一定每个字幕组的流程里都有，但是其实是必不可少的一个步骤，最基本是检查翻译好的字幕里有没有错别字等等低级错误，然后就是有没有翻译错误，例如对原文理解失误、中文表达不顺畅、或者有没有更好的表达等等之类的。校对需要比较熟练、对背景有深度了解、比较有责任心的人来做，一般都是字幕组里的老人。</p><p>六、格式、特效</p><p>这时候，格式一般就从srt转成ass了（不是屁股），ass格式中不光包括了时间轴信息和字幕内容，还有字幕的字体、位置、字号、颜色，甚至淡入淡出、在屏幕上移动、变大变小、卡拉OK特效等等。</p><p>格式上有一些我个人的习惯，可供大家参考：</p><p>如果你要做中英双语字幕，英文的字号要比中文小一点，和中文一样大的英文字母会显得非常臃肿。</p><p>中文字幕上的标点，可以有感叹号、问号、逗号等等，但是省略句号会比较美观，因为放了句号会显得原本居中的字幕向左偏了。</p><p>尽量用易读清晰的字体，适中的大小，颜色我喜欢选最常规的白色或者稍微低饱和度一点的黄色。高饱和度的颜色会让字幕显得非常廉价——当然如果你要突出复古迪斯科舞厅的感觉，某些特定的偶尔也能用个五彩斑斓的颜色点缀点缀，就是别从头到尾都闪瞎人眼就行。</p><p>为了增强字幕的易读性，描边、阴影、半透明背景、阴刻&#x2F;阳刻效果等等这些做法至少要选择一项，否则字幕常常会出现和视频背景颜色混杂导致看不清的情况。同样也是为了易读，不要选择太细的字体。</p><p>字幕的位置不要太高太低，更要注意不要挡住视频的重要部分，调节位置的时候一定要细心一点。</p><p>有些特效能手还会在ass的基础上用AE等等其他软件字幕做更进一步的特效，这就是更加各显神通的地方，也看各组的审美了。</p><p>七、压制</p><p>完成格式特效之后，又有两条路可走：直接发布外挂字幕，让观众自己把外挂字幕加载到生肉里面观看。或者直接把字幕压制到生肉中，做成熟肉。</p><p>以前的视频编码、格式比较混乱，有人用rmvb，有人用avi，还有人直接用mkv封装的，近些年来大家似乎慢慢都比较统一压成mp4了。压制也比以前简单了很多，不用再写代码，有许多傻瓜式的软件，把生肉和字幕拖进去，不到一会儿它就压好了。</p><p>八、发布</p><p>发布也有区别，可以线上平台直接让人观看，如果有版权因素容易被和谐，不过是当下懒人观众越来越多的情况下，线上还是最容易能被人看到的方式。还有还是发资源链接给人下载，以前大家搞BT、磁力、电驴，后来各类网盘野蛮生长的时候下载最方便，不过随着版权净网的增强和网盘限速越来越多，也稍难了一点，不过这两年貌似又有一些新的网盘开始野蛮生长了，不知道这些新的网盘还能野蛮多久。</p><p>还有一种比较尴尬的“发布”，就是字幕组做好的字幕，被某些盗版在线网站拿去，压进一些什么澳门赌场之类的诈骗广告，再发到自己的网站上让人在线看，很多字幕组对于这种事情都很无奈，但是本身又是个灰色地带，很少有维权的办法。</p><p>其实到了这个时代，字幕组越来越少了，有一点是因为中文市场越来越大，很多影视剧上流媒体的时候，都会自带翻译好的中文字幕，这时候只需要压制一下就成了熟肉了。当然某个内容的深度爱好者还是会觉得官方字幕不够精确，会自己再出精校版、注释版等等。还有一点是AI越来越发达了，许多比较简单口语的内容AI能够完成听译一条龙，不过目前对于语言类的AI还是英语方面做得最好，到翻译成中文还是经常有那么些纰漏和不像人话的地方，碰到英语之外的语言就更孱弱了。等到AI进化成完全体的那一天，也许字幕组才会真正退出历史舞台吧。 </p>]]></content>
      
      
      <categories>
          
          <category> 搬运 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网关吃了我的 dnsmasq REPLY</title>
      <link href="/20240721-dnsmasq/"/>
      <url>/20240721-dnsmasq/</url>
      
        <content type="html"><![CDATA[<p>这次只能说，好好品一下了。</p><p>先说一下网络配置：</p><p>网关 - 路由器 - dhcp 服务器1： 192.168.3.1 Huawei AX3 Pro</p><p>dhcp 服务器2，PXE 服务器：192.168.3.21(dnsmasq)</p><p>上 dnsmasq 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/etc/dnsmasq.conf</span><br><span class="line">--------------------------</span><br><span class="line">port=0</span><br><span class="line"># dhcp-option-force=209,archiso_pxe.cfg</span><br><span class="line"># dhcp-option-force=210,</span><br><span class="line">dhcp-boot=/boot/syslinux/lpxelinux.0</span><br><span class="line">enable-tftp</span><br><span class="line">tftp-root=/srv/tftp</span><br><span class="line">log-dhcp</span><br><span class="line">dhcp-range=192.168.3.0,proxy,255.255.255.0</span><br><span class="line"># dhcp-vendorclass=set:bios,PXEClient:Arch:00000</span><br><span class="line">pxe-service=x86PC,&#x27;Network Boot&#x27;,/boot/syslinux/lpxelinux</span><br></pre></td></tr></table></figure><p>PXE 客户端：VirtualBox BIOS</p><p>两边抓包：</p><p>服务端：<img src="image-20240721151300600.png" alt="我肯定回复里是有信息的"></p><p>客户端：</p><p>不好意思，Wireshark 抓包结果没存。但是没有发现来自 c0a80315 的 DHCP 协议消息。RNM</p><p>我关掉了路由器的 DHCP，使用 Linux 上的 isc-dhcp-server，</p><p><img src="image-20240721203959046.png" alt="image-20240721203959046"></p><p>都没有 OFFER 了。如何验证是不是被路由器吞了？我们直接把两台电脑接起来</p><p><img src="image-20240721204222334.png" alt="image-20240721204222334"></p><p>瞬间啥都有了</p><p><img src="image-20240721204302756.png" alt="image-20240721204302756"></p><p>问题在于，我把 pxelinux.0 一送过去它就停下来了。不管是 VBox 还是物理 BIOS 都是这个 B 样。我懒得弄了，爬</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在没有DHCP的情况下使用PXE-网络启动服务器设置</title>
      <link href="/20240720-ipxe/"/>
      <url>/20240720-ipxe/</url>
      
        <content type="html"><![CDATA[<p>PXE, Preboot eXecution Environment，发音一般为 pixie，是从网卡启动的环境。我的了解并不深刻，但是总归，这种启动方式是和硬盘启动、USB 启动并列的一种方式。它做的事情无非是：</p><ul><li>从当前网络环境中找到一个 DHCP 服务器</li><li>DHCP 服务器告诉本机，TFTP 服务器的位置</li><li>本机从 TFTP 服务器上下载一个引导程序。可能是 lpxelinux，总之是个程序</li><li>可能还下载一些配置文件，告诉引导程序应该做什么</li><li>然后将控制权移交给引导程序</li></ul><p>这样的启动方式，还可以直接启动 grub。间接地，可以启动任何的操作系统。只要引导程序后续向远程请求 vmlinuz 和 initramfs，就可以启动 linux 内核。这也是无盘机的原理。</p><p>但是，pxe 的不便之处就在于，必须要一个 DHCP 服务器来给出这些配置。这对于广域网上的用户，并不是很友好。比如我在南京大学，想要连接中科大的网络启动服务，这就很困难。如果我想要我自己搭建的网络启动服务在校内都可用，我还需要和 ITSC (信息服务中心) 做可能的协商（并且大概率不会成功！除非以组织的名义来做，比如 LUG 和高性能计算中心一起来）。</p><p>造成这一切的主要原因是，网卡自带的 pxe ROM 并没有很复杂的功能。于是 iPXE 呼之欲出。</p><h2 id="配置-iPXE"><a href="#配置-iPXE" class="headerlink" title="配置 iPXE"></a>配置 iPXE</h2><p><a href="https://ipxe.org/">iPXE</a></p><p>可以选择烧到网卡上（！）或是烧到其他的启动介质上。</p><p>如果烧到网卡上，等于是仅对于我现在能够控制的机器有用。对于未来可能的机器，比如我要装个系统，我还要先烧一个 iPXE。这就麻烦了。烧到其他的启动介质上？我不如直接烧一个 Windows.iso 进去。</p><p>当然因为是做一个小玩具。并且我们并不确定会不会雀实存在有的电脑上采用了 iPXE。（并且我们不想用 U 盘）。因此在这里我们选择<a href="https://ipxe.org/howto/romburning/intel">烧网卡</a>。注意根据自己的网卡型号去看 ipxe 官网上不同的指引。</p><p>然而根据指引，我们还是要烧 U 盘。你妈</p><p>我居然真的没有 U 盘</p><h2 id="放弃-iPXE"><a href="#放弃-iPXE" class="headerlink" title="放弃 iPXE"></a>放弃 iPXE</h2><p>使用 DHCP 服务器吧。</p><p>使用打包好的 <a href="https://netboot.xyz/">netboot.xyz</a> 的 docker image。</p><h2 id="放弃-netboot"><a href="#放弃-netboot" class="headerlink" title="放弃 netboot"></a>放弃 netboot</h2><p>docker 要加 proxy 才能运行。dashboard 完全加载不了。</p><h2 id="跟着-ArchWiki-来做"><a href="#跟着-ArchWiki-来做" class="headerlink" title="跟着 ArchWiki 来做"></a>跟着 ArchWiki 来做</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人生是一场巨大的寸止</title>
      <link href="/20240720-bsk/"/>
      <url>/20240720-bsk/</url>
      
        <content type="html"><![CDATA[<p>人生就是在一场寸止之后，永远地提上裤子  —-我</p><p>周日（7.15）晚上和小智去了一趟 Boomshake，我大受震撼。去之前其实有点怕自己被卡颜直接卡出去，之后才明白，我擦，联系他的其实是酒吧销售。谁会跟钱过不去啊。</p><p>去之后现实冷清地等上人。在社恐当中开始了游戏。我艹，完全玩不明白，就是学着别人怎么玩我也怎么玩，没有什么交流，音乐声巨大也没办法语言交流。</p><p>越玩越没兴趣，多次想遁走，去卫生间外的休息室抽烟，全是俊男靓女。只能说没有好好预习，游戏咔咔输。</p><p>等到第二次逃到卫生间，头昏脑胀地坐了一会儿后，小智也来了，他走进去，10分钟都不带反应的。我只能进去看看他，好家伙，直接干趴了。我俩直接受不了了，准备打车跑路。</p><p>技术总结：看起来没什么技术含量的娱乐方式仍然是有门槛的。如果不懂里面的规矩，那就只能当个局外人。当然也没什么丢人了，毕竟素不相识。但也忍不住觉得自己也没开心，又可能让别人觉得莫名其妙，又有点挫败。也许是一件幸运的事，毕竟直接关上了这扇窗，对我的身体反而好一点。</p><p>这里的年轻人们出了门后也许就是寻常模样。有些是来玩的，有些是以此为生。雇佣方式有可能是销售摇人，私下结清。很难想象如果出了门，这些历史记录是否就消除地一干二净。</p><p>当然我并不在意别人的过去，难道为自己的笨拙找个理由开脱是什么罪吗？</p><p>有心无力，应该去到哪里才能使自己被容得下？那岂不是要改变自己的意志。</p><p>一个强到能够改变自己的意志的人，也是强到能够不移其志的人。总而言之–他是自由的。这两种做法需要的品格明明同源同种。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从源码更新 sshd</title>
      <link href="/20240718-sshd/"/>
      <url>/20240718-sshd/</url>
      
        <content type="html"><![CDATA[<p> 之前爆出 Linux 上的 sshd 可能有一个 race condition 导致的 RCE。建议更新到 openssh 9.8。于是火速 clone 源码之后直接 make install 了。</p><p>但是今天在断电之后想扫一下办公室网络发现主机，觉得更新的人应该不多，随手就</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV ip/24 -p 22</span><br></pre></td></tr></table></figure><p>期待出一个 openssh 9.8，结果出来了一个别人的主机，自己的是没有。当然后来验证了其实是我的机器没有开，但我到了座位上之后，也是闲的蛋疼想看看 nmap 一下自己的设备到底能出些什么玩意。结果大为震撼，<code>openssh-9.6p1</code> 。。。</p><p>到底是谁发明的 <code>ssh -V</code> 验证版本更新成功法？这里面有另外？个变量：</p><ul><li>openssh 的安装目录</li><li>systemd 的配置</li><li>ssh 的编译参数</li></ul><p>openssh 现在居然默认安装在 <code>/usr/local</code>。。。但是 systemd 当然只认 <code>/usr/</code>。</p><p>ssh 编译时如果不指定和当前版本一致的 config 目录，就。。不知道会是哪里。最后会导致 fingerprint changed &amp; man in the middle attack。</p><p><img src="image-20240718215331548.png" alt="image-20240718215331548"></p><blockquote><p>配置文件目录变了之后，就不会用原来的 pubkey 作为 fingerprint 了</p></blockquote><p>所以我们根据 <a href="https://www.linuxfromscratch.org/blfs/view/systemd/postlfs/openssh.html">OpenSSH-9.8p1 (linuxfromscratch.org)</a> 的指导，重新编译了 openssh，并且小改 Makefile 进行了安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr                            \</span><br><span class="line">            --sysconfdir=/etc/ssh                    \</span><br><span class="line">            --with-privsep-path=/var/lib/sshd        \</span><br><span class="line">            --with-default-path=/usr/bin             \</span><br><span class="line">            --with-superuser-path=/usr/sbin:/usr/bin \</span><br><span class="line">            --with-pid-dir=/run                      &amp;&amp;</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>更新：这样做会使得在 ssh client（ssh-session）中，PATH 没有 &#x2F;usr&#x2F;local&#x2F;bin。导致自己编译安装的 vim 没办法直接启动。</p><p>解决办法：<code>--with-default-path</code> 和 <code>--with-superuser-path</code> 加一加。</p><p>更新：2FA 和登录邮件提醒消失了</p><p>解决：添加 <code>--with-pam</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux wakeonlan 无法正常开启</title>
      <link href="/20240718-linuxwol/"/>
      <url>/20240718-linuxwol/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nettool -s enp34s0 wol g</span><br></pre></td></tr></table></figure><p>g 就是 granted，d 就是 denied</p><p>这样设置网卡允许wol是一次性的。重启之后，又自动变成禁止。尝试用 update-rc.d 开机自动执行脚本，不知道为什么不行。</p><p>所以按照 ArchWiki 的方式，设置成 systemd 管理的</p><p><a href="https://wiki.archlinux.org/title/Wake-on-LAN">Wake-on-LAN - ArchWiki (archlinux.org)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/systemd/network/50-wired.link</span><br><span class="line">---</span><br><span class="line">[Match]</span><br><span class="line">MACAddress=aa:bb:cc:dd:ee:ff</span><br><span class="line"></span><br><span class="line">[Link]</span><br><span class="line">NamePolicy=kernel database onboard slot path</span><br><span class="line">MACAddressPolicy=persistent</span><br><span class="line">WakeOnLan=magic</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows 快速启动无法被 wol 唤醒</title>
      <link href="/20240718-wol/"/>
      <url>/20240718-wol/</url>
      
        <content type="html"><![CDATA[<p>Windows 官方文档《 <a href="https://go.smzdm.com/3ecd4f1e758f18ee/ca_aa_yc_163_amx025p4_16293_2621_1641_0">System Power States</a> 》中讲述到，<strong>Windows 系统自身（抛开 BIOS 不谈）是不支持“快速启动”和“关机”状态下的网络唤醒，只支持“睡眠”、“休眠”状态下的网络唤醒</strong>：</p><ul><li><p>睡眠（Sleep），属于 S3 电源状态；</p></li><li><p>快速启动（Fast Startup），属于 S4 电源状态；</p></li><li><p>休眠（Hibernate），属于 S4 电源状态；</p></li><li><p>关机（Soft off），属于 S5 电源状态</p></li><li><p>对于<strong>“快速启动（fast startup, S4）”：</strong>从 Windows 8.1 开始到 Windows 11，“快速启动”作为系统默认的“<strong>关机”方式</strong>，是不支持网络唤醒的，<strong>这也是为什么在 WOL 的教程中会让你关闭“快速启动”</strong>：</p></li></ul><blockquote><p>“快速启动”：快速启动是一种关机类型，它使用休眠文件来加快后续的启动速度，在这种关机状态下，Windows 系统不支持网络唤醒。“快速启动”与“休眠”同属于  S4 电源状态。</p></blockquote><p><img src="619f939c2356a9109.png_e1080.jpg" alt="WOL 网络唤醒避坑指南：常见问题的分析与内容补充"></p><p>“快速启动”属于“<strong>hybrid shutdown（混合关机）</strong>”，是关机的一种类型：</p><p><img src="619fb314b625f7326.png_e1080.jpg" alt="《System Power States》"></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统无法正常 suspend （睡眠）</title>
      <link href="/20240718-suspend/"/>
      <url>/20240718-suspend/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p>仔细翻看 journal：</p><p><img src="image-20240718185134192.png" alt="image-20240718185134192"></p><p> 但其实我们并没有 nvidia 驱动，甚至是 headless 的。查看 service 的依赖</p><p><img src="image-20240718185214952.png" alt="image-20240718185214952"></p><p>全删掉，然后 <code>daemon-reload</code> 就好了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>看看Redis 2.8源码</title>
      <link href="/20240715-redis/"/>
      <url>/20240715-redis/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20240715140825253.png" alt="image-20240715140825253"></p><p>唯一用到多线程的地方是一个看起来很 tricky 的优化，震撼我妈</p>]]></content>
      
      
      <categories>
          
          <category> Distributed Systems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图形绘制技术-光学相机</title>
      <link href="/20240708-optical/"/>
      <url>/20240708-optical/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20240708144504816.png" alt="image-20240708144504816"></p><p>参考文献：现代光学镜头设计方法与实例</p><p><img src="image-20240710155552561.png" alt="image-20240710155552561"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知识领域</title>
      <link href="/20240706-fields/"/>
      <url>/20240706-fields/</url>
      
        <content type="html"><![CDATA[<p>之前总结过一次研究生阶段需要关注的领域。不过那张纸丢失了，这样也好，我可以调整一下重心。</p><p>健美&#x2F;力量举&#x2F;举重</p><p>营养学&#x2F;烹饪</p><p>斯诺克&#x2F;台球</p><p>赛车&#x2F;F1&#x2F;摩托车&#x2F;汽车</p><p>生理学&#x2F;运动科学&#x2F;医学</p><p>心理学</p><p>哲学&#x2F;精神分析&#x2F;现象学</p><p>文学&#x2F;历史&#x2F;神话</p><p>植物学&#x2F;动物学&#x2F;微生物学</p><p>化学</p><p>声乐&#x2F;器乐&#x2F;古典&#x2F;歌剧   吉他</p><p>电视剧&#x2F;电影</p><p>书法</p><p>行政&#x2F;政治学&#x2F;国际政治</p><p>经济学&#x2F;金融</p><p>管理学</p><p>调酒&#x2F;果茶&#x2F;奶茶&#x2F;茶&#x2F;咖啡</p><p>园艺&#x2F;插花</p><p>立直麻将&#x2F;国际象棋</p><p>社交技巧&#x2F;人际关系</p><p>军事&#x2F;军用装备</p><p>日语&#x2F;法语</p><p>电脑维修</p><p>手工&#x2F;木工&#x2F;设计&#x2F;机械</p><p>写作&#x2F;表达&#x2F;喷人</p><p>电子产品</p><p>机器学习</p><p>营销学</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK 设计</title>
      <link href="/20240701-dmck/"/>
      <url>/20240701-dmck/</url>
      
        <content type="html"><![CDATA[<p>我也不知道怎么回事，在后台有一个随机读写lock的程序忘了kill的情况下，测试程序一直能打出长度一样、顺序一样、甚至内容也一样的log，企图骗我这就是执行路径。CS套路深，我要回农村</p><p>假设我获得了系统调用的顺序和所有系统调用之后的进程状态。</p><p><img src="image-20240702214113221.png" alt="image-20240702214113221"></p><p>显然是B。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssite_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> buf[.count], <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>注意 buf 是 <code>const</code> 意思是写之前和写之后是同一个状态。但是 $\mathbb{A}$ 状态下，write 的参数未必准备好了。只有到系统调用的前一刻，其所有的参数才被准备好。想要从 $\mathbb{B} $ 之前获取参数并不是什么问题，关键在于「向前多少」</p>]]></content>
      
      
      <categories>
          
          <category> DisSys </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>了结</title>
      <link href="/20240630-ending/"/>
      <url>/20240630-ending/</url>
      
        <content type="html"><![CDATA[<p>这几天实在狠狠地玩大了。本来应该用来干活的时间都浪费掉了。睡觉睡不醒，看不完的剧，打不完的麻将。我也不知道我这是怎么了，很久很久没有拿得出手的成就，也没有什么东西值得去拼。这个目标不一定要多么高尚，甚至于千万不能高尚，而仅仅在于一个“有”。有一个很矬、很蛇皮的目标，却能使人行高尚之实。</p><p>第一件事就是为接下来的工作安排一个章程。</p><p>什么时候休息？真正疲劳的时候，完全疲劳的时候。只要脑力仍能运转，就不安排休息；甚至是一段时间后清醒了又可以继续。这几天就略微放任一下作息，到个人最自然的节律即可。</p><p>然后把心事都了解一下。首先是关于 Z女士。上周日外出喝酒，真心话环节她问，是否会接受一夜情，是否接受炮友。我当然是都接受的，也正面回答了。这问题倒是并不恼人，毕竟我从来不打算掩饰，但是提出问题的原因无法探究，也许就是好奇一下？反而我就不能问回去，毕竟对方的对象在场，有的话毕竟不该说。另外令人在意的是，提及本科阶段都喜欢过哪些人的时候，总之我不在其列。我在妄想什么？不过这些都是無駄のこと！真的假的都不能说出来。</p><p>周三还是周四晚上，我在计科楼东南角抽烟。满耳的蝉鸣让我感觉身在乡下，于是发了条动态。结果过了十几分钟，她居然和她男朋友到原地来逮捕我。也不能说是碰巧，也就是赌我在那里坐了几十分钟。</p><p>于是后来也没有见到。戏剧已经落幕。</p><p>会有人掉两滴眼泪吗？她离开的是这一切，理所当然；而我离开的只是她，所以我不会。</p><p>写完这些的确是很丧气的。这位断断续续地在我生命中走了两三年，这期间我不是过于冲动和情绪化，就是过于谨慎。事到如今我也不知道我有没有成熟一点，我们之间的关系是简单呢？还是复杂呢？谁知道。</p><p>我们一起喝酒，一起抽烟。最后留下的身影也是那样。她坐着 Z先生 的车，叫我好好珍惜她。</p><p>谁知道该怎么珍惜呢？懂事的孩子是不应该多说什么的。</p><p>莫欺少年穷；而少年却不可以此自恃，隐而不发。赢得所谓的最终胜利？如今也不知道是不是有这样的胜利存在。总之一切都不可信，自从隐瞒的心思重了之后，就发现一件事：想要人不知，即使外界用尽手段去探知，也有可能无功而返。只要讲故事的功夫到位，叙述诡计可以骗过所有人的眼睛。他人的谜团是永远都解不开的。</p><p>当然放在自己身上还是要谨慎一点，因为这是一个悖论：自己不希望别人知道的事情一定会被人知道。</p><p>思路有点中断，依我看确实应该休息了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内心快板一则</title>
      <link href="/20240630-allegro/"/>
      <url>/20240630-allegro/</url>
      
        <content type="html"><![CDATA[<p>客人：这差使您办好了，不负众望。</p><p>先生：鬼知道我吃了多少苦头。</p><p>客人：这些磨难让您更加成熟老练，以后世上的人听到您的姓名，无人不知无人不晓这一位铁骨头的硬汉子。</p><p>先生：我本不想收受它的这些好处。这难事落到谁的头上，本来就是一笔糊涂账！有人可以得过且过，有人就要苦尽甘来， 甚至于这甘也并不来。</p><p>人本没有必要平衡心态，无非是对比多了自觉“失衡”。但我只劝想要“平衡”的，那高高在上的为什么用不着自己平衡，反而让落在下面的自己去找？</p><p>子女较多的家里，经常有被要求懂事的那几个，和被溺爱的那几个。那要懂事的，往往受到的恩惠是较少的。因为是”懂事的”，所以他们并不能为少受恩惠而大呼小叫。于是发展出的那种苦闷是二阶性的： 其怀疑的是【必须自己想出将这一切合理化的说辞说服自身】这件事。</p><p>简单来说，这个气我受了，但是要我跟谁也不能说，打碎了牙往肚子里咽，哪有这么霸道的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024春季 蒋炎岩《操作系统》期末回忆</title>
      <link href="/20240630-OS/"/>
      <url>/20240630-OS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>By <a href="https://space.bilibili.com/8002700">Fradow</a></p></blockquote><h2 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一 基本概念"></a>一 基本概念</h2><p>均用10-20字描述即可。</p><ol><li>什么是内核（kernel），什么是外壳（shell）？</li><li>写出系统调用（<code>syscall</code>、<code>ecall</code> 等）的功能。</li><li>什么是数据竞争？为什么C代码中要避免数据竞争？</li><li>很多操作系统都没有关机指令，那么它是如何实现关闭计算机的？</li><li>为什么磁盘等存储设备要设计成按块读取？</li></ol><h2 id="二-进程、线程与地址空间"><a href="#二-进程、线程与地址空间" class="headerlink" title="二 进程、线程与地址空间"></a>二 进程、线程与地址空间</h2><p>现在你想在Linux上实现 <code>pidof</code> 指令，可通过命令行参数传入进程名，打印拥有该进程名的所有进程号。</p><ol><li><code>pidof</code> 的 <code>main</code> 函数有 <code>argc</code>、<code>argv</code> 两个参数，写出其函数原型，解释它们都代表什么含义。</li><li>命令行参数传给进程后存放在什么位置？</li><li>10-20字描述如何实现 <code>pidof</code>。</li><li>操作系统中的进程可以随时开始、中止。这对的实现有何影响？如果想让 <code>pidof</code> 显示（近期）历史上某个瞬间的进程列表，需要如何实现？</li></ol><h2 id="三-编译、链接和加载"><a href="#三-编译、链接和加载" class="headerlink" title="三 编译、链接和加载"></a>三 编译、链接和加载</h2><p>以下是执行 <code>./a.out</code> 后其进程对应的一段 <code>pmap</code> 输出。<em>（回忆时编的，重点是最后一列）</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0000000000400000</span>    <span class="number">132</span>K r-x-- a.out</span><br><span class="line"><span class="attribute">0000000000602000</span>      <span class="number">4</span>K r---- a.out</span><br><span class="line"><span class="attribute">0000000000603000</span>      <span class="number">4</span>K r---- a.out</span><br><span class="line"><span class="attribute">0000000000604000</span>      <span class="number">4</span>K rw--- a.out</span><br><span class="line"><span class="attribute">00007f8b1c000000</span>    <span class="number">128</span>K rw---<span class="meta"> [anon]</span></span><br><span class="line"><span class="attribute">00007f8b1c020000</span>    <span class="number">256</span>K rw---<span class="meta"> [anon]</span></span><br><span class="line"><span class="attribute">00007f8b1c040000</span>    <span class="number">132</span>K rw---<span class="meta"> [stack]</span></span><br><span class="line"><span class="attribute">00007fffedcfed00</span>      <span class="number">4</span>K r-x--<span class="meta"> [vvar]</span></span><br><span class="line"><span class="attribute">00007fffedcff000</span>      <span class="number">4</span>K r----<span class="meta"> [vdso]</span></span><br></pre></td></tr></table></figure><ol><li>解释静态链接和动态链接的区别。</li><li>在输出中的每一行地址空间后写出其表示的含义。<code>./a.out</code> 是通过静态链接还是动态链接得到的？</li><li>若实现一个调试器，支持用一个进程调试另一个进程，需要在操作系统上做什么设计（在系统对象和系统调用上）？</li></ol><h2 id="四-并发编程"><a href="#四-并发编程" class="headerlink" title="四 并发编程"></a>四 并发编程</h2><p>现有n个线程（线程号为1, 2, 3, …, n）玩石头剪刀布，每个线程创建后均执行一次 <code>play_one_round</code>。其中调用 <code>play</code> 得到每个线程的胜负结果，若平局则结果均为 <code>TIE</code>。请写出完整的 <code>play</code> 函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">play_one_round</span><span class="params">(<span class="type">int</span> pid, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">  assert(type == ROCK || type == SCISSORS || type == PAPER);</span><br><span class="line">  <span class="type">int</span> result = play(pid, type);</span><br><span class="line">  <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">    <span class="keyword">case</span> WIN: <span class="built_in">printf</span>(<span class="string">&quot;I (%d) win!\n&quot;</span>, pid); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LOSE: <span class="built_in">printf</span>(<span class="string">&quot;I (%d) win!\n&quot;</span>, pid); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为可以使用的线程库函数。假设互斥锁初始状态为解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mutex_lock</span><span class="params">(<span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mutex_unlock</span><span class="params">(<span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">sem_t</span> semaphore = SEM_INIT(<span class="type">int</span> value); <span class="comment">// initialize semaphore</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> sem, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> sem, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cond_wait</span><span class="params">(<span class="type">cond_t</span> *cond, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cond_signal</span><span class="params">(<span class="type">cond_t</span> *cond, <span class="type">mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cond_broadcast</span><span class="params">(<span class="type">cond_t</span> *cond, <span class="type">mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><h2 id="五-文件系统"><a href="#五-文件系统" class="headerlink" title="五 文件系统"></a>五 文件系统</h2><ol><li>Everything is a file. 目录是文件吗？</li><li>什么是文件描述符？写出3个返回文件描述符的系统调用名称。</li><li>解释操作系统如何区分一个文件是普通文件、流还是设备。</li><li>RAID相比使用单个或多个可靠磁盘有何优点？</li><li>假如有一款内存得到普及，其容量和性能与DRAM相当，断电后数据不消失（但正在写入的内容可能会消失），这会对文件系统有何影响？可以适当展开分析。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>镜头光晕 分析</title>
      <link href="/20240627-lensflare/"/>
      <url>/20240627-lensflare/</url>
      
        <content type="html"><![CDATA[<p>直观上来看：</p><ol><li>图片上的圆形和光斑是由于光线在镜头和光圈之间“来回反射”（反射）造成的。 </li><li>特定方向上的光线尖峰很可能是由于光线在相机传感器（数字相机上是网格状的）和&#x2F;或光圈光阑上的衍射造成的。 </li><li>光源周围的光晕（我这里不是说任何大气效应）是由于强光在镜头的玻璃材料中的散射造成的。</li></ol><p>为了实现1和3，需要扩展现实相机模型。我们必须考虑一些在镜头上反射的光线，除了那些仅通过它们折射的光线。</p><p>控制两种不同材料之间界面处光重新分配的物理方程是菲涅耳方程。它们可以从麦克斯韦方程中推导出来，麦克斯韦方程更普遍地控制电磁波在材料中的传播。</p><p>菲涅耳方程给出了在界面处反射的光的百分比 R，具体取决于斯涅尔角 θi 和 θt 以及两种材料的折射率 n1 和 n2。有两个方程，取决于入射光是否在垂直于该平面的入射平面上偏振。对于非偏振光 - 我们假设摄影师在这里没有使用任何偏振滤光片 - R 只是两个项 Rs 和 Rp 的平均值。</p><p>让我们看一下 R 的值取决于参数。正如我们所看到的，反射系数 R 增加得更快——当光从折射率较大的材料变为折射率较小的材料时，对于长角度（全内反射）等于 1。</p><p>在我们的例子中，这意味着镜头外部的反射比镜头内部的反射更频繁——这有点违反直觉。</p><p>下面可以看到光线在通过相机时被反射 4 次的示例：</p><p>我实现这一点的方式是概率的：在每个接口上，我计算反射系数 R。然后，我根据这个值随机决定光线是反射还是折射。这相当于实际拆分每个界面处的每条射线，并用 R 或 （1-R） 对它们进行加权，但以这种方式更容易实现。</p><p>下面是在随机选择的界面上分割的射线示例。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AML复习</title>
      <link href="/20240618-aml/"/>
      <url>/20240618-aml/</url>
      
        <content type="html"><![CDATA[<p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkU5ZXBZQjN5YlYzY1hNeXNhaXRMVHliSlZqaEdJQ1BDU0QtQ2lpSmlNeVJtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkpYVGNGWm1nTzludDg5ejJaQUgzSUpRdXVGY0dJZVBDaUQtQ2lqdGxNeVJtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkNiUFlnU09oVUlGdExDY1YzQzAwUFNFbFZwUEdNcnNDaUQtQ2lqQjU5S1JtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRlBscGxpMVdVWnJqYzJ3UThMakdURkNQcWtCVkdJWENDQ0QtQ2lqVm50cVJtdUtHQTFDQXV5OA" alt="img"></p><p><img src="NTV2COMPAT.Ck0IARAAGkdDZ2s1T1RNeU16STNPRElTRkFLYzV5SktBV2lSV0hrb05pNV9QcEppYTM2NEdPdVJEU0QtQ2lqUHBOT1JtdUtHQTFDQXV5OA" alt=" "></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算模型导引复习</title>
      <link href="/20240616-computTH/"/>
      <url>/20240616-computTH/</url>
      
        <content type="html"><![CDATA[<p>题型分析</p><p>基础概念 1，2-图灵机（16，17）3-一般、原始、部分递归函数，Lambda演算的CR性质（18）4-配对函数组，停机问题（19）5-（20） Lambda不动点算子（21）6-（22） 7-通用图灵机（22） 8-（23）9-Turing。。。算法可以达到的绝对极限（23）</p><p>函数 1，3，5，7，9，11，13-判定数论函数类（16，17，18，19，20，21，22）2-构造函数（16）4-构造函数（17）6，12-一元递归函数性质证明（18，21） 8-证明初等函数（19） 10-构造什么什么定义数论全函数 14，16-函数和Godel编码（22，23）15-一元递归函数性质，函数周期性等（23）</p><p>Lambda演算 1，2，3，4，5，6，7，8-添加公理的证明（16，17，18，19，20，21，22，23）</p><p>图灵机 1-求输出（16） 2，7，8，9，10，11-构造图灵机计算函数（16，19，20，21，22，23）3，5-从输入输出构造函数（17，18）4，6-停机问题证明（17，18） </p><p>其他：1，3，4，8，9-证明sinh&#x2F;其他函数的第n位 f(n) 为Turing可计算（23），进而证明是初等函数。（18，19，20，22）  2-可判定的证明（19） 5-证明Turing可计算函数为一般递归函数（20）  6-看不懂（21.6） 7-证明不动点结合子（21.7） 8-算中国剩余定理（23）</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为赋新词</title>
      <link href="/20240611-shortcircuit/"/>
      <url>/20240611-shortcircuit/</url>
      
        <content type="html"><![CDATA[<p>如今看年轻人为赋新词而说的愁，不免感到有点可笑。我倒不是在说他们的困境并非真实的，而是这种姿态显得不够强大。最近在很多场合，我都下了这样的定论：如果你觉得的内心足够强大，你尽可以随心意去做事；但如果一个人的内心容易受到伤害而不能很快地恢复，那对他来说采取保守的防备姿态也是一件相当正常的事情。</p><p>如何让自己相信自己的内心是强大的，我想这只能借助于一种自负，即那种在任何情况下否认自己受到了伤害，自己坚信不疑。（录者语：我现在改变看法了）这可能有很大一部分是天生的，有一小部分是长久以来的习惯。这样的习惯是很难刹得住车的。让人从一种信念而转向另一种看起来简直是蛮不讲理的信念。</p><p>这种蛮不讲理，仅仅是因为其不符合社会从一开始就赋予所有人的一种“短路”。可以想到只要解开这一短路。但这需要一个人在其经历中的反复思考，以及一种作“哥白尼式的革命”的勇气。</p><p>经验上看来，对于短路的路径作一系列追问将使人沉默。此时不应给予任何答案，不引入新的短路，而叫人获得一个自己选择的机会，深刻地在考虑自身的欲望之后进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Isolated</title>
      <link href="/20240611-lone/"/>
      <url>/20240611-lone/</url>
      
        <content type="html"><![CDATA[<p>越是到夏天这时候，在床上就越是难以入眠，特别是有一个喜欢关了空调睡觉的舍友。好在这光景也就只是持续一周。躺在床上翻来覆去，其实并没有什么可思考的。只是在那里把遗书的事情在脑子里安排了一遍。醒来之后倒也没觉得这种想法很可笑，只是觉得可以按住暂时不去实行，毕竟没到非死不可的境地。</p><p>去412坐了一晚，那是一个相当亲切又热情的地方，就像加州旅馆一样。之后一冲动就想着入社了。那里确实有很多朋友，就算我并不是社员，偶尔去玩一趟也不是什么不可以的事情，但毕竟还是希望名正言顺，希望没人会有意见。仿佛经过这一年的事情之后，我变得有点畏首畏尾的，昨晚还想着是不是应该行善积德，重新建立一下自我。这段时间我应该多一个人待着。特别忙碌的时候，人的进步就停止了。需要一段完整的时间对自己施加肉眼可见的改变。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夕拾 第三周</title>
      <link href="/20240609-week3/"/>
      <url>/20240609-week3/</url>
      
        <content type="html"><![CDATA[<p>上周除了电视剧以外基本没看什么。明天补一点吧。</p><p>我找到一本书。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z:/ZijingBT/kindle电子书资源/kindle人的资源打包/自制21-40/ZZ21-22/数码摄影构图与用光.pdf</span><br></pre></td></tr></table></figure><p>本周来把它看掉。</p><p>看雍正王朝（已过半）</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 夕拾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人民的名义</title>
      <link href="/20240603-intheNameofPeople/"/>
      <url>/20240603-intheNameofPeople/</url>
      
        <content type="html"><![CDATA[<p>这是一部很长的剧，有55集之多。最后是用两周时间去看完的。</p><p>里面值得学习的细节很多，需要解读的内容也很多。当然有很多人去做了“中译中”，而我在看的时候的确就思考不了那么多，语言的艺术这些东西都显得有点虚了。</p><p>我只提几点：</p><p>一是守住底线。做任何事都要把原则性放在第一位。</p><p>二是谨慎交友。不结交卑鄙小人，不得罪道不同不相为谋的人；保持真正的革命友谊，既是最务实的，也是最打动人心的。</p><p>三是学会以退为进。适当的时候放弃眼前的，看到下一步应该怎么做。</p><p>四是学习上不能放松。特别是用严谨的思维分析情势的能力要加强。</p>]]></content>
      
      
      <categories>
          
          <category> 电视剧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夕拾 第二周</title>
      <link href="/20240603-week2/"/>
      <url>/20240603-week2/</url>
      
        <content type="html"><![CDATA[<p>上周剩下一个没看完的：</p><p><img src="image-20240527150622100.png"></p><p>当然是因为上周最后把所有的时间都用来刷完了人民的名义，读性心理学这些。本周还是可以照常安排。</p><p>剧：</p><p><img src="image-20240603174946953.png" alt="image-20240603174946953"></p><p>电影：</p><p><img src="image-20240603175029995.png" alt="image-20240603175029995"></p><p><img src="image-20240603175126800.png" alt="image-20240603175126800"></p><p>学习材料</p><p><img src="image-20240603180310929.png" alt="image-20240603180310929"></p><p>纪录片</p><p><img src="image-20240603180358644.png" alt="image-20240603180358644"></p><p>​</p><p>我突然觉得摄影还是要比较系统地学。多练眼睛和构图的巧思</p>]]></content>
      
      
      <categories>
          
          <category> 夕拾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The.Scent.of.Yvonne.1994</title>
      <link href="/20240601-yvonne/"/>
      <url>/20240601-yvonne/</url>
      
        <content type="html"><![CDATA[<blockquote><p>吐个槽，紫荆站上的老电影真的是不能随便点开，你根本不知道什么时候会突然露个点给你看。</p></blockquote><p>背景大概是1940年左右，在法国。一个有点普通的爱情故事。但是最后的发展很奇怪。当然，在讲述往事的时候，穿插了十几年以后两位男主的故事。</p><p>为什么男主提出去美国之后，女主就和本地乡绅好上了？</p><p>为什么男二被打成同性恋者？完全没有交代。</p><p>为什么男二最后倒车再冲下山崖在男主面前自杀了？</p><p>真是一部一言难尽的电影。</p><p>从豆瓣摘了一点。看来我还是不懂一点浪漫。</p><blockquote><p>假如你见到了一个能满足你各种幻想的女人，你会有另一个脑子去相信她又懒又放荡又薄情吗？电影的关键点，就是伊冯娜的叔叔跟维克多私下交谈的内容，在她叔叔嘴里，完全是真实的伊冯娜。男女都是视觉动物，以貌取人，爱上的，都是这个人带给你的一种感觉，而感觉里有一半都是脑补出来的幻想。人的外表，和内在不见得是一致的，它代表一部分内在，但也隐藏了一部分内在。漂亮女人，让人贪爱的同时，很难想到她漂亮的外表下，可能是另一颗并不美丽的心。甚至，即使你知道她并不美丽的另一面，你也依然不觉得不美，甚至你还会去理解她。</p><p>这就是美丽外表的力量！</p><p>就像是香水，掩盖住了不堪的体味儿，却让你久久不能遗忘。漂亮，是一种资本，它可以让人沉迷于对猎物获取的快感之中，又能享受从不同猎物身上获取的价值。因此，有的漂亮的动物，就像是鸟儿一样，不会总落在同一个枝头。这就是更了解伊冯娜的勒内说的，你不要让她离开你的视线，她只属于那一刻。</p><p>而维克多，并没有理解这一番话的意思。香水带给人的感觉是挥之不去的，久久停留在人的记忆中，即使是失去，即使是知道不堪，你也忘不掉它带给你的感觉。</p></blockquote><blockquote><p>勒孔特搞突然死亡，无非是要解释人物对无聊生活、机械人生的厌倦，企望用死来获得超脱，用死来挽留正在流逝的美好时光，“证明我活过，我爱你，我爱你们，爱的那么纯粹”。</p></blockquote><blockquote><p>她叔叔说，她是个麻烦，她只活在那一刻。他砸烂那个每小时敲12下报时的老钟，那一刻，他是希望她能停下在那一刻的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 观影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>未记录时间的记录</title>
      <link href="/20240601-whattime/"/>
      <url>/20240601-whattime/</url>
      
        <content type="html"><![CDATA[<p>理工科人的文笔，从统计的角度上来讲，可能的确是比较差。</p><p>但这并不是理工科本身的错，逻辑链条要比这长得多。</p><p>这更主要地是因为—理工科是对爱幻灭的遗族们为自己的子女选择的避难所。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高级机器学习：二分类</title>
      <link href="/20240530-aml/"/>
      <url>/20240530-aml/</url>
      
        <content type="html"><![CDATA[<p>任务：</p><ul><li>读描述，下载数据集</li></ul><p>数据集：客户id，名字，信用点，位置，性别，年龄，年限，存款，产品数量，有信用卡，活跃，月薪</p><p>预测：客户是不是跑路了</p><p>实现：任何算法，任何语言。</p><p><strong>网络设计</strong>：根据问题的具体需求设计神经网络的结构。对于简单的二分类问题，一个两到三个隐藏层的小型 MLP 通常就足够。</p><p><strong>激活函数</strong>：对于隐藏层可以使用 ReLU 激活函数，因为它有助于解决梯度消失问题，并且计算上比较高效。输出层因为是二分类问题，所以建议使用 sigmoid 激活函数。</p><p><strong>损失函数</strong>：使用交叉熵损失函数（binary cross-entropy），这是处理二分类问题的标准选择。</p><p><strong>优化器</strong>：可以使用 Adam 或 SGD（带动量），这些优化器能帮助快速收敛且通常表现良好。</p><p><strong>正则化</strong>：为了避免过拟合，可以在训练过程中加入 Dropout 层或使用 L2 权重正则化。</p><p>**可以作一些仔细的分析。</p><p>输出：$yourId.txt，1000 lines，没有文件头的结果。</p><ul><li>实现算法，输出预测</li><li>写报告</li></ul><p>1）你的理解和分析</p><p>2）算法的动机，介绍算法的背景</p><p>3）算法的技术细节，特别是要包括伪代码</p><p>4）描述或分析算法的表现</p><p>5）总结和（可选的）讨论</p><p>使用 LaTeX 模板撰写含有英文摘要的中文报告。命名为 report.pdf</p><ul><li>提交</li></ul><p>1）$yourId.txt</p><p>2）report.pdf</p><p>3）源代码</p><p>打包zip，命名为 $Id_v$version.zip。e.g. 1912xxx_v1.zip</p><p>使用南大表格提交</p><p>Baselines:</p><p>经典算法包括随机森林，逻辑回归，XGBoost GBST，SVM，MLP，GBDT 等等。可以参考这些算法的表现。</p><table><thead><tr><th>alg</th><th>f1</th></tr></thead><tbody><tr><td>RF</td><td>0.583</td></tr><tr><td>LR</td><td>0.487</td></tr><tr><td>SVM</td><td>0.568</td></tr><tr><td>MLP</td><td>0.586</td></tr><tr><td>GBDT</td><td>0.603</td></tr><tr><td>RFE (n&#x3D;9)</td><td>0.609</td></tr></tbody></table><p>算法选择</p><p>CatBoost 是一种流行的梯度提升决策树（Gradient Boosting Decision Tree, GBDT）算法，由 Yandex 开发。它是专门为处理分类特征而优化的机器学习算法，同时也适用于回归问题。CatBoost 有几个显著的优点：</p><ol><li><strong>对分类特征的原生支持</strong>：CatBoost 可以直接处理分类特征，无需进行预处理（如独热编码）。这简化了数据预处理步骤，并通常能提高模型的性能。</li><li><strong>避免过拟合</strong>：CatBoost 实现了几种机制来减少过拟合的风险，例如具有有序提升的默认树学习策略。这种技术在训练每棵树时使用不同的数据子集，从而提高了模型的泛化能力。</li></ol><table><thead><tr><th>性能</th><th>baseline</th><th>smoothing + binning</th><th></th></tr></thead><tbody><tr><td>f1</td><td>0.598446</td><td>0.630029</td><td></td></tr><tr><td>acc</td><td>0.827778</td><td>0.846667</td><td></td></tr><tr><td>recall</td><td>0.641667</td><td>0.652778</td><td></td></tr><tr><td>precision</td><td>0.560680</td><td>0.608808</td><td></td></tr><tr><td>auprc</td><td>0.691654</td><td>0.693995</td><td></td></tr><tr><td>auc</td><td>0.856181</td><td>0.862392</td><td></td></tr><tr><td>macro f1</td><td>0.744414</td><td>0.766660</td><td></td></tr></tbody></table><p>数据预处理</p><p>观察训练集上属性值的数量可知，Surname 是 High-catdinality categorial variables. 做 polynomial smoothing</p><p>提高泛化能力，对Balance和Salary 做等频分箱</p><p>调参</p><p>depth, score_function,list of cat features</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>性心理学 - 读书</title>
      <link href="/20240529-sexpsychology/"/>
      <url>/20240529-sexpsychology/</url>
      
        <content type="html"><![CDATA[<p>作者：霭理士</p><p>快快地读，做纸质的笔记，然后在归纳的时候录入到这里。</p>]]></content>
      
      
      <categories>
          
          <category> 心理学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>天水围的夜与雾.Night.and.Fog.2009</title>
      <link href="/20240528-nightandfog/"/>
      <url>/20240528-nightandfog/</url>
      
        <content type="html"><![CDATA[<p>Night and Fog</p><p>以家庭暴力为题材的电影。镜头和布置平淡但真实，90年代的风格又使人仿佛要窒息。</p><p>看前半段的时候，总是觉得故事叙述节奏太慢。后半段则穿插李森和玲相识的往事，与问询知情人的片段，最后停止在案发当场。</p><p>这是在说什么呢？看起来美好的开局，和习以为常的平静生活，仍然酝酿出一桩惨案。</p>]]></content>
      
      
      <categories>
          
          <category> 观影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>污垢.Filth.2013</title>
      <link href="/20240529-filth/"/>
      <url>/20240529-filth/</url>
      
        <content type="html"><![CDATA[<p>过了两天才来写。</p><p>说实话里面有很多内容我看不明白，比如说，男主的那个妻子到底是否是幻想？还是真实的？我倾向于认为那个是男主的幻想。更进一步，是一个内化了的大他者：用诱惑的方式要求男主晋升，并且允诺一种持续的激情。男主对于这个幻想可以说是唯命是从，以至于他不遗余力地通过女装的方式成为那个幻想中的。既然“她”能允诺我拥有极度的幸福和激情，那么她本身是必然有享乐的能力的。</p><p>男主在升职这件事情的做法上很有意思：通过栽赃同事靠性上位、是男同、说领导坏话，而这些都是男主自身。包括后来把朋友陷害入狱，其罪行也是男主自己犯下的；男主所办的案子，自己也是目击证人。将自己的缺陷都附加到他人的身上。</p><p>然而男主是什么样的人呢？一个抑郁症患者，一个警探；一个吸食毒品的人；疑似同性恋者，但一直都和很多女性保持关系。一个自大狂，但也是一个自卑的人：在游戏中用复印机复印自己的阳具，却偷用放大功能。加上前面的行为，不得不说他充满了焦虑，他对于自己的缺点太过于敏感，而且在众人面前一直都做好了伪装。</p><p>男主的自卑是有原因的：在年幼的时候，男主的表现一直没有弟弟出色。在推推搡搡中，弟弟不小心摔下煤山，但是并没有能够施以援手。于是他成为了一个永远差一点的孩子，并且自认为是把弟弟害死了。</p><p>于是，男主最后留下的一番话实在是有意思</p><blockquote><p>你把你那厚瓶底一样的眼镜摘了吧，配一副隐形眼镜，或者是去做激光手术。知道吗，戴着眼镜是没有人会真诚对待你的。你太软了，其实所有人都和你一样害怕这个世界。试着变得强硬一点，她还是会很爱你的。</p></blockquote><p>何尝不是男主对自己说的话。在撂下了这番话之后，男主自杀了。</p><p>最后，还有疑点：他几次梦境中的老男人是否是兄弟的父亲？还有，“规则照旧”这个反复，到底是什么意思？</p>]]></content>
      
      
      <categories>
          
          <category> 观影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有样学样</title>
      <link href="/20240528-review/"/>
      <url>/20240528-review/</url>
      
        <content type="html"><![CDATA[<p>回顾历史，我从来都比较谨慎，甚至是比较怕事。主要对于情绪问题，无论是对方的还是自身的，都有点照顾不到。这里的补全就是要多观察。所以第一个任务就呼之欲出。</p><p>1、观察其他的亲密关系是如何发展的。具体而言，从机遇、动机以及后续行为方面去看，主要是客观地描述，以材料为主。最后是总结与练习方面的指导。</p><p>第二个任务就是培养心态。</p><p>2、读一读书，读一读哲学。说到底是自身的定力。</p><p>第三方面是识人。察言观色，认清形势，怎么能知道一个人在思考什么，目的是什么，底线是什么，是否是同路人。老实说这最后一点并不很重要，只要判断到双方是否合得来就可以了。</p><p>3、见人，不一定是现实里的人，也可以是经典的影视作品。读心理学，以及文学作品。</p><p>still 锻炼聊天技巧，多掌握一些话题，是长期的事。先碎片化后系统化。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异性交往中的心理学 - 陈昌凯</title>
      <link href="/20240528-psycoInOpposSexComm/"/>
      <url>/20240528-psycoInOpposSexComm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结：浅显但做不到的大道理。一个词概括，就是“降格”</p></blockquote><p>1&#x2F;2000 一个男人在茫茫人海中喜欢上一个女人并鼓起勇气约会她的概率。</p><p>1&#x2F;4 这个女人和男人约会4次后，喜欢上他的概率。</p><p>1&#x2F;2 男人坚持约会同一个女人4次的概率。</p><p>1&#x2F;3 相爱的两个人最后结婚的概率。</p><p>1&#x2F;20 离婚率</p><p>谈恋爱是一件理性的事情吗？真的会做一些傻事。不是一个理性的过程。</p><p>情商是人类最重要的生存能力。（但其实我从来都有点不屑）</p><ul><li><p>认识自身情绪的能力：感情表达有障碍的人，对别人的感情也比较冷漠。</p></li><li><p>妥善管理情绪的能力：在适当的时候，对适当的人，适度地发脾气。</p></li><li><p>自我激励的能力：延迟满足和抑制冲动</p><ul><li><p>一开始提出较低的要求，逐渐成长</p></li><li><blockquote><p>延迟满足是一种能力而不是技巧</p></blockquote></li></ul></li><li><p>认识他人情绪的能力：顺畅沟通的基础</p><ul><li>不要启动应激模式，那是没有用的。</li></ul></li><li><p>人际关系的管理能力：领导和管理能力</p><ul><li>“你生气了？”“你为什么生气？”解释</li><li>“没有。”“我不知道。”“自己去想啊。”直接做能让对方开心的事情</li></ul></li></ul><p>男女差异</p><ul><li>女性喜爱分享，男性崇尚效率</li><li>女性需要倾诉，男性向往独立</li><li>女性强调当下，男性注重长远</li></ul><p>《男人来自火星》</p><p>QA</p><p>Q：一直是女生主动怎么办？</p><p>A：没什么怎么办。这是很好的一件事。当然还要考虑是否适合。女生不要再暗示啦，明示一下更容易上钩。</p><p>Q：人为什么会作？为什么有的人会装傻而不是面对？</p><p>A：测试是否是真心喜欢。容忍就是真心的喜欢。适度对于自己的安全感是有好处的。但是过度了就会让人觉得很累。也有可能是行为模式或性格习惯，人是自我中心的，可能无意地侵犯到对方。</p><p>遇到问题不知所措，遇到威胁的时候，第一反应是呆着，第二反应才是逃跑。有的时候不是装傻。另一方面也有可以装傻的，但底层也是不知道应该怎么做。</p><p>Q：为什么男孩子更愿意向男生倾诉而不是女朋友？</p><p>A：也愿意向女生倾诉，但可能不是女朋友。主要是求得一种认同和帮助。男女之间的关注点不一样。（吃药的时候看到一则新闻.txt）因为他觉得这是一个烦恼，向女朋友倾诉不能解决问题还会平添你的烦恼。</p><p>Q：是不是一定会吵架？怎么避免？</p><p>A：无法避免。这是呈现双方需求的一种方式。当然也不是完全没有办法：情商高一点。句式换一换：我怎么怎么样……避免激起对方的防御心理，用正向的方式而不是否定的。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>德意志意识形态 - 摘录</title>
      <link href="/20240527-germanideology/"/>
      <url>/20240527-germanideology/</url>
      
        <content type="html"><![CDATA[<p>圣xxx的各种东西我都没看了。看人驳斥这种东西确实没有什么意思，况且写得太抽象了。只要把前面关于费尔巴哈的部分，也是写作最困难的部分看完就好。</p><p>[TOC]</p><h1 id="关于费尔巴哈的提纲"><a href="#关于费尔巴哈的提纲" class="headerlink" title="关于费尔巴哈的提纲"></a>关于费尔巴哈的提纲</h1><p>从前的一切唯物主义—— 包括费尔巴哈的唯物主义—— 的主要缺点是：对事物、现实、感性，只是从客体的或者直观的形式去理解，而不是把它们当作人的感性活动，当作实践去理解，不是从主观方面去理解。所以，结果竟是这样，和唯物主义相反，能动的方面却被唯心主义发展了，但只是抽象地发展了，因为唯心主义当然是不知道真正现实的、感性的活动的。</p><p>（六）<br>费尔巴哈把宗教的本质归结于人的本质。但是，人的本质并不是单个人所固有的抽象物，实际上，它是一切社会关系的总和。<br>费尔巴哈不是对这种现实的本质进行批判，所以他不得不：<br>（１）撇开历史的进程，孤立地观察宗教感情，并假定出一种抽象的—— 孤立的—— 人类个体；<br>（２）所以，他只能把人的本质理解为“类”，理解为一种内在的、无声的、把许多个人纯粹自然地联系起来的共同性。</p><p>所以，费尔巴哈没有看到，“宗教感情”本身是社会的产物，而他所分析的抽象的个人，实际上是属于一定的社会形式的。</p><h1 id="德意志意识形态"><a href="#德意志意识形态" class="headerlink" title="德意志意识形态"></a>德意志意识形态</h1><h6 id="对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判"><a href="#对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判" class="headerlink" title="对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判"></a>对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学以及各式各样先知所代表的德国社会主义的批判</h6><h2 id="第一卷-对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判"><a href="#第一卷-对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判" class="headerlink" title="第一卷 对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判"></a>第一卷 对费尔巴哈、布·鲍威尔和施蒂纳所代表的现代德国哲学的批判</h2><blockquote><p>对应三个人的观点</p></blockquote><p>一个人说，只要我们教会他们如何用符合人的本质的思想来代替这些幻想，另一个人说，只要我们教会他们如何批判地对待这些幻想，还有个人说，只要我们教会他们如何从头脑里抛掉这些幻想，这样……当前的现实就会崩溃。</p><p>这些天真的幼稚的空想构成现代青年黑格尔哲学的核心。在德国不仅是公众怀着畏惧和虔敬的心情来接受这种哲学，就是哲学英雄们自己在捧出它的时候也洋洋自得地感到它有震撼世界的危险性和大逆不道的残酷性。</p><h3 id="一-费尔巴哈-唯物主义观点和唯心主义观点的对立"><a href="#一-费尔巴哈-唯物主义观点和唯心主义观点的对立" class="headerlink" title="一 费尔巴哈 唯物主义观点和唯心主义观点的对立"></a>一 费尔巴哈 唯物主义观点和唯心主义观点的对立</h3><blockquote><p>背景</p></blockquote><p>正如德国的思想家们所宣告的，德国在最近几年里经历了一次空前的变革。从施特劳斯开始的黑格尔体系的解体过程变成了一种席卷一切“过去的力量”的世界性骚动。在普遍的混乱中，一些强大的国家产生了，但是立刻又消逝了，瞬息之间出现了许多英雄，但是马上又因为出现了更勇敢更强悍的对手而销声匿迹。这是一次革命，法国革命同它比起来只不过是儿戏；这是一次世界斗争，在它面前狄亚多希的斗争简直微不足道。在瞬息间一些原则为另一些原则所代替，一些思想勇士为另一些思想勇士所歼灭。在１８４２年至１８４５年这三年中间，在德国所进行的清洗比过去三个世纪都要彻底得多。<br>据说这一切都是在纯粹思想的领域中发生的。</p><p>然而，不管怎么样，我们碰到的是一个有意义的事件：绝对精神的瓦解过程。</p><blockquote><p>利用民族感情的哲学叫卖，青年黑格尔派的局限性。</p></blockquote><h4 id="A-一般意识形态-德意志意识形态"><a href="#A-一般意识形态-德意志意识形态" class="headerlink" title="A. 一般意识形态 德意志意识形态"></a>A. 一般意识形态 德意志意识形态</h4><p>他们和黑格尔的论战以及互相之间的论战，只局限于他们当中的每一个人都抓住黑格尔体系中的某一方面来反对他的整个体系，或反对别人所抓住的那些方面。起初他们还是抓住纯粹的、未加伪造的黑格尔的范畴，如实体和自我意识，但是后来却亵渎了这些范畴，用一些世俗的名称称呼它们，如“类”、“唯一者”、“人”，等等。</p><p>从施特劳斯到施蒂纳的整个德国哲学批判都局限于对宗教观念的批判。</p><p>老年黑格尔派认为，任何东西只要归入某种黑格尔的逻辑范畴，就明白易懂了。青年黑格尔派则批判一切，到处用宗教的观念来代替一切，或者宣布一切都是神学上的东西。青年黑格尔派同意老年黑格尔派的这样一个信念，即认为宗教、观念、普遍的东西统治着现存世界。不过一派认为这种统治是篡夺而加以反对，而另一派则认为它是合法的而加以赞扬。</p><p>既然青年黑格尔派认为观念、思想、概念，即被他们变为某种独立东西的意识的一切产物，是人们的真正枷锁，就像老年黑格尔派把它们看作是人类社会的真正羁绊一样，所以不言而喻，青年黑格尔派只要同意识的这些幻想进行斗争就行了。</p><p>他们之中最年轻的人确切地表达了他们的活动，说他们仅仅是为反对“词句”而斗争。</p><blockquote><p>没有反对现实的现存的世界。最终只能从宗教史上对基督教作一些片面的说明。</p></blockquote><p>这些哲学家没有一个想到要提出关于德国哲学和德国现实之间的联系问题，关于他们所作的批判和他们自身的物质环境之间的联系问题。</p><p>可以根据意识、宗教或随便别的什么来区别人和动物。一当人们自己开始生产他们所必需的生活资料的时候（这一步是由他们的肉体组织所决定的），他们就开始把自己和动物区别开来。人们生产他们所必需的生活资料，同时也就间接地生产着他们的物质生活本身。</p><blockquote><p>You are what you produce.  所谓人是什么样，就是说他的生产怎么样。</p></blockquote><p>这种生产方式不仅应当从它是个人肉体存在的再生产这方面来加以考察。它在更大程度上是这些个人的一定的活动方式、表现他们生活的一定形式、他们的一定的生活方式。个人怎样表现自己的生活，他们自己也就怎样。因此，他们是什么样的，这同他们的生产是一致的—— 既和他们生产什么一致，又和他们怎样生产一致。因而，个人是什么样的，这取决于他们进行生产的物质条件。</p><p>这种生产第一次是随着人口的增长而开始的。而生产本身又是以个人之间的交往为前提的。这种交往的形式又是由生产决定的。</p><p>各民族之间的相互关系取决于每一个民族的生产力、分工和内部交往的发展程度。这个原理是公认的。然而不仅一个民族与其他民族的关系，而且一个民族本身的整个内部结构都取决于它的生产以及内部和外部的交往的发展程度。一个民族的生产力发展的水平，最明显地表现在该民族分工的发展程度上。任何新的生产力都会引起分工的进一步发展，因为它不仅仅是现有生产力的量的增加（例如开垦新的土地）</p><blockquote><p>民族间，民族内社会关系，都取决于生产力和分工。</p></blockquote><p>某一民族内部的分工，首先引起工商业劳动和农业劳动的分离，从而也引起城乡的分离和城乡利益的对立。分工的进一步发展导致商业劳动和工业劳动的分离。同时，由于这些不同部门内部的分工，在某一劳动部门共同劳动的个人之间的分工也愈来愈细致了。</p><p>分工发展的各个不同阶段，同时也就是所有制的各种不同形式。这就是说，分工的每一个阶段还根据个人与劳动的材料、工具和产品的关系决定他们相互之间的关系。</p><blockquote><p>分工的发展就是所有制的发展。</p></blockquote><ul><li><p>部落所有制，分工还很不发达，仅限于家庭中现有的自然产生的分工的进一步扩大。因此，社会结构只局限于家庭的扩大。</p></li><li><p>古代公社所有制和国家所有制，几个部落通过契约或征服联合为一个城市。仍然保存着奴隶制。除公社所有制以外，动产的私有制以及后来不动产的私有制已经开始发展起来。分工已经比较发达。城乡之间的对立已经产生，国家之间的对立也相继出现。这些国家当中有一些代表城市利益，另一些则代表乡村利益。在城市内部存在着工业和海外贸易之间的对立。公民和奴隶之间的阶级关系已经充分发展。</p></li><li><p>封建的或等级的所有制，古代的起点是城市及其狭小的领地。而中世纪的起点则是乡村。这种所有制与部落所有制和公社所有制一样，也是以某种共同体为基础的。但是作为直接进行生产的阶级而与这种共同体对立的，已经不是古代世界的奴隶，而是小农奴。土地占有的等级结构以及与之有关的武装扈从制度使贵族掌握了支配农奴的权力。这种封建结构同古代的公社所有制一样，是一种联合，其目的在于对付被统治的生产阶级，只是联合的形式和对于直接生产者的关系有所不同，因为出现了不同的生产条件。</p><p>在城市中和这种封建的土地占有结构相适应的是行会所有制，即手工业的封建组织。个别手工业者逐渐积蓄起来的少量资本及其与不断增长的人口比较起来是固定的人数，使得帮工和学徒制度发展起来了，而这种制度在城市里产生了一种和农村等级制相似的等级制。</p></li></ul><p>这样，封建时代的所有制的主要形式，一方面是地产和束缚于地产上的农奴劳动，另一方面是拥有少量资本并支配着帮工劳动的自身劳动。</p><p>比较广大的地区联合为封建王国，无论对于土地贵族或城市说来，都是一种需要。因此领导统治阶级组织即贵族组织的到处都是君主。</p><p>由此可见，事情是这样的：以一定的方式进行生产活动的一定的个人，发生一定的社会关系和政治关系。</p><p>社会结构和国家经常是从一定个人的生活过程中产生的。但这里所说的个人不是他们自己或别人想像中的那种个人，而是现实中的个人，也就是说，这些个人是从事活动的，进行物质生产的，因而是在一定的物质的、不受他们任意支配的界限、前提和条件下能动地表现自己的。</p><p>意识在任何时候都只能是被意识到了的存在，而人们的存在就是他们的实际生活过程。</p><p>德国哲学从天上降到地上；和它完全相反，这里我们是从地上升到天上，就是说，我们不是从人们所说的、所想像的、所设想的东西出发，也不是从只存在于口头上所说的、思考出来的、想像出来的、设想出来的人出发，去理解真正的人。我们的出发点是从事实际活动的人，而且从他们的现实生活过程中我们还可以揭示出这一生活过程在意识形态上的反射和回声的发展。</p><p>因此，道德、宗教、形而上学和其他意识形态，以及与它们相适应的意识形式便失去独立性的外观。它们没有历史，没有发展；那些发展着自己的物质生产和物质交往的人们，在改变自己的这个现实的同时也改变着自己的思维和思维的产物。不是意识决定生活，而是生活决定意识。前一种观察方法从意识出发，把意识看作是有生命的个人。符合实际生活的第二种观察方法则是从现实的、有生命的个人本身出发，把意识仅仅看作是他们的意识。</p><blockquote><p>一句话：物质决定意识.</p></blockquote><p>对现实的描述会使独立的哲学失去生存环境，能够取而代之的充其量不过是从对人类历史发展的观察中抽象出来的最一般的结果的综合。</p><blockquote><p>我们所提出的不过是一些“抽象”。这些抽象，不同于哲学，是不提供适用于各个历史时代的药方或公式的。在整理资料的时候，困难就开始出现，解决困难的前提只能从对每个时代的个人实际生活和活动的研究中得到。</p><p>具体时代的生活，具体分析。</p></blockquote><blockquote><p>下面是一些同德意志意识形态，那种空中楼阁式的历史观，所相对的“抽象”</p></blockquote><h5 id="【1】历史"><a href="#【1】历史" class="headerlink" title="【1】历史"></a>【1】历史</h5><p>一切人类生存的第一个前提也就是一切历史的第一个前提，这个前提就是：人们为了能够“创造历史”，必须能够生活。</p><p>但是为了生活，首先就需要衣、食、住以及其他东西。因此第一个历史活动就是生产满足这些需要的资料，即生产物质生活本身。</p><blockquote><p>生产物质生活是一切历史的基本条件。</p></blockquote><p>德国人从来没有这样做过，所以他们从来没有为历史提供世俗基础，因而也从来没有过一个历史学家。法国人和英国人尽管对这一事实同所谓的历史的联系了解得非常片面（特别因为他们受政治思想的束缚），但毕竟作了一些给历史编纂学提供唯物主义基础的初步尝试，首次写出了市民社会史、商业史和工业史。</p><p>已经得到满足的第一个需要本身、满足需要的活动和已经获得的为满足需要用的工具又引起新的需要。这种新的需要的产生是第一个历史活动。</p><p>德国人认为凡是在他们缺乏实证材料的地方，凡是在神学、政治和文学的缪论不能立足的地方，就没有任何历史，那里只有“史前时期”……他们的历史思辨所以特别热衷于这个“史前历史”，是因为他们认为在这里他们不会受到“粗暴事实”的干预，而且还可以让他们的思辨欲望得到充分的自由，创立和推翻成千成万的假说。</p><p>一开始就纳入历史发展过程的第三种关系就是：每日都在重新生产自己生活的人们开始生产另外一些人，即增殖。这就是夫妻之间的关系，父母和子女之间的关系，也就是家庭。这个家庭起初是唯一的社会关系，后来，当需要的增长产生了新的社会关系，而人口的增多又产生了新的需要的时候，家庭便成为（德国除外）从属的关系了。</p><p>但是人并非一开始就具有“纯粹的”意识。“精神”从一开始就很倒霉，法定要受物质的“纠缠”，物质在这里表现为震动着的空气层、声音，简言之，即语言。语言和意识具有同样长久的历史；语言是一种实践的、既为别人存在并仅仅因此也为我自己存在的、现实的意识。语言也和意识一样，只是由于需要，由于和他人交往的迫切需要才产生的②。凡是有某种关系存在的地方，这种关系都是为我而存在的；动物不对什么东西发生“关系”，而且根本没有“关系”；对于动物说来，它对他物的关系不是作为关系存在的。</p><p>因而，意识一开始就是社会的产物，而且只要人们还存在着，它就仍然是这种产物。</p><p>但是，另一方面，意识到必须和周围的人们来往，也就是开始意识到人一般地是生活在社会中的。这个开始和这个阶段上的社会生活本身一样，带有同样的动物性质；这是纯粹畜群的意识，这里人和绵羊不同的地方只是在于：意识代替了他的本能，或者说他的本能是被意识到了的本能。</p><p>分工起初只是性交方面的分工，后来是由于天赋（例如体力）、需要、偶然性等等而自发地或“自然地产生的”分工。分工只是从物质劳动和精神劳动分离的时候起才开始成为真实的分工①。</p><p>从这时候起意识才能真实地这样想像：它是同对现存实践的意识不同的某种其他的东西；它不想像某种真实的东西而能够真实地想像某种东西。从这时候起，意识才能摆脱世界而去构造“纯粹的”理论、神学、哲学、道德等等。但是，如果这种理论、神学、哲学、道德等等和现存的关系发生矛盾，那末，这仅仅是因为现存的社会关系和现存的生产力发生了矛盾。</p><p>我们从这一大堆赘述中只能得出一个结论，那就是，上述三个因素—— 生产力、社会状况和意识—— 彼此之间可能而且一定会发生矛盾，因为分工不仅使物质活动和精神活动、享受和劳动、生产和消费由各种不同的人来分担这种情况成为可能，而且成为现实。要使这三个因素彼此不发生矛盾，只有消灭分工。</p><p>与这种分工同时出现的还有分配，而且是劳动及其产品的不平等的分配（无论在数量上或质量上）；因而也产生了所有制，它的萌芽和原始形态在家庭中已经出现，在那里妻子和孩子是丈夫的奴隶。</p><p>……即所有制是对他人劳动力的支配。其实，分工和私有制是两个同义语，讲的是同一件事情，一个是就活动而言，另一个是就活动的产品而言。</p><blockquote><p>下面这段隐隐地引出了异化的话题。</p></blockquote><p>最后，分工还给我们提供了第一个例证，说明只要人们还处在自发地形成的社会中，也就是说，只要私人利益和公共利益之间还有分裂，也就是说，只要分工还不是出于自愿，而是自发的，那末人本身的活动对人说来就成为一种异己的、与他对立的力量，这种力量驱使着人，而不是人驾驭着这种力量。原来，当分工一出现之后，每个人就有了自己一定的特殊的活动范围，这个范围是强加于他的，他不能超出这个范围：他是一个猎人、渔夫或牧人，或者是一个批判的批判者，只要他不想失去生活资料，他就始终应该是这样的人。而在共产主义社会里，任何人都没有特定的活动范围，每个人都可以在任何部门内发展，社会调节着整个生产，因而使我有可能随我自己的心愿今天干这事，明天干那事，上午打猎，下午捕鱼，傍晚从事畜牧，晚饭后从事批判，但并不因此就使我成为一个猎人、渔夫、牧人或批判者。社会活动的这种固定化，我们本身的产物聚合为一种统治我们的、不受我们控制的、与我们愿望背道而驰的并抹煞我们的打算的物质力量，这是过去历史发展的主要因素之一。</p><blockquote><p>国家是一个妥协的结果</p></blockquote><p>正是由于私人利益和公共利益之间的这种矛盾，公共利益才以国家的姿态而采取一种和实际利益（不论是单个的还是共同的）脱离的独立形式，也就是说采取一种虚幻的共同体的形式。</p><blockquote><p>而又有现实的支持的土壤</p></blockquote><p>然而这始终是在每一个家庭或部落集团中现有的骨肉联系、语言联系、较大规模的分工联系以及其他利害关系的现实基础上，特别是在我们以后将要证明的各阶级利益的基础上发生的。</p><p>由此可见，国家内部的一切斗争—— 民主政体、贵族政体和君主政体相互之间的斗争，争取选举权的斗争等等，不过是一些虚幻的形式，在这些形式下进行着各个不同阶级间的真正的斗争。</p><p>从这里还可以看出，每一个力图取得统治的阶级，如果它的统治就像无产阶级的统治那样，预定要消灭整个旧的社会形态和一切统治，都必须首先夺取政权，以便把自己的利益说成是普遍的利益，而这是它在初期不得不如此做的。</p><blockquote><p>个人追求的是特殊利益，并以真正地反对共同利益和虚幻的共同利益进行实际斗争，国家则以虚幻的“普遍”利益对特殊利益进行实际的干涉。</p></blockquote><blockquote><p>缩句：生产力不是不同个人自身的联合力量，而是异己的权力，并支配了人们的意志和行为。</p></blockquote><p>受分工制约的不同个人的共同活动产生了一种社会力量，即扩大了的生产力。由于共同活动本身不是自愿地而是自发地形成的，因此这种社会力量在这些个人看来就不是他们自身的联合力量，而是某种异己的、在他们之外的权力。关于这种权力的起源和发展趋向，他们一点也不了解；因而他们就不再能驾驭这种力量，相反地，这种力量现在却经历着一系列独特的、不仅不以人们的意志和行为为转移的，反而支配着人们的意志和行为的发展阶段。</p><blockquote><p>生产力作为一种社会力量，拥有的这样的表现，就叫做异化。</p></blockquote><p>要使这种异化成为一种“不堪忍受的”力量，即成为革命所要反对的力量，就必须</p><ul><li>让它把人类的大多数变成完全“没有财产的”人</li><li>同时这些人又和现存的有钱的有教养的世界相对立</li></ul><p>而这两个条件都是以生产力的巨大增长和高度发展为前提的。</p><p>另一方面，生产力的这种发展（随着这种发展，人们的世界历史性的而不是狭隘地域性的存在已经是经验的存在了）之所以是绝对必需的实际前提，还因为如果没有这种发展，那就只会有贫穷的普遍化；而在极端贫困的情况下，就必须重新开始争取必需品的斗争，也就是说，全部陈腐的东西又要死灰复燃。其次，这种发展之所以是必需的前提，还因为：只有随着生产力的这种普遍发展，人们之间的普遍交往才能建立起来；由于普遍的交往，一方面，可以发现在一切民族中同时都存在着“没有财产的”群众这一事实（普遍竞争），而其中每一民族同其他民族的变革都有依存关系；最后，狭隘地域性的个人为世界历史性的、真正普遍的个人所代替。</p><blockquote><p>人作为一种经验的“世界的历史性的存在”的重要性。</p></blockquote><p>不这样，</p><p>（１）共产主义就只能作为某种地域性的东西而存在；</p><p>（２）交往的力量本身就不可能发展成为一种普遍的因而是不堪忍受的力量：它们会依然处于家庭的、笼罩着迷信气氛的“境地”；</p><p>（３）交往的任何扩大都会消灭地域性的共产主义。共产主义只有作为占统治地位的各民族“立即”同时发生的行动才可能是经验的，而这是以生产力的普遍发展和与此有关的世界交往的普遍发展为前提的。</p><p>共产主义对我们说来不是应当确立的状况，不是现实应当与之相适应的理想。我们所称为共产主义的是那种消灭现存状况的现实的运动。</p><p>在过去一切历史阶段上受生产力所制约、同时也制约生产力的交往形式，就是市民社会。这个社会（从前面已经可以这样判定）是以简单的家庭和复杂的家庭，即所谓部落生活作为自己的前提和基础的。</p><p>从这里已经可以看出，这个市民社会是全部历史的真正发源地和舞台，可以看出过去那种轻视现实关系而只看到元首和国家的丰功伟绩的历史观何等荒谬。</p><p>市民社会包括各个个人在生产力发展的一定阶段上的一切物质交往。它包括该阶段上的整个商业生活和工业生活，因此它超出了国家和民族的范围，尽管另一方面它对外仍然需要以民族的姿态出现，对内仍然需要组成国家的形式。“市民社会”这一用语是在１８世纪产生的，当时财产关系已经摆脱了古代的和中世纪的共同体。真正的资产阶级社会只是随同资产阶级发展起来的；但是这一名称②始终标志着直接从生产和交往中发展起来的社会组织，这种社会组织在一切时代都构成国家的基础以及任何其他的观念的上层建筑的基础。</p><h5 id="【2】关于意识的生产"><a href="#【2】关于意识的生产" class="headerlink" title="【2】关于意识的生产"></a>【2】关于意识的生产</h5><p>单独的个人随着他们的活动扩大为世界历史性的活动，愈来愈受到异己力量的支配（他们把这种压迫想像为所谓宇宙精神等等的圈套），受到日益扩大的、归根到底表现为世界市场的力量的支配；这种情况在过去的历史中也绝对是经验的事实。</p><p>各个个人的全面的依存关系、他们的这种自发形成的世界历史性的共同活动的形式，由于共产主义革命而转化为对那些异己力量的控制和自觉的驾驭，这些力量本来是由人们的相互作用所产生的，但是对他们说来却一直是一种异己的、统治着他们的力量。</p><blockquote><p>主要就是注意“作为主体的社会”，一种社会意识成为异己的力量对人进行了统治。</p></blockquote><p>这种观点仍然可以被思辨地、唯心地、即幻想地解释为“类的自我产生”（“作为主体的社会”），把所有前后相继、彼此相联的个人设想为从事自我产生这种神秘活动的唯一的个人。这里很明显，尽管人们在肉体上和精神上互相创造着，但是他们并不像圣布鲁诺胡说的那样，或者像“唯一者”、“被创造的”人那样创造自己本身。</p><blockquote><p>还并没有发展到神棍的地步。</p></blockquote><p>由此可见，这种历史观就在于：从直接生活的物质生产出发来考察现实的生产过程，并把与该生产方式相联系的、它所产生的交往形式，即各个不同阶段上的市民社会，理解为整个历史的基础；然后必须在国家生活的范围内描述市民社会的活动，同时从市民社会出发来阐明各种不同的理论产物和意识形式，如宗教、哲学、道德等等，并在这个基础上追溯它们产生的过程。这样做当然就能够完整地描述全部过程（因而也就能够描述这个过程的各个不同方面之间的相互作用）了。</p><p>这种历史观和唯心主义历史观不同，它不是在每个时代中寻找某种范畴，而是始终站在现实历史的基础上，不是从观念出发来解释实践，而是从物质实践出发来解释观念的东西。</p><p>……而只有实际地推翻这一切唯心主义谬论所由产生的现实的社会关系，才能把它们消灭；历史的动力以及宗教、哲学和任何其他理论的动力是革命，而不是批判。</p><p>印度人和埃及人借以实现分工的原始形态在这些民族的国家和宗教中产生了等级制度，所以历史家便认为似乎等级制度是产生这种原始社会形态的力量。法国人和英国人至少抱着一种毕竟是同现实最接近的政治幻想，而德国人却在“纯粹精神”的领域中兜圈子，把宗教幻想推崇为历史的动力。在德国历史编纂学看来，问题完全不在于现实的利益，甚至不在于政治的利益，而在于纯粹的思想。</p><p>正如上面所说的，要真正地、实际地消灭这些词句，要从人们的意识中消除这些观念，只有靠改变条件，而不是靠理论上的演绎。对于人民大众、即无产阶级来说，这些理论观念是不存在的，因而也就用不着去消灭它们。如果这些群众在某个时候有过某些理论观念，如宗教，那末这些观念也早已被环境所消灭了。</p><p>这也是费尔巴哈和我们的敌人的共同之点。费尔巴哈在这些地方证明：某物或某人的存在同时也就是某物或某人的本质；一个动物或一个人的一定生存条件、生活方式和活动，就是使这个动物或人的“本质”感到满足的东西。任何例外在这里都被肯定地看作是不幸事件，是不能改变的反常现象。</p><p>这样说来，如果千百万无产者根本不满足于他们的生活条件，如果他们的“存在”同他们的……相矛盾……</p><p>在对感性世界的直观中，他不可避免地碰到与他的意识和感觉相矛盾的东西，这些东西破坏着他所假定的感性世界一切部分的和谐，特别是人与自然界的和谐②。为了消灭这个障碍，他不得不求助于某种二重性的直观，这种直观介于仅仅看到“眼前”的东西的普通直观和看出事物的“真正本质”的高级的哲学直观之间。</p><p>他没有看到，他周围的感性世界决不是某种开天辟地以来就已存在的、始终如一的东西，而是工业和社会状况的产物，是历史的产物，是世世代代活动的结果，其中每一代都在前一代所达到的基础上继续发展前一代的工业和交往方式，并随着需要的改变而改变它的社会制度。甚至连最简单的“可靠的感性”的对象也只是由于社会发展、由于工业和商业往来才提供给他的。</p><p>大家知道，樱桃树和几乎所有的果树一样，只是在数世纪以前依靠商业的结果才在我们这个地区出现。由此可见，樱桃树只是依靠一定的社会在一定时期的这种活动才为费尔巴哈的“可靠的感性”所感知。</p><p>诚然，费尔巴哈比“纯粹的”唯物主义者有巨大的优越性：他也承认人是“感性的对象”。但是，毋庸讳言，他把人只看作是“感性的对象”，而不是“感性的活动”，因为他在这里也仍然停留在理论的领域内，而没有从人们现有的社会联系，从那些使人们成为现在这种样子的周围生活条件来观察人们。</p><blockquote><p>只停留在抽象的人。仅仅限于在感情范围内承认“现实的、单独的、肉体的人”。没有发现其他的“人的关系”。</p></blockquote><p>然而，事情被思辨地颠倒成这样：好像后一个时期历史乃是前一个时期历史的目的，例如，好像美洲的发现的根本目的就是要引起法国革命。因此，历史便具有其特殊的目的并成为某个与“其他人物并列的人物”（如像“自我意识”、“批判”、“唯一者”等等）。其实，以往历史的“使命”、“目的”、“萌芽”、“观念”等词所表明的东西，无非是从后来历史中得出的抽象，无非是从先前历史对后来历史发生的积极影响中得出的抽象。</p><p>……历史就在愈来愈大的程度上成为全世界的历史。例如，如果在英国发明了一种机器，它夺走了印度和中国的千千万万工人的饭碗，并引起这些国家的整个生存形式的改变，那末，这个发明便成为一个世界历史性的事实。</p><p>例如，在某一国家里，某个时期王权、贵族和资产阶级争夺统治，因而，在那里统治是分享的，那里占统治地位的思想就会是关于分权的学说，人们把分权当作“永恒的规律”来谈论。</p><p>如果完全不考虑这些思想的基础—— 个人和历史环境，那就可以这样说：例如，在贵族统治时期占统治地位的是忠诚信义等等概念，而在资产阶级统治时期占统治地位的则是自由平等等等概念。总之，统治阶级自己为自己编造出诸如此类的幻想。所有历史学家（主要是１８世纪以来的）所固有的这种历史观必然会碰到这样一种现象：占统治地位的将是愈来愈抽象的思想，即愈来愈具有普遍性形式的思想。</p><p>事情是这样的，每一个企图代替旧统治阶级的地位的新阶级，就是为了达到自己的目的而不得不把自己的利益说成是社会全体成员的共同利益，抽象地讲，就是赋予自己的思想以普遍性的形式，把它们描绘成唯一合理的、有普遍意义的思想。</p><p>由此可见，每一个新阶级赖以建立自己统治的基础，比它以前的统治阶级所依赖的基础要宽广一些；可是后来，非统治阶级和取得统治的阶级之间的对立也发展得更尖锐和更深刻。</p><p>黑格尔本人在“历史哲学”１４的结尾承认，“他所考察的仅仅是概念的前进运动”，他在历史方面描述了“真正的神正论”（第４４６页）。在这之后，又可以重新回复到“概念”的生产者，回复到理论家、思想家和哲学家，并做出结论说：哲学家、思想家自古以来就是在历史上占统治地位的。这个结论，如我们所看到的，早就由黑格尔表述过了。</p><p>这样，根据历史材料来证明精神的最高些治（施蒂纳的教阶制）的全部戏法，可以归结为以下三个手段：</p><p>第一，必须把统治的个人—— 而且是由于种种经验的根据、在经验条件下和作为物质的个人进行统治的个人—— 的思想同这些统治的个人本身分割开来，从而承认思想和幻想在历史上的统治。</p><p>第二，必须使这种思想统治具有某种秩序，必须证明，在一个承继着另一个的统治思想之间存在着某种神秘的联系。达到这一点 的办法是：把这些思想看作是“概念的自我规定”（所以能这样做，是因为这些思想由于它们都有经验的基础而彼此确实是联系在一起的，还因为它们既被仅仅当作思想来看待，因而就变成自我区别，变成由思维产生的区别）。<br>第三，为了消除这种“自我规定着的概念”的神秘的外观，便把它变成某种人物——“自我意识”；或者，为了表明自己是真正的唯物主义者，又把它变成在历史上代表着“概念”的许多人物——“思维着的人”、“哲学家”、思想家，而这些人又被规定为历史的创造者、“监护人会议”、统治者①。这样一来，就把一切唯物主义的因素从历史上消除了，于是就可以放心地解开缰绳，让自己的思辨之马自由奔驰了。</p><h4 id="B-意识形态的现实基础"><a href="#B-意识形态的现实基础" class="headerlink" title="B. 意识形态的现实基础"></a>B. 意识形态的现实基础</h4><h5 id="【1】交往和生产力"><a href="#【1】交往和生产力" class="headerlink" title="【1】交往和生产力"></a>【1】交往和生产力</h5><p>物质劳动和精神劳动的最大的一次分工，就是城市和乡村的分离。城乡之间的对立是随着野蛮向文明的过渡、部落制度向国家的过渡、地方局限性向民族的过渡而开始的，它贯穿着全部文明的历史并一直延续到现在。</p><p>随着城市的出现也就需要有行政机关、警察、赋税等等，一句话，就是需要有公共的政治机构，也就是说需要一般政治。在这里居民第一次划分为两大阶级，这种划分直接以分工和生产工具为基础。城市本身表明了人口、生产工具、资本、享乐和需求的集中；而在乡村里所看到的却是完全相反的情况：孤立和分散。</p><p>城市和乡村的分离还可以看作是资本和地产的分离，看作是资本不依赖于地产而存在和发展的开始，也就是仅仅以劳动和交换为基础的所有制的开始。</p><blockquote><p>行会 师傅 帮工 日工（平民） 农奴逃入城市</p></blockquote><p>分工的进一步扩大表现为商业和生产的分离，表现为特殊的商人阶级的形成。…….这样就产生了同附近地区以外的地区建立贸易联系的可能，这种可能之变为现实，取决于现有的交通工具的情况，取决于由政治关系所决定的沿途社会治安状况（大家知道，整个中世纪，商人都是结成武装商队行动的）以及取决于交往所及地区内由相应的文明程度所决定的需求的发展程度。</p><p>城市彼此发生了联系，新的劳动工具从一个城市运往另一个城市，生产和商业间的分工随即引起了各城市间在生产上的新的分工，在每一个城市中都有自己的特殊的工业部门占着优势。最初的地域局限性开始逐渐消失</p><blockquote><p>市民保卫生活，反对农村贵族；商业和交通带来城市间交往，捍卫同样的利益而缓慢地产生出市民阶级。</p></blockquote><p>市民创造了这些条件，因为他们脱离了封建联系；同时他们又是由这些条件所创造的，因为他们是由自己同既存封建主义的对立所制约的。随着各城市间的联系的产生，这些对他们来说都是共同的条件发展为阶级条件。</p><p>同样的条件、同样的对立、同样的利益，一般说来也就应当在一切地方产生同样的风俗习惯。</p><p>资产阶级本身只是逐渐地、随同自己的生存条件一起发展起来的，同时它又由于分工关系重新分裂为各种不同的集团，最后随着一切现有财产被变为工业资本或商业资本，它吞并了在它以前存在过的一切有产阶级（同时资产阶级把原先没有财产的阶级的大部分和原先有财产的阶级的一部分变为新的阶级——无产阶级）。单独的个人所以组成阶级只是因为他们必须进行共同的斗争来反对某一另外的阶级；在其他方面，他们本身就是相互敌对的竞争者。另一方面，阶级对各个人来说又是独立的，因此各个人可以看到自己的生活条件是早已确定了的：阶级决定他们的生活状况，同时也决定他们的个人命运，使他们受它支配。这和个人屈从于分工是同类的现象，这种现象只有通过消灭私有制和消灭劳动本身才能消除。</p><blockquote><p>“消灭劳动”（Aufhebung der Arbeit）这种说法在这里是什么意思，请参看</p></blockquote><blockquote><p>织布的手工业工场是第一个产生的。它与行会的束缚是对立的。资本开始积聚。</p></blockquote><p>随着摆脱了行会束缚的工场手工业的出现，所有制关系也立即发生了变化。离开自然形成的等级资本向前走的第一步是受商人的出现所制约的，商人的资本一开始就是活动的，是现代意义上的资本。向前走的第二步是工场手工业的出现，工场手工业又动员了大量自然形成的资本，并且同自然形成的资本的数量比较起来，一般是增加了活动资本的数量。</p><p>随着工场手工业的出现，工人和雇主的关系也发生了变化。在行会中，帮工和师傅之间存在着一种宗法关系，而在工场手工业中，这种关系由工人和资本家之间的金钱关系代替了。</p><p>商业和工场手工业产生了大资产阶级，而集中在行会里的是小资产阶级，现在它和过去不同，在城市里已经不占统治地位了，而且还必须屈从于大商人和手工工场主的统治①。由此可见，行会一跟工场手工业接触，就衰落下去了。</p><p>对工场手工业经常采用种种的保护办法：在国内市场上实行保护关税，在殖民地市场上实行垄断，而在国外市场上则实行差别关税。……只要在稍微有利的条件下，工场手工业就可以很容易地在某个国家建立起来，正因为这样，它也很容易被破坏。此外，它的经营方法，特别是１８世纪在乡村里的经营方法，使它和广大群众的生活方式结合在一起，以致没有一个国家敢于不顾工场手工业的生存而允许自由竞争。因而工场手工业，在它能够输出自己的产品的时候，是完全依赖于贸易的扩展或收缩的，而它对贸易的反作用却是比较微小的。</p><p>大工业通过普遍的竞争迫使所有人的全部精力极度紧张起来。只要可能，它就消灭意识形态、宗教、道德等等，而当它不能做到这一点时，它就把它们变成赤裸裸的谎言。</p><p>它使自然科学从属于资本，并使分工丧失了自然性质的最后一点痕迹。它把自然形成的关系一概消灭掉（只要这一点在劳动范围内可能做到的话）；它把这些关系变成金钱的关系。</p><p>大工业到处造成了社会各阶级间大致相同的关系，从而消灭了各民族的特殊性。最后，当每一民族的资产阶级还保持着它的特殊的民族利益的时候，大工业却创造了这样一个阶级，这个阶级在所有的民族中都具有同样的利益，在它那里民族独特性已经消灭，这是一个真正同整个旧世界脱离并与之对立的阶级。大工业不仅使工人与资本家的关系，而且使劳动本身都成为工人所不堪忍受的东西。</p><p>当然，在一个国家里，大工业不是在一切地方都达到了同样的发展水平。但这并不能阻碍无产阶级的阶级运动：大工业所产生的那个无产者阶层走在这个运动的前面，并引导着所有其余的群众，而没有卷入大工业的工人，则由于大工业的过错而处于比在大工业中做工的工人更糟的生活境遇中。同样，大工业发达的国家也〔或多或少〕影响着非工业国家，因为非工业国家由于世界贸易而被卷入普遍竞争的斗争中①。</p><h5 id="【2】国家和法同所有制的关系"><a href="#【2】国家和法同所有制的关系" class="headerlink" title="【2】国家和法同所有制的关系"></a>【2】国家和法同所有制的关系</h5><p>起源于中世纪的民族那里，部落所有制先经过了几个不同的阶段—— 封建地产，同业公会的动产，工场手工业资本—— 然后才变为由大工业和普遍竞争所产生的现代资本，即变成抛弃了共同体的一切外观并消除了国家对财产发展的任何影响的纯粹私有制。</p><p>现代国家是与这种现代私有制相适应的。现代国家由于捐税逐渐被私有者所操纵，并由于借国债而完全为他们所控制；这种国家的命运既受到交易所中国家债券行市涨落的调节，所以它完全取决于私有者即资产者提供给它的商业信贷。由于资产阶级已经不再是一个等级，而是一个阶级了，因此它必须在全国范围内而不是在一个地区内组织起来，并且必须使自己通常的利益具有一种普遍的形式。</p><p>由于私有制摆脱了共同体，国家获得了和市民社会并列的并且在市民社会之外的独立存在；实际上国家不外是资产者为了在国内外相互保障自己的财产和利益所必然要采取的一种组织形式。</p><p>在私法中，现存的所有制关系表现为普遍意志的结果。仅仅ｊｕｓ ｕｔｅｎｄｉ ｅｔ ａｂｕｔｅｎｄｉ〔使用和滥用的权利〕②就一方面表明私有制已经完全不依赖于共同体，另一方面表明了一个幻想，仿佛私有制本身仅仅是以个人意志，即以对物的任意支配为基础的。</p><p>每当工业和商业的发展创造出新的交往形式，例如保险公司等等的时候，法便不得不承认它们是获得财产的新方式。</p><h5 id="【3】自然产生的和由文明创造的生产工具与所有制形式"><a href="#【3】自然产生的和由文明创造的生产工具与所有制形式" class="headerlink" title="【3】自然产生的和由文明创造的生产工具与所有制形式"></a>【3】自然产生的和由文明创造的生产工具与所有制形式</h5><p>因而这里出现了自然产生的生产工具和由文明创造的生产工具之间的差异。耕地（水等等）可以看作是自然产生的生产工具。在前一种情况下，即在自然产生的生产工具的情况下，各个个人受自然界的支配，在后一种情况下，他们则受劳动产品的支配。在前一种情况下，财产（地产）也表现为直接的、自然产生的统治，而在后一种情况下，则表现为劳动的统治，特别是积累起来的劳动即资本的统治。</p><blockquote><p>货币作为一种统治手段</p></blockquote><p>在前一种情况下，所有者可以依靠个人关系，依靠这种或那种形式的共同体来统治非所有者；在后一种情况下这种统治必须采取物的形式，通过某种第三者，即通过<strong>货币</strong>。</p><p>在大工业中，生产工具和私有制之间的矛盾才第一次作为大工业所产生的结果表现出来；这种矛盾只有在大工业高度发达的情况下才会产生。因此，只有在大工业的条件下才有可能消灭私有制。</p><p>因此，这里显露出两个事实①。第一，生产力表现为一种完全不依赖于各个个人并与他们分离的东西，……他们同生产力和自身存在还保持着的唯一联系，即劳动，在他们那里已经失去了任何自主活动的假象，它只是用摧残生命的东西来维持他们的生命。而在过去，<strong>自主活动</strong>和<strong>物质生活的生产</strong>是分开的，这是因为它们是不同人的命运，同时物质生活的生产，由于个人本身的局限性，还被认为是自主活动的次要形式，—— 现在它们互相分离竟达到这般地步，……</p><p>……占有就必须带有适应生产力和交往的普遍性质。</p><blockquote><p>所有制所具有的性质与生产力和交往的现实相适应</p></blockquote><p>对这些力量的占有本身不外是同物质生产工具相适应的个人才能的发挥。仅仅因为这个缘故，对生产工具的一定总和的占有，也就是个人本身的才能的一定总和的发挥。</p><p>其次，占有还受实现占有所必须采取的方式的制约。占有只有通过联合才能得到实现，由于无产阶级所固有的本性，这种联合只能是普遍性的，而且占有也只有通过革命才能得到实现。</p><p>只有在这个阶段上，自主活动才同物质生活一致起来，而这点又是同个人向完整的个人的发展以及一切自发性的消除相适应的。同样，劳动转化为自主活动，同过去的被迫交往转化为所有个人作为真正个人参加的交往，也是相互适应的。</p><blockquote><p>大工业生产促成了联合起来的个人，创造了联合起来的个人对全部生产力总和的占有，消灭私有制。意指过去的生产组织形式并没有带来革命的土壤。在下面也有批评。</p></blockquote><p>哲学家们在已经不再屈从于分工的个人身上看见了他们名之为“人”的那种理想，他们把我们所描绘的整个发展过程看作是“人”的发展过程，而且他们用这个“人”来代替过去每一历史时代中所存在的个人，并把他描绘成历史的动力。这样，整个历史过程被看成是“人”的自我异化过程，实际上这是因为，他们总是用后来阶段的普通人来代替过去阶段的人并赋予过去的个人以后来的意识。由于这种本末倒置的做法，<strong>即由于公然舍弃实际条件</strong>，于是就可以把整个历史变成意识发展的过程了。</p><blockquote><p>革命与自我革命</p></blockquote><p>无论为了使这种共产主义意识普遍地产生还是为了达到目的本身，都必须使人们普遍地发生变化，这种变化只有在实际运动中，在革命中才有可能实现；因此革命之所以必需，不仅是因为没有任何其他的办法能推翻统治阶级，而且还因为推翻统治阶级的那个阶级，只有在革命中才能抛掉自己身上的一切陈旧的肮脏东西，才能建立社会的新基础③。</p><h4 id="C-共产主义。——交往形式本身的生产"><a href="#C-共产主义。——交往形式本身的生产" class="headerlink" title="C. 共产主义。——交往形式本身的生产"></a>C. 共产主义。——交往形式本身的生产</h4><blockquote><p>这似乎是对共产主义在下一个定义。</p></blockquote><p>…….上述矛盾产生以前，个人之间进行交往的条件是与他们的个性相适应的条件，这些条件对于他们说来不是什么外部的东西；它们是这样一些条件，在这些条件下，生存于一定关系中的一定的个人只能生产自己的物质生活以及与这种物质生活有关的东西，因而它们是个人自主活动的条件，而且是由这种自主活动创造出来的①。……人们进行生产的一定条件是同他们的现实的局限状态和他们的片面存在相适应的，这种存在的片面性只是在矛盾产生时才表现出来，因而只是对于后代才存在的。这时人们才觉得这些条件是偶然的桎梏，并且把这种视上述条件为桎梏的观点也强加给过去的时代。</p><blockquote><p>省流：交往的条件与现实的状态相适应。交往的条件是自主活动的条件，并被自主活动创造出来。</p></blockquote><p>已成为桎梏的旧的交往形式被适应于比较发达的生产力，因而也适应于更进步的个人自主活动类型的新的交往形式所代替。</p><p>而且较早时期的利益，在与之相适应的交往形式已经为适应于较晚时期的利益的交往形式所排挤之后，仍然在长时间内拥有一种表现为与个人隔离的虚幻共同体（国家、法）的传统权力，这种权力归根结底只有通过革命才能打倒。</p><p>这也就说明了：为什么在某些带有较大的概括性的问题上，意识有时似乎超过了当代的经验关系，因此人们在后来某个时代的斗争中可以指靠先前时代理论家的威望。</p><p>最后，无论什么地方，占领很快就面临结束之日，那时已经没有东西可供占领了，需要转向生产。从这种很快到来的生产的必要性中可以做出如下结论：定居下来的征服者所采纳的社会制度形式，应当适应于他们面临的生产力发展水平，如果起初没有这种适应，那末社会制度形式就应当按照生产力而发生变化。这也就说明了民族大迁移后的时期中到处都可见到的一件事实，即奴隶成了主人，征服者很快就学会了被征服民族的语言，接受了他们的教育和风俗。</p><p>一切历史冲突都根源于生产力和交往形式之间的矛盾。此外，对于其一国家内冲突的发生来说，完全没有必要等这种矛盾在这个国家本身中发展到极端的地步。由于同工业比较发达的国家进行广泛的国际交往所引起的竞争，就足以使工业比较不发达的国家内产生类似的矛盾（例如，英国工业的竞争使德国潜在的无产阶级显露出来了）。</p><p>过去的联合只是一种（决不像“社会契约”中所描绘的那样是任意的，而是必然的）关于这样一些条件的协定（参阅例如北美合众国和南美诸共和国的形成），在这些条件下，个人然后有可能利用偶然性为自己服务。这种在一定条件下无阻碍地享用偶然性的权利，迄今一直称为个人自由。而这些生存条件当然只是现存的生产力和交往形式。</p><blockquote><p>我称，过去的个人作为阶级的成员，他们的根本利益是分散的，是互有矛盾的，而那种联合仅仅是一种”协定“。而革命无产者的联合，是将根本利益的条件把握在自己的控制当中。</p></blockquote><p>注意。不要忘记，单是维持农奴存在的必要性和大经济的不可能性（它要求把ａｌｌｏｔｍｅｎｔｓ〔小块土地〕分给农奴），很快就使农奴对封建主的赋役降低到中等水平的代役租和徭役地租，这样就使农奴有可能积累一些动产，便于从他的领主那里里逃跑出来，并使他有可能去当市民，同时还引起了农奴的分化。可见逃亡农奴已经是半资产者了。由此也可以清楚地看到，掌握了某种手艺的农奴获得动产的可能性最大。</p><h2 id="第二卷-对各式各样先知所代表的德国社会主义的批判"><a href="#第二卷-对各式各样先知所代表的德国社会主义的批判" class="headerlink" title="第二卷 对各式各样先知所代表的德国社会主义的批判"></a>第二卷 对各式各样先知所代表的德国社会主义的批判</h2><h3 id="“真正的社会主义”"><a href="#“真正的社会主义”" class="headerlink" title="“真正的社会主义”"></a>“真正的社会主义”</h3><h3 id="一-“莱茵年鉴”或“真正的社会主义的哲学"><a href="#一-“莱茵年鉴”或“真正的社会主义的哲学" class="headerlink" title="一 “莱茵年鉴”或“真正的社会主义的哲学"></a>一 “莱茵年鉴”或“真正的社会主义的哲学</h3><h4 id="A-“共产主义、社会主义、人道主义”"><a href="#A-“共产主义、社会主义、人道主义”" class="headerlink" title="A. “共产主义、社会主义、人道主义”"></a>A. “共产主义、社会主义、人道主义”</h4><p>我们从这篇文章开始谈起，因为在这篇文章中十分自觉地、而且以强烈的自尊感表露出“真正的社会主义” 的德国民族性质。</p><blockquote><p>共产主义是法国的现象，社会主义是德国的现象；法国人的幸福在于，他们具有这样一种幸福的社会本能，他们用这种本能在任何一个时候都可以代替科学工作。这个结果是在两个民族的发展进程中预先确定了的。法国人通过政治走向共产主义〈当然，现在我们已经知道，法国人民是怎样走向共产主义的〉；德国人通过最后变成人类学的形而上学走向社会主义〈即走向“真正的社会主义”〉。共产主义和社会主义归根到底都消融在人道主义中了。</p></blockquote><p>把共产主义和社会主义变成了两种抽象的理论、两种原则以后，再给这两个对立面杜撰任何一种黑格尔式的统一，随便安上一个名称，当然是非常容易的事。这样做就不仅有可能洞悉“两个民族的发展进程”，而且有可能光辉地显示出一个醉心于思辨妙想的个人比法国人和德国人高明的地方。</p><p>这些“真正的社会主义者”对于法国人的一切责难就在于：法国人没有以费尔巴哈的哲学作为自己的整个运动的最高原则。我们的这位作者是以关于劳动和享乐之间的分裂这一现成的命题为依据的。但他不是从这个命题开始谈起，而是在思想上把问题倒转过来，一开始就说什么人没有意识，并由此作出了关于“对粗暴的物质的依赖”的推论，接着就强使这种依赖在“劳动和享乐之间的分裂”中得到实现。</p><p>外国人思考和行动是为了自己所处的时代，而德国人思考和行动却是为了永恒。我们这位“真正的社会主义者”把这种意见阐述如下：</p><blockquote><p> “共产主义在其标志着反对竞争的那个名称上就已经暴露出自己的片面性；虽然这种狭隘的见解作为党的称号现在也许还有意义，但是，难道它会永恒地继续下去吗？”</p></blockquote><p>我们这位作者在根本消灭了共产主义以后，就转而谈到它的对立面—— 社会主义。</p><blockquote><p>“社会主义实行无政府制度，这个制度是人类和宇宙的本质上独特的特性”（第１７０页），正因为如此，这个制度过去对“人类”说来是没有存在过的。</p></blockquote><p>自由竞争太 “粗暴” 了，所以我们这位 “真正的社会主义者” 没有宣布它是“无政府制度”</p><p>因此，这里所得出的因果关系可归结如下。无产者生存着并像机器一样地工作着：这是我们所看见的事实。但是，为什么无产者要“像机器一样地工作” 呢？因为食利者“让自己的固有本质腐化”。为什么食利者让自己的固有本质腐化呢？因为“现在我们这个社会如此野蛮化了”。而为什么它如此野蛮化了呢？请你们去问上帝。</p><p>他说，自由活动就是“不决定于我们之外的物”的活动；这就是说，自由活动是ａｃｔｕｓ ｐｕｒｕｓ，纯粹的抽象的活动， 只不过是活动的那种活动，而且，归根到底，它又被归结为“纯粹思维”的幻想。既然这种纯粹的活动有了物质的基质和物质的结果，那末这种活动当然是完全被玷污的了；“真正的社会主义 者”只是迫不得已才从事这种被玷污了的活动，所以他轻视这种活动的产物，称它不是“结果”，而 “只不过是人的糟粕”（第１６９ 页 ）。</p><p>我们的作者这样驳倒了共产主义和社会主义之后，就给我们揭示出两者的最高统一——人道主义。从这时起，我们进入了 “人”的境地，从此我们这个“真正的社会主义”的全部真正的历史就只在德国展开了。</p><p>我们很清楚，一小撮德国空谈家是断送不了共产主义运动的。但是，在像德国这样的国家里，许多世纪 以来哲学词句都占有一定的势力，这里没有其他民族所有的那种尖锐的阶级对立，而这种情况本来就削弱着共产主义意识的尖锐性和坚定性，在这样的国家中毕竟应当反对一切能够更加冲淡和削弱对于共产主义同现存秩序的充分对立性的认识的词句。</p><p>后面零星摘一点</p><blockquote><p>“人和自然界的斗争是以两极的对立、以 我 的 特 殊 生 命 和 自然界的普遍 生命的相互作用为基础的。当这一斗争表现为自觉活动的时候，就叫作劳 动。”（第１６４ 页 ）</p></blockquote><p>相反，如果说“两极的对立”的观念是以对人和自然界的斗争的观察为基础的，不是更正确吗 ？ 先从事实得出一个抽象概念，然后宣称这个事实是以这个抽象概念为基础的。这是给自己装上一副德国人的深思的和思辨的姿态的一种最便宜的方法。</p><p>在手稿中，没有“德意志意识形态”第二卷的第二章和第三章。 在遗留给我们的手稿中，有些地方已经受到了“老鼠的牙齿的批判”。这些根据句子的完整部分所恢复起来的地方，都用方括弧括起来了。</p><p>在恩格斯的“共产主义原理”（１８４７）中指出，无产阶级革命只有在一切先进的资本主义国家同时发动时才可能胜利，因而不可能在一个国家内胜利，这个结论对于垄断前的资本主义时代来说是正确的。在新的历史条件下，在垄断资本主义时期，列宁根据他所发现的帝国主义时代资本主义的经济政治发展不平衡的规律，做出了新的结论：社会主义革命可能首先在几个或者甚至在单独一个国家内获得胜利，不可能同时在一切国家或大多数国家内获得胜利。这个新的结论是在列宁“论欧洲联邦口号”（１９１５） 这篇论文中第一次提出来的。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夕拾 第一周</title>
      <link href="/20240527-month/"/>
      <url>/20240527-month/</url>
      
        <content type="html"><![CDATA[<p>夕拾，用来管理除了学术以外的学习生活。</p><p>第一月 （1-4 周）</p><ol><li>恢复训练。能做15个引体向上，140kg 深蹲，170kg 硬拉。做新的计划，走3个月。</li><li>读小逻辑。</li><li>从头开始学习计算模型。</li><li>见纸质材料</li></ol><p>第一周 5.27-6.2</p><p><img src="image-20240527145945379.png" alt="image-20240527145945379"></p><p><img src="image-20240527150012060.png" alt="image-20240527150012060"></p><p><img src="image-20240527150036874.png" alt="image-20240527150036874"></p><p><img src="image-20240527150622100.png" alt="image-20240527150622100"></p><p>雁过留痕。</p><p>这样管理结构还是很乱。我需要学一些管理学的方法**。</p>]]></content>
      
      
      <categories>
          
          <category> 夕拾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图形绘制技术Lab2</title>
      <link href="/20240520-MoerLab2/"/>
      <url>/20240520-MoerLab2/</url>
      
        <content type="html"><![CDATA[<h1 id="图形绘制技术-Lab2"><a href="#图形绘制技术-Lab2" class="headerlink" title="图形绘制技术 Lab2"></a><center>图形绘制技术 Lab2</center></h1><h5 id="纹理的采样、映射以及生成"><a href="#纹理的采样、映射以及生成" class="headerlink" title="纹理的采样、映射以及生成"></a><center>纹理的采样、映射以及生成</center></h5><center>502023330051 孙博文</center><h2 id="光线微分"><a href="#光线微分" class="headerlink" title="光线微分"></a>光线微分</h2><p>根据 $p_i - p_0 &#x3D; \Delta u \dfrac{\partial p}{\partial u} + \Delta v \dfrac{\partial p}{\partial v}$</p><p>将其分成3个维度计算，以 $u$ 为例，$p(w, u, v)$ 是点坐标，$t(u, v)$ 是纹理坐标，而我们先前假设，$\dfrac{\partial p}{\partial u}$ 和 $\dfrac{\partial p}{\partial v}$ 都是常数：</p><p>$p_1.u - p_0.u &#x3D; \Delta t_1.u \dfrac{\partial p.u}{\partial t.u} + \Delta t_1.v \dfrac{\partial p.u}{\partial t.v}$</p><p>$p_2.u - p_0.u &#x3D; \Delta t_2.u \dfrac{\partial p.u}{\partial t.u} + \Delta t_2.v \dfrac{\partial p.u}{\partial t.v}$</p><p>故可以写成：</p><div>$$\begin{bmatrix}p_1.u - p_0.u\\\\p_2.u - p_0.u \end{bmatrix}=\begin{bmatrix}\Delta t_1.u &\Delta t_1.v\\\\\Delta t_2.u &\Delta t2.v\end{bmatrix}\begin{bmatrix}\dfrac{\partial p.u}{\partial t.u}\\\\\dfrac{\partial p.u}{\partial t.v}\end{bmatrix}$$</div><p>2阶方阵中 $\Delta t_1.u$ 可以通过计算 $t_1, t_0$ 的 $u$ 方向差值得到，其余同理；</p><p>左边可以计算三角形点坐标差得到。</p><p>进而调用 <code>solveLinearSystem2x2</code> 可求得 $\dfrac{\partial p.u}{\partial t.u}$ 和 $\dfrac{\partial p.u}{\partial t.v}$，即$\dfrac{\partial p}{\partial u}$ 和 $\dfrac{\partial p}{\partial v}$ 在 $u$ 方向上的分量。</p><p>$v, w$ 方向同理。</p><p>求解代码如下：</p><img src="image-20240520185709226.png" alt="image-20240520185709226" style="zoom: 67%;"><p>双线性滤波结果：</p><img src="image-20240520185915426.png" alt="image-20240520185915426" style="zoom:50%;"><p>光线微分结果：</p><img src="image-20240520185829080.png" alt="image-20240520185829080" style="zoom:50%;"><h2 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h2><p>球面映射：计算出方位角后，修正到 [0, 1]</p><p>用于修正的fix函数：</p><img src="image-20240520202122018.png" alt="image-20240520202122018" style="zoom: 67%;"><p>圆柱体：v 取归一化的 z 坐标</p><p>平面：直接取 x，y 坐标</p><img src="image-20240520202219930.png" alt="image-20240520202219930" style="zoom:67%;"><p><img src="image-20240520194408285.png" alt="image-20240520194408285"></p><p><img src="image-20240520195042337.png" alt="image-20240520195042337"></p><p><img src="image-20240520202023233.png" alt="image-20240520202023233"></p><h2 id="木纹"><a href="#木纹" class="headerlink" title="木纹"></a>木纹</h2><p>在构造函数中读取木纹的属性并生成随机的单位向量</p><img src="image-20240520212215999.png" alt="image-20240520212215999" style="zoom:67%;"><p>在 <code>evaluate</code> 中，根据坐标，使用 Berlin 噪声和双线性插值计算颜色，与讲义一致</p><img src="image-20240520215052001.png" alt="image-20240520215052001" style="zoom: 50%;"><p><img src="image-20240520214932641.png" alt="image-20240520214932641"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>强装镇定</title>
      <link href="/20240519-composure/"/>
      <url>/20240519-composure/</url>
      
        <content type="html"><![CDATA[<p>前阵的闹剧以完美解决的方式，连事带人一起滚出了我的生活。这好吗？这不一定好。至少今晚就因为它，我被工学椅硬控了两个小时，既没在工作，也没在娱乐。这说明我是真的需要休息。</p><p>不过我有点被迫弹出的感觉，是说真正开心的事情发生之后，我还是不算知情。但也没事，就算后面只能眼睁睁看着事情发展，那也正常，本该如此。</p><p>我已经不知道上次以单一纯粹的心态面对这种事是什么时候了。越多考虑，真心就越难辨。所以我主张的是“以个人自己的主张而非分析”为准。简而言之，就是他敢于说出的东西就是真的。</p><p>跑题了。左顾右盼、左右逢源的日子也要结束了。</p><p>先谈另一件事。事件本身依然有值得观察的地方。作为只抓大学的尾巴，这样一场恋爱能持续多久？面对这种新人，某人是否还能守住？敬请期待。。。我想要的很多答案，就会出现在这一绝佳的样本上。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.26 酒单-最终版</title>
      <link href="/20240518-list/"/>
      <url>/20240518-list/</url>
      
        <content type="html"><![CDATA[<p>中心思想：颜色好看</p><h3 id="酒"><a href="#酒" class="headerlink" title="酒"></a>酒</h3><p>金汤力 - 添加利金酒45ml，青柠汁8ml，托马斯亨利汤力水补满（约120-150ml），蝶豆花，青柠片装饰   蓝紫色</p><ul><li>清爽，草本，酸甜微苦</li></ul><p>椰林飘香 - 哈瓦那3年朗姆45ml，马利宝15ml，椰奶45ml，菠萝汁45ml，红色花瓣装饰   奶白色</p><ul><li>热带风味，甜</li></ul><p>自由古巴 - 哈瓦那3年朗姆45ml，青柠汁8ml，可乐补满，青柠角装饰   深褐色</p><ul><li>清爽，甜</li></ul><h3 id="无酒精特饮"><a href="#无酒精特饮" class="headerlink" title="无酒精特饮"></a>无酒精特饮</h3><p>蓝色夏威夷 - 莫林蓝柑糖浆20ml，柠檬汁20ml，象牌苏打水补满  黄柠檬片装饰  蓝色</p><ul><li>酸甜，橙味</li></ul><p>郝思嘉 - 优鲜沛蔓越莓汁60ml，象牌苏打水补满，柠檬皮装饰  红色</p><ul><li>酸甜，蔓越莓风味</li></ul><p>菠萝冰茶 - 菠萝汁45ml，橙汁30ml，柠檬汁15ml，糖浆15ml，茉莉绿D茶补满   橙色</p><ul><li>菠萝风味</li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><p>以最终出品约50杯为前提，估计各物料用量如下表：</p><table><thead><tr><th>品种</th><th>数量</th><th>单价</th><th>总价</th></tr></thead><tbody><tr><td>添加利金酒700ml</td><td>1</td><td>85.5 + 3</td><td>88.5</td></tr><tr><td>哈瓦那3年朗姆700ml</td><td>2</td><td>74 + 3</td><td>154</td></tr><tr><td>托马斯亨利汤力水 200ml</td><td>8</td><td>65 &#x2F; 6</td><td>86.6</td></tr><tr><td>青柠檬</td><td>5</td><td>11</td><td>55</td></tr><tr><td>黄柠檬</td><td>5</td><td>6</td><td>30</td></tr><tr><td>马利宝椰子味朗姆酒 700ml</td><td>1</td><td>78</td><td>78</td></tr><tr><td>菲诺厚椰乳 1L</td><td>1</td><td>15.8</td><td>15.8</td></tr><tr><td>意文菠萝汁 1L</td><td>2</td><td>10.9</td><td>21.8</td></tr><tr><td>可口可乐330ml</td><td>6</td><td>3.0</td><td>18</td></tr><tr><td>必得利蓝柑糖浆</td><td>1</td><td>41.5 + 3</td><td>44.5</td></tr><tr><td>象牌苏打水325ml x 6</td><td>1</td><td>17.9</td><td>17.9</td></tr><tr><td>优鲜沛蔓越莓汁 2L</td><td>1</td><td>20.9</td><td>20.9</td></tr><tr><td>意文橙汁 1L</td><td>1</td><td>10.9</td><td>10.9</td></tr><tr><td>蝶豆花 40g</td><td>1</td><td>13.9</td><td>13.9</td></tr><tr><td>小计</td><td></td><td></td><td>742.4</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 酒 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本周剩余工作盘点</title>
      <link href="/20240515-workleft/"/>
      <url>/20240515-workleft/</url>
      
        <content type="html"><![CDATA[<p>周四 批作业 1 <strong>定酒单</strong> 1，并且汇报好；买烟 1</p><p>周五~ 摆摊 1</p><p>周六 准备定完酒单的材料 0；扫除 1</p><p>周日 图形绘制技术作业；排练</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝色</title>
      <link href="/20240514-idk/"/>
      <url>/20240514-idk/</url>
      
        <content type="html"><![CDATA[<p>染了个蓝色头发。感觉自己萌萌哒</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组会大纲</title>
      <link href="/20240513-dmck/"/>
      <url>/20240513-dmck/</url>
      
        <content type="html"><![CDATA[<p>做了什么：</p><p>用 willemt&#x2F;raft，做了一个基于 UDP 通信的被测程序</p><p>对 tracer，实现了 emu_socket, emu_sendto, emu_recvfrom 等多个网络相关函数，完全模拟 SOCK_DGRAM </p><p>care:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_sendto</span><br><span class="line">SYS_recvfrom</span><br><span class="line">SYS_write</span><br><span class="line">SYS_read</span><br><span class="line">SYS_clock_nanosleep</span><br></pre></td></tr></table></figure><p>1、对socket、connect、listen、send、recv等的拦截</p><ul><li>拦截与模拟 <font color="gree">OK</font></li><li>tracer 与 tracee 之间的数据拷贝 <font color="gree">yes</font></li></ul><p>2、对数据报的管理 - 数据结构 <font color="gree">OK</font></p><p>3、用 raft 写简易被测程序，研究其性质</p><p>4、手动操控模式，随机模式 —- 一条线走下去</p><p>5、稍作划分；还是强耦合</p><ul><li>tracer: 调度、控制</li><li>state: 状态（结构体、序列和反序列化）</li><li>guest: tracer 与 tracee 交互</li><li>network: 网络行为的模拟</li></ul><p><img src="image-20240513082647413.png" alt="image-20240513082647413"></p><p>实际设计上，消息队列归属于节点状态了。相当于为每一个节点添加了一个 recvbuffer</p><p>不需要choose：</p><ul><li>超时。通过调度的枚举即可。在 sleep 处打上点即可。<ul><li>譬如，先 send_applyentries 再退出 sleep；或反之 sleep 后先判是否收到心跳，再 send_applyentries。</li></ul></li></ul><p>对于 willemt&#x2F;raft，要求周期性 raft_periodic(msec_since_last_period)。</p><p>它做两件事，一是计算 time_elapsed，用于判定心跳超时和选举超时。二是 apply_log</p><p>几乎所有的信息都在 raft_server_private_t 里。也就是说只要把 raft_server_t *raft 的指针地址找到即可 —— 这比较简单。然后引用 raft_private.h 对结构体进行解析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">raft_term_t</span> current_term;</span><br><span class="line">  <span class="type">raft_node_id_t</span> voted_for;</span><br><span class="line">  </span><br><span class="line">  <span class="type">raft_index_t</span> commit_idx;</span><br><span class="line">  <span class="type">raft_index_t</span> last_applied_idx;</span><br><span class="line">  <span class="type">int</span> state;</span><br><span class="line">  <span class="type">int</span> timeout_elapsed;</span><br><span class="line">  </span><br><span class="line">  <span class="type">raft_node_t</span>* nodes;</span><br><span class="line">  <span class="type">int</span> num_nodes;</span><br><span class="line">  </span><br><span class="line">  <span class="type">raft_node_t</span> *current_leader;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="type">raft_server_private_t</span>;</span><br></pre></td></tr></table></figure><p>代价：为这个结构体编写反序列化函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *addr = get_var_addr(<span class="string">&quot;raft&quot;</span>);</span><br><span class="line"><span class="type">raft_server_private_t</span> *raft = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*raft));</span><br><span class="line">memcpy_guest2host(raft, addr, <span class="keyword">sizeof</span>(*raft));   <span class="comment">// 此时里面的指针还是在 tracee 进程的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">raft_node_t</span> *nodes = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*nodes));</span><br><span class="line">memcpy_guest2host(nodes, raft-&gt;nodes, <span class="keyword">sizeof</span>(*nodes));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>running state (procfs)  &lt;=&#x3D;&gt;  recorded state (structure)  &lt;=&#x3D;&gt;  stored state (serialized)</p><p>目前的状况</p><ul><li><p>运行起 raft 协议</p></li><li><p>逻辑比较琐碎。数据结构管理混乱，有一些 bug（结构体倒来倒去）</p><ul><li>经典：用链表存的消息队列，serialize deserialize不停。每跑一次就得复制一份。一会儿用的是以前留下的，一会儿用的是从文件里读的。最终导致网络的行为有问题。</li></ul></li><li><p>数据结构不连续，不适合映射到磁盘上。需调整。</p><ul><li>数组，预分配</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/20240505-brokenthoughts/"/>
      <url>/20240505-brokenthoughts/</url>
      
        <content type="html"><![CDATA[<p>我想学一点关于女性的心理学，这样也能算是知己知彼。</p><p>想来想去，还是不觉得有人能管住我，拿捏我。有些事情没做，纯粹是因为我自己还做不到。</p><p>在有勇气做出大方向、大的路线的选择以外，我更需要的是事无巨细地去研究一件事的细节。至今为止我一直都在强调的往往都是我不缺的东西，却把我真正缺少的东西忽视掉了。</p><p>我看到有一个回答里写的军用地图，能够细化到连一棵独立的树都标注在图上。所以好好想一想，军事上的成功除了大方向上的决策以外，在看不到的地方是事无巨细的绣花工作，或许称之为“微操”。</p><p>胆大心细。一定要逼自己做这样的工作。</p><p>最近身上也发生了各种各样的变化，尤其是对以前听过的小故事进行了重新思考，甚至是亲历。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK工作</title>
      <link href="/20240504-dmck/"/>
      <url>/20240504-dmck/</url>
      
        <content type="html"><![CDATA[<p>这次至少要把 raft 跑起来</p><p>还缺的内容：</p><p>1、根据 raft 框架写一个应用程序 <font color="gree">OK</font></p><p>2、把规约所需的语义信息爬出来</p><p>3、environment</p><p>首先做environment 模拟网络通信。写一个一主一备来测试。</p><ul><li>socket管理</li><li>数据报队列</li></ul><p>4、hash去重</p><p>UDP 测试程序 OK</p><p>分析 environment</p><p>1、对socket、connect、listen、send、recv等的拦截</p><ul><li>拦截与模拟 <font color="gree">OK</font></li><li>tracer 与 tracee 之间的数据拷贝 <font color="red">NO</font></li></ul><p>2、对数据报的管理 - 数据结构 <font color="gree">OK</font></p><p>观察 ticketd 是怎么做初始化的</p><p>main</p><ul><li>传参</li><li>raft_new</li><li>set callbacks</li><li>start server for client</li><li>add self</li><li>start socket</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接着复盘</title>
      <link href="/20240504-review/"/>
      <url>/20240504-review/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上（5.2）在酒吧问一个超级姐的姐姐要了微信，但我的打招呼方式太学生气了。然而对方是浙江台州的，就。。反正之后要更注意这方面的技巧，需要花时间琢磨一下。</p><p>我现在性格上应该是不成问题，但是之前都不屑于去学一点技巧，轻视了套路。当然信心还是有的，毕竟人同意加好友了，说明印象不差。</p><p>困惑。这世界上到底是享受到性爱的人多还是享受不到的人多。呃其实也不是这个问题。而是总有人看起来轻轻松松就享受到了性，而自己就要耐心地守着。我也是急了。我到底输在哪？</p><p>并不服气。然而并不是要甩锅。我唯一希望的事情是，我想干的事情，就要干一件成一件。无论是个人问题，还是科研课题，我都想要完全地掌控。野心只是一方面，事实上我现在是有点万念俱灰的。我没有放过自己，我不想放过自己，因为<strong>放过自己就不好玩了</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>尾声：以后怎么办</title>
      <link href="/20240430-tot5/"/>
      <url>/20240430-tot5/</url>
      
        <content type="html"><![CDATA[<p>一连五篇是同一天写出来的。有两篇不太重要就不录入了。</p><p>反复提的问题，即使每一次都没有完全解决，每一次都没有得到自己的足够重视，也要不厌其烦地去提。千万不要还没解决掉，就开始主动放弃。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>想要得到谁的夸奖，是不会骗人的</title>
      <link href="/20240430-tot4/"/>
      <url>/20240430-tot4/</url>
      
        <content type="html"><![CDATA[<p>上周几乎全都在和 Z女士 见面。周日的酒局她似乎玩得挺开心，之后也催着我组局，周二就又来了一次。我也才知道波士顿壶这种东西到底有多方便。</p><p>周一到 Tribeca，稍微聊了两嘴。我感到 &lt;数据删除&gt; 这件事极度危险。</p><p>两三年下来，我和 Z女士 之间的了解只能说不多不少。不知道应该以什么样的关系进入下一阶段。现在的我比起大三的时候毕竟有一些进步，但我已经不想走回头路了。</p><p>周四被 Z女士 拉着教他抽烟。一年前我对于这种事情其实是极力阻拦的，后来自己也学会了；再后来竟至于教人抽烟。我可能的确是缺少幸福感。或者更准确地说，是缺少羁绊。</p><p>不过有一件事现在是确定无疑的：我无比重视 Z女士 对我的评价，比其他任何人的都重视。所以我会尽力好好表现，有的事也会选择性隐瞒……</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>惊醒</title>
      <link href="/20240430-tot2/"/>
      <url>/20240430-tot2/</url>
      
        <content type="html"><![CDATA[<p>Z女士 一句话点醒了我。除了 M女士 以外，我似乎更是应该小心谨慎。</p><p>&lt;数据删除&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 见闻 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>恋爱、报复与忏悔</title>
      <link href="/20240430-tot1/"/>
      <url>/20240430-tot1/</url>
      
        <content type="html"><![CDATA[<p>前段时间发生了不少事，下面进行技术总结。</p><p>这一篇是一连串的事情中对我影响最小但是最 dramatic 的。</p><p>Sさん 碰巧转给我 Pさん 的长篇动态，里面详细地揭露了一位“海后” M女士 是如何通过约拍与自己暧昧，最终被发现是一场巨大 NTR 的事件：在 地点A 处分别之后，二人的行踪错开，使得 Pさん 刚好发现 M女士 在另一位 Gさん 的怀里。</p><p>当即我并未发现所指人物 （M女士）是我认识的人。但两小时之后，我灵光乍现，怀疑根据 Pさん 的描述，其中时间地点与我认识的一位朋友的朋友圈更新几乎吻合。在简单的交涉之后，我向 Pさん 确认了我的猜想，并大跌眼镜。因为本人曾经与 M女士  吃过一顿饭。我并不怀疑，如果 M女士 的糖衣炮弹再猛烈一点，我将成为受害者之一。复盘的时候，Z女士 说，如果我看上了 M女士，那她一辈子都看不起我，因为我曾经喜欢过的女生都是很神奇很酷的类型。我只能庆祝自己是如此侥幸，因为的确我当时身陷另一个僵局于是就把这边的事情搁置了。</p><p>这是属于动摇之人的强运。</p><p>update: </p><p>没想到，这件事后来又能连上。某日 Hさん 来找我忏悔，说他的旧相识一直在外面沾花惹草。我一听直接爆出 M女士 的大名，直接震慑住了对方。据 Hさん 交代，其因为心情不好在寒假时冷落了 M女士，于是 M女士 试图以通过与其他男性勾勾搭搭的方式吸引 Hさん 的注意。</p><p>并感叹了 Pさん 的确让他心生嫉妒。但他自己已经不想再掺和这件事了，已经心累了。</p><p>-終わり-</p>]]></content>
      
      
      <categories>
          
          <category> 见闻 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你不理解吗？我们看到的东西，都不一样</title>
      <link href="/20240430-tot3/"/>
      <url>/20240430-tot3/</url>
      
        <content type="html"><![CDATA[<p>Y女士 与一位男同学似乎暧昧过。据说一切都是线下发生的而没有留下任何文字证据，导致两方亲友对这件事情的看法都不一样。</p><p>我也没有什么立场，或者说给这件事情定性什么的。事实上对我完全没影响。只是对于 “视角” 所带来的态度差异又了解了一分。</p><p>不能掉以轻心，授人以柄。</p>]]></content>
      
      
      <categories>
          
          <category> 见闻 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图形绘制技术Lab1</title>
      <link href="/20240415-CGLab1/"/>
      <url>/20240415-CGLab1/</url>
      
        <content type="html"><![CDATA[<h1 id="图形绘制技术-Lab1"><a href="#图形绘制技术-Lab1" class="headerlink" title="图形绘制技术 Lab1"></a><center>图形绘制技术 Lab1</center></h1><h5 id="复杂光源的实现"><a href="#复杂光源的实现" class="headerlink" title="复杂光源的实现"></a><center>复杂光源的实现</center></h5><center>502023330051 孙博文</center><h2 id="1-恒定功率光源"><a href="#1-恒定功率光源" class="headerlink" title="1 恒定功率光源"></a>1 恒定功率光源</h2><p>根据<br>$$<br>\Phi_e &#x3D; \int_{Area}\int_{Hemisphere}L_e(x, \omega)\cos\theta d\omega dA<br>&#x3D;L\pi S<br>$$<br>可知 Radiance 为 $Power &#x2F; (\pi * shape.getArea())$</p><img src="image-20240415213747112.png" alt="image-20240415213747112" style="zoom:50%;"><p>结果：</p><p><img src="1-1713188409799.png" alt="1"></p><h2 id="2-球面光源"><a href="#2-球面光源" class="headerlink" title="2 球面光源"></a>2 球面光源</h2><p>按俯仰角 $\phi$ 对球面面积进行微分，得到：</p><p>$$<br>dS &#x3D; 2\pi R^2 \cos\phi\ d\phi &#x3D; 2\pi R^2 d\sin\phi &#x3D; 2\pi Rdz<br>$$<br>直观的理解是，将球面在 $z$ 轴上分割为高相等的无穷细的圆环，它们之间的面积相等。因而按 $z$ 坐标与方位角 $\theta$ 均匀采样可以等可能地采样到球面上的每一个点。</p><p>于是设置两个随机变量：$z &#x3D; 1 - 2u, \theta &#x3D; 2\pi v\ (u, v\in [0, 1])$ </p><p>根据 $z$ 偏移量与方位角算出法向量，并乘以半径再加上球心 $\boldsymbol {pos}$ 得到交点。</p><p>pdf 即为 1 &#x2F; 球表面积</p><img src="image-20240415213523699.png" alt="image-20240415213523699" style="zoom:50%;"><p>结果：</p><p><img src="2.png" alt="2"></p><h2 id="3-三角形网格光源"><a href="#3-三角形网格光源" class="headerlink" title="3 三角形网格光源"></a>3 三角形网格光源</h2><p>首先在 <code>TriangleMesh</code> 中添加面积累加得到的数列，在构造函数中，对各三角形面积累加计算总面积，并构造数列。</p><p>然后使用 <code>u * getArea()</code>，在数列中进行二分查找得到采样的目标三角形，编号为L。</p><p>为了在三角形内的采样均匀，计算新的 u<br>$$<br>u &#x3D; \dfrac{u * getArea() - area_L}{area_{L + 1} - area_L}<br>$$<br>这样，对于任意的三角形，$u$ 仍然遵循在 $[0, 1]$ 间的均匀分布，虽然精度有所下降。</p><p>为了在三角形内均匀采样，需要判断 $u + v &gt; 1$ 如果成立，则采样点超出三角形外。此时只要使得：</p><p>$u &#x3D; 1 - u, v &#x3D; 1 - v$，即可修正到三角形内并保持均匀采样。<br>pdf 即为 1 &#x2F; 总表面积</p><p><img src="image-20240415213631568.png" alt="image-20240415213631568"></p><p>结果：</p><p><img src="3.png" alt="3"></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《德意志意识形态》first time</title>
      <link href="/20240317-marx/"/>
      <url>/20240317-marx/</url>
      
        <content type="html"><![CDATA[<p>序言：把人从幻象、观念、教条和臆想的存在物的枷锁中解放出来。</p><ul><li>费尔巴哈：用符合人的本质的思想来代替臆想</li><li>鲍威尔：批判地对待臆想</li><li>施蒂纳：从头脑里抛掉臆想，这样当前的现实就会崩溃（意指只要改变人们的思想，就可以撼动社会现实）</li></ul><p>以上都是青年黑格尔派的天真的幼稚的空想，是自以为是狼、也被人看成是狼的绵羊（没有引起现实的革命，要严肃地批判）。</p><p>Chapter 1 费尔巴哈，唯物主义观点与唯心主义观点的对立。</p><p>德意志意识形态：以青年黑格尔派为代表的德国哲学，颠倒意识与存在、思想与现实的关系，以纯思想批判反对现存制度的实际斗争。</p><p>这是一种“在可敬的德国市民中唤起怡然自得的民族感情的哲学叫卖”。</p><p>站在德国以外的立场上来考察并表明黑格尔派的运动的狭隘性、地域局限性。</p><p>肯定了1842－1845年的思想发展为“绝对精神的瓦解过程”</p><p>整个德国哲学，从施特劳斯到施蒂纳的批判，都局限于对于宗教观念的批判。青年黑格尔派同老年黑格尔派的共同信念：宗教、概念、普遍的东西统治着现存世界。一派认为这种统治是篡夺而加以反对，另一派认为这种统治是合法的而加以赞扬（qb，必要之恶）。</p><p>青年黑格尔派认为，观念、思想、概念，是某种独立东西意识的一切产物，是人们的真正枷锁。老年黑格尔派认为它们是人类社会的真正镣铐。那么只要同意识里的这些幻想作斗争就行了。</p><p>只为反对“词句”而斗争。</p><p>全部人类历史的第一个前提无疑是有生命的个人的<strong>存在</strong>。一当人开始生产自己的生活资料，即迈出由他们的肉体组织所决定的这一步的时候，人本身就把自己和动物区别开来。</p><p>人表现生命的一定方式——生活方式——生产什么，怎样生产。</p><p>生产随着人口的增长开始，以个人彼此之间的交往为前提。而交往的形式是由生产决定的。</p><p>各民族之间的相互关系取决于每一个民族的生产力、分工和内部交往的发展程度。民族本身的整个内部结构也取决于自己的生产以及自己内部和外部的交往发展程度。新的生产力，只要不是单纯量的发展，都会引起分工的发展。</p><p>一个民族内部的分工，首先引起工商业劳动同农业劳动的分离，从而引起城乡的分离和城乡利益的对立。</p><p><strong>分工的各个不同发展阶段，同事也就是所有制的各种不同形式。</strong></p><p>所有制，就是个人在劳动材料、劳动工具和劳动产品的相互关系。</p><p>分析了发展中的三种所有制形式：1、部落所有制－氏族，2、公社所有制和国家所有制－部落形成城市，3、封建的或等级的所有制－城市及乡村。</p><p>等级划分在乡村（中世纪）是王公－贵族－僧侣－农民，在城市（古代）是师傅－帮工－学徒－平民短工。</p><p>由此可见，事情是这样的：以一定的方式进行生产活动的一定的个人（或是，在一定的生产关系下的一定的个人）发生一定的社会和政治关系。</p><p><strong>现实的</strong>个人，是从事活动的，进行物质生产的，因而是在一定的物质的、不受他们任意支配的界限、前提和条件下活动着的。</p><p>接下来——思想、观念、意识的生产最初是直接与人们的物质活动，与人们的物质交往，与现实生活的语言交织在一起的。</p><p><strong>表现在某一民族的政治、法律、道德、宗教、形而上学等的语言中的精神生产也是这样。</strong></p><p><strong>意识在任何时候都只能是被意识到了的存在，而人们的存在就是他们的现实生活过程。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《小逻辑》again</title>
      <link href="/20240317-hegel/"/>
      <url>/20240317-hegel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我的确从没有如此精读过。读《纯粹理性批判》的时候是按讨论的概念去写总结的。而黑格尔的哲学写作，就如同他的哲学思想一般，是一个整体性的：自为因果，循环发展。因而试图按部门去读解是困难的。做笔记的目的在于，能够时时都作整体性的梳理。</p></blockquote><p>第一版序是纯粹的客套</p><p>第二版序</p><p> 一般科学教育的理智导致一种重要的消极结果，即认为采取有限概念的道路就没有中介可能达到真理。</p><p> （我有点没看懂后面这个批评）</p><p> “人们对待斯宾诺莎好像对待一条死狗”。（对唯理论的轻视？）</p><p> 哲学的历史就是发现关于“绝对”的思想的历史。绝对就是哲学研究的对象。（康德：上溯到“无条件者”）</p><p> 谈宗教的部分就不<strong>看了。</strong></p><p>第三版序略</p><p>致辞</p><p> “这个时代之走到对于理性的绝望…” </p><p> 批判哲学确信它证明了我们对永恒、神圣、真理什么也不知道，并将此种无知、浅薄和空疏宣称为一切理智努力的最终结果。（批评康德式的不可知论，把人的理性提到一个更高的点上：我们对于绝对的概念的追寻绝不是一种臆想。在上课前，给学生先打一针鸡血）。 </p><p> 小逻辑总体上是黑格尔的课程讲义。并附有学生从课堂上归纳的解释。</p><p>导言</p><p>Para 1 对于事物作<strong>思维着的</strong>考察，必指出思维内容的必然性，证明其存在与规定性。因而，困难在于寻得一个哲学的开端是一种困难。以任何当前直接的东西作为开端，那只是提出了一种假定。</p><p>Para 2 概括讲来，哲学可以定义为对于事物<strong>思维着的</strong>考察。哲学作为一种特殊的思维方式（与普遍的人的思维对应），思维成为认识，成为把握对象的概念式的认识。</p><p> 基于思维表现人性的意识内容，每每首先不借思想的形式出现，而是作为情感、直觉或表象等形式而出现。情绪与思维并不是截然分开的。 </p><p> （欲望、意志、情绪，有别于纯粹的思想，同样是人类理性。）</p><p>Para 3 情绪、直观、印象等，是意识内容所表现的诸形式。在任何一种或混合形式下的内容都是意识的对象。而形式在遗失的对象中归为内容而呈现。因而每一形式好像是特殊的对象。（我意欲的和我思考的东西，它们仅仅是以不同形式呈现在意识当中。）</p><p> 我们所意识到的情绪、直观、欲望、意志等规定，一般被称为<strong>表象</strong>。大体上可以说，哲学是以思想、范畴，或更确切地说，是以<strong>概念</strong>去代替表象。</p><p> 表象的感觉材料的一个命题：这片树叶是绿的。这样的命题却也掺杂了存在、个体性的<strong>范畴</strong>。</p><p> （而哲学的难点则在于作抽象思维。）“把思想本身，单纯不杂地作为思考的对象”。（单纯地思考范畴？还是单纯地思考概念？）</p><p>Para 4 略</p><p>Para 5 意识的真实内容，一经翻译为思想和概念的形式，反而更能保持其真相，甚至反而能更正确地认识的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组会主题</title>
      <link href="/20240315-progres/"/>
      <url>/20240315-progres/</url>
      
        <content type="html"><![CDATA[<p>尼玛早上6点就有人进来了，刚夜里3点还有人在隔壁通宵，今天疑似有点撞大运了。</p><p>这次的工作量可能不太够，所以尽量就啰嗦一点。</p><ul><li>bakery算法，完整版，去掉choosing版，atomic和safe寄存器的考量</li><li>一个raft协议的考察，使用udp去实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">process(i) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        choosing[i] = true;</span><br><span class="line">        number[i] = 1 + max(number[1], number[2], ..., number[n-1]);</span><br><span class="line">        choosing[i] = false;</span><br><span class="line">        </span><br><span class="line">        for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            while (choosing[j]);</span><br><span class="line">            while (number[j] != 0 &amp;&amp; (number[j], j) &lt; (number[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &lt;critical section&gt;</span><br><span class="line"></span><br><span class="line">        number[i] = 0; </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1: Send(T2, REQUEST_VOTE, term = 1)</span><br><span class="line">T1: Send(T3, REQUEST_VOTE, term = 1)</span><br><span class="line">T3: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Send(T1, GRANT_VOTE)</span><br><span class="line">T3: Send(T1, GRANT_VOTE)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1: Send(T2, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T2: Send(T1, GRANT_VOTE)</span><br><span class="line">T1: Send(T3, REQUEST_VOTE, term = 1)</span><br><span class="line">T3: Recv(T1, REQUEST_VOTE, term = 1)</span><br><span class="line">T3: Send(T1, GRANT_VOTE)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>禁止吸烟</title>
      <link href="/20240313-banned/"/>
      <url>/20240313-banned/</url>
      
        <content type="html"><![CDATA[<p><img src="IMG_20240313_012453.jpg" alt="IMG_20240313_012453"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无垠小手</title>
      <link href="/20240311-update/"/>
      <url>/20240311-update/</url>
      
        <content type="html"><![CDATA[<p>很久没有写博客了。但也不是没有任何记录，这段时间的所想我都1510地用纸笔记录下来了。等到心情闲下来我就更新到线上。对着屏幕可能并不是无话可说，但也许是觉得混合波长的光线过于聒噪。</p><p>周五花了一大笔钱买了一套正装，然后立即就约上摄影师拍了一套照片。平时不常拍照片的我在镜头的审视下尽显死角，要么是表情僵硬，要么是体态不到位。一直以来其实容貌焦虑都是有的，不过我在高中时期学到了一点成年人的从容，于是生搬硬套地带到了大学里。大部分时间里，还是那个放飞自我的人；一旦察觉到露怯的可能，我就会端着了。一开始是沉默寡言，给人一种不苟言笑的感觉；后来想起了那份从容，于是假装放松，身体后仰，眼神放空；不过这还没形成一种气质。众人评议的结论是我的各种态度会很受男生的欢迎，不过据我观察也不尽然。至少我现在这个疯批气质还是会劝退很多人。</p><p>既然要端着，那就贯彻到底。不知道从什么时候开始我就沉迷于各种各样的正装。但同时也喜欢上了打耳洞，这两项可以说是风格迥异。就最后的结果而言，我整个人身上都有了一种人格分裂的美。当然我从来没怀疑过自己人格的整体性，并且也没有那种分裂的迹象。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>于计算理论课上</title>
      <link href="/20240304-misc/"/>
      <url>/20240304-misc/</url>
      
        <content type="html"><![CDATA[<p>上周发生了非常非常多的事。到了周末最后的最后，我也不能说是爆炸，毕竟心态并无大碍，而且现实的事情并没有对我完全展开。</p><p>可能漂亮妹子说的一两句话就够我琢磨好一会儿了吧。</p><p>所有的惆怅，都有待现实的展开去消除。</p><p>“我仍然想和你一起做梦。”</p><p>话说，去问别人的戒指的寓意真的好么？这种东西相信的人会直接得出结论，不信的就完全不会管。而我是。。知道，并且自己遵守这套游戏规则，但也会怀疑别人。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IOT 认证技术</title>
      <link href="/20240112-iot/"/>
      <url>/20240112-iot/</url>
      
        <content type="html"><![CDATA[<p>我肯定需要加一行小字。只有表格的话，预览会出一点问题。</p><p>填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用填线用</p><table><thead><tr><th>认证技术</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>指纹识别</td><td>高度准确，辨识度高。 便于使用，用户体验良好。 可以嵌入到设备的物理按键或屏幕中。</td><td>指纹信息可能被复制（尽管现代系统采用活体检测）。 需要专门的硬件支持。 部分人可能有阻碍指纹录入的情况。</td></tr><tr><td>面部识别</td><td>便于使用，用户体验良好。 无需接触设备即可进行认证。 部分系统采用3D面部扫描，提高安全性。</td><td>部分面部识别系统可能被攻击，例如使用照片欺骗。 在低光环境或夜间光线不足时可能准确度降低。 部分系统对面部变化敏感。</td></tr><tr><td>虹膜扫描</td><td>生物特征独一无二，辨识度高。 无需接触设备即可进行认证。 对于眼镜、隐形眼镜等外部因素的影响较小。</td><td>需要专门的硬件支持。 目前较为昂贵。 可能在低光环境下工作不佳。 部分用户可能对虹膜扫描有顾虑。</td></tr><tr><td>声纹识别</td><td>无需接触设备即可进行认证。 对语音特征的辨识度较高。 不受外部环境光线等条件限制。</td><td>受到环境噪音的干扰。 可能受到声音录制或模仿的攻击。 不适合在公共场合等需要保持安静的环境中使用。</td></tr><tr><td>手势识别</td><td>通过分析用户的手势，可以实现动态认证。 无需接触设备即可进行认证。 增加了用户体验的创新性。</td><td>安全性相对较低，容易被模仿。 部分用户可能不喜欢在公共场合使用手势认证。 部分系统可能对手势的识别准确度有限。</td></tr><tr><td>行为分析和生物特征融合认证</td><td>通过结合用户行为和生物特征进行认证，提高了系统的安全性。 具备持续认证的能力，不仅仅局限于静态认证。 可以适应不同使用环境。</td><td>需要复杂的算法和分析。 在初期阶段可能存在准确度和鲁棒性方面的挑战。 部分系统可能对用户行为的监测引起隐私担忧。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Raft 实验报告</title>
      <link href="/20240110-raft/"/>
      <url>/20240110-raft/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统课程实验报告"><a href="#分布式系统课程实验报告" class="headerlink" title="分布式系统课程实验报告"></a>分布式系统课程实验报告</h1><p>502023330051 孙博文</p><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>基于所给go语言框架实现了一个简单的 Raft 协议，包括选举、复制。最终通过了如下的测试(包含 Part1 和 Part2 的全部测试)：</p><img src="image-20240110214418292.png" alt="image-20240110214418292" style="zoom:50%;"><h2 id="分析与设计"><a href="#分析与设计" class="headerlink" title="分析与设计"></a>分析与设计</h2><p>定义角色</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">LEADER = <span class="number">-1</span></span><br><span class="line">FOLLOWER = <span class="number">-2</span></span><br><span class="line">CANDIDATE = <span class="number">-3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>并设置时间相关变量</p><ul><li>选举超时间隔 100-500ms</li><li>心跳间隔100ms</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ElectionTOMin = <span class="number">100</span></span><br><span class="line">ElectionTOMax = <span class="number">500</span></span><br><span class="line">HBInterval = <span class="number">100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>定义日志项</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Term    <span class="type">int</span></span><br><span class="line">Index   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Raft结构体定义</p><p>为了实现选举，心跳机制和日志追加等内容，还引入了一些其他字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log    []Entry     <span class="comment">// 日志</span></span><br><span class="line">lastApplied   <span class="type">int</span>    <span class="comment">// 已应用</span></span><br><span class="line">role           <span class="type">int</span>         <span class="comment">// 角色</span></span><br><span class="line">leaderID       <span class="type">int</span>  </span><br><span class="line">electionTimer  *time.Timer <span class="comment">// 选举超时</span></span><br><span class="line">heartBeatTimer *time.Timer <span class="comment">// 心跳间隔</span></span><br><span class="line">applyCh        <span class="keyword">chan</span> ApplyMsg <span class="comment">// 日志应用</span></span><br></pre></td></tr></table></figure><h4 id="RPC相关"><a href="#RPC相关" class="headerlink" title="RPC相关"></a>RPC相关</h4><p>RequestVote 和 AppendEntries, 和论文基本一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="type">int</span></span><br><span class="line">CandidatedId <span class="type">int</span></span><br><span class="line">LastLogIndex <span class="type">int</span></span><br><span class="line">LastLogTerm  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term        <span class="type">int</span> </span><br><span class="line">VoteGranted <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Term         <span class="type">int</span>       </span><br><span class="line">LeaderId     <span class="type">int</span>       </span><br><span class="line">PrevLogIndex <span class="type">int</span>       </span><br><span class="line">PrevLogTerm  <span class="type">int</span>       </span><br><span class="line">Entries      []Entry</span><br><span class="line">LeaderCommit <span class="type">int</span>       </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Term      <span class="type">int</span> </span><br><span class="line">Success   <span class="type">bool</span></span><br><span class="line">NextIndex <span class="type">int</span>  <span class="comment">// 之后应用的Log索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议实现"><a href="#协议实现" class="headerlink" title="协议实现"></a>协议实现</h2><p>节点启动后, 将创建3个goroutine:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go rf.LeaderElection()</span><br><span class="line">go rf.HeartBeat()</span><br><span class="line">go rf.LogApply()</span><br></pre></td></tr></table></figure><p>分别对应选举, 心跳, 与日志应用</p><h3 id="节点选举"><a href="#节点选举" class="headerlink" title="节点选举"></a>节点选举</h3><p>首先节点需要在三个角色中切换. 因此设计了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> goLeader()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> goCandidate()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> goFollower(term <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>其中转换到 Follower 需要对应的任期.</p><p>节点启动后,都初始化为 Follower, 并设置选举超时. 进入 LeaderElection 协程后, 等待一个随机的选举超时, 如果自身是 Follower 或 Candidate, 则 <code>goCandidate()</code>, 任期 + 1, 发起选举, 给自己投一票, 然后发送 <code>RequestVote</code>RPC. 发送时即接收回复, 收到多数派承认则成为 Leader.</p><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>对于 Leader, 等待心跳间隔后发送一个 <code>AppendEntry</code>, 附加上 nextIndex 指示的一部分 Log, 发给所有的 Follower 即可.</p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>发送者发送心跳后, 会受到回复.</p><p>如果 reply.Term &gt; currentTerm, 此时发送者已经不是 Leader, 无需响应;</p><p>如果 reply 成功, 则更新对应节点的 matchIndex 等信息, 并尝试更新 commitIndex;</p><p>如果 reply 失败, 则可能后退任期进行重试.</p><p>而接收者的行为可以概括为:</p><ul><li>拒绝 Term 小于自身任期的请求</li><li>lastLogIndex 小于心跳包的 PrevLogIndex, 说明节点日志陈旧, 通过回复 Leader 一个 NextIndex 来指示下次的发送</li><li>除此之外, 覆盖原有条目</li><li>接收 LeaderCommit, 更新 commitIndex</li></ul><h3 id="日志应用"><a href="#日志应用" class="headerlink" title="日志应用"></a>日志应用</h3><p>通过 LogApply() 中的循环, 不断更新最新被应用的条目, 直到不超过 commitIndex 的条目.</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>Raft 相比于 Paxos 已经较为容易理解，但是在实现过程中，依然难以完美。主要问题出现在并发程序上。一共三个节点，加上每个节点有3个&#x2F;实际是4个协程，各种打印信息交织在一起，很难分析出问题的原因。</p><img src="image-20240110213025465.png" alt="image-20240110213025465" style="zoom: 50%;"><p>▲没有大写RPC相关结构体的字段浪费了大量时间，直到看到了这段提示</p>]]></content>
      
      
      <categories>
          
          <category> Distributed Systems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自由</title>
      <link href="/20240102-free/"/>
      <url>/20240102-free/</url>
      
        <content type="html"><![CDATA[<p>自由是个倒装。它的本意就是「由自」，一切认识与实践，皆由自我而开辟出来。这才是最具解放性的：不预设一个超越性的维度，不需要任何高级的存在为自己背书，一切矛盾都是我和我自己的矛盾。对于世界而言，一切的矛盾就是世界和世界它自己的矛盾。</p><p>对于差异性的抹平要比差异本身更加难以为继。随着温度下降，四大基本作用一个一个地分离出来，不同的粒子在此时创造出来。从来都是从一致的东西当中产生断裂，诞生差异，扬弃了原先的那个整全，才是世界的运动方向。不是东风压了西风，就是西风压了东风。</p><p>只是没人有勇气接受这样的「自由」。没有人敢「自由」。这需要主体价值观的「惊险一跃」：先是感受到绝对的自由的无限性；然而这无限性归根结底是单一的：除了「不存在不存在」以外，什么规定也没有做出。一贯的、平整的无限性，对于人类的理智而言是无法把握的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK 第?次汇报前准备</title>
      <link href="/20231225-dmck/"/>
      <url>/20231225-dmck/</url>
      
        <content type="html"><![CDATA[<p>总的来说，要做的是这几件事：</p><p>1、尽量把带malloc，带page变动的恢复做出来</p><p>2、完善状态恢复的实现</p><p>3、做一个交互式的控制台</p><p>4、模拟网络相关系统调用</p><p>5、环境部分的代码</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>审美和恐惧</title>
      <link href="/20231220-utsukushisa/"/>
      <url>/20231220-utsukushisa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>感觉应该是从哪里抄的。我没有自己思考过这些东西的记忆。</p></blockquote><p>人们以为自己可以审美（忍受）恐惧就会没有恐惧了，这时候显在的的确就是审美。</p><p>处于恐惧之中的主体会享乐来试图缓解恐惧，想要彻底消灭恐惧。但他的享乐冲动会越来越多。他看的或做的事情可能越来越危险，暴力，血腥。显然，他开始对恐惧上瘾。对恐惧的口味会越来越重。实在一点，再实在一点，因为这还不够把自身的恐惧否定掉。</p><p>审美主体想要摆脱自恋，以为去否定自己，不自我赞扬，不肯定自己多么优秀，就是不自恋，但其却迷恋上了一个悲剧性的想象自我。他爱上了没人爱的自己，这是他的自我认同。</p><p>审美主体主观上可能不会觉得他会因为这些否定而痛苦，但客观上却是痛苦的。我这里所说的客观就是主体所不知道的知识。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>行动力？</title>
      <link href="/20231214-tatakau/"/>
      <url>/20231214-tatakau/</url>
      
        <content type="html"><![CDATA[<p>该如何言说我的当下？</p><p>“我千万不能太陶醉在这种虚假的快感里了,周末必须放松一下,认清我的人生旨趣必须是打鱼摸虾耽误庄稼,吃喝嫖赌抽烟烫头。”</p><p>我的行动力有点丧失了。或者也不是。至少在打孔这件事上我做到了完全果断。这些学业上的事，归根结底是我自己不太想做。</p><p>但总是要混到这个该死的文凭的。想想时间还剩一周，却有这么多事要做。我的内心缓缓升起两个字：歇逼。</p><p>不能正经做事，似乎是这一整个学期的情况。从什么时候开始的呢？已经很难去回忆了。</p><p>还有一会儿天就亮了，我希望还是在8点之前结束战斗。</p><p>明天，呃，如果结束得早，就该回去睡觉。</p><p>下午上课之后，来实验室写编译原理。周末尽量留多点时间来处理组会…与周一、二、三…</p><p>但是各种进度为0，只能疯狂一点了。</p><p>今天是周五。现在是6:09</p><p>我知道不能耽搁在写东西缓解焦虑上，但显然是很焦虑，几乎控制不了了。恐惧催人享乐，陷入了一种循环。</p><p>需要一个地方来安放我的心。但事实上，做事是安放焦虑的唯一方法，但我显然</p><p>做不了事。</p><p>其实我并不是这样的人。我肯定是很有动力去做的，且有能力有意愿。但事情就因为各种奇怪的原因延宕了。“奇怪的想法”。</p><p>好了，周末是最后的冲刺阶段，没有链子可以掉了。</p><p>所谓“绝境”的意义，我不止一次地领教。现在是真到了：没有一次比这更加 dangling （录者语：没事，以后有更逆天的）</p><p>我并没有那个勇气去退学。哈哈哈哈。。。</p><p>但是，其实我肯定也不是想放弃。唯一想摆脱的是当前这种状态，显然，要以比正确还正确地姿态来面对，那就是——竭尽全力跳出循环。</p><p>这也容易。不是对自己“狠一点”，因为这里面还有回旋的余地。而现实是苍白的、直接的、不容商量的、没有回旋余地的。不能幻想一种界限&#x2F;界定，超过这个标准就算尽力，而是说，尽力是一件发生的事，而不是对已经产生的结果的描述。因为这种事后的描述一定是带有粉饰的。</p><p>我们在时候决不需要一个评价“尽力了”如何。事实上是不可评价的。事情的发生并不需要主观的量度。</p><p>因而不要“狠一点”，而要领悟“绝对”。</p><p>我“绝对”要做到，而不是尽力做。不做到，就性命攸关。</p><p>这样看，就是达到一种强迫症式的人格。我必然能，我必定要，在自己的面前表演那个高度社会化的人。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>酒神精神</title>
      <link href="/20231206-dionysus/"/>
      <url>/20231206-dionysus/</url>
      
        <content type="html"><![CDATA[<p>无论如何追问意义，最后都会得到沉默的回应。生命的无意义仅在于不存在客观的终极解释。在此基础上自我产生悲剧式的解释，因为这个原处缺失被发现。</p><p>酒神的内核在于，人在悲剧中的兼任。对痛苦的对抗时展现着生命的。</p><p>在于与痛苦对抗的生存姿态，从中感受到生命本体的欢乐，使微观视角下的悲剧称为宏观的戏剧。</p><p>个体视角局限下的悲剧成为一般生命直观下的喜剧。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Piecing</title>
      <link href="/20231204-piecing/"/>
      <url>/20231204-piecing/</url>
      
        <content type="html"><![CDATA[<p> 小睡了 1.5 小时。起来还是看丁主任的比赛，在追到 7:7 之后，基本上就直接失去还手之力了。火箭看起来就像是在放水一样。（2023英锦赛）</p><p>早上比赛结束后本来打算小睡一会儿，然后下床抽了两支烟。要我说，这第二支实在是有点多余。一根已经足够进入状态。两根除了感觉很冷意外也就没什么了。</p><p>之后就听到升国旗了。心一横就直接起了床，想想也是，没什么好睡的。课肯定是盖上了，顶多睡到9点半，还得赶着起来洗澡。</p><p>等等。我宿舍冰箱门关了吗？。。。要写一个checklist放在宿舍门口了。</p><p>前几天我随手发了一句 “我不是女同”。这本来就是先射箭再画靶，其实根本没人想到这个，是我自己唐突地想到了这样一句话。而实际的意思是：我艹，原来我是女同。。。</p><p>刚才又在想另一个问题。如果在以后可能会有（大概率不会有）的高中同学会上，那我最能拿得出手的是什么东西？我感觉右耳大概最后会有 8-10 个耳洞吧（2024.10.8 录入语：现在刚好 8 个）。</p><p>其实就是这样一个问题：怎么向所有人解释我的钛合金右耳？</p><p>“你的耳朵是怎么回事？”“我去打了几次耳洞”</p><p>“你怎么打这么多？”“我自己挺喜欢这个的”</p><p>就这样，大部分的对话就应该终止于此。并没有人会在意这个，大部分人应该是不太瞧得上这种风格。</p><p>这是一种什么感觉：从同一个班出来，大家各奔东西。一些人去了豪华的大都市，享受上流生活；还有那么几个在底层鬼混。。。我的心理设定就把自己放在了这个低位。如果说这件事有任何值得自豪的，无非是忍受穿孔时的疼痛，以及毫不留情地表达着对于世俗价值观的蔑视。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一种自动发生学</title>
      <link href="/20231130-automata/"/>
      <url>/20231130-automata/</url>
      
        <content type="html"><![CDATA[<p>也不知道日子要什么时候才能恢复正常。可能已经有半个月没有正常睡过觉了，并且也有在抽烟。</p><p>谁能想到会发生什么呢？今年五月份是玩得比较疯的时候。即使这样也不如当下放纵。这并不是说抽烟时不可接受的、是令人感到耻辱、羞愧的。</p><p>在压抑的时候，一个人往往更加控制不住自己。放纵的时候，确实全身心地贯注于当下的欲望，而不被别的事情所沾染。</p><p>显式地纵情，比压抑中的“偷跑”的破坏力明显是更小的。</p><p>这里我并没有做什么价值判断，而只是描述两种模式对于“稳态”的影响。好比T人常常有情感的爆发，而F人是将其藏匿于与惯常无异的行动当中。</p><p>如果要问我Prefer哪一种，我只能说无论何时都要接受当下的自我；但更重要的是承认变化的Automatic。自动发生的一种本性，比起自我，非我更显现出一个随时变化着的意向。</p><p>随心而并非随性，自为而并非自在。</p><p>“酒神精神”的肯定也绝不是僵死的，而是运（滑）动中的。</p><p>所以主要是感受到什么而写了这些？抽烟比起喝酒的接受程度在当下是要低许多的。然而我是否应该考虑这个问题？对此提出疑问主要还是考虑到，作为一个习惯性&gt;成瘾性的行为，对身体的损害时较大的。抽烟它本身，作为习惯，甚至不如酒精容易控制。我不知道烟与酒哪一个更伤身，但自身的接受度可以说明一切。我不可能不喝酒，但是消除烟的影响是看似轻而易举的。因为这件事情并没有预想中的快感，也没有预想中的成瘾性。我日常就像个瘾君子一样精神萎靡。从开始抽烟之前就有这种表现了。因而是自己就取消了对这种“精神影响”的信仰。</p><p>所以，戒烟的实质是一种精神胜利法，而且仅仅能以精神胜利法的方式实现。只要你蔑视它作为精神药物的“必要性”，就很容易做到。</p><p>戒烟失败又怎么办？那就是不要把失败想象成一种奇耻大辱。拍拍屁股接着来又能怎么样？不能让“大他者”来监视你的过程并且在失败的时候嘲笑你（嘲笑自己）。</p><p>而我抽烟的理由，很不幸；很万幸。没有任何理由，只是突然想。这表明在背后驱动着的根据实际上只是一种拟制。</p><p>没什么想说的了。现在在想有没有可能把手写的只言片语写成博客？应该是没什么时间了。至少把纸面上的东西都收集起来吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>思政课作业</title>
      <link href="/20231127-politics/"/>
      <url>/20231127-politics/</url>
      
        <content type="html"><![CDATA[<p>502023330051 孙博文 计算机科学与技术系 计算机科学与技术专业</p><h2 id="我是谁，我要做什么"><a href="#我是谁，我要做什么" class="headerlink" title="我是谁，我要做什么"></a><center>我是谁，我要做什么</center></h2><p>​我是孙博文，来自计算机科学与技术专业。我出生于一个无产阶级家庭：父亲是建筑工人，母亲是保洁工人。从小家教相对严格，加上在初高中时期都遇上了欣赏我的老师，使得我拥有努力上进的部分先决条件。</p><p>​作为市民社会的成员，我的未来规划无非是利用所学知识成为异化的生产关系中被异化的劳动者。异化在劳动所在之处，而人不能不劳动，就像人不能不吃饭。但低头做事之余，依然要仰望星空。我想要把哲学的思辨与实践作为我终身热心的事业。</p><p>​人生的意义无非在于认识世界与改造世界。认识是将自然的规律完全精神化，化为直观和思维的规律，整个自然借助意识将自己溶化为一种理智的理论（谢林. 先验唯心论体系）。而相对应的实践是将思维中的概念实现为自然世界中的实在。这两种相会合的活动是自然的必然的倾向，是人类自社会产生以来都坚持着的主题。</p><p>​这样谈论人生意义似乎显得太大了，一个人能够产生的影响是非常有限的。但我们能够说，因为这一影响微不足道因而它就是没有必要的吗？我认为不是。这也反映出当下的一种焦虑症，对应一种虚无主义的世界观。很多人都抛弃了实践当中最细微的那些，仿佛它们不配被称为实践；同时又对于翻天覆地的改变抱有幻想。</p><p>​这就不得不引到我对当前社会发展所抱有的最大困惑：青年人的思想工作到底应该如何开展。</p><p>​当下的青年有一种小资产阶级化的倾向。当然，想要“小资产阶级化”的无产阶级还是无产阶级。许多人的愿望竟然是不劳动就能获得幸福的生活。在当前的生产力与生产关系下，实现这一目标的唯一途径就是实现他们自己从无产阶级到小资产阶级的历史反向运动。这一反向运动，对于整个无产阶级是必然失败的。但我们竟不能够严肃地批判，因为当前的形势毕竟没有发展成剧烈的“你死我活的斗争”。不严肃的、不清醒的想法毕竟还不至于使人变得走投无路。</p><p>​同时，当下的青年似乎也没有自信力。形势并没有到令人沮丧的地步，以至于中年人们显得比青年人有信心。更具体地来说，青年的自信心有一种分化：一派抱有适当的信心，而另一派则非常沮丧，甚至在南大这样的高等学府，这种信心的丧失更甚：他们都认为自己以后找不到工作。</p><p>​因而，我也希望将哲学作为精神分析学的引子，以期找到其原因与解决办法。</p><h2 id="思政课要为学生先"><a href="#思政课要为学生先" class="headerlink" title="思政课要为学生先"></a><center>思政课要为学生先</center></h2><p>​学生们需要一个子弹头、钢笔尖式的人物。</p><p>​而这样的一个人物，所能起的最大作用，就是给所有人带来理论上的理性。教师这一身份最合适。</p><p>​二十出头的年纪是大多数学生对于政治话题最敏感的时期，就算对政治再不感兴趣的人也会形成他自己的观点。而同学们在上面讲一些东西并不会引发更多的认同。毕竟大家在台上讲得内容和他们平时关注的内容相差甚远。作为教师和学生的距离虽然比较远，但老师毕竟也有做学生的时期。所以学生的心理是好推断的。</p><p>​我们提倡自由和包容；时代的主题还是和平与发展。这些基调不是大学的思政课程能够影响的，因而我们不可能讨论太尖锐的话题，同时也就失去了在这些话题上进行教育的可能。不过，即使我们一点也不能奢求所有同学都对社会现实的问题都抱有相同的立场，但是至少要抱有对于他所处的社会经济地位中合理的立场。这就需要一些分析方法的介入：阶级分析和意识形态分析。 </p><p>​介绍这些分析方法，是有一些积极作用的。首先它是一种正确的独立思考的工具。很多时候我们对自诩“独立思考”的人感到头疼，都是因为他在本质上仍然是道听途说，拾人牙慧，把别人具有感染力的观点不加以批判地使用。而这样的人其实在某种程度上是“驳不倒的”，因为他之所以从众多看法中采取了这个或那个看法，其来源多半是基于他的某些信仰。而一些有偏差的信仰，往往又是他并不能把我到自己在切身利益中的真正立场。</p><p>​其次它能够给予朴素的情感与观点一些切实的信心。总是说“劝同志们读一点书，免得受知识分子的骗”。朴素的想法最容易迷茫。它从“人的感受”的质料中最直接地产生出来，也最容易受到各种方面的批判。有了分析的方法来应证这些观点，我们就容易有理论上的自信，就不容易“受知识分子的骗”了。</p><p>​在积极作用之外，还有一些“消极”的作用。这里的消极是说，虽然它不能够带来正面的认识增加，但至少告诉我们哪些看法是不可取的。</p><p>​这些完全客观的理论工具一经被把握，便成为青年学生对抗意识形态渗透的最好工具，而不需要再多言其他的。信念动摇的来源在于没有信心，而喜欢理性的人的特性就是喜欢从理论出发推出当前的处境。如果能够运用分析的工具确定无疑地判断当下的形势，疑虑也就自然地消解了。</p><h2 id="同一和综合的统一——谈谈对辩证法的认识"><a href="#同一和综合的统一——谈谈对辩证法的认识" class="headerlink" title="同一和综合的统一——谈谈对辩证法的认识"></a><center>同一和综合的统一——谈谈对辩证法的认识</center></h2><h6 id="毛泽东-在延安文艺座谈会上的讲话、实践论、矛盾论-读后感"><a href="#毛泽东-在延安文艺座谈会上的讲话、实践论、矛盾论-读后感" class="headerlink" title="毛泽东 在延安文艺座谈会上的讲话、实践论、矛盾论 读后感"></a><center>毛泽东 在延安文艺座谈会上的讲话、实践论、矛盾论 读后感</center></h6><p>​“唯心论者是强调动机否认效果的，机械唯物论者是强调效果否认动机的，我们和这两者相反，我们是辩证唯物主义的动机和效果的统一论者…………检验一个作家的主观愿望即其动机是否正确，是否善良，不是看他的宣言，而是看他的行为（主要是作品）在社会大众中产生的效果。”（毛泽东. 在延安文艺座谈会上的讲话，1942）</p><p>​从康德的范畴表开始，到黑格尔时已经自觉地使用“正反合”作为辩证法的形式了。提出一对截然相反的论题A和非A，在这里辩证法的答案是：A又非A，因为A是非A。</p><p>​我们应该如何理解这样的说法？ 形式逻辑的矛盾律与同一律绝对不允许辩证法如此这般的操作。但辩证法的实质是什么？</p><p>​“列宁说，‘就本来的意义讲，辩证法是研究对象的本质自身中的矛盾’”（毛泽东. 矛盾论，1937）。我们在使用形式逻辑的时候，仅仅是在形式上使用它。我们形式地说A是A的时候，总是不管A到底是什么的，就算A本身是不存在的、不正确的，我们依然说“A是A”是对的，因为形式逻辑只管抽离了其中的对象而言的形式上的正确性。而辩证法是“研究对象本质”的。对于辩证法而言，不管是A还是非A，它里面到底装了什么还是要打问号的。所以它超越形式上的逻辑，而成为一种内容的逻辑。</p><p>​对于辩证法而言，它极力要达到的终点是弥合、修补、消除矛盾，把所有的东西都统筹在一起。对于两个不相容的概念之间的连接，我们称之为综合；而从一个概念中分析出其中既有的东西叫做分析。“同一”则是分析的极限：从一个东西分析出它自己，一步也没有进。辩证法做的就是这样的一件事：对于矛盾的双方既综合又同一。</p><p>回到一开始引用的例子。首先提出，</p><p>正题：强调动机否认效果</p><p>反题：强调效果否认动机</p><p>合题：效果就是动机的体现</p><p>​这个合题是如何达到的？在辩证法里，“合题”不如说是“裂题”。辩证法不是把黑的白的放到一起搅合成灰的，而是看到问题本身的裂隙；看到被讨论的概念其自身的矛盾；看到概念超出形式规定的“内容”；看到问题本身所分裂出来的那个“更值得被问的问题”。</p><p>​这里的正题和反题一列出来，我们从形式上看，它们是水火不容的。但是这种“水火不容”当中暗含的预设是，动机和效果一点关系都没有。那么我们立马就要反应过来，动机和效果果真是没有一点关系的吗？动机是我们的认识，效果是我们的实践，我们要做到主观和客观、理论和实践、知和行的具体的历史的统一（毛泽东. 实践论，1937）， 因而，只有在实践中达到了预想的结果，人的认识才被证实了。换言之，只有文艺工作达到了预期的效果，才能说明文艺工作者的动机是清楚而没有偏差的。</p><p>​这样，矛盾的双方就被我们通过对双方概念的实际分析，综合而同一地统一起来了。可以这样说：辩证法就是对原问题的扬弃。</p><h2 id="阶级斗争的形式正在起变化——共产党宣言读后感"><a href="#阶级斗争的形式正在起变化——共产党宣言读后感" class="headerlink" title="阶级斗争的形式正在起变化——共产党宣言读后感"></a><center>阶级斗争的形式正在起变化——共产党宣言读后感</center></h2><p>​共产党宣言诞生的185年后，阶级斗争除了原来的形式之外，已经产生了新的形式。而当今的世界在普遍进入资本主义社会形态之后，俨然成为广大无产阶级和资产阶级最终的决斗场。</p><p>​但是通过广泛的矛盾转移的手段，当今阶级斗争的烈度已经达到一种低谷。而伴随着消费主义，出现的是资本主义新的现代统治形式。通过用景观社会取代商品社会，通过一种甜蜜的意识形态控制，消解主体的反抗性和批判性。在没有“你死我活”的斗争的情况下，人们是容易被这样的一种景观遮蔽的。人们只能单向度地盲从并丧失对本真的生活的渴望和要求。</p><p>​现代资本主义，同样生产穷人。这部分穷人必须是相对而言的，而不是赤贫，作为社会阶层的底层结构出现。与美轮美奂的景观社会不同，它们是被资本主义社会生产出来充当被比较对象的，其作用是为另外一些人提供比较而言的满足感。</p><p>​在一般的视角下，无产阶级是物质财富的生产者，资产阶级是消费者；而在辩证法的视角下，资产阶级俨然也是生产者：他们为社会生产一种上层的奢华的景观，和底层的悲惨的景观，供无产阶级和小资产阶级消费，实现对新的资产阶级的再生产，以维持这个体系。</p><p>​就更不用论证艺术、教育等意识形态宰制和高福利、政治体制等政治经济手段所带来的影响了。其中就以意识形态的影响最为深远，包括但不限于人性论、资产阶级的理论人道主义。在这些手段的影响下，有的人不相信共产主义；有的人认为自己能够跃升为小资产阶级或资产阶级。</p><p>​这与共产党宣言创作时期的背景已经相去甚远。但我们依然坚持马克思主义，依然不忘初心。因为我们能够认识到，这些转变其实是历史发展的内在症结，资本主义社会中诞生的一切都是资本主义自身的特殊性质带来的，正如资本主义诞生了无产阶级，作为扬弃资本主义自身的力量。所以我们并不惧怕这种斗争形式的变化，而是接受历史的必然性，把握这种变化，然后诞生新的理论与新的实践。这就是马克思主义的本来面貌：它不是在固定僵死的历史背景下的认识以及斗争方法，也不是给出一个放之四海而皆准的某种答案，而是告诉我们如何做突破历史的局限性的尝试，用普遍又特殊的分析方法分析具体的情景。</p><p>​马克思主义哲学的核心就在于，找到人自身所蕴含的革命性和解放性的力量。所以，与黑格尔将认识和实践作为绝对精神运动中的阶段相比，马克思主义哲学将实践抬到了最高的位置，这标志着人的直接现实的能动性被提到了最高的位置，从康德提“人为自然界立法”以来，人的实践理性在这里获得了最高的尊严。</p><p>​因此，我们要不忘初心，并且与时俱进，了解到当前世界资本主义的新的发展，斗争的新的形式与形势。并且发挥自己的能动性，去进行改造世界的实践。</p><p>​作为辩证唯物主义者，要时时感受到自己的新生。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Libido</title>
      <link href="/20231125-libido/"/>
      <url>/20231125-libido/</url>
      
        <content type="html"><![CDATA[<p> 什么是性欲？</p><p>一个只会对我造成烦扰的东西出现在视野中。</p><p>当我看到美丽且露骨的内容时，这一欲望即被激发出来。然而其满足却不仅仅是自身可以完成的。</p><p>拉康将做爱比作两个人各自的、以对方的身体为工具的手淫。但差错就出现在“有一个客体”那里。或者说是一种差距。无论字面上的分析再令人绝望、再透彻、再切中要害。</p><p>我们可以看出实际上上述的比喻只是在表达“性关系不可能”这一命题。从孤立的主体视角看自然是如此。然而我并不可能因此而批判精神分析为一种孤立的片面的学说，即使这多半是出自一种信念。因而要解读其真意；或是说探究性爱的真正内容，只能认为此处所采用的言辞仅仅是一种临时的阐明之用。</p><p>手淫和做爱的确是又差异的。这一差异不在别处，而正在于完成这一目的的手段、客体，是真实的人（而非工具化的人）。</p><p>而这一个人的作用在于何处？一则实在的感官的体验，二是意识的想象作用。在手淫中，我们尚且可以作有限而贫乏的想象。三是反馈，或是说，建立起想象的“协同性”。</p><p>所以要采用分析的方法，考察做爱之所以为做爱，其中不可缺少的部分是什么。换个说法即为，去掉一些要素，直到剩下某些要素，但凡再去掉其中之一，便不可想象此种性爱能够作为一种性爱。正如直观不可能以没有广延的形式而称为一种直观。</p><p>答案自然是那个存在于想象中的协同。正如性伴侣的不应便得性爱索然无味。失去交互的作用，人根本无法称其自己是处于某种性爱当中。通过当下存在的“另一个”来确证我自己处于这样的享乐结构当中。</p><p>“给点反应行不行”。大约如此。人仿佛能感受得到对方的欲望，尽管它不一定是对方所想的那样，这就是想象的作用了。</p><p>故精神分析的批判重点实则是表达“想象的协同性”的荒谬。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>timing</title>
      <link href="/20231116-timing/"/>
      <url>/20231116-timing/</url>
      
        <content type="html"><![CDATA[<p>可喜可贺，作业都交上了</p><p>从现在开始就是组会时间。。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关关难过关关过</title>
      <link href="/20231115-hurdle/"/>
      <url>/20231115-hurdle/</url>
      
        <content type="html"><![CDATA[<p>尽力做好，不论结果。</p><p>总是要熬完的，硬着头皮也得上。</p><p>研究生有几个人从没失意过呢？那些博士生的心理素质也强多了。也不是。他们面对更加严重的问题也能走下去。</p><p>想想那些每天都和导师交锋的人，不也都活得好好的。黄开乐不也很厉害，所以不要一次的状况比较危急就大惊小怪。</p><p>关关难过关关过；桥到船头自然直。</p><p>讲什么内容呢？进展不多，有了解其他工作。</p><p>1、相关工作：CrystalBall MaceMC MODIST DEMETER。对比，摘出可用的。由此找到这份工作的位置。</p><p>2、被测系统、协议选型</p><p>上次找了一个C实现。我们的优点体现在 ①有状态②非侵入，不修改③尽可能的通用化</p><p>3、系统设计进展（Coding）</p><p>时间的生成 - 根据执行的进程，与 Choose().  Stateless？之后就都是工程问题。</p><p>4、拿出设计的文档</p><p>5、代码暂未释出 - 先拿出来，放一个仓库。之后再来跟进</p><p>另外是，关于 Time 的产生，应该是一个重点。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组会前时间表</title>
      <link href="/20231114-timing/"/>
      <url>/20231114-timing/</url>
      
        <content type="html"><![CDATA[<p>要点：</p><ul><li>分布式系统作业 - 还挺简单的 - 2h</li><li>软件分析作业 - 今晚搞定</li><li>程序设计语言的形式语义作业 - 还挺简单的 - 2h</li><li>（16日）ISER proposal - 组会开完之后马不停蹄</li><li>组会</li></ul><p>11.14 </p><p>19-24 软分</p><p>11.15</p><p>0-6 休息</p><p>6-8 组会</p><p>8-10 SEM</p><p>10-12 dissys</p><p>12-13 休息</p><p>13-24 组会</p><p>11.16</p><p>0-7 休息</p><p>7-13 组会</p><p>13-14 休息</p><p>14-16组会</p><p>16-24 iser</p><p>总计：20小时组会准备 </p><p>8 + 2 + 2 + 5</p><p>每天都有7小时休息</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK 中期报告草稿</title>
      <link href="/20231107-dmckMID/"/>
      <url>/20231107-dmckMID/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><p>科研选题：基于 ptrace 实现的适用于分布式系统测试的操控执行框架</p><h3 id="1-1-研究背景"><a href="#1-1-研究背景" class="headerlink" title="1.1 研究背景"></a>1.1 研究背景</h3><p>分布式系统运行的过程中往往会出现大量不确定性的因素。在多个节点上运行的进程协同工作，会产生通信、调度上的偶然变化，构造分布式系统的时候往往无法穷举这些情况，程序的异常处理不完善导致系统潜在的崩溃可能。并且在错误发生之后，引发问题的执行路径通常难以还原，导致最终定位不到问题所在。</p><p>面对这一问题，通常的做法是模型检测。使用 TLA+ 等形式化验证工具对分布式算法进行建模。然而，面对真实而复杂的系统实现，强行使用形式化的方法进行建模则面临着困难的约简：约简过多，则与实际系统偏差越远；约简越少，则执行的分支越多，容易出现“状态爆炸”的问题。</p><p>为了解决上述问题，Mandanlal 等人提出了 CMC，一个用于直接对代码进行模型检测的执行框架。在工作中，他们对一个 ad-hoc 网络协议 AODV 的三种实现进行了模型检测。Junfeng Yang 等人提出了 eXplode 对文件系统进行穷举式的测试。后提出了一个在 Windows 上对实现级的分布式系统进行透明的模型检验的 MoDist 框架。类似的工作还有 MaceMC、CristalBall 等。</p><h3 id="1-2-ptrace-简介"><a href="#1-2-ptrace-简介" class="headerlink" title="1.2 ptrace 简介"></a>1.2 ptrace 简介</h3><p>ptrace 是 Linux 内核提供的进程跟踪的系统调用，它允许父进程检查和替换子进程的内核镜像（包括寄存器）的值。</p><p>子进程调用 ptrace(PTRACE_TRACEME) 且父进程调用 ptrace(PTRACE_SEIZE) 后，父进程即可对子进程的执行进行控制：在子进程进行系统调用前或系统调用返回后停止；获取子进程系统调用信息；读写子进程内存和寄存器的值；模拟系统调用执行等。通过几种基本操作，能够实现程序的确定性执行。</p><h2 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2 系统设计"></a>2 系统设计</h2><p>单线程程序从一个特定的状态出发，其状态转换分为两类。一是进行系统调用，对操作系统对象进行创建、删除、读写；二是系统调用以外的运算逻辑。对于第二类而言，其代表的状态转换是确定性的，即给定进程状态和代码，执行代码达到的目标状态是唯一确定的；对于第一类而言，则状态转换还要取决于操作系统对象的状态。比如同样执行 read() 系统调用，如果文件的内容正同时被其他进程改变，则产生的结果不确定。</p><p>在多线程程序以及分布式系统中，由于其由多个独立执行的程序组成，因而其执行路径还受到各执行流之间的调度的影响。 </p><p>因此，为了对分布式系统进行模型检验，首先需要穷尽系统调用的可能结果；同时穷尽系统所有节点的各操作执行的先后顺序。</p><h3 id="2-1-整体框架"><a href="#2-1-整体框架" class="headerlink" title="2.1 整体框架"></a>2.1 整体框架</h3><p>对于 n 个节点的分布式系统，我们用 n + 1 个进程进行整个系统的操控执行：</p><ul><li>一个 tracer 进程，用以控制所有的进程</li><li>n 个 tracee 节点进程，即受控运行的分布式系统</li></ul><p>以 3 个节点为例，对于一个运行中的分布式系统，其状态为 $S&#x3D; &lt;Env, Node1, Node2, Node3&gt;$，其中：</p><p>$Node$N$ 代表节点的状态，包括节点的堆、栈、寄存器。</p><p>$Env$ 代表节点之外的环境，包括被节点使用的操作系统对象的状态，如网络消息，系统时间，打开的文件等。</p><p>在分布式系统执行的过程中，能够引发状态不确定性的分歧操作包括：消息的先后顺序，消息是否到达，以及消息等待是否超时。</p><p>tracer 进程每次从一个状态 $S$ 开始控制其中一个节点，运行到下一个分歧操作前，即：消息发送前，消息接受前，以及请求系统时间之前。之后对于每一个节点，都由 Choose() 函数根据运行时的上下文决定下一个分歧操作可能的状态转换集合$Transfer$，且对于每一种可能性 $t \in Transfer$，生成如下的“转换边”：  $(Node$N.t(), &lt;Env, Node1, Node2, Node3)&gt;)$ </p><p>它表示，状态的下一次转换从状态四元组出发，通过 $Node$N$ 执行 $p()$ 所代表的转换可达到下一个状态：</p><p>$(Node$1.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’, Node1’, Node2, Node3)&gt;$ </p><p>$(Node$2.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’, Node1, Node2’, Node3)&gt;$ </p><p>$(Node$3.p(), &lt;Env, Node1, Node2, Node3)&gt;)\rightarrow &lt;Env’’’, Node1, Node2, Node3’)&gt;$ </p><p>总的工作流程是：设置一个状态转换边的队列；每一次从中取出一条边并执行达到新的状态，在新的状态的基础上，生成新的转换边并入队。</p><p>对于 DMCK 的实现有两种，一种是 stateful，即通过保存和恢复节点的内存、寄存器等信息来重现状态；一种是 stateless，通过重放记录的执行路径来重现状态。我们的工作主要是 stateful 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S = &lt;Env, Node1, Node2, Node3&gt;</span><br><span class="line"></span><br><span class="line">q.add(Edge(skip, S))</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">    edge = q.deque()</span><br><span class="line">    S&#x27; = edge.transfer()</span><br><span class="line">    forall (node in Nodes) &#123;</span><br><span class="line">        // 只根据 node 的状态就可以算出当前执行上下文了</span><br><span class="line">    Transfers = Choose(node)    </span><br><span class="line">    forall (t in Transfers) &#123;</span><br><span class="line">    q.add(Edge(t, S&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def transfer(edge) &#123;</span><br><span class="line">S = edge.getState()</span><br><span class="line">t = edge.getTransfer()</span><br><span class="line">node = t.getNode()</span><br><span class="line">nodeState = S.getNodeState(node)</span><br><span class="line">nodeState.t()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-相关工作"><a href="#2-2-相关工作" class="headerlink" title="2.2 相关工作"></a>2.2 相关工作</h3><p>CMC 是一个 stateful 的模型检测工具，能够对 C 代码直接进行模型检测，被用于检测网络协议和文件系统（FiSC）。但是 CMC 的检测需要侵入式地修改源程序代码，以使得被测程序运行在 CMC 的地址空间内。</p><p>MaceMC 使用深度优先搜索和随机行走来检测网络协议实现中的 liveness 问题，但是被测系统需要是 Mace 生成的 C&#x2F;C++ 实现。Yabandeh 等人基于 MaceMC 提出的 CrystalBall 增加了 Steering Execution，在运行的过程中分析未来的错误状态，并通过控制执行来避免。</p><p>Yang 等人提出的 MoDist 是一个适用于 Windows 上的分布式系统的模型检测框架。它与 MaceMC 一样是 stateless 的。</p><h3 id="2-3-目标场景（与相关工作不一样的）"><a href="#2-3-目标场景（与相关工作不一样的）" class="headerlink" title="2.3 目标场景（与相关工作不一样的）"></a>2.3 目标场景（与相关工作不一样的）</h3><ul><li>支持对 go 语言编写的程序进行检测</li><li>stateful，不用每次都从头开始控制获得最新状态（节省运算性能，可能更占用空间）</li><li>无侵入性（不用修改实现的源码）</li></ul><h2 id="3-被测案例"><a href="#3-被测案例" class="headerlink" title="3 被测案例"></a>3 被测案例</h2><h3 id="3-1-计数器"><a href="#3-1-计数器" class="headerlink" title="3.1 计数器"></a>3.1 计数器</h3><p>被测的程序是 3 个独立的递增计数器，由 tracer 同时控制其运行，能够生成并执行 3 个进程的全部可能的调度顺序。</p><h3 id="3-2-client-x2F-server"><a href="#3-2-client-x2F-server" class="headerlink" title="3.2 client&#x2F;server"></a>3.2 client&#x2F;server</h3><p>客户端定时向服务端发送心跳消息，服务端每次收到心跳消息就刷新计时器，若超时则打印一条超时信息。tracer 通过调度顺序以及虚拟时钟模拟延迟，通过截获网络的调用模拟丢包，进行错误注入。</p><h3 id="3-3-共识"><a href="#3-3-共识" class="headerlink" title="3.3 共识"></a>3.3 共识</h3><h4 id="3-3-1-编程作业"><a href="#3-3-1-编程作业" class="headerlink" title="3.3.1 编程作业"></a>3.3.1 编程作业</h4><h4 id="3-3-2-开源案例-待测"><a href="#3-3-2-开源案例-待测" class="headerlink" title="3.3.2 开源案例(待测)"></a>3.3.2 开源案例(待测)</h4><p><a href="github.com/willemt/raft">github.com&#x2F;willemt&#x2F;raft</a> 是一个 C 实现的 Raft 共识协议。其优势在于单线程，且本身没有指定通信方式。数据发送与接收的接口在 raft 运行实例启动时由使用者通过注册回调函数自定义，因而可以自由选取节点间的通信协议。</p><p>TODO: 另选取一个 go 语言的实现。</p><h2 id="4-实现方法"><a href="#4-实现方法" class="headerlink" title="4 实现方法"></a>4 实现方法</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十周工作重点</title>
      <link href="/20231107-work/"/>
      <url>/20231107-work/</url>
      
        <content type="html"><![CDATA[<p>列举一下本周工作：</p><ul><li>软件分析A4</li><li>Semantic作业</li><li>PL作业</li><li>ISER proposal</li><li>DMCK main</li><li>…</li></ul><p>其他方面的就不在这里写了。现在是14：32，到19：00还有270分钟。我们抓紧把DMCK多搞一点。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>仔细地考察一下皮肤问题的解决</title>
      <link href="/20231103-skin/"/>
      <url>/20231103-skin/</url>
      
        <content type="html"><![CDATA[<p>前情提要：</p><p>作息饮食和锻炼是正道。仅为应急处理方法</p><p>痤疮是<em>一谱系疾病</em>，从微粉刺到广泛瘢痕的聚合性痤疮。</p><p>在正常的代谢过程中，毛囊皮脂腺导管上皮细胞脱屑，皮脂腺分泌皮脂，皮脂携带脱屑从毛囊口排出，其中可含有大量的皮肤正常菌群，如痤疮丙酸杆菌、需氧葡萄球菌及马拉色菌等。</p><p>痤疮是一种具有损容性的毛囊皮脂腺的慢性炎症性皮肤病。</p><p><strong>一、生理性粉刺</strong></p><p><strong>1. 微粉刺</strong></p><p>微粉刺是全部痤疮损害的基础，肉眼不可见。微粉刺在表皮下继续演变发展成肉眼见的痤疮皮疹大约需8周时间</p><img src="v2-489e9e6ad71fac7870e500e8f233813d_1440w.webp" alt="img" style="zoom:33%;"><p>毛孔内部存在明显的导管角化过度和由此引起的毛囊皮脂腺导管的堵塞，形成微粉刺。</p><p><strong>2.</strong> <strong>白头粉刺</strong></p><p>白头粉刺又称封闭性粉刺(Closed Comedo)，由微粉刺发展而来。外观为皮肤表面出现的白色稍隆起的小疙瘩。皮损为针尖到针头大小灰白色球形小丘疹，类似粟丘疹。肉眼看不到毛囊开口部，只有当皮肤被过度的伸拉时，才可以看到，并可挤压出白色糊状物。</p><img src="v2-290187a0ce5b2ee51bfba121d5a7eb6b_1440w.webp" alt="img" style="zoom:33%;"><p><strong>3.</strong> <strong>黑头粉刺</strong></p><p>黑头粉刺(blackhead)又称开放性粉刺(open come-do)由白头粉刺发展而来，或直接来源于微粉刺。外观为明显扩大的毛孔中的小黑点，略高于皮面或与皮面平行，可挤出乳白色的豆腐渣样的粉刺栓。开始暴露的角栓头小于1mm，随着毛囊口的扩大，暴露越多，一些可达5mm。</p><p><img src="v2-e8c8fb61a2e71e39b005ee19a59b8cbf_1440w.webp" alt="img"></p><p><strong>二、炎症性痤疮</strong></p><p><strong>1. 丘疹性痤疮</strong></p><p>丘疹性痤疮(papules)由白头粉刺发展而来。随着白头粉刺扩张，毛囊皮脂腺导管破裂，导致炎性损害的形成，位置较深的粉刺破裂可以形成丘疹。皮肤表面为红色坚实丘疹，一般为米粒到绿豆大小，暗红色，顶端略尖而稍硬的小丘疹，有的丘疹中心可有黑头粉刺或顶端未变黑的皮脂栓。</p><p>丘疹是痤疮最基本损害，具有代表性的损害。</p><img src="v2-5172635ae79d396d6aa0c01fdb593b6d_1440w.webp" alt="img" style="zoom: 25%;"><p>丘疹性痤疮 图5-1</p><p><strong>丘疹性痤疮病理显示：</strong>在毛囊漏斗部闭塞的情况下，形成毛囊皮脂腺内缺氧的环境。厌氧性痤疮丙酸杆菌大量繁殖，分解皮脂，产生化学趋化因子，白细胞聚集而发生炎症性丘疹。</p><img src="v2-13a1294d6cca3c94c106d5f103c7b941_1440w.webp" alt="img" style="zoom:33%;"><p>丘疹性痤疮病理示意图 图5-2</p><p><strong>2.</strong> <strong>脓疱性痤疮</strong></p><img src="v2-7d6adb5c9c6719e56d39976eec795b96_1440w.webp" alt="img" style="zoom:50%;"><p>脓疱性痤疮 图6-1</p><p>脓疱性痤疮(pustule)由白头粉刺发展而来。 随着白头粉刺的扩张，毛囊皮脂腺导管破裂，导致炎性损害的形成。脓疱多位于丘疹顶端，可以像豌豆大小或更大。如果损害较浅，突出于表皮，几天内脓疱破裂，脓液排出，可见粉刺栓与脓液流到皮面皮肤愈合且没有瘢痕的形成。如果是丘疹性痤疮的继发感染，则脓疱较深，可以引起凹陷性疤痕或瘢痕疙瘩。</p><p>脓疱还可以形成几种转归，上皮重新角化过度，炎症后粉刺继续生长，内容物往往排到深层组织，引起广泛而严重的炎症反应。继发的粉刺比原损害大，可以重复破裂形成大的囊肿。</p><p><strong>脓疱性痤疮病理显示：</strong>在封闭的毛囊皮脂腺结构中大量中性粒细胞被游离脂肪酸和白细胞趋化因子吸引过来，消灭、吞噬痤疮丙酸杆菌，发生剧烈炎症反应，白细胞形成脓细胞，形成脓腔，腔内还可以看到坏死、脱落的毛囊组织。</p><p><img src="v2-97e1dea84db1c2ffda9fd12c9e0682ad_1440w.webp" alt="img"></p><p>脓疱性痤疮病理示意图 图6-2</p><p><strong>3. 结节性痤疮</strong></p><p>结节性痤疮(nodule)由丘疹脓疱性痤疮发展而来。丘疹脓疱性痤疮的炎症继续扩大深入，则于皮下形成大小不等的淡红色、暗红色或紫红色厚壁的结节。通常位于面颊上部的两侧以及关节活动区域的前后。</p><p>损害一般位置较深，可高出皮面呈半球形或圆锥形隆起，也可不高出皮面，基底有明显的浸润、潮红，触之有压痛。结节范围较大，一个大的结节可包含几个毛囊和粉刺。直径5～10mm的结节称为小结节，大于1 cm称为大结节，有的结节常达到2～3cm。结节刚开始较坚实，周围很红，以后可变软，表面还可破溃形成出血性痂。此种损害可持续数月，或以后逐渐吸收，或化脓破溃形成瘢痕。</p><p><img src="v2-8e025974c5ab8537fdb481ab0d6d709d_1440w.webp" alt="img"></p><p>结节性痤疮 图7-1</p><p><strong>结节性痤疮病理显示：</strong>在脓疱的基础上，毛囊皮脂腺内大量的角质物、皮脂、脓细胞堆积，大量皮脂排不出去，引来大量中性粒细胞，吞噬、消火痤疮丙酸杆菌，炎症较剧烈，部位又较深，使毛囊皮脂腺结构破坏。结节结节多为两个或两个以上毗邻的粉刺破裂融合而成。包含的毛囊、血管、神经和汗腺等结构被完全破坏，损害内可有出血或渗出的血清，并可见残存的毛发和角化物。损害中出现大量的异物巨细胞，以后逐出现早核细胞和组织细胞。</p><img src="v2-3804cbef221a4d01b8e9ce19cd78baf6_1440w.webp" alt="img" style="zoom:33%;"><p>结节性痤疮病理示意图图7-2</p><p><strong>4. 囊肿性痤疮</strong></p><p>囊肿性痤疮(acne cystica)由结节发展而来，是最轻的聚合性痤疮，皮损主要为大小不等的囊肿，囊肿表现为光滑、圆顶、稍高出皮肤的圆形或是卵圆形结构，质软，挤压时有波动感，直径常为1 cm左右，呈暗红或正常皮色。该皮损常较结节易破裂，破裂后形成出血性痂。囊肿多侵犯患者的背部，会出现于面、颈和项部。以后可以发生很明显的瘢痕，甚至成为瘢痕疙瘩。有时可继发化脓菌感染，破溃后流脓，常经久不愈，可持续5～10年。</p><img src="v2-81edcb8a3da6c25bab632d105618906f_1440w.webp" alt="img" style="zoom:33%;"><p>囊肿性痤疮 图8-1</p><p><strong>囊肿性痤疮病理显示：</strong>在结节的基础上，毛囊皮脂腺结构内大量脓细胞的聚集，剧烈的炎症把整个毛囊皮脂腺正常结构破坏掉，形成固态或液态的物质聚积，既有脓液、细菌残体、皮脂和角化物，又有炎症浸润。较深部位的囊腔里的内容物逐渐地向皮肤表面移动，最后穿破皮肤，排出内容物。其排出物所经过的通道形成纤维化的管道，形成瘘管。单纯性囊肿性痤疮往往无化脓或轻微化脓。</p><img src="v2-7d5634d6af1230e8cde57e5f1559d438_1440w.webp" alt="img" style="zoom:33%;"><p>囊肿性痤疮病理示意图 图8-2</p><p><strong>三、瘢痕</strong></p><p>瘢痕分为两种：</p><p>（一）萎缩性瘢痕，如冰渣样瘢痕、纤维凹陷性瘢痕、萎缩性斑疹、毛囊性斑状萎缩、毛囊周围弹力纤维变性性瘢痕。</p><img src="v2-87bafdde28775e1fff7d522bf6571680_1440w.webp" alt="img" style="zoom:33%;"><p>瘢痕 图9-1</p><p><strong>萎缩性瘢痕病理显示：</strong>表皮层甚至真皮层缺失，胶原组织的萎缩，局部纤维化，弹性纤维消失等。</p><p>萎缩性瘢痕病理示意图</p><img src="v2-4a703c00e3ce08b9d64195a9a002b46f_1440w.webp" alt="img" style="zoom:33%;"><p>图9-2</p><img src="v2-40d819ea29a9440ba4c2eb1b8efd9d8e_1440w.webp" alt="img" style="zoom:33%;"><p>图9-3</p><img src="v2-efcf27ce5c2622152ab4df083223f599_1440w.webp" alt="img" style="zoom:33%;"><p>图9-4</p><p>（二）增生性瘢痕，如瘢痕疙瘩、软化瘢痕等。</p><p>增生性瘢痕</p><p><strong>增生性瘢痕病理显示：</strong>胶原组织增生。</p><p>至此各位应该已经对什么是痤疮以及痤疮的类型有了较为系统的了解，下篇将为各位痘友详细介绍痤疮的病因和影响因素，有兴趣的小伙伴可移步下篇。</p><p><img src="v2-8b7d3e79b1de31402226e6e62464f443_r.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随便写写</title>
      <link href="/20231103-dontknow/"/>
      <url>/20231103-dontknow/</url>
      
        <content type="html"><![CDATA[<p>有能力打开20把锁的钥匙。</p><p>我现在实在是想象不到被一段感情拴着有多恐怖。</p><p>并不是说我不能够专一。我只是希望两个人在一起就随意一点，不要没事摆个批脸质问对方为什么没做到什么什么。。。</p><p>我只能handle这种关系。我对人的控制欲是0，希望能将心比心，不要来对我施加控制。</p><p>有点要买的东西</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>适莽苍者</title>
      <link href="/20231101-clothes/"/>
      <url>/20231101-clothes/</url>
      
        <content type="html"><![CDATA[<p>（后录入的时候，已经找不到日期了）</p><p>适莽苍者，三餐而反，腹犹果然。</p><p>脑子里突然浮现就写下来了。（现在想想，从那个时候开始，我就一直特别喜欢逍遥游）</p><p>现在是下午4点，工作仍未开始。我仍未知道什么时候开始讨论。看来今晚是不能寐了。</p><p>大概成了整个办公室通宵次数最多的那个。。。虽然也没干什么。</p><p>发现自己在以往对自己外形上的需求（主要是服装上）克扣得太多了。应该更多地花钱去试衣服，不行可以退了。以前没有这样的意识导致真的看衣服的时候也没什么眼光。所以稍微定点小目标，每个月都要看看有没有合适的衣服可以买的。</p><p>目前的主基调是休闲的正装，面料一般、有点设计感，略显随意的西装、衬衫，etc.</p><p>还有风衣。不过这个如果料子不好会更有廉价感，除非设计特别在线，否则千万不要被卖家秀蒙蔽了。</p><p>等周一周二看看上身效果怎么样，尤其是那条裤子。</p><p>很麻烦，不想工作，但也没什么别的事可干（也不是）。可能还是上班更适合我。</p><p>但是因为要工作又不敢着手干别的事，闭环。寄了！</p><p> 一不小心走捷径是最危险的状态，拖延症大概是在趋利避害。寄！</p><p>摸鱼、不停地摸鱼。</p><p>记下来，写代码之余就是写文档，应该是不容有失。先画个靶子：</p><p>基本完成进程关停与启动的重写；能够真正搞定恢复与路径还原；基本实现 Choose()；实现一个 easy 的网络模型（支持 server&#x2F;client 操作）</p><p>暂时，不用去管时间。完成被测系统的选型。在此基础上，完成已完成部分的技术文档。</p><p>具体来说，是进程地址空间的dump和 fd 的恢复。</p><p>重要的是做出一个可交互的操作模式，比如人工选进程去运行。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不知道该咋整</title>
      <link href="/20231031-untitled/"/>
      <url>/20231031-untitled/</url>
      
        <content type="html"><![CDATA[<p>刚tmd到工位。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>置之死地</title>
      <link href="/20231030-death/"/>
      <url>/20231030-death/</url>
      
        <content type="html"><![CDATA[<p>「置之死地」</p><p>对于地球的千万种生命，乙醇足以致命。腐败的食物中散发出的发酵气息昭示着凶险。 为了取得生存必需的养料 ，动物进化出了脱氢酶。而人类作为最特殊的那一个，甚至发掘其作为快感来源之一。</p><p>酒——aqua vitae——生命之水，是一种让人「接近死亡」的饮料。完全醉酒前的回光返照，则是人主观意识最接近活着的时候。玻璃瓶中的酒只需一饮而尽，而后迸发的是生命的极致体验——濒死感。</p><p>鲜花易逝，有好事者摘取并作为装饰，生命即进入倒计时，仅能在短期内绽放。</p><p>我们都是要将自己燃尽的。</p>]]></content>
      
      
      <categories>
          
          <category> 观点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>心想事成</title>
      <link href="/20231030-willing/"/>
      <url>/20231030-willing/</url>
      
        <content type="html"><![CDATA[<p>「心想事成」</p><p>有一个古老的关于戒烟的传说。戒烟的人在决定戒烟的那一刻就要想着：「我已经戒烟了」，而不是想着「我从今天开始戒烟」。</p><p>这不是简单的心理暗示。</p><p>我已经戒烟了。从此抽烟没有任何借口。而当实在忍不住去抽了一根的时候，也并不意味着戒烟这件事宣告破产。嘬两口，弹弹烟灰，再掐灭它，继续埋头戒烟。</p><p>饭桌上朋友发你一根：</p><p>你摇摇头说「我正在戒烟」，朋友会劝你「哎呀就一根，不影响你戒」，你会动摇「是啊，慢慢戒呗，少抽点没事的」。</p><p>你摆摆手说「我早就戒了」，朋友会羡慕「哎呀真厉害，你怎么戒的」，你会骄傲「说戒就戒了，有什么难的」。</p><p>最忌讳的想法是从客观的角度审视自己「戒烟失败」，进而思想上滑了坡：抽一根已经失败，抽一包一条也是失败，不如抽个爽。</p><hr><p>在情绪的泥沼里无法自拔的人，尽管他们想摆脱——至少表面上如此；尽管他们有所行动——至少从外界看来，已经足够努力。但一次又一次只是同一个模式的循环。</p><p>这种死结消除不了的根本原因在于，人根本「不愿意」去消除。恰恰相反，他们以这个无限循环的死结产生的创伤为养料，维持着一个想象性的自我认同。就像胎记标示着一个独一无二的人一样。</p><p>「什么档次，竟然敢称理解我」。于是任何理解都被否认。「你根本就不懂」。</p><p>每个人都用同种可悲的方式，维持着自我。于是并不是不可接受。</p><p>但是想要破解此局并不困难，只需要问两个问题：</p><p>谁规定了什么叫放下？——我说我放下了，别人可能觉得不是，那是别人的事。</p><p>凭什么要放下？——就好像放不下是什么难以启齿的事，就好像放不下会毁了一辈子，其实根本无伤大雅。</p><p>将评判的标准交由所谓客观理性，那么总有一个角度能给出否定的论证。只有收回决定和判断的权利，才有可能实现主观的意愿。</p>]]></content>
      
      
      <categories>
          
          <category> 观点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么喜欢纸笔</title>
      <link href="/20231020-bridge/"/>
      <url>/20231020-bridge/</url>
      
        <content type="html"><![CDATA[<p>今晚是约定的采访日。总得来说只要随意点就完事了，虽然还是不懂主题到底是什么。</p><p>下周二要去打耳桥。另外得陪人去查双相障碍。不过我也没准备好：如果查出来真的有，那我该怎么处理？</p><p>首先是劝她把结果告诉家里，毕竟她大部分时间都是脱产在家。如果她当场情绪比较强烈呢？那稍微喝两口，是否有点危险。。。最后就是必须送到家。</p><p>耳桥是打左耳还是右耳？可能我左侧对人的时间要多一些，放右边吧，因为我总是要摸左耳。</p><p>面对纸笔，我至少能够表达。原因的一部分也许是：我真的想看到好看的手写内容。有“书写”的过程来分散注意力，以至于无意识可以自如地流淌。而我又并不能投入注意到键盘输入的过程。“审美”与“理性”同时进行时候的我活跃的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一版置顶Archive</title>
      <link href="/20231017-top/"/>
      <url>/20231017-top/</url>
      
        <content type="html"><![CDATA[<p>只要是我在电脑里写下的文字，除了少量牵扯到对其他人的看法的，几乎都会在这里出现。</p><p>我是一个看起来很正常的不正常的人。经常喝酒，轻度抽烟。喜欢花但是不太懂，养一些容易养活的盆栽，不过不想花太多精力。</p><p>正在努力学习调酒；并且努力取得练习调酒的经济条件。毕竟一瓶一两百的酒要比两块多的可乐要难获取得多。以低价格经营着一家宿舍内的酒吧；当然也可以做外送。</p><p>我用右耳的人体的穿刺警示着来往的人；尽管所有人都觉得我的性格没什么问题——甚至可以说性格极好。但经过23年的人生短跑，我知道自己可以对朋友很好，但完全没有耐心去搞这个年代里时兴的那种亲密关系。</p><p>我否认所有对爱情的普遍的模式化的定义：“爱谁就该怎么做”；我否认爱情中可以存在两个人：爱情顶多是两个人各自的爱情，其指向也不是别的，而正是与对方的身形刚好错位的幻影；我否认爱情是“崇高”、“神圣”的：不要拘泥于外界的灌输影响下你对爱情的各种幻想，爱情顶多是“独特”的。</p><p>我会认真思考每一个社会契约中的隐含条款，并在不逃避责任的情况下享受权利；或是通过<strong>拒绝行使权利与拒不承担责任</strong>来表达我对该条款的抗议。所以请不要通过<strong>附加隐含条款的“好意”</strong>将压力给到我头上。</p><p>有任何要求，任何疑惑，任何不满：</p><h1 id="讲。"><a href="#讲。" class="headerlink" title="讲。"></a>讲。</h1><p>我从来都不生气。请不要再当谜语人了。</p><p>2023-10-17</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件分析A1 实验前后</title>
      <link href="/20231017-taieA1/"/>
      <url>/20231017-taieA1/</url>
      
        <content type="html"><![CDATA[<p>虽然我赶时间，但还是要小心地对待这个作业。</p><p>看看 tai-e 的结构：我们这次要关注的有哪些？</p><p>要提交的包括</p><ul><li>LiveVariableAnalysis.java</li><li>Solver.java</li><li>IterativeSolver.java</li></ul><p>活跃变量分析，solver，和递归求解器</p><p>我估计：</p><p>活跃变量分析调用递归求解器，递归求解器调用求解器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LiveVariableAnalysis &#123;</span><br><span class="line">public SetFact&lt;Var&gt; newBoundaryFact(CFG&lt;Stmt&gt; cfg);</span><br><span class="line"></span><br><span class="line">public SetFact&lt;Var&gt; newInitialFact();</span><br><span class="line"></span><br><span class="line">public void meetInto(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target);</span><br><span class="line"></span><br><span class="line">public boolean transferNode(Stmt stme, SetFact&lt;Var&gt; in, SetFact&lt;var&gt; out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IterativeSolver::doSolveBackward();</span><br><span class="line"></span><br><span class="line">Solver&lt;Node, Fact&gt;::initializeBackward();</span><br></pre></td></tr></table></figure><p>我做完了，事实证明我全猜反了</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>债</title>
      <link href="/20231017-publishversion/"/>
      <url>/20231017-publishversion/</url>
      
        <content type="html"><![CDATA[<p>爱不生债。谁也不欠谁的。若我自认欠债，则将对方至于隐形放债人的不义地位。反过来也如此。</p><p>我认真地考虑在自己的身上添加一个警示标志，以表示我并非正常人，并没有任何正常恋爱的可能。因而劝退不能理解我的所谓“正常人”。</p><p>每个人都反常，只是他们不自知罢了。</p><p>此种表达的徒劳无功——并非错误，而是从歇斯底里的质问中得到沉默的响应，并转而求诸自身。</p><p>我决定这个月就去打耳桥。</p><p>有说点什么的冲动，但是已经不知道该说什么了…每次面对纸笔就充满表达欲，面对屏幕则立即消失了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迎新讲话</title>
      <link href="/20231014-talk/"/>
      <url>/20231014-talk/</url>
      
        <content type="html"><![CDATA[<p>当然也不尽然是在写讲稿。主要是思路。</p><p>要求：讲一讲怎么在大学里面过得舒服。侧重生活、生活与工作分离这些内容。让大家放下心来，缓解小年轻们的焦虑。</p><p>此外，需要幽默有梗一点，不要太绷着</p><p>首先声明，我们这个根本不算是脱口秀。</p><p>所有内容仅代表个人观点</p><p>任何商品请从正规网站购买</p><p>不要贪图低价商品</p><p>只要坚持认为自己不可能这么幸运，就可以避免90%诈骗</p><h2 id="一个本科生的自我修养：心态"><a href="#一个本科生的自我修养：心态" class="headerlink" title="一个本科生的自我修养：心态"></a>一个本科生的自我修养：心态</h2><h3 id="你先别急"><a href="#你先别急" class="headerlink" title="你先别急"></a><del>你先别急</del></h3><p>因为急也没用。</p><p>我们的社会总是要求大家在20多岁的时候得到30多岁的时候的东西。</p><p>事业、思想成熟、<del>爱情</del></p><p>大家自己没啥事也都喜欢拿这些事pua自己。</p><p><strong>建议在看到别人有什么的时候，仔细想想他有的东西是不是那么个事儿</strong></p><p>没有什么东西是天经地义地“就是好”的。要根据自己最深刻的愿望形成价值观。</p><p><strong>如果你反复问自己，我到底要的是什么？</strong></p><p>我想要钱-&gt;我要的其实是金钱带来的丰富的物质生活，而钱只是一个中介罢了-&gt;丰富的物质生活？什么算丰富？谁规定的？-&gt;我要的明明是那个理想，为什么最后都落到money上？-&gt;有钱只是社会对我的期许罢了。</p><p>我想要成功-&gt;怎么算成功？依然是社会的期许？</p><p>社会不期许你有钱、成功…只要对社会有用，一点微小的作用。</p><p>人不可避免地要“生产”某些东西。总有人会享受到你创造的价值，而人能够通过生产这些有价值的东西感到满足。</p><p>&#x3D;&gt;只有那些兜售成功学的人才会希望你向往成功（是的，他们甚至都不希望你成功）</p><p>手段是多种多样的。做出科研成果，投入到现实应用中是一种；进行知识分享，让他人也获得知识；生产可供消费的商品与服务同样也是。</p><p>喜欢做菜的人学炒菜&#x3D;&gt;大家都很喜欢吃。</p><p>​</p><p>多花点时间，好好考虑，自己到底喜欢什么。</p><p>过得从容一点。</p><h2 id="大学生存指南"><a href="#大学生存指南" class="headerlink" title="大学生存指南"></a>大学生存指南</h2><p>工作生活分离。生活区域（特指宿舍）就要有生活气息。</p><p>——只有我工作时间摸鱼，杜绝休闲时间加班。</p><p>足够的照明（多买点灯装点一下）、 适量的书（当然全是书也行）、个人电脑&#x2F;显示器。</p><p>卫生打扫干净， 住起来会更惬意<del>（仙林的水泥地面超容易起灰简直没法住）</del></p><p>合适的装饰：绿色植物，花卉，购买的&#x2F;自制的手工艺品，瓶瓶罐罐；运动装备；喜欢的海报；etc</p><p>生活电器：咖啡机&#x2F;电热锅&#x2F;烤面包机&#x2F;冰箱（一筐违章电器，总有办法的）</p><p><del>买个折叠桌，冬天炖炖火锅围着吃</del></p><p>工作区域：图书馆，或者你喜欢的任何教室</p><p>南大图书馆的环境普遍还是很好的。就是不能机械键盘炸馆。（使用电脑的同学可以去机房自习）</p><p>只要不在宿舍，摸鱼的动机就减少了80%</p><p>建议准点上下班：早9晚5，或者其他的什么安排。</p><p><del>一定不要养成这个干不完就不睡觉的习惯</del></p><p><del>尤其是你们计算机的</del></p><p>多去户外，多出学校。我院的巨大优势之一是学生普遍压力不高；巨大缺陷是学生之间交流太少（全员自闭）。到了大四发现错过了培养社交能力的黄金时期，大呼上当。</p><p>——实际上，大家都在宿舍里躺尸。可千万不要再这样了。</p><p>读研，尤其是读博之后，你就知道有朋友、会交朋友是多么重要的事情了。</p>]]></content>
      
      
      <categories>
          
          <category> 讲稿 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小总结</title>
      <link href="/20230919_whatislove/"/>
      <url>/20230919_whatislove/</url>
      
        <content type="html"><![CDATA[<p>获取信心的关键在于：各种各样的人都能获得幸福。但是他们也都是像我一样有太多缺陷的普通人。就算并不优于他们，但也不算逊色。</p><p>如果我最终失败了，并不是因为我不好，而是我在这一段中的表现并不符合对方的期待。我有这样的能力，我有这样的意愿，展示出对方喜欢的一面。</p><p>既然如此那就自信地拿出来就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9月工作要点</title>
      <link href="/20230919_points/"/>
      <url>/20230919_points/</url>
      
        <content type="html"><![CDATA[<p>一些题外话：商院那边的校对工作可以挑选一个状态不太好的时间去做。尽量自动化吧</p><p>主题当然还是：用我们的系统调用拦截机制去跑一个进程。甚至是两个进程。</p><p>比较方便的一个小玩具是一个 Server-Client 的系统，比如天气查询系统之类的。可以集齐获取时间、日期这些要素。</p><p>之前提过两个东西。一个是可以去读写内存的地址空间，那就使用 &#x2F;proc&#x2F;pid&#x2F;memory 这个文件？让我先试试。</p><p>第二个是使用 clone 系统调用来管理</p><p>得想办法设计一下架构</p><p>1、用 procfs 重写地址空间读写</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学期初准备</title>
      <link href="/20230913_new/"/>
      <url>/20230913_new/</url>
      
        <content type="html"><![CDATA[<p><del>预约体检</del></p><p><del>交社保</del></p><p>挂刷课脚本（记得做试题）</p><p><del>9.14 8:30 体检</del></p><p><del>9.14 16:00-18:00 233 报告厅 软件所全体师生会议</del></p><p>记得预约牙医</p><p><del>信息确认</del></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩托车相关知识</title>
      <link href="/20230830-motor/"/>
      <url>/20230830-motor/</url>
      
        <content type="html"><![CDATA[<p> 购车前须知及入门准备</p><p>1、品牌（没说到的品牌不适合新手，或者牌子太小）</p><p>T0 本田Wing 川崎 雅马哈  质量、保值率、B格 OK 无脑冲</p><p>T1 豪爵、豪爵铃木 国产一哥 外观好看</p><p>T1.5 高金、凯越、升仕、力刻 正经想造好车的品牌，但需要时间</p><p>T2 新大洲本田、五羊本田、无极、赛科龙、春风、济南铃木、光阳、SYM三阳 各有优劣，小毛病</p><p>T3 奔达、长江、QJMOTOR钱江（不想做车只想做营销）、大阳、力帆 直接二手</p><p>T4 各类小品牌、杂牌 除非外观特别好看否则不建议购买</p><p>T5 地平线（？）</p><p>费用</p><p>1、驾照 800±</p><p>2、头盔 400± 护膝护肘200+</p><p>3、购车 1-2w</p><p>新车：裸车价+车价8%左右购置税+246&#x2F;626交强险+60上牌</p><p>二手车：卖价+100发票+50过户</p><p>购车渠道：当地实体店</p><ul><li>品牌官网查询经销商</li><li>摩托范</li></ul><p>新手选车的关键点</p><p>1、保值率：尽量选择梯队排名靠前的热门车型</p><p>2、安全性：尽可能选前后轮都带ABS大幅减少摔车概率</p><p>3、售后：离自己近的大车行</p><p>车型分类</p><p>1、街车</p><p>传统街车、运动复古街车 水桶车。复古街车适合改装</p><p>2、ADV拉力车</p><p>长途越野全地形车。专业度要求及售价高，新手不推荐。市面上很多自称拉力车的只能算休旅车。</p><p>3、休旅车</p><p>适合铺装道路长途骑行，烂路不如专业ADV。</p><p>4、复古巡航</p><p>小巡航 车身小，坐高低，适合市区街道代步通勤，有外观改装空间。</p><p>大巡航 硬汉，又长又宽，改装空间巨大。部分可胜任一些短途摩旅。</p><p>5、弯梁</p><p>不用捏离合就换挡，不担心熄火。但无路权，专治低血压。</p><p>6、踏板车</p><p>小平踏5km以内便携实用性无敌。大多排量 ≤ 150cc。</p><p>中小踏 &gt; 150cc 为提升车架强度提升操控性，一般取消了平踏空间。</p><p>大踏板 &gt; 250cc 不用换挡的休旅车。车身巨大，新手不好驾驭。</p><p>7、仿赛 跑车 长途骑行累，几乎没有装载能力。</p><p>明确需求</p><p>1、街车&#x2F;运动复古接车&#x2F;复古小巡航</p><p>综合性较强，动力、外观、实用性都占一部分。需求不清晰可先练手</p><p>2、仿赛</p><p>跑车外观，运动属性，短途代步。长途与其他实用性完全不在乎</p><p>3、复古街车&#x2F;复古巡航</p><p>独特风格、改装。骑范不骑快</p><p>4、休旅车</p><p>长途需求、装载能力，大气。</p><p>5、小平踏，中小踏板</p><p>实用为主，代步无敌，家中常备。</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DMCK-ptrace</title>
      <link href="/20230726_ptrace/"/>
      <url>/20230726_ptrace/</url>
      
        <content type="html"><![CDATA[<p>稍微总结一下技术路线：</p><p>首先，被测方注册信号处理函数，并分配好信号执行的栈空间（sigaltstack）。两个处理函数，分别用于保存和恢复进程。</p><p>保存，具体来说就是把堆、栈、全局变量全都dump到文件。对于例子而言，这个文件大约是500KiB。压缩后是5KiB。</p><p>恢复，从文件中把数据再拷进来。首先不能破坏信号执行的栈区，要保留好 restore 函数的执行环境；其次要修改 restore 结束后返回的位置（主要是栈指针。pop rbp 之后，rbp要回到 dump 发生的位置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp // rbp 是 restore 发生时的 user_stack 上的地址</span><br><span class="line">movq %rsp, %rbp  // rsp 是 ss_stack 上的地址</span><br><span class="line">...</span><br><span class="line">movq %rbp, %rsp</span><br><span class="line">popq %rbp   // 此时需要回到 dump 发生时的 user_stack 地址。当时的栈区已全部恢复</span><br></pre></td></tr></table></figure><ul><li>总结下来，restore 不能破坏 restore 的栈结构，但是要把 push 的 rbp 换成 dump 下来的。之后 rsp 回到正常位置后，自然会取到正确的返回地址。</li></ul><p>问题：</p><p>1、FILE * 是分配在堆上的。这带来的问题是，恢复了上次的堆空间之后，FILE * 所指的内容随着执行进度的不同，也会发生变化</p><p>解决A：使用操作系统的文件描述符表。此处用栈上 fd 代替堆上 FILE *。仍然需要管理操作系统对象，并且不能 kill 进程，每一个分支都得保留一个 proxy 进程用来维持系统资源。尝试过感觉稍微有点困难。</p><ul><li>困难点在于，fork() 的 proxy 进程，脱离了 tracer。在有 tracer 的情况下，当 read() 系统调用被 SIGRESTORE 打断后，可以控制 read() 重新执行。在没有 tracer 的情况下，打断了就是打断了。</li><li>当然我们可以直接在打断失败的调用基础上修改返回的数据，这样单一调用的结果没问题。但是文件描述符的状态就没有发生变化了。</li></ul><p>解决B：不使用操作系统的文件描述符表，而是全部自己模拟（全模拟有大量细节要考虑。类似于 select&#x2F;epoll 的行为仍不明确。但是估计最终是这样）</p><p>2、随机性的产生 （choose()）</p><p>取决于被测程序使用何种随机。考虑以下简单情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> devrandom;  <span class="comment">// open(&quot;/dev/urandom&quot;, O_RDONLY);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    read(devrandom, &amp;ret, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种还是有一个系统调用可以控制的。但是如果面对这种使用场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> determ = rand() % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (rand) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read 的返回值很多，但是最终我们只要两个分支。根据概率分布的不同，我们可能需要走好多遍才能遍历两个分支。</p><p>故而，此类函数全都需要劫持或从代码上改写为 choose(N)。</p><p>choose(N) 要做什么？</p><ul><li>构造一棵执行路径树。每个节点都需要有可能的取值范围，这个可能需要手工确定。</li><li>获取当前的执行路径。产生新的取值</li><li>让被测程序走到新的节点</li></ul><p>rand.invoke()  –&gt; 被 ptrace 截停并通知父进程 –&gt; 父进程发信号使 rand 被拦截，并保存程序状态</p><p>–&gt; 父进程根据当前状态查表得知此处 rand 调用的取值可能 </p><p>–&gt; 对每种可能，新启动实例并给予返回值，运行至下一个选择的状态然后被 ptrace 捕获</p><p>ptrace 如何拦截用户函数？查询符号表，在函数开头插入 0xcc，这样就会触发 SIGTRAP… 接着只需要设置 rax 作为返回值，然后 ret。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *rand = symlookup(<span class="string">&quot;rand&quot;</span>);</span><br><span class="line">ptrace(PTRACE_POKEDATA, pid, rand, <span class="number">0xc3cc</span>);   <span class="comment">// cc c3 00 00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WIFEXITED(wstatus) == <span class="literal">true</span> &amp;&amp; WSTOPSIG(wstatus) == SIGTRAP) &#123;</span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">    kill(pid, SIGDUMP);</span><br><span class="line">    <span class="keyword">for</span> (all possible val) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">            exec() the tested;</span><br><span class="line">        &#125;</span><br><span class="line">        kill(pid, SIGRESTORE);</span><br><span class="line">        ptrace(PTRACE_SYSCALL, pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    regs.rax = WANTED_BRANCH();</span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个 rand 也不是真正执行的</p><p>只要算好了 rand 的可能取值，就可以刚刚好跑过所有分支不重复。</p><p>3、怎么对其他程序应用此方案</p><ul><li>如果不用 signal handler，而是用 PEEKDATA 的方式 dump 进程，可以想象到效率</li><li>但进程信号表并不能 survive execve。如果原来的 elf 里没有这个 handler，没有办法后加</li><li>魔改elf感觉最稳。硬往里加text和data，有一定希望</li></ul><p>目前就局限在 C&#x2F;C++ 代码的单进程、单线程程序。</p><p>4、牵扯到线程调度怎么办</p><p>还没有调查如何控制并发调度。甚至还不知道 ptrace 一个多线程程序会发生什么。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本科跑路步骤</title>
      <link href="/20230630-boxign/"/>
      <url>/20230630-boxign/</url>
      
        <content type="html"><![CDATA[<p>扫描复印学位证</p><p>拆机</p><p>封箱</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组会论文</title>
      <link href="/20230626-explode/"/>
      <url>/20230626-explode/</url>
      
        <content type="html"><![CDATA[<p>通过动态Interface约简（Reduction）实现软件的模型检测</p><p>实现级别的软件模型检测。直接通过系统实现检测软件的缺陷。但是状态空间爆炸导致扩展性很差。DeMeter的贡献：1、提出动态 Interface约简，新的约简方法。2、用合理的工作量，在现有的 MC 中实现了动态 Interface 约简的框架。3、为框架提供了分布式运行时环境引擎，支持了并行分布式的 MC。</p><p>与 MaceMC 和 MoDist 集成，每一个差不多1000行代码工作量。可约简5到10^5倍的状态空间（Paxos、BerkeleyDB、Chord、Pastry。DeMeter 探索了Paxos的全部有意义的状态空间，提供了非常可靠的保障。</p><p>Dynamic Interface Reduction (DIR)   Interface，界面？接口？连接？</p><p>两个原则：</p><p>1、check components separately。（？）</p><p>软件通过封装隐藏细节。基于这个，一个典型的分布式系统就可以看作是一组进程通过消息交换交互。message traces （of a component and the rest of system）决定了这一component行为。</p><p>Interface 行为以外的所有行为，都是 Locally contained。给定了所有component的 InterBehav，DIR就可以只看本地状态空间。不需要去探索全局状态空间。（就像是硬件虚拟化、一叶障目的感觉）</p><p>2、discover interface behavior dynamically.(?)</p><p>分别 MC 各个组件，需要知道 interface behavior。DIR就在探索时动态发现这类行为。这个过程忽略组件内的复杂度，它不会通过interface传播。并且这个过程是自动的，所以不用手动指定（枯燥、error-prone、不准确）。而且，只会出现现实中会有的 interface behav，避免了 false positive。</p><p>主要思路：对于多个本地的执行流，它们拥有不同的本地状态却有相同的发送序列。这些本地状态的变化有可能不会传导给整个系统。所以就像 cache hit 一样。</p><p>所以，只要interface很好地掩盖了实现细节，DIR就能很好地工作。</p><p>由例子，过渡到DIR的系统模型和算法</p><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>DeMeter 检查标准的并发&#x2F;分布式系统。抽象地说，系统从一个初始状态出发，经过状态转换到达下一个状态。一个转换是 enabled 如果 not blocked （？？？）并且能够在当前状态下被调度到。</p><p><em>环境</em> 是用来建模状态转换当中的 <em>非确定性</em> 的（状态图中的分叉）。这种分叉就包括线程进程调度、消息顺序、时钟、错误，和其他很多不确定性（随机）。</p><p>实现级别的Mchecker一般有两大块。</p><p>一是 system wrapper。暴露处于下层的系统并允许环境中不确定性的控制。</p><p>二是 exploration mechanism，建在 syswrapper 上层，探索系统状态空间——记录和控制非确定性以寻找软件缺陷：异常，崩溃，断言，安全性违例。</p><p>处于下层的 system：C 为 components 的集合。（每个节点）。Components 通过 interface objects 进行互动（通讯信道、共享对象）。状态转变有 internal（don’t access interface objects）和 interface transitions（access）。</p><p>interface transition： output and input。（读和写信道、共享内存、收发消息）</p><p>两个transition <em>依赖</em> 如果它们的执行互相影响：一个会使另一个 enable、disable，或调换顺序产生不同结果。比如两个竞争的写&#x2F;读写。</p><p>从初始态，系统的执行（transition 序列）被建模为 <em>trace</em>，其中的 transition 拥有dependency &lt;&#x3D; 关系的偏序。两个偏序等价的 trace 认为相同。给定 trace $\tau$，然后一个 transition t 在之后发生，即可扩展为新 trace τ·t 。同时可定义前缀，。。。。</p><p>SKELETON，只有interface transition 的trace。对 component c 的 interface-equivalent，就是说 skel(localc(τ)) &#x3D; skel(localc(τ’))。</p><p>A partial order ($\preceq$) is defined between transitions in the same thread, between a send transition and its corresponding receive transition across threads and processes, and is transitive.</p><p>看完本篇剩下的：5小时</p><p>想好讲什么：2小时</p><p>做ppt：2小时</p><p>参考别的：3小时</p><p>整个 Local 和 Global explorer 的交互还是很清晰的。</p><p><img src="image-20230627001823927.png" alt="image-20230627001823927"></p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>教务处要的东西</title>
      <link href="/20230610-jiaowu/"/>
      <url>/20230610-jiaowu/</url>
      
        <content type="html"><![CDATA[<h1 id="期中项目选题及要求"><a href="#期中项目选题及要求" class="headerlink" title="期中项目选题及要求"></a>期中项目选题及要求</h1><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>在现代的编程语言中，表达式求值是必须要支持的一部分，比如 <code>Python</code> 的命令行模式，可以作为一个增强版的计算器来使用。</p><p>![image](Untitled 2.assets&#x2F;python-command-line.png.34cf22df)</p><p>本项目要求实现一个类似的表达式求值工具，接受变量赋值（比如 <code>a = 233</code>）和表达式求值（比如 <code>a + 114514</code>）两种语句，检查输入的错误，并计算表达式的值。</p><h3 id="项目指南"><a href="#项目指南" class="headerlink" title="项目指南"></a>项目指南</h3><p>2022.12.08 upd：项目指南更新，修正了一些错误与遗漏之处，欢迎大家找错误。</p><p><a href="https://box.nju.edu.cn/f/914aebbc04c347db879e/">新版链接</a>。</p><p>2022.12.26 upd：李清扬助教对手册的讲解：<a href="https://box.nju.edu.cn/f/0dd03c818a644077979c/">点此链接</a></p><p>旧版请查看 <a href="https://box.nju.edu.cn/f/dd2244548a2b43bcb59a/">NJU Box 链接</a> （可下载）。</p><h3 id="评分标准"><a href="#评分标准" class="headerlink" title="评分标准"></a>评分标准</h3><p>本题为客观题，由 dotOJ 黑箱测试自动评分，根据通过的测试点客观给分，OJ 得分即为你期中项目的得分。与主观题不同，你<strong>不</strong>需要提交项目文档。</p><p>你可以及时看到得分，但无法得知错误的测试数据点（<strong>助教不会给</strong>，保证公平性），与平时编程练习的形式<strong>完全相同</strong>，可多次提交，取最高分，以 dotOJ 显示为准。</p><blockquote><p>蔡之恒：感觉师姐去年造数据的时候有点偷懒，今年想办法加强一波（</p></blockquote><p>本题将同其他作业一样参与查重，并按照 <a href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p><p>选做该题目，将有<del>较大</del>机会得到期中项目的满分。其中，正确实现所有必做部分，可得到 70% 的分数；每正确实现一个选做部分，将额外得到 10%，也就是说，实现题面中所有部分，将得到满分。</p><p>除去该题之外，其余题目均为主观题，都将在期中项目截止后人工验收，因此选做本项目的同学的得分分布将会作为其他项目评分的参考标准，我们会尽力保证期中项目所有选择的在评分时的公平性。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含若干行，每行为一个表达式或赋值语句，关于输入输出的详细规约请参考<a href="https://box.nju.edu.cn/f/dd2244548a2b43bcb59a/">项目指南</a>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个输入的表达式或赋值语句，输出 <code>Error</code> 或相应的值。</p><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2</span><br></pre></td></tr></table></figure><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="小恐龙"><a href="#小恐龙" class="headerlink" title="小恐龙"></a>小恐龙</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：李薛成</p><p>验题人：李薛成</p></blockquote><h3 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h3><p>机房电脑上除了<a href="https://oj.cpl.icu/contest/27/problem/45"><em>扫雷</em></a>、<a href="https://oj.cpl.icu/contest/34/problem/159"><em>蜘蛛纸牌</em></a>，还是要数<em>Chrome</em>的小恐龙最好玩了，一玩就是一节信息课（）</p><p>没玩过的同学们也可以现在就打开 <em>Chrome</em>，在地址栏输入 <code>chrome://dino</code> （或者断网）就可以畅玩了！（<em>Edge</em>的小恐龙被换成冲浪了没法玩）</p><p>Sakiyary 在高中每节信息课都和同学比拼小恐龙赛跑，但自从上了大学，时移事易，物是人非（还记得2016年夏的守望先锋吗.jpg），Sakiyary 再也找不回当年玩小恐龙的感觉（再也没有超过高中时的最高纪录）。</p><p>现在请你来帮帮他，写一个 C 语言的小恐龙并和 Sakiyary 一起比拼，让他找回当年的感觉！</p><hr><h3 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用命令行的字符界面或图形界面来制作并运行游戏。</p><p>建议用键盘来操控小恐龙而不是鼠标。（Chrome 的小恐龙使用了空格键与上下两个方向键来操控）</p><p>你可以用命令行字符或图形界面的贴图绘出小恐龙，<strong>题目注解</strong>中提供了一种可能的字符小恐龙画法，请根据小恐龙的大小决定整个场景的大小，障碍物同理。（小恐龙之外的形象也可以，但不能是竖线、正方形、圆形等简单几何图形。下文均以“小恐龙”来指代玩家所操控的角色）</p><p>你需要至少实现两种障碍物，即需要跳跃的障碍物（如仙人掌）和需要下蹲的障碍物（如飞鸟）。</p><p>你需要让你的代码能够在别人的电脑上（按照你自己给出的<strong>环境要求与规定</strong>）<strong>编译并正确运行</strong>。</p><p>Sakiyary 将人工审查你的代码（与其他同学、各大开源平台上的开源代码进行比对与查重）并按照 <a href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p><hr><p>你需要正确地实现游戏进程：</p><ol><li>如何实现小恐龙向前跑动与障碍物迎面而来的效果与动画？</li><li>如何实现小恐龙跳起落下、下蹲的效果与动画？</li><li>如何实现按键操控且保证键盘输入<strong>不冲突不积压</strong>？</li><li>如何判断小恐龙与障碍物的碰撞与 Game Over？</li><li>如何计算与记录小恐龙跑出的分数？</li><li>如何暂停游戏、继续游戏？</li><li>如何<strong>在不重启程序的情况下</strong>重新开始一局新的游戏？</li></ol><p>关于上述第3点，给出一些补充：</p><ol><li>根据正常操控逻辑，跳跃键（如空格键）需要点按生效，下蹲键（如下方向键）需要长按生效。</li><li>如果一边按毫无意义的按键（如字母键），一边按跳跃键，小恐龙能否不卡顿地正常起跳？</li><li>如果长按或快速按跳跃键，小恐龙会飞上天吗？还是只能一下一下地跳？</li><li>如果在跳跃的过程中按下蹲键，小恐龙会有什么表现？</li><li>如果按住下蹲键的同时按跳跃键，小恐龙会有什么表现？</li></ol><p>按键操控有许多细节，大家都可以在原版小恐龙游戏中尝试，并在自己的代码中体现出来。若能完美实现，获得一定的加分，见下。</p><hr><p>关于两种界面的实现，分别给出一定的要求：</p><h3 id="命令行字符界面"><a href="#命令行字符界面" class="headerlink" title="命令行字符界面"></a>命令行字符界面</h3><p>推荐使用 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">Windows Terminal</a> 来运行程序，你需要锁定整个命令行界面的大小，可以自定义命令行字体大小，自行判断小恐龙与整个场景的比例。</p><p>字符的动画可以通过清屏+重新输出全部来实现（但这种做法效率很低哦），游戏的帧率与动画速度需要自行把控。</p><p>但显然，这个游戏越流畅越好玩。思考怎样让界面的字符动画能够尽可能流畅且屏幕不闪烁。</p><h3 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h3><p>图形界面的难点就是你要去自学怎么写好图形界面……参见本课程 <a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>但在绘制小恐龙与场景与实现动画保证流畅度的时候会比字符界面简单非常多。</p><p>故就难度而言其实与命令行字符界面差不多，甚至更加简单。但要求也会更高哦~</p><hr><h3 id="评分标准-1"><a href="#评分标准-1" class="headerlink" title="评分标准"></a>评分标准</h3><p>Sakiyary 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong> ，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li><li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现一些扩展功能：<ul><li>随得分增长小恐龙加速；</li><li>更多种类的障碍物；</li><li>道具与状态（飞行、无敌、冲刺）；</li><li>符合游戏逻辑的情况下自由发挥</li></ul></li><li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li></ul><hr><h3 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="题目注解"><a href="#题目注解" class="headerlink" title="题目注解"></a>题目注解</h3><ol><li><p>小恐龙越大，整个场景就越大，字符界面动画的显示就越卡顿，碰撞判断就越困难。</p><p>这里提供一种使用<strong>扩展ascii码</strong>的 12×812×8 的小恐龙画法（仅限 Windows mingw gcc）：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SetConsoleOutputCP(<span class="number">437</span>);</span><br><span class="line">    <span class="type">char</span> dino[<span class="number">8</span>][<span class="number">12</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">200</span>, <span class="number">205</span>, <span class="number">181</span>&#125;,</span><br><span class="line">        &#123;<span class="number">47</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">218</span>, <span class="number">196</span>, <span class="number">217</span>&#125;,</span><br><span class="line">        &#123;<span class="number">92</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">208</span>, <span class="number">208</span>, <span class="number">217</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">198</span>, <span class="number">203</span>, <span class="number">187</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">207</span>, <span class="number">205</span>, <span class="number">32</span>, <span class="number">207</span>, <span class="number">205</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++, <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dino[i][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预览效果：</p><p>![image](Untitled 2.assets&#x2F;QQ图片20221121145105.png.2e50b1e5)</p><p>TODO（持续更新ing……）</p><h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="羊了个🐏"><a href="#羊了个🐏" class="headerlink" title="羊了个🐏"></a>羊了个🐏</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：张哲恺</p><p>验题人：张哲恺</p></blockquote><h3 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h3><p>没玩过<em>羊了个羊</em>的人只能度过一些相对美好的夜晚😄</p><p><em>羊了个羊</em>是一款突然也不知道为什么就火起来了的<strong>垃圾</strong>游戏，玩家可以选择地图中随机出的卡片放到界面下方的卡槽中，卡槽中每具有三张同种类的卡片就可以消除掉它们，如果地图中的卡片被全部消除则 You Win，如果卡槽中卡片堆满了则 Game Over。</p><p>可以参考<a href="https://search.bilibili.com/all?keyword=%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A&from_source=webtop_search&spm_id_from=333.1007&search_source=5">一些视频</a>来了解具体的游戏流程。</p><hr><p>Corax 在接触到<em>羊了个羊</em>之后很快就恨上了这款随机无解的垃圾游戏，在无数的夜晚向文件传输助手转发了无数的广告之后，Corax终于破防了，然而他的好胜心不允许他征服不了这款游戏，于是他决定让你帮他写一个<strong>更合理</strong>的<em>羊了个羊</em>，以此来通关这个游戏曲线救国。</p><hr><h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏</p><p>游戏的逻辑需要正确实现，例如当地图上的卡片被清空或者卡槽中的卡片堆满且无法消除时游戏要能够正常结束，卡槽中同种类的卡片应该堆放在<strong>相邻</strong>的位置，每三张相同卡牌要能够正常消除等</p><p>卡牌要能够明确地分辨其边界，地图中需要有<strong>多层卡牌</strong>，并且能通过上层卡牌看到部分下层卡牌（可参考实机游戏画面，字符界面会在后面说明），下层卡牌上面的数张上层卡牌未被清空前不可选择下层的卡牌（具体要求在后面说明），你需要保证游戏有解，即不会存在剩下两张或一张某种卡牌的情况</p><p>你还需要实现一些附加的游戏道具功能，如洗牌（即重新打乱地图中卡牌的位置，但你仍然需要保证游戏有解），撤销（即将最近一张放入卡槽的卡牌放回其原有的位置），移出卡牌（即将卡槽中现有的卡牌移出，并放置于地图中的随机位置）</p><p>游戏中要能够暂停、继续、退出游戏，在游戏结束后要能够重新开始，而不是关掉程序重新打开</p><hr><h3 id="图形界面附加要求"><a href="#图形界面附加要求" class="headerlink" title="图形界面附加要求"></a>图形界面附加要求</h3><p>首先请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>如果你选择使用图形界面运行游戏，那么需要通过鼠标点击卡牌进行操作，通过设置图片的饱和度或给图片蒙一层半透明蒙版等来区分可选择的上层卡牌和暂时不可选择，仅可见的下层卡牌。</p><h3 id="字符界面附加要求"><a href="#字符界面附加要求" class="headerlink" title="字符界面附加要求"></a>字符界面附加要求</h3><p>如果你选择使用字符的命令行界面运行游戏，那么需要通过键盘进行操作，为了区分卡牌的边界和能看见下层的卡牌，你需要给每一张卡牌画上边界，可参考下图</p><p>![img](Untitled 2.assets&#x2F;image.png.0ab1f489)</p><p>示例中用<code>+</code>和<code>-</code>绘制了地图边界，用<strong>扩展ascii码</strong>中的 <code>191</code>，<code>192</code>，<code>217</code> 和 <code>218</code> 以及 <code>-</code> 和 <code>|</code> 绘制了卡牌的边框，为了在你的代码中使用扩展ascii码（关于什么是扩展ascii码以及更多其中的符号请自行STFW），你可以尝试以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SetConsoleOutputCP(<span class="number">437</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输出的编码标准切换至允许使用扩展ascii编码的标准，你也可以使用其他的字符来绘制边框，总之你的游戏中卡牌的边框要可见。但卡槽中的卡片可以没有边框，否则会显得有些冗杂</p><p>选择卡牌时可以通过<code>↑</code>，<code>↓</code>，<code>←</code>，<code>→</code>或者WASD来控制选择光标的移动，并将选中的卡牌编号或者整张卡牌的颜色切换为显眼的颜色，因此你的程序逻辑要<strong>正确地控制光标的移动</strong>，例如在上面的图片中按下右键，22号卡牌变回白色，33号卡牌变为红色，再按下右键，应该是位于顶层可被选中的11号卡牌变为红色，而非位于第二层且仍被第一层卡牌压住的55号卡牌变为红色，（如果5号卡牌上没有第一层卡牌，那么应该是它被选中）另外，如果Corax <strong>输入一系列预期之外的字符你的程序应该无视并且仍然能够正常运行</strong></p><p>为了改变输出的字符颜色，你可以使用以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is white now. U&#x27;ll change it to red.\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is red now. U&#x27;ll change it again\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It turns back to white.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以尝试改变 <code>SetConsoleTextAttribute</code> 函数的第二个参数来获得不同的颜色。</p><p>至于按下键盘上的哪个键将当前选中的卡牌放入卡槽可由你自己定义。</p><p>tips：以上代码均仅适用于 Windows 操作系统环境，如果是 Linux&#x2F;macos 用户请自行 STFW&#x2F;RTFM，应该需要用到 UTF-8 字符集。</p><hr><h3 id="评分标准-2"><a href="#评分标准-2" class="headerlink" title="评分标准"></a>评分标准</h3><p>Corax 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，没有 bug。（bug 太多会倒扣）</li><li>Corax 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现一些扩展功能：<ul><li>若Corax在一定时间内消除了足够数量的卡牌，即可进入<code>狂热模式</code>，在此期间他可以快速地消除地图上的卡牌，但你需要通过一定手段保证狂热模式结束后游戏仍然有解，并且Corax在游戏期间要能看见狂热模式的积攒条；</li><li>除此之外，你还可以设计一些其他有趣的功能。</li></ul></li><li>对于图形界面，实现正确的图片动态移入卡槽可酌情加分。</li><li>对于命令行字符界面，实现附加的选牌逻辑加分，附加的选牌逻辑如下：<ul><li>当输入→后如果当前卡牌的正右方没有卡牌，但右下&#x2F;上方有卡牌，那么应该移动到右下&#x2F;上方的卡牌，其他三个方向同理；</li><li>除此之外，你需要用另外一种颜色来标记可以被选中的卡牌，区分不可被选中的卡牌和已经被选中的卡牌。</li></ul></li></ul><hr><h3 id="技术要求-1"><a href="#技术要求-1" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）。</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="提交方式-1"><a href="#提交方式-1" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="飞行棋"><a href="#飞行棋" class="headerlink" title="飞行棋"></a>飞行棋</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：浦亮</p><p>验题人：浦亮</p></blockquote><h3 id="项目概述-2"><a href="#项目概述-2" class="headerlink" title="项目概述"></a>项目概述</h3><p>飞行棋是<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%81%E5%AD%97%E6%88%B2%E9%A1%9E%E9%81%8A%E6%88%B2">十字戏类游戏</a>，以模拟飞机飞航为主题，游戏以飞机由机场起飞至目的地，所以称为飞行棋。飞行棋是<a href="https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B">中国</a>参考<a href="https://zh.m.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E5%8D%81%E5%AD%97%E6%88%B2">英国十字戏</a>发展出来的，而<a href="https://zh.m.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E5%8D%81%E5%AD%97%E6%88%B2">英国十字戏</a>是从<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%B0%E5%BA%A6%E5%8D%81%E5%AD%97%E6%88%B2">印度十字戏</a>演变出来的。</p><p>在这个项目里，需要大家完成一个简易版本的飞行棋游戏，最终呈现的效果可以是命令行呈现，也可以是自己学习图形库后以GUI的形式呈现。</p><p>![image](Untitled 2.assets&#x2F;QQ图片20221102224124.png.0d47332e)</p><h3 id="项目要求-1"><a href="#项目要求-1" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用命令行的字符界面或图形界面来制作并运行游戏。最终实现的效果既可以是通过在终端里打印飞行棋的棋盘来表现，也可以是完整的图形界面。但要求一定要对棋盘上的情况有所呈现。</p><p>shuilongzhihun 将人工审查你的代码（与其他同学、各大开源平台上的开源代码进行比对与查重）并按照 <a href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p><h3 id="简化版飞行棋规则-游戏基本逻辑"><a href="#简化版飞行棋规则-游戏基本逻辑" class="headerlink" title="简化版飞行棋规则(游戏基本逻辑)"></a>简化版飞行棋规则(游戏基本逻辑)</h3><ol><li>有2-4个“玩家”。</li><li>每个“玩家”操控一个颜色对应的棋子，“玩家”可以是真人控制也可以是电脑控制，<strong>“玩家”可以全是真人也可以全是电脑。</strong>真人通过与实现系统交互来进行游戏，电脑玩家自动进行游戏。</li><li>每个玩家四颗棋子，初始都在机场不能出门，按顺序投骰子（1-6点的骰子）。如果玩家骰子抛出6，则可以让自己一个在机场的棋子在起点准备出发，并且再抛一次骰子决定可以出门走几格（该次抛骰子无论抛出几都只能作为刚刚准备出发的棋子前进的步数）。<ol><li>如果玩家的每个棋子都在机场或者终点处，且没有抛到6，则该玩家这个回合结束。</li><li>如果玩家抛出的点数是1-5，且有至少一个既不在机场也不在终点的棋子，则可以选择一个棋子根据点数往前移动一定步数。在简化实现中，所有的棋子都共享一条直线型的跑道！</li><li>如果玩家同时有棋子在机场和已经出发，在抛到6的情况下如何处理留给同学自行设计（可以设计成只能让棋子出发，或者也可以设计成可以选择让已经出发的前进，或其他设计）。</li><li>为了方便大家的实现，在这里做了简化处理。如果有同学想实现原版的效果，可以作为扩展功能实现。</li></ol></li><li>同时要求 <strong>直线型的跑道格子数量不低于15个</strong>，也就是下图中中间的深蓝色格子不少于15个。</li><li><strong>终点的格子数应该为6个</strong></li></ol><p>![image](Untitled 2.assets&#x2F;r1.png.2925d469)</p><ol><li>在终点前要进行分流，各自进入对应颜色的分流终点。然后进入终点分流阶段。</li></ol><p>![image](Untitled 2.assets&#x2F;r2.png.5e82d363)</p><p>如图，绿色的棋子如果此时是抛出了某些点数，或者是因为前面抛出了点数走到了这个位置还有几步没有走完，接下来都应该进入绿色对应的终点区域</p><ol><li>在终点区域，到达终点的判定是正好走到最后一格。如果没有走到则等待下一轮抛投，如果走到最后一格还有剩余步数，则需要反弹剩余步数。</li></ol><p>![image](Untitled 2.assets&#x2F;r3.png.16a0cb13)</p><p>如上图，在当前位置时，如果抛出的点数是3，则正好到达终点。如果抛出的点数是5，则反弹效果如图所示。</p><p>![image](Untitled 2.assets&#x2F;r4.png.23a43eea)</p><ol><li>一颗棋子达到终点的时候，就将这个棋子移出整个棋盘，记为成功到达。玩家胜利的条件是让全部的四颗棋子都到达终点。</li><li>对于同格子情况的处理：有不同的规则版本，在此处统一：<ol><li>对于途径的其他棋子无视，不论那个途径的格子里有几个棋子。</li><li>如果本次移动最终落点处是己方棋子，则这两个棋子可以同时存在这个格子里（但是不采取某些可以叠子的规则，后续再进行移动的时候同一格的棋子仍然视为多个分开的个体前进）</li><li>如果本次移动最终落点处有敌方棋子，则己方棋子占据这个格子，所有在这个格子的敌方棋子不论数量都返回机场（也就是需要抛到6才能再出发的状态）</li></ol></li></ol><h3 id="电脑操作"><a href="#电脑操作" class="headerlink" title="电脑操作"></a>电脑操作</h3><p>对于上述提到的电脑玩家操作，应当保证电脑的表现正常，即不存在非法操作（比如没有投到6但是让一个棋子出发），而且所有操作都是正常操作（比如不会在投了骰子且有棋子可以移动的情况下什么都不做）。</p><p>电脑玩家的操作也应当以某种方式（输出日志或其他）展现出来。</p><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><p>上述描述的实现标准是一个简化改进版本的要求，同学们可以在现有的基础上尝试实现更多效果，包括但不限于：</p><ul><li>一个实现得非常好的命令行交互系统或者图形界面；</li><li>体现简化版本中没有提到的“飞”，即在某个满足特定要求的特定位置时可以飞到另外一格；</li><li>体现简化版本中没有提到的“跳”，即给中间的深蓝色格子进行染色，当棋子移动的最终落点在同色的格子上时可以往前跳到下一个同色格子上；</li><li>把跑道改为原版中的环形跑道的设计；</li><li>……</li></ul><p>你可以随意添加功能，<strong>但是理论上不能破坏现在的基本规则或者是使得规则变得更简单改动</strong>（例如删除终点的反弹但是又不设计一个更复杂的规则代替将会反过来影响你的成绩）。</p><hr><p>关于两种界面的实现，分别给出一定的要求：</p><h3 id="命令行字符界面-1"><a href="#命令行字符界面-1" class="headerlink" title="命令行字符界面"></a>命令行字符界面</h3><p>参见本课程 <a href="http://docs.cpl.icu/#/project/cli_req">命令行字符界面要求</a>，只是简单的将模拟的棋盘用一些代表特殊意义的字符不断的输出在屏幕上是可以的。</p><h3 id="图形界面-1"><a href="#图形界面-1" class="headerlink" title="图形界面"></a>图形界面</h3><p>参见本课程 <a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><hr><h3 id="评分标准-3"><a href="#评分标准-3" class="headerlink" title="评分标准"></a>评分标准</h3><p>shuilongzhihun 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li><li>shuilongzhihun 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现上述的扩展功能或自行发挥。</li></ul><h3 id="技术要求-2"><a href="#技术要求-2" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="项目注解"><a href="#项目注解" class="headerlink" title="项目注解"></a>项目注解</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>该部分仅作为参考的建议和提示，如果你有更好的设计思路和实现，完全可以自己采用。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>对于棋子和棋盘格状态的存储，用数组和变量的方式就可以实现。比如用数组来记录当前棋子的位置和当前的状态，再用一些数组来存储棋盘格子内的状态。</p><h4 id="游戏控制"><a href="#游戏控制" class="headerlink" title="游戏控制"></a>游戏控制</h4><p>对于游戏整体逻辑控制 可以参考如下的设计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!game_ends)&#123;</span><br><span class="line">    player=(player+<span class="number">1</span>)%player_num;<span class="comment">//切换玩家</span></span><br><span class="line">    die_point=<span class="built_in">getDieRes</span>();<span class="comment">//投骰子</span></span><br><span class="line">    <span class="built_in">move</span>(player,die_point);<span class="comment">//移动部分的判断</span></span><br><span class="line">    game_ends=<span class="built_in">judge</span>();<span class="comment">//判断游戏是否结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令行字符界面呈现"><a href="#命令行字符界面呈现" class="headerlink" title="命令行字符界面呈现"></a>命令行字符界面呈现</h4><p>只是简单的将模拟的棋盘用一些代表特殊意义的字符不断的输出在屏幕上是可以的。例如像下面的模拟输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------</span><br><span class="line">GG</span><br><span class="line">GG                         DDDDD(green)</span><br><span class="line">  □□□□□□□□□□□□□□□□□□□□□□□□□</span><br><span class="line">YY                         DDDDD(yellow)</span><br><span class="line">YY</span><br><span class="line">Green team throw the die and get 2 point!</span><br><span class="line">Green team ubable to move!</span><br><span class="line">------------------------------------------------</span><br><span class="line">GG</span><br><span class="line">GG                         DDDDD(green)</span><br><span class="line">  □Y□□□□□□□□□□□□□□□□□□□□□□□</span><br><span class="line">Y□                         DDDDD(yellow)</span><br><span class="line">YY</span><br><span class="line">Yellow team throw the die and get 6 point!</span><br><span class="line">Yellow team throw the die again and get 2 point!</span><br><span class="line">Yellow team moves.</span><br></pre></td></tr></table></figure><p>当然，如果你对字符进行了染色并且实现了刷屏的效果(屏幕上不是通过类似上述分隔符分隔的多次输出来展示，而是通过清屏再输出或者修改屏幕上显示的某些字符来实现)，这个设计可以被认为是一个扩展功能，根据效果可以作为评分标准里扩展功能部分的分数。</p><h4 id="DEBUG模式"><a href="#DEBUG模式" class="headerlink" title="DEBUG模式"></a>DEBUG模式</h4><p>为了方便助教测试和自己debug，推荐自己在程序里加入一个“外挂”，比如在输入某些指令后，或者全局定义某些变量值为1或自定义宏(例如#define DEBUG)开启自己定义的debug模式，你可以编写操控骰子投出的点数的代码，从而可以控制棋子的走动。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="comment">//假设这是一个用于得到投骰子结果点数的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDieRes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该部分不计入分数，但是强烈推荐做一下。</strong></p><h4 id="先动脑-再动手！"><a href="#先动脑-再动手！" class="headerlink" title="先动脑 再动手！"></a>先动脑 再动手！</h4><p>由于在很多地方都存在共通之处，同学们在编写代码的时候可以先思考一下有些地方的代码是不是可以抽象出来作为一个函数在多个地方复用，而通过设置一些变量来进行区分，这样可以很好的实现代码的压缩，防止出现屎山，也会减少在复制的时候有些地方没改完全导致出错!</p><p>对于每个玩家阵营，很多流程是一样的，是否可以把里面的一些操作抽象出来，而不是在每回合的循环里复制四遍代码？</p><p>比如对于每个棋子（飞机）可以增加一个标签来标记他是什么颜色的棋子，这样对于棋子的一些操作就可以通用了。</p><p>比如对于真人和电脑玩家的区分，本质区别其实只有在移动的时候有区别，而且移动都要检查是否合法，那么可以考虑一个设计是：对于玩家的每个棋子，判断投出骰子对应点数的移动是否合法，如果合法，那么就返回一个所有可以选择移动的棋子列表，电脑是从中随机选一个移动，而真人是自己选择。这样真人和电脑的代码差异就变得很小了。</p><h3 id="提交方式-2"><a href="#提交方式-2" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：肖江</p><p>验题人：肖江</p></blockquote><h3 id="项目概述-3"><a href="#项目概述-3" class="headerlink" title="项目概述"></a>项目概述</h3><p>单色蜘蛛纸牌是一款经典的休闲益智纸牌游戏，该游戏基本规则如下：</p><ul><li>有 �<em>N</em> 副牌，�<em>M</em> 个牌槽，�<em>K</em>次发牌机会</li><li>初始牌槽中有 �×13−�×�<em>N</em>×13−<em>K</em>×<em>M</em> 张牌</li><li>只可以移动牌槽最上层的连续牌组</li><li>移动的目的地要么是空牌槽，要么能够和被移动牌组连接上</li><li>形成一组完整的连续牌组后（�<em>A</em>~�<em>K</em>），该牌组被从牌槽中收回</li><li>可以申请发牌，每个牌槽中新增一张牌，新增的牌可以和原牌组不连续</li><li>所有牌全部收回时判定胜利</li><li>无法进行有效操作时判定失败</li></ul><p>比如有4个牌槽：</p><p>![image](Untitled 2.assets&#x2F;image.png.7bba8639)</p><p>那么此时可以进行的操作是：</p><ol><li>将牌槽1的 <code>A, 2, 3</code>移动到牌槽2；</li><li>将牌槽1的 <code>A, 2</code> 移动到牌槽3；</li><li>将牌槽3的 <code>3</code> 移动到牌槽2；</li><li>申请发牌。</li></ol><p>其余均为非法操作。</p><p>更具体的规则过程可以观看如下两个视频</p><ul><li><a href="https://www.bilibili.com/video/BV1s64y1s7aP">判定胜利</a></li><li><a href="https://www.bilibili.com/video/BV1XS4y1C7kh">判定失败</a></li></ul><h3 id="项目要求-2"><a href="#项目要求-2" class="headerlink" title="项目要求"></a>项目要求</h3><p>我们需要在字符界面或者图形界面实现一个单色的蜘蛛纸牌。</p><p>该蜘蛛纸牌共包含88副牌（�<em>A</em>~�<em>K</em>），1010 个牌槽，初始时 1010 个牌槽各拥有 66、66、66、66、55、55、55、55、55、55 张牌，最上层的牌可见，其余牌不可见，有 55 次发牌机会，每次给 1010 个牌组各发一张牌，其余规则和游戏介绍中的一致。</p><h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4><ul><li>初始化牌桌，展示牌槽，可发牌次数和已收回牌组；</li><li>移动牌组；</li><li>发牌；</li><li>收回已形成的完整牌组；</li><li>结束判定。</li></ul><h4 id="扩展功能-1"><a href="#扩展功能-1" class="headerlink" title="扩展功能"></a>扩展功能</h4><ul><li>撤回一次或多次操作；</li><li>提示有效操作：<ul><li>需要按照要求和优先级进行提示，详见项目注解；</li></ul></li><li>计时器；</li><li>多色的游戏模式。</li></ul><hr><p>关于两种界面的实现，分别给出一定的要求：</p><h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>部分功能仍然需要实现动画，详见项目注解中命令行交互方式，并遵守<a href="http://docs.cpl.icu/#/project/cli_req">命令行字符界面要求</a>。</p><h3 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h3><p>可以直接参考游戏介绍中的视频，使用拖拽，高亮，鼠标点击按钮等交互方式，但请遵守<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><hr><h3 id="评分标准-4"><a href="#评分标准-4" class="headerlink" title="评分标准"></a>评分标准</h3><p>875C 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li><li>875C 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现上述的扩展功能或自行发挥。</li></ul><h3 id="技术要求-3"><a href="#技术要求-3" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="项目注解-1"><a href="#项目注解-1" class="headerlink" title="项目注解"></a>项目注解</h3><p>接下来对失败条件判定和有效操作提示，以及交互方式做更进一步的解释</p><h4 id="失败条件判定和有效操作提示"><a href="#失败条件判定和有效操作提示" class="headerlink" title="失败条件判定和有效操作提示"></a>失败条件判定和有效操作提示</h4><p>由于失败条件以及有效操作的定义和证明不属于C语言课程的范围，在这里我们直接给出它的定义，大家按照定义实现即可。</p><p>首先定义最大上层连续牌组，即一个牌槽内的上层的最多的连续牌组，如一个牌槽自底向上的牌是<code>?, ?, ?, K, Q, 9, 7, 8, 3, 2, A</code>（<code>?</code>表示未翻面的牌），则最大上层连续牌组为<code>3, 2, A</code>。</p><h4 id="失败条件"><a href="#失败条件" class="headerlink" title="失败条件"></a>失败条件</h4><p>失败条件为同时满足以下三条：</p><ol><li>所有牌槽的最大上层连续牌组<strong>并集不包含</strong>完整的一副牌；</li><li>无法移动任何最大上层连续牌组；</li><li>无剩余发牌次数。</li></ol><h4 id="失败条件示例"><a href="#失败条件示例" class="headerlink" title="失败条件示例"></a>失败条件示例</h4><p>假设一共有 33 个牌槽且无法发牌（项目要求是 1010 个，这里示例用 33 个展示逻辑过程）</p><p>![image](Untitled 2.assets&#x2F;image.png.303ee8c1)</p><p>他们的最大上层连续牌组为 <code>&#123;A, 2, 3&#125;, &#123;8, 9, 10&#125;, &#123;5,6&#125;</code>，并集为 <code>&#123;A, 2, 3, 5, 6, 8, 9, 10&#125;</code>，不包含 �<em>A</em>~�<em>K</em>，且所有最大上层连续牌组都无法移动，且无法发牌，故判定失败。</p><h4 id="有效操作"><a href="#有效操作" class="headerlink" title="有效操作"></a>有效操作</h4><p>有效操作包括以下三种，<strong>按优先级从高到低排序，即“能提示1，就不要提示23”</strong>：</p><ol><li>通过移动牌组，将一副牌直接收回；</li><li>移动某个牌槽的最大上层连续牌组（但不能是全牌组和空牌组互换）；</li><li>发牌。</li></ol><h4 id="有效操作1示例"><a href="#有效操作1示例" class="headerlink" title="有效操作1示例"></a>有效操作1示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p><p>![image](Untitled 2.assets&#x2F;image.png.1a93a157)</p><p>此时可以通过将牌槽2的A移动到牌槽3，再将牌槽3的A,2,3移动到牌槽1，将一整副牌收回。</p><p>提示并不需要提示完整的操作过程，只需要高亮最大上层连续牌组并集能包含 �<em>A</em>~�<em>K</em> 的牌槽即可，样例中可以高亮牌槽1, 2, 3。</p><h4 id="有效操作2示例"><a href="#有效操作2示例" class="headerlink" title="有效操作2示例"></a>有效操作2示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p><p>![image](Untitled 2.assets&#x2F;image.png.34a931dc)</p><p>他们的最大上层连续牌组为<code>&#123;A, 2, 3&#125;, &#123;4&#125;, &#123;5, 6, 7&#125;</code>，你可以提示将牌槽1的 <code>A, 2, 3</code> 移动到牌槽2，也可以提示将牌槽2的 <code>4</code> 移动到牌槽3，但是不可以提示将牌槽3的所有牌移动到牌槽4。</p><h4 id="有效操作3示例"><a href="#有效操作3示例" class="headerlink" title="有效操作3示例"></a>有效操作3示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p><p><img src="https://oj.cpl.icu/image/image.png.00ecbcd9" alt="image"></p><p>他们的最大上层连续牌组为<code>&#123;A, 2, 3, 4&#125;, &#123;4&#125;, &#123;6, 7&#125;, &#123;K&#125;</code>，此时既没有有效操作1，也没有有效操作2，可以直接提示发牌。（如果无法发牌就说明应该判定失败了）</p><h3 id="命令行交互方式"><a href="#命令行交互方式" class="headerlink" title="命令行交互方式"></a>命令行交互方式</h3><h4 id="初始化牌桌，展示牌槽，可发牌次数和已收回牌组"><a href="#初始化牌桌，展示牌槽，可发牌次数和已收回牌组" class="headerlink" title="初始化牌桌，展示牌槽，可发牌次数和已收回牌组"></a>初始化牌桌，展示牌槽，可发牌次数和已收回牌组</h4><p>无需动画，直接展示，可发牌次数和已收回牌组可以使用数字展示。</p><p>牌槽牌面最简单也需要使用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--+</span><br><span class="line">| A|</span><br><span class="line">+--+</span><br></pre></td></tr></table></figure><p>展示，不能只有一个字符。</p><h4 id="移动牌组"><a href="#移动牌组" class="headerlink" title="移动牌组"></a>移动牌组</h4><p>可以直接使用命令进行交互，如 <code>m 3 2 1</code> 表示牌槽3移动到牌槽2，移动1张牌。</p><p>也可以使用，选定原牌槽-&gt;选定牌组-&gt;选定目标牌槽的方式进行移动。</p><p>动画至少需要三个关键帧，即原牌桌，移动到半途的牌桌，移动完毕的牌桌。</p><h4 id="发牌"><a href="#发牌" class="headerlink" title="发牌"></a>发牌</h4><p>可以使用按键发牌。</p><p>动画需要至少两个关键帧，展示要发的牌，将牌发到各个牌槽。</p><h4 id="收回已形成的完整牌组"><a href="#收回已形成的完整牌组" class="headerlink" title="收回已形成的完整牌组"></a>收回已形成的完整牌组</h4><p>动画至少需要两个关键帧，高亮完整牌组，收回牌组且计数器增加&#x2F;牌组增加。</p><h4 id="结束判定"><a href="#结束判定" class="headerlink" title="结束判定"></a>结束判定</h4><p>弹窗，不要覆盖牌桌，因为需要截图展示，可以在牌桌旁展示弹窗提示胜利或失败。</p><h4 id="撤回操作"><a href="#撤回操作" class="headerlink" title="撤回操作"></a>撤回操作</h4><p>无需动画，直接使用弹窗提示撤回的操作类型——发牌&#x2F;移动，并还原牌桌状态。</p><h4 id="提示有效操作"><a href="#提示有效操作" class="headerlink" title="提示有效操作"></a>提示有效操作</h4><p>按照有效操作一节中的要求和优先级进行有效操作提示，使用按键或命令激活提示。</p><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>直接展示即可，不要出现跳表情况，即不能出现 <code>00:01</code> 直接变成 <code>00:04</code>。</p><h3 id="提交方式-3"><a href="#提交方式-3" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="苏联块"><a href="#苏联块" class="headerlink" title="苏联块"></a>苏联块</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：孙博文</p><p>验题人：孙博文</p><p>Sakiyary：我摆烂了，不想格式化题面了，和其他项目题总要求是一样的……</p></blockquote><p>“俄罗斯方块”（Tetris）是一个经久不衰的小游戏。我们这就来做一个：</p><p>原版游戏当中Tetra4。我们做一个 Extended Edition</p><p>硬性要求：不做掉大分。</p><ul><li><p>掉落的方块，在原游戏基础上增加几种：</p><p>3方块的 “L” 和 “l” 型, 5 方块的 3 种 “L” 型。</p></li><li><p>容纳方块大小至少为 12 列 16 行。游戏界面自适应当前终端，如果终端尺寸不够放下全部内容，则不能启动并给出一行提示。</p></li><li><p>使用上下左右方向键！方向键！方向键！实时控制方块旋转与下落，直到方块的下表面与已有方块接触，则刷出下一个方块</p></li><li><p>旋转前后，如果没有卡上游戏 tick （即向下掉落一格的时刻），方块的最下端高度不应变化</p></li><li><p>输入不合法的字符，不应使你的程序卡顿、崩溃、异常。</p></li><li><p>行填满需要消除，下落。并计分。</p></li><li><p>屏幕内给出操控指示。支持暂停，和重新开始。</p></li></ul><p>软性：</p><ul><li>最好能打印出较为标准的正方形。比如终端内打印两个黑方块▇▇来组成一个。<del>否则方块旋转后会变形</del></li><li>按下方向下键时方块速度增加</li><li>支持计分榜等扩展功能</li></ul><p>本实验选题不会奖励写图形界面的同学。如果图形界面有bug还可能导致多的扣分。</p><p>命令行界面简洁而完整。</p><h3 id="评分标准-5"><a href="#评分标准-5" class="headerlink" title="评分标准"></a>评分标准</h3><p>请仅提交三个文件放在 .zip 压缩包内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">submission.zip</span><br><span class="line">  - tetris.c</span><br><span class="line">  - tetris.exe / tetris.out</span><br><span class="line">  - report.txt</span><br></pre></td></tr></table></figure><p>我们会运行你的程序。基本能玩就给 80 分。游戏交互逻辑较好并且没 bug 就是一伯分。</p><p>我们会做包括但不限于下列操作：</p><ul><li>正常地游玩游戏</li><li>键盘随机输入一大堆随机字母数字，并观察你程序的行为</li></ul><p>项目报告</p><ul><li>你的平台(Windows&#x2F;Linux&#x2F;MacOS)，编译选项，（依赖的图形库），具体交互方式(图形化拖拽 or 命令行按键)</li><li>简单思路</li><li>完成项目的感想和意见</li><li>建议使用 txt 纯文本</li><li>不要过长，不超过两页，主要是将前两项说清楚，方便助教验收，前两项说清楚就是满分，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可</li></ul><h1 id="期末项目选题及要求"><a href="#期末项目选题及要求" class="headerlink" title="期末项目选题及要求"></a>期末项目选题及要求</h1><h2 id="冬津羽戏"><a href="#冬津羽戏" class="headerlink" title="冬津羽戏"></a>冬津羽戏</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：张哲恺</p><p>验题人：张哲恺</p></blockquote><h3 id="项目概述-4"><a href="#项目概述-4" class="headerlink" title="项目概述"></a>项目概述</h3><p>俗名打砖块😄打砖块是一款总共可以发射数个小球，并通过控制挡板位置，反弹小球使其击碎路径上砖块并不断反弹的游戏。</p><p>同样可以参考<a href="https://www.bilibili.com/video/BV1Rb411c7RF/?spm_id_from=333.337.search-card.all.click&vd_source=20202ec91c1882d95954b8843ae70102">一些视频</a>来了解具体的游戏流程。</p><hr><p>Corax 收到大冒险家 Sakiyary 想要自己做一个打砖块游戏的委托但是却不知所措，于是他决定转发委托，并作为中间商在其中狠狠捞一笔。不过纯粹的打砖块太过次时代缺乏趣味性，只能让Sakiyary 获得 3030% 的满意度，为了让产品能 100100% 使委托人满意，他需要你附加实现<strong>双人联机mod</strong>和<strong>奇幻之旅DLC</strong>。</p><hr><h3 id="实现要求-1"><a href="#实现要求-1" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>游戏的逻辑需要正确实现，例如挡板只能在一定的区域内移动，当小球从地图下边界离开时要重新发球，地图中所有砖块都被击碎后要结束游戏或进入下一关（刷新地图），挡板和砖块要能够反弹小球，砖块反弹小球后要判定其受到撞击，反弹的角度需要对称等等。</p><p>砖块的不同种类要能够区分（具体内容将在下面继续说明）</p><hr><h3 id="双人联机mod要求"><a href="#双人联机mod要求" class="headerlink" title="双人联机mod要求"></a>双人联机mod要求</h3><p>你需要使用socket网络编程实现两个客户端在同一局游戏中操控两个不同的挡板一起游戏，采用客户端、服务端二分的模式，因此你需要编写<strong>两个程序</strong>。</p><p>服务端：</p><ul><li>监听某个主机的某个端口</li><li>监听并应答来自客户端的连接和请求</li><li>维护游戏状态，包括两个玩家各自的挡板位置等，因此在多人模式下，你需要<strong>对两个玩家的挡板做出相应的区分</strong></li></ul><p>客户端：</p><ul><li>向服务端发起请求或通讯</li><li>维护游戏状态，包括小球的运动轨迹，地图的状态（此状态也可交由服务器维护，具体做法由你自己决定）等</li></ul><p>在联机游玩的两个客户端程序之间画面的延迟不能太高，状态要能够正确维护。</p><p>参考的思路是：服务端创建<strong>监听线程</strong>，每接收到一个消息，将其放入一个全局队列中，等待处理；另一个线程负责<strong>处理来自客户端的请求</strong>，while(1) 循环从队列中取一条消息，然后分析其中的内容。客户端创建与服务端连接的线程，负责<strong>与服务端进行通信</strong>；另一个线程，负责<strong>计算游戏进程和输出游戏图形</strong>。这里需要用到<strong>多线程</strong>，具体的做法请STFW&#x2F;RTFM，至于原因你不妨让服务端对某一种客户端请求一直不做应答试试看:D</p><p><strong>既然只是mod，你也需要支持单机游玩</strong>，毕竟 Corax 虽然不能双人成行，但是他单人也行，<strong>请注意你应该如何实现单机和联机两种模式，减少代码克隆的现象。</strong></p><hr><h3 id="奇幻之旅DLC要求"><a href="#奇幻之旅DLC要求" class="headerlink" title="奇幻之旅DLC要求"></a>奇幻之旅DLC要求</h3><p>你需要给砖块和小球附加不同的元素属性，砖块可以添加生命值属性（需要额外进行数次撞击才能彻底击碎），还需要添加一系列道具。</p><p>不同元素属性的砖块需要通过<strong>颜色</strong>来区分，例如红色代表火元素，深蓝色代表水元素，浅蓝色代表冰元素，紫色代表雷元素，黄色代表暂时还没有元素。</p><p>对于字符界面选手来说，可以使用自己喜欢的符号或画出的图形来代表小球和砖块，为了改变输出的字符颜色，你可以使用以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is white now. U&#x27;ll change it to red.\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is red now. U&#x27;ll change it again\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It turns back to white.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以尝试改变 <code>SetConsoleTextAttribute</code> 函数的第二个参数来获得不同的颜色。</p><p>tips：以上代码均仅适用于 Windows 操作系统环境，如果是 Linux&#x2F;macos 用户请自行 STFW&#x2F;RTFM，应该需要用到 UTF-8 字符集。</p><p>对于砖块和小球的元素属性，你可以设计丰富有趣的机制，小球的元素可以由<strong>上次与挡板相撞时挡板的元素属性</strong>来确定，玩家可以控制并改变挡板的元素属性。例如火元素与雷元素相遇会爆炸，对半径一定范围内的砖块全部造成一次攻击；水元素与雷元素、冰元素相遇会引发链式反应，导致相邻的水元素方块全部受到一次攻击；雷元素与冰元素相遇会强化小球，使其在下次与地图边界相撞并反弹前不会被砖块反弹；暂时无元素方块在被相应元素小球撞击后会附着上相应元素等等。</p><p>你需要设计一系列丰富有趣的道具，例如在地图下边界暂时生成防护墙保护小球不会离开地图，小球与挡板或砖块碰撞后生成额外的小球，挡板自身发射垂直向前的子弹攻击砖块等等，道具的触发条件也可以多种多样，可以由击碎砖块后随机触发，可以由击碎特殊砖块触发，也可以由当前小球击碎数个砖块后触发。</p><p>你可以从<a href="https://box.nju.edu.cn/f/636b2c46f0c240a08031/">链接中的视频</a>参考上述描述的具体实现。</p><hr><h3 id="评分标准-6"><a href="#评分标准-6" class="headerlink" title="评分标准"></a>评分标准</h3><p>打砖块本体占分比重 30%，奇幻之旅DLC占分比重 40%，双人联机mod占分比重 30%，后两者的分数<strong>依赖于打砖块本体</strong>，也即如果你只写了一个实现完美的联机mod你的分数也只会是 0 分</p><p>Corax 人工评判，以上三个模块实现每个模块内的要求基本正常即可得到各自模块内 80% 以上的分数（也可以通过前两项拿满分，第三项水一水来得到 80% 以上的分数）。</p><p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a href="https://oj.cpl.icu/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，没有 bug。（bug 太多会倒扣）</li><li>Corax 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>对于打砖块本体，能够实现挡板的普通速度和双倍速度移动，一定范围内的上下移动并根据与小球相撞时挡板的移动方向和速度改变小球的反弹方向（不要求严格按照物理规律，有<strong>不惊动牛顿棺材板</strong>的影响即可，当然如果能模拟真实物理情况也很好，你同样可以参考<a href="https://box.nju.edu.cn/f/636b2c46f0c240a08031/">链接中的视频</a>）加分。</li><li>对于奇幻之旅DLC，不同元素的反应和道具丰富有趣无bug，能够实现砖块生命值大于等于2时元素产生反应后自身附着元素消失，根据反应给周围的方块附着元素（例如水与雷的链式反应可能可以使与路径上的砖块相邻的砖块附着上雷元素等），并且小球与挡板发生的元素反应可以使小球的下次碰撞产生相应的反应（例如火球与雷元素挡板相撞并反弹后，下次与砖块相撞时引发爆炸等等，此时小球具有的反应状态应该在程序内对玩家可见）即可加分。（<strong>每一点都可以加分，不是全部实现才加分</strong>）</li><li>对于双人联机mod，能够实现游玩过程中两个客户端画面延迟非常小，多线程和要求中提到的问题完成较好即可加分。</li></ul><hr><h3 id="技术要求-4"><a href="#技术要求-4" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）。</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="提交方式-4"><a href="#提交方式-4" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="中国象棋"><a href="#中国象棋" class="headerlink" title="中国象棋"></a>中国象棋</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：肖江</p><p>验题人：肖江</p></blockquote><h3 id="项目概述-5"><a href="#项目概述-5" class="headerlink" title="项目概述"></a>项目概述</h3><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/278314">中国象棋</a>是一种起源于中国，历史悠久的棋类游戏。你需要实现一个双人联机对战的象棋游戏。</p><h3 id="实现要求-2"><a href="#实现要求-2" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>游戏的逻辑需要正确实现，比如各类棋子不能有非法移动，最终胜负判定能够正常进行</p><h3 id="联机要求"><a href="#联机要求" class="headerlink" title="联机要求"></a>联机要求</h3><p>你需要使用socket网络编程实现两个客户端在同一棋局内对弈的功能，采用客户端，服务端分离的模式，因此你需要实现<strong>两个程序</strong>。</p><p>你可以采取<a href="https://zhuanlan.zhihu.com/p/36884005">状态同步或者帧同步</a>的方式对客户端和服务端进行分工。</p><p>状态同步：棋盘的运算都发生在服务端，客户端只负责和用户交互</p><p>帧同步：棋盘的运算都发生在客户端，服务端只负责转发客户端动作消息到对手侧</p><p>在联机游玩的两个客户端程序之间画面的延迟不能太高，状态要能够正确维护。</p><p>参考的思路是：服务端创建<strong>监听线程</strong>，每接收到一个消息，将其放入一个全局队列中，等待处理；另一个线程负责<strong>处理来自客户端的请求</strong>，while(1) 循环从队列中取一条消息，然后分析其中的内容。客户端创建与服务端连接的线程，负责<strong>与服务端进行通信</strong>；另一个线程，负责<strong>计算游戏进程和输出游戏图形</strong>。这里需要用到<strong>多线程</strong>，具体的做法请STFW&#x2F;RTFM。</p><h3 id="额外功能"><a href="#额外功能" class="headerlink" title="额外功能"></a>额外功能</h3><p>你可以实现一部分额外功能以获得更高的分数，包括但不限于</p><ul><li>悔棋</li><li>倒计时</li><li>打赏&#x2F;催促对方<ul><li>“你这么菜你老师不会生气吧哥哥”</li><li>“每一盘都当最后一盘，然后也不要怕输”</li><li>“3,2,1，落子！”</li></ul></li><li>添加道具&#x2F;技能<ul><li>改变棋子的行为规则</li><li>改变整个棋局的状态，比如添加棋子，转换棋子等</li><li>可以参考<a href="https://www.bilibili.com/video/BV1cr4y1Q72G">万宁象棋</a></li></ul></li></ul><h3 id="评分标准-7"><a href="#评分标准-7" class="headerlink" title="评分标准"></a>评分标准</h3><p>原生象棋移动和胜负判定占分比重 60%，额外功能占分比重 15%，联机功能占分比重 20%，代码风格，项目组织占分比重 5%。</p><p>875C 人工评判，以上三个模块实现每个模块内的要求基本正常即可得到各自模块内 80% 以上的分数。</p><p>使用图形界面<strong>并不会得到更高的分数</strong>，若图形界面不符合要求或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><h2 id="技术要求-5"><a href="#技术要求-5" class="headerlink" title="技术要求"></a>技术要求</h2><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在<a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a>自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）。</li><li>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</li></ul><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h2 id="提交方式-5"><a href="#提交方式-5" class="headerlink" title="提交方式"></a>提交方式</h2><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile/ CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="落井大战"><a href="#落井大战" class="headerlink" title="落井大战"></a>落井大战</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：李薛成</p><p>验题人：李薛成</p></blockquote><h3 id="项目概述-6"><a href="#项目概述-6" class="headerlink" title="项目概述"></a>项目概述</h3><p>Downwell，是一款风靡全球的 <a href="https://baike.baidu.com/item/Roguelike/10973209">Roguelike</a> 竖版过关游戏，是一位日本音乐专业的大佬在大四折腾出来的小游戏。你可能从没听说过这款游戏，那么你可以从下面几个链接中初步了解一下：</p><p><a href="https://zhuanlan.zhihu.com/p/20589067">Downwell - 日本独立游戏佳作 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/26949872">《下井大战》的游戏性是你难以想象的 - 知乎</a></p><p>也可以上这款游戏的官网 <a href="https://downwellgame.com/">Downwell (downwellgame.com)</a> 购买&#x2F;下载体验，或者上 B 站看大佬的通关视频<a href="https://www.bilibili.com/video/BV1uE411j7ew/">视频链接</a>。</p><p><del>（速去 Steam 买！优惠只要 ￥4.5，1月6日0点结束！）</del></p><hr><h3 id="项目要求-3"><a href="#项目要求-3" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>首先我们要明确你需要做一个什么样的游戏出来。显然，如果你能模仿原作实现它的绝大部分功能，拿到满分应该很大。但我们还是来解构一下这款游戏的要素：</p><h3 id="基础要素"><a href="#基础要素" class="headerlink" title="基础要素"></a>基础要素</h3><ul><li>一位可以操控的主角，主角需要三种基础交互：左、右移动、跳跃&#x2F;向下射击。</li><li>一个竖版的地图（井），地图上随机生成有方块拼成的各种形状平台供主角落脚。</li><li>怪物们，可以是在墙上爬、在平台上爬、在空中飞、同时会或不会发射子弹攻击、带刺或不带刺的怪物。</li><li>主角在平台上时只能跳跃，在空中可以向下射击子弹，发射的同时获得一定的滞空，同时消耗弹夹中的子弹数量。弹夹需主角停留在平台上方可自动地逐渐地回满。</li><li>主角与怪物都有各自的血量，如主角有 4 格血、怪物有 8 格血，受到一次攻击就掉相应的血。</li><li>主角踩在不带刺的怪物上方可以对怪物造成伤害，踩在带刺的怪物身上会受到伤害。</li></ul><p>到这里，游戏最最基本的解构就完成了。</p><h3 id="Rougelike-要素"><a href="#Rougelike-要素" class="headerlink" title="Rougelike 要素"></a>Rougelike 要素</h3><p>但原作是 Rougelike 游戏，所谓肉鸽（Rougelike），首先是在一定固定规则上的随机，如随机地形、随机怪物，其次就是通过阶段性的随机奖励&#x2F;道具，来提升或改变角色的能力（攻击力、攻击方式、弹夹容量、血量、恢复力等等）。同时，地图并不是一图到底无限延伸，而是分为一个个关卡。怪物也会随着关卡层数（下降层数）变强，数量、种类更多、速度更快、攻击更猛。在关底（最后的关卡）有强力 Boss，打败 Boss 游戏就算通关。来解构一下这一部分的要素：</p><ul><li>随机性，地形随机生成，怪物（符合关卡难度的基础上）随机生成，道具随机生成等等。</li><li>要让主角变强，就要获得奖励&#x2F;道具。道具可由击杀怪物掉落，或者通过击杀怪物得到的货币来到随机生成的商店处购买（商店内道具随机生成）。这也使得主角需要更多的交互操作，如在商店中购买道具、开启主动技能等等。同时需要有货币机制。</li><li>关卡设计，如每次下降一定的单位长度就自动进入下一关，每过一关主角可以获得一些随机道具。关卡中的怪物需要体现递进，即越来越难。难度的提升可以体现在怪物活动方式、攻击方式上的不同与递进。</li><li>在关底设计 Boss，拥有独特的存在方式、活动方式与攻击方式，可以模仿上述视频中 Boss 的行为与机制。</li><li>通关机制，评分机制。</li></ul><p>那么 Rougelike 要素就差不多了，这只是一些粗浅的解构，但对本项目已经足够了。</p><hr><p>在初步解构完要素的基础上，开始提出具体的要求：</p><ul><li>和<a href="https://oj.cpl.icu/contest/34/problem/156">小恐龙🦖（dino）</a>中大部分要求基本相同。</li><li>地图中随机平台的生成，不能完全堵住路，也不能太过散乱。</li><li>子弹（我方或敌方）的路线设计（直线、曲线、跟踪）与内存管理。</li><li>至少实现三种不同机制的怪物（如只爬动不攻击、爬动且带刺、只飞行不攻击）。</li><li>合理的碰撞判定与扣血机制。</li><li>弹夹消耗与补充机制，发射子弹时主角的滞空机制。</li><li>关于 Rougelike 要素的具体要求全凭你自己的理解，随意发挥即可。</li></ul><hr><h3 id="评分标准-8"><a href="#评分标准-8" class="headerlink" title="评分标准"></a>评分标准</h3><p>Sakiyary 人工评判，正确实现<strong>基础要素</strong>与其相关的具体要求即可得到 8080% 以上的分数。</p><p>使用图形界面并<strong>不会得到更高的分数</strong> ，若图形界面不符合<a href="https://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会 <strong>倒扣</strong> ）</li><li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>实现 Rougelike 要素的相关功能与具体要求。</li><li>模拟出原作的更多机制与游戏性。（不是贴图，是游戏机制）</li><li>在不改变原有游戏性的前提下，实现超出原作的合理的扩展功能。</li><li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li></ul><hr><h3 id="技术要求-6"><a href="#技术要求-6" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><h3 id="提交方式-6"><a href="#提交方式-6" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="滑雪冒险"><a href="#滑雪冒险" class="headerlink" title="滑雪冒险"></a>滑雪冒险</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>出题人：李薛成</p><p>验题人：不知道</p></blockquote><h3 id="项目概述-7"><a href="#项目概述-7" class="headerlink" title="项目概述"></a>项目概述</h3><p>好耶，是滑雪大冒险！这款游戏的 BGM 应该耳熟能详吧，不熟也不要紧，我们直接来看 B 站大佬的魔改版👉 <a href="https://www.bilibili.com/video/BV1VK411R7BM/">我做了个滑雪大冒险，但是纳西妲！</a></p><hr><h3 id="项目要求-4"><a href="#项目要求-4" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。（等一下，这道题真的能用字符界面吗？）</p><p>如果你选择使用图形界面，请仔细阅读课程网站上的<a href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p><p>首先我们要明确你需要做一个什么样的游戏出来。显然，如果你能模仿原作实现它的绝大部分功能，拿到满分应该很大。但我们还是来解构一下这款游戏的要素：</p><h3 id="基础要素-1"><a href="#基础要素-1" class="headerlink" title="基础要素"></a>基础要素</h3><ul><li>一位可以操控的主角，主角只需要一种交互：跳跃。</li><li>一个无限延伸山坡，作为地图。</li><li>追赶主角的雪崩，随分数升高速度逐渐增大（小幅度）。</li><li>主角的“装备”们（如雪橇、企鹅、雪怪、摩托、鹰等）</li><li>坡道上的障碍物（石块），碰到障碍物时，若主角无装备，则摔倒；若有装备，则按一定的顺序掉一件装备。</li></ul><p>到这里，游戏最最基本的解构就完成了。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>这个游戏其实有几个难点，如山坡的生成、雪崩跟着山坡的滑动、装备们的组合等。</p><ol><li>山坡可以是固定的斜着的波浪线，也可以是随机参数的线性函数的平滑拼接。</li><li>雪崩甚至可以直接用一个长方形来模拟，意思到了就行，也可以将雪崩精细地实现为随山坡滑动的有宽度（高度？）的曲线。</li><li>装备的组合首先是视觉上的位置关系，其次就是你想将这个实现到哪种程度，粗糙一些也可以，十分精细也可以。</li></ol><p>实现全看自己的想法，但是给分也会根据你实现各难点的方式与难度来评判。</p><hr><p>在初步解构完要素的基础上，开始提出具体的要求（<strong>基础版</strong>）：</p><ul><li>和<a href="https://oj.cpl.icu/contest/34/problem/156">小恐龙🦖（dino）</a>中大部分要求基本相同。</li><li>地图中坡道的生成，曲线要有起伏，不能有断崖或太多的小疙瘩。（可以用固定模式生成）</li><li>随分数增长不断加速的追赶主角的雪崩。（可以用简单的图形模拟）</li><li>随机出现的障碍物。（如大大小小的石头）</li><li>“装备”们的运动，至少实现三种装备，且能以合理的不同的方式各自组合。</li><li>合理的碰撞判定与穿装备&#x2F;掉装备&#x2F;摔倒机制。</li></ul><hr><h3 id="评分标准-9"><a href="#评分标准-9" class="headerlink" title="评分标准"></a>评分标准</h3><p>不知道谁人工评判，正确实现<strong>基础版</strong>要求（即用最简单的方式完成各个难点）即可得到 8080% 以上的分数。</p><p>（不好意思，这道题我真不知道字符界面怎么做……）</p><p>剩余分数由相应的加分条件给出：</p><ul><li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会 <strong>倒扣</strong> ）</li><li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li><li>将上述三个难点用精细的方式实现。</li><li>模拟出原作的更多机制与游戏性。（不是贴图，是游戏机制）</li><li>在不改变原有游戏性的前提下，实现超出原作的合理的扩展功能。</li><li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li></ul><hr><h3 id="技术要求-7"><a href="#技术要求-7" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p><p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p><p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p><p>Markdown 可以在 <a href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p><p>文档中请务必指出：</p><ul><li>平台（操作系统）</li><li>C 语言环境（mingw、msvc等及其详细的版本）</li><li>编译选项（CMakeLists、MakeFile、编译指令等）</li><li>使用的第三方库</li><li>游戏方式（你设计的键位、操作等）</li></ul><p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p><p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p><hr><h3 id="提交方式-7"><a href="#提交方式-7" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p><p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p><p><strong>可以参考如下的结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure><h2 id="内存文件系统"><a href="#内存文件系统" class="headerlink" title="内存文件系统"></a>内存文件系统</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>出好实验要求了。本题由 OJ 进行自动测试，OJ 最大的特点就是严格，不能蒙混过关了。</p><p><a href="https://box.nju.edu.cn/f/0dd09ebfbbb3457fbaad/">实验要求（简单版）</a> 请查看群文件的最新版。部分测试用例也在群文件中。</p><p>推荐使用 linux，git，make。可以先尝试着提交，任何问题请提出。</p><p>Windows 上的提交不能用 make submit。你需要手动将你的目录下的 <strong>.git 文件夹</strong>压缩成 zip 手动在 OJ 那里上传。</p><p>按时提交即得 20 分诚信分。（与 gitm 一样）前言</p><p>这可能是大家第一次做类似的工作：你不是编写一个完整的程序，而是按照要求实现一些函数。这些函数将会被我们调用，以检测是否实现了所要求的功能。</p><p><strong>本要求为（基本上是）最终版本。其中重要的描述修正将以这样的形式标出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+++ 这里是修改过的描述，请注意检查 +++</span><br></pre></td></tr></table></figure><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>文件系统是操作系统的重要组成部分。调用文件系统 api，我们可以轻松地将数据持久化到磁盘上。C 语言中为我们提供了一组 api，它们基于操作系统 api，允许我们对文件进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Linux 操作系统中，上述的 C 文件操作 api 是基于一组操作系统的文件 api 实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现要求你实现一个内存文件系统（ramfs）。顾名思义，这个文件系统的所有数据并不持久化到磁盘上，而是保存到内存当中，是一个易失性的文件管理系统。</p><h3 id="文件系统的约定"><a href="#文件系统的约定" class="headerlink" title="文件系统的约定"></a>文件系统的约定</h3><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><p>Ramfs 的目录结构与 Linux 的树形结构一致。在初始状态下，只存在根目录 “&#x2F;“。文件系统中存在两类对象，目录与文件。目录下可以存放其他对象，而文件不可以。即在树形结构中，文件只能是叶子节点。</p><p>例 (#)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── 1.txt            &quot;/1.txt&quot;</span><br><span class="line">├── 2.txt            &quot;/2.txt&quot;</span><br><span class="line">└── dir              &quot;/dir&quot;</span><br><span class="line">    ├── 1.txt        &quot;/dir/1.txt&quot;</span><br><span class="line">    └── 2.txt        &quot;/dir/2.txt&quot;</span><br></pre></td></tr></table></figure><p>可以看到，在根目录下一共有 3 个项目：两个文件，一个目录 dir，而 dir 下还可以拥有两个文件。右侧的字符串称为对象的“绝对路径”。</p><p>单个文件和目录名长度 &lt;&#x3D; 32 字节，</p><h6 id="修订1"><a href="#修订1" class="headerlink" title="修订1"></a>修订1</h6><p>+++ <strong>是字母、数字、英文句点的任意组合。例如，’.’ 不是当前目录，’..’ 也不是上级目录</strong> +++</p><p>对于存在<strong>不合法文件名</strong>的路径，你的文件系统 api 应当统一通过返回 -1 来拒绝此类操作。</p><p>所有 api 调用中，路径长度 &lt;&#x3D; 1024 字节。（也就是说，文件系统的路径深度是存在上限的）。</p><p>文件系统 api 统一使用绝对路径，即以 ‘&#x2F;‘ 开头。在未创建任何文件时，就已经存在 “&#x2F;“ 指向的根目录。该目录可打开，不可删除，其余性质与一般目录一致。</p><h4 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h4><p>整个文件系统同时存在的所有文件内容不会超过 512 MiB（不含已经删去的文件和数据），给予 1GiB 的内存限制。</p><p>同时存在的文件与目录不会超过 65536 个。</p><p>同时活跃着的文件描述符不会超过 4096 个。</p><p>对于所有数据点，文件操作读写的总字节数不会超过 10GiB。时限将给到一个非常可观的量级。</p><p>各数据点的性质：</p><ol><li><p>如原始的 main.c</p></li><li><p>根目录下少量文件创建 + ropen + rwrite + rclose</p></li><li><p>在 2 的基础上，测试 O_APPEND，rseek</p></li><li><p>在 3 的基础上扩大规模</p></li><li><p>少量子目录创建（&lt;&#x3D; 5 层）+ 文件创建与随机读写</p></li><li><p>在 5 的基础上，测试 rrmdir, runlink。</p></li><li><p>大文件测试。多 fd 对少量大文件大量读写 + rseek + O_TRUNCATE</p></li><li><p>复杂的文件树结构测试。大量的 O_CREAT，rmkdir, rrmdir, runlink。少量读写</p></li><li><p>文件描述符管理测试。大量 ropen、rclose，多 fd 单文件</p></li><li><p>综合场景的大型测试。模拟真实的系统。</p></li></ol><p>错误将会分散在各个数据点中。你需要保证你的 API 能正确地判断错误的情况并按照要求的返回值退出。</p><p>如果你获得 ”Wrong Answer“，说明仅仅是程序行为与 API 不一致。如读写的结果不正确，应该打开失败的文件却成功了…</p><p>如果获得 ”Runtime Error”，说明你的程序会出现运行错误而 crash。比如你在遍历文件树时，解引用了空指针…</p><h4 id="接口简述"><a href="#接口简述" class="headerlink" title="接口简述"></a>接口简述</h4><p>我们要求你实现如下的 api，以实现文件系统的管理。其具体行为将会在 api 说明部分阐释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>注意，我们要求你实现的是内存操作系统。故你的程序应当使用内存管理 api（malloc、free）来存放文件所需的数据结构，以及文件的所有内容。请小心地管理好内存注意不要超限。</p><h3 id="开始你的项目"><a href="#开始你的项目" class="headerlink" title="开始你的项目"></a>开始你的项目</h3><p>我们为你准备了一个 git repo。请基于这个 git repo 进行你的项目。如果你不会 git，请学着使用。</p><p>在 git repo 中我们为你提供了一个自动编译脚本 Makefile。并且为你配置好了记录自动追踪。请不要随意修改 Makefile。你的修改记录将成为查重时证明独立完成的重要证据。</p><p>推荐在 Linux 操作系统中完成本作业。如果你要使用 Windows，产生的问题由你自己解决。</p><p>获取代码框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://git.nju.edu.cn/Tilnel/ramfs.git&quot;</span></span><br></pre></td></tr></table></figure><p>注意：请在默认的 master 分支上进行开发。最终 OJ 的评分也将以你的 master 分支为准。</p><p><strong>你应当在 ramfs.c 中包含你的所有实现</strong>（包括指定的函数和你使用的所有数据结构）。评测机会用我们自己的 Makefile（和分发版本一致）、ramfs.h（和分发版本一致）、main.c（包含更强力的测试用例）进行编译运行。因此你对 ranfs.h 和 main.c 以及 Makefile 的修改在 OJ 上不会产生效果。</p><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make submit TOKEN=<span class="variable">$&#123;你的token&#125;</span></span><br></pre></td></tr></table></figure><p>请在题目中“打开代码编辑器”后，获取你的提交 token。注意在校园网环境下提交。然后你就能在提交列表中看到你的提交。</p><blockquote><p>由于服务器现可以通过 public.oj.cpl.icu 访问，你可以对 Makefile 中 submit 目标下的 url 进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@ -25,5 +25,5 @@ submit:</span><br><span class="line">     @cd .. &amp;&amp; zip -qr $&#123;FILE&#125; $&#123;BASE&#125;/.git</span><br><span class="line">     @echo &quot;Created submission archive $&#123;FILE&#125;&quot;</span><br><span class="line">     @curl -m 5 -w &quot;\n&quot; -X POST -F &quot;TOKEN=$&#123;TOKEN&#125;&quot; -F &quot;FILE=@$&#123;FILE&#125;&quot; \</span><br><span class="line">-               https://oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">+               http://public.oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">        @rm -r $&#123;TEMP&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意在 make submit 之前，你需要将最新的改动 commit。同样注意保持你的工作目录整洁，如果你的 git repo 超过 20MiB（这一定是因为你放了很多很多奇怪的玩意），则没有办法提交。</p><p>你的 git repo 中不应当包含各种形式的编译产生的中间文件、编译结果。我们的 Makefile 只会在 build 目录下产生文件，我们也会配置好 .gitignore 文件避免 track 这些文件。</p><h3 id="API-手册"><a href="#API-手册" class="headerlink" title="API 手册"></a>API 手册</h3><h6 id="修订2"><a href="#修订2" class="headerlink" title="修订2"></a>修订2</h6><p>+++ <strong>你的实现不应当有任何输出</strong> +++</p><p>以下注意区分两种对象的定义：文件（file），目录（directory）。</p><p>另一个重要的对象是：文件描述符（file descriptocr），简称 FD。它是所有<strong>打开的文件和目录的指示符</strong>，为一个非负整数。在 Windows 操作系统中称之为“句柄”。我们使用路径打开一个文件或目录，操作系统就会为这一次文件的打开分配一个文件描述符，它就像是一个“把手”一样。我们用这个文件描述符来指示打开的文件，进行对文件的操作。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);  <span class="comment">// open 返回一个文件描述符</span></span><br><span class="line">read(fd, buf, <span class="number">5</span>);                   <span class="comment">// 从打开的 fd (/1.txt) 中读取五个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><h6 id="修订3"><a href="#修订3" class="headerlink" title="修订3"></a>修订3</h6><p>+++ 打开 ramfs 中的<strong>文件或目录</strong>。如果成功，返回一个文件描述符（一个非负整数），用于标识这个对象。+++</p><p>如果打开失败，则返回一个 -1。</p><p>pathname 为一个字符串，为一个绝对路径。<strong>对于所有存在的文件和目录，你的 ropen 调用都应当成功</strong>。特别地，在指示一个目录时，pathname 的末尾可以有多余的 ‘&#x2F;‘。pathname 中间同样可以有冗余的 ‘&#x2F;‘。</p><p>例如，在上文的例 (#) 中，以下的绝对路径是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dir/        =/dir</span><br><span class="line">////dir       =/dir</span><br><span class="line">/1.txt        =/1.txt</span><br><span class="line">//dir/1.txt   =/dir/1.txt</span><br></pre></td></tr></table></figure><p>以下的绝对路径是不存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/3.txt</span><br><span class="line">/1.txt/       (文件路径后不可以有多余的&#x27;/&#x27;)</span><br><span class="line">/di/r/1.txt   (不存在这个路径)</span><br></pre></td></tr></table></figure><p>flag 指示打开方式，这些打开方式仅对<strong>文件</strong>起作用。如果被打开的是目录则自动忽略。其取值有如下可能（或可以是它们的组合）：</p><p>注意，在 C 中，以 0 开头的数字采用 8 进制表示法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND  02000 以追加模式打开文件。即打开后，文件描述符的偏移量指向文件的末尾。若无此标志，则指向文件的开头</span><br><span class="line">O_CREAT   0100 如果 pathname 不存在，就创建这个文件，但如果这个目录中的父目录不存在，则创建失败；如果存在则正常打开</span><br><span class="line">O_TRUNC   01000 如果 pathname 是一个存在的文件，并且同时以可写方式 (O_WRONLY/O_RDWR) 打开了文件，则文件内容被清空</span><br><span class="line">O_RDONLY  00 以只读方式打开</span><br><span class="line">O_WRONLY  01 以只写方式打开</span><br><span class="line">O_RDWR    02 以可读可写方式打开</span><br></pre></td></tr></table></figure><p>这些标志位的组合方式是使用按位的或运算。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_TRUNC | O_RDWR   (可读可写，打开时清空)</span><br><span class="line">+++ O_CREAT | O_WRONLY (若不存在，创建后以只写方式打开；否则以只写方式直接打开) +++ （原来写成读写了）</span><br><span class="line">+++ O_APPEND   (文件描述符的偏移量指向文件末尾，并可读) +++</span><br></pre></td></tr></table></figure><h6 id="修订8"><a href="#修订8" class="headerlink" title="修订8"></a>修订8</h6><p>+++ O_TRUNC 但文件以只读方式打开时，在 Linux 中为 unspecified 行为。此处约定为正常只读打开而不清空。 （1.15 聊天记录）+++</p><h6 id="修订4"><a href="#修订4" class="headerlink" title="修订4"></a>修订4</h6><p>+++ 注意点：+++</p><p>+++ <code>O_RDWR | O_WRONLY</code> 共同存在时，取只写的语义； +++</p><p>+++ 由于 <code>O_RDONLY</code> 是 0，因此若未指定任何读写方式时，默认是只读的； +++</p><p>+++ 同时，易得 <code>O_RDONLY | O_WRONLY == O_WRONLY</code>。因此组合只读只写得到的结果是只写。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭打开的文件描述符，并返回 0。如果不存在一个打开的 fd，则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>向 fd 中的<em><strong>偏移量</strong></em>（马上解释）位置写入以 buf 开始的至多 count 字节，覆盖文件原有的数据。如果 count 超过 buf 的大小，仍继续写入（数据保证不因此而产生段错误），将 fd 的<em><strong>偏移量</strong></em>后移 count，并返回实际成功写入的字节数。如果写入的位置超过了原来的文件末尾，则自动为该文件扩容。</p><p>如果 fd 不是一个可写的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>在本实验中，ramfs 中同时存在的文件大小不会超过限制。因此你的 rwrite 对于一个能够写入的文件，事实上总应返回 count。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>从 fd 中的<em><strong>偏移量</strong></em>位置读出至多 count 字节到 buf 指向的内存空间当中，</p><h6 id="修订5"><a href="#修订5" class="headerlink" title="修订5"></a>修订5</h6><p>+++ 将<em><strong>偏移量</strong></em>后移实际读出的字节数，并返回实际读出的字节数。+++</p><p>因为可能会读到文件末尾，因此返回值有可能小于 count。</p><p>如果 fd 不是一个可读的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><h4 id="偏移量（offset）"><a href="#偏移量（offset）" class="headerlink" title="偏移量（offset）"></a>偏移量（offset）</h4><p>想象你用手指指着读一本书，offset 相当于你手指指向的位置。你每读一个字，手指就向前前进一个字；如果你想改写书本上的字，每改写一个字，手指也向前前进一个字。</p><p>每一个文件描述符都拥有一个偏移量，用来指示读和写操作的开始位置。这个偏移量对应的是文件描述符，而不是“文件”对象。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/1.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);</span><br><span class="line">write(fd1, <span class="string">&quot;helloworld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">read(fd2, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h6 id="修订6"><a href="#修订6" class="headerlink" title="修订6"></a>修订6</h6><p>--- 此时 buf 中将从文件的开头读到”hello\0”。但如果换一种方式： ---  </p><p>+++ 此时 buf 中将从文件的开头读到”hellow”。但如果换一种方式： +++</p><p>假设 “&#x2F;1.txt” 中原来有数据 “helloworld\0”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDWR);</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">read(fd, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时，write 在读取时，将文件指针前移了 5 个字节。于是read在读取的时候，将会从第6个字节开始读取。也即，read 将会读到 “world\0”。对于同一个文件描述符，读取和写入操作是共享偏移量的；对于不同的文件描述符，它们的偏移量则是各自独立的。</p><p>对于 open 操作，如果没有 O_APPEND 标志来将偏移量指向末尾，那么默认指向文件开头。</p><p>如何自由地修改和获取文件描述符的偏移量呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于修改 fd 表示的文件描述符的偏移量，并返回当前文件的实际偏移量。</p><p>whence有三种取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEEK_SET 0   将文件描述符的偏移量设置到 offset 指向的位置</span><br><span class="line">SEEK_CUR 1   将文件描述符的偏移量设置到 当前位置 + offset 字节的位置</span><br><span class="line">SEEK_END 2   将文件描述符的偏移量设置到 文件末尾 + offset 字节的位置</span><br></pre></td></tr></table></figure><p>rseek 允许将偏移量设置到文件末尾之后的位置，但是并不会改变文件的大小，<strong>直到它在这个位置写入了数据</strong>。在 超过文件末尾的地方写入了数据后，原来的文件末尾到实际写入位置之间可能出现一个空隙，我们规定应当以 “\0” 填充这段空间。</p><p>+++ 但不允许将偏移量设置到文件开头之前，也就是一个负数的绝对偏移量。这种情况下返回 -1。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>创建目录，成功则返回 0。如果目录的父目录不存在或此路径已经存在，则失败返回 -1。</p><p>如，原来系统中只存在根目录 “&#x2F;“，调用：<code>rmkdir(&quot;/path/to/dir&quot;)</code> 返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个空目录，成功则返回 0。如果目录不存在或不为空，或 pathname 指向的不是目录，返回 -1。测试保证不对打开的 pathname 做 rrmdir。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个文件，成功则返回 0。如果文件不存在或 pathname 指向的不是文件，则返回 -1。测试保证不对打开的 pathname 做 runlink。</p><p>额外的一个 api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_ramfs();</span><br></pre></td></tr></table></figure><p><strong>可以</strong>用于初始化你的文件系统。比如创建根目录。我们用于测试的 main() 将总会包含它。（要在里面做什么取决于你自己！）</p><p>我们的测试用例长什么样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* our main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();     <span class="comment">// 你的初始化操作</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/dir&quot;</span>) == <span class="number">0</span>);   <span class="comment">// 应当成功</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;//dir&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为目录已存在</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/a/b&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为父目录不存在</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  assert((fd = ropen(<span class="string">&quot;//dir///////1.txt&quot;</span>, O_CREAT | O_RDWR)) &gt; <span class="number">0</span>);  <span class="comment">// 创建文件应当成功</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 应当完整地写入</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_CUR) == <span class="number">5</span>);  <span class="comment">// 当前 fd 的偏移量应该为 5</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">0</span>);  <span class="comment">// 应当成功将 fd 的偏移量复位到文件开头</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(rread(fd, buf, <span class="number">7</span>) == <span class="number">5</span>);   <span class="comment">// 只能读到 5 字节，因为文件只有 5 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>);   <span class="comment">// rread 应当确实读到 &quot;hello&quot; 5 个字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">3</span>, SEEK_END) == <span class="number">8</span>);  <span class="comment">// 文件大小为 5，向后 3 字节则是在第 8 字节</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 再写 5 字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">5</span>, SEEK_SET) == <span class="number">5</span>);  <span class="comment">// 将偏移量重设到 5 字节</span></span><br><span class="line">  assert(rread(fd, buf, <span class="number">8</span>) == <span class="number">8</span>);   <span class="comment">// 在第 8 字节后写入了 5 字节，文件大小 13 字节；那么从第 5 字节后应当能成功读到 8 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0world&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>); <span class="comment">// 3 字节的空隙应当默认填 0</span></span><br><span class="line">  assert(rclose(fd) == <span class="number">0</span>); <span class="comment">// 关闭打开的文件应当成功</span></span><br><span class="line">  assert(rclose(fd + <span class="number">1</span>) == <span class="number">-1</span>); <span class="comment">//关闭未打开的文件应当失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="修订7"><a href="#修订7" class="headerlink" title="修订7"></a>修订7</h6><p>+++ 我们将会在这份手册的最后，提供几份测试代码供大家参考。大家可以将这些代码放到你的 <code>main.c</code> 中，并使用 <code>make run</code> 进行测试。+++</p><h3 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h3><p>首先是目录树。这里给出一个参考的文件对象结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FILE_NODE, DIR_NODE &#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">dirents</span>;</span>  <span class="comment">// if it&#x27;s a dir, there&#x27;s subentries</span></span><br><span class="line">    <span class="type">void</span> *content;         <span class="comment">// if it&#x27;s a file, there&#x27;s data content</span></span><br><span class="line">    <span class="type">int</span> nrde;              <span class="comment">// number of subentries for dir</span></span><br><span class="line">    <span class="type">int</span> size;              <span class="comment">// size of file</span></span><br><span class="line">    <span class="type">char</span> *name;            <span class="comment">// it&#x27;s short name</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p>目录的子项的数量会变化；文件的内容大小也会变化。因次我们可能需要对 <code>dirents</code> 或 <code>content</code> 的内存大小进行动态的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>这一函数会创建一段新的空间，将原来的内容复制到新的空间上，并释放原来的指针。注意原有指针一定也是动态分配的。</p><p>其次是文件描述符。对于文件描述符来说，其重要的只有这几个属性：读写性质，偏移量，指向的实际文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FD</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    node *f;</span><br><span class="line">&#125; FD;</span><br></pre></td></tr></table></figure><p>最初的根文件可以直接定义成全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node root;</span><br></pre></td></tr></table></figure><p>然后在 <code>init_ramfs</code> 中进行初始化。</p><p>接下来的事情，就很显然了：</p><p>添加文件和目录，就是往树里添加节点；</p><p>删除文件，就是删除节点；</p><p>读取内容，就是从 content 里复制出一段…</p><p>一个小建议：使用 <code>memcpy</code> 而不是 <code>strcpy</code>。（区别在哪？读手册）</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>第一个数据点已经给出。</p><p>test2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">notin</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[i] == fd) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">genfd</span><span class="params">(<span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (notin(i, fds, n))</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();</span><br><span class="line">  <span class="type">int</span> fd[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(ropen(<span class="string">&quot;/abc==d&quot;</span>, O_CREAT) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_RDONLY)) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    assert(rwrite(fd[<span class="number">0</span>], <span class="string">&quot;\0\0\0\0\0&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">1</span>], <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">2</span>], <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">3</span>], <span class="string">&quot;\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  assert(rclose(genfd(fd, <span class="number">4</span>)) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0\0\0\0\0\0\0\0&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hellohello&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;worldworld&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x001\x002\x003\x0fe\x0ff\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他的请再等等吧（</p><p>2023.1.14 补：</p><p>上线了测试点 4，在 main() 的开头做了一件事：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rread(<span class="number">-100000000</span>, buf, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>所有人都炸掉了。但按照手册，它应该返回 -1。这只是测试中不合理数据的一角，请大家保证自己的实现的可靠性。</p><p>如果你对某些特例会产生什么行为抱有疑问，欢迎提问。</p><h6 id="修订9"><a href="#修订9" class="headerlink" title="修订9"></a>修订9</h6><p>+++ 再次强调请小心地管理内存，否则内存容易超限，特别是注意释放掉已经不用的空间。</p><p>+++ OJ 评测结果解释：</p><p>+++ 答案错误：你的函数行为与规定的行为不一致。可能是文件系统中的内容不一致，也可能是函数返回值不符合约定。</p><p>+++ 运行错误：你的函数在内部崩溃了。</p><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://box.nju.edu.cn/f/8ef6cedb59de48f8a0b7/">实验要求</a> 请看群文件最新版。</p><p>项目框架将发布在 <a href="https://git.nju.edu.cn/Tilnel/gitm.git">https://git.nju.edu.cn/Tilnel/gitm.git</a></p><p><del>目前题目只有一个样例，直接交就是一伯分</del>。但我出好数据之后会重新评测。</p><p>有一个送分样例。正确按时提交保底 20 分。</p><p>Windows 上的提交不能用 make submit。你需要手动将你的目录下的 .git 文件夹压缩成 zip 手动在 OJ 那里上传。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>git 是当今世界上最流行的版本控制系统。本实验要求你通过提交 git repo 的方式来提交一个迷你版的命令行工具 gitm(inus)。</p><p><strong>注意：本实验将只能在 Linux 操作系统中完成</strong>，因为你不得不使用系统调用，而 OJ 是 Linux 的。提交 Windows 上可以编译运行的代码，在评测机上注定不可兼容。</p><p>首先，你需要学习 git ，否则你将完全不明白 gitm 的功能，并且也无法用 git 来管理本次作业的代码。</p><blockquote><p>是的！我们将会发布一个由 git 管理的框架代码，并且要求你一直使用 git 来管理，最终提交一个 git repo。</p></blockquote><p>获取框架代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.nju.edu.cn/Tilnel/gitm.git</span><br></pre></td></tr></table></figure><h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><p>所有代码，包括 .c 和 .h 文件需要放在 git repo 的根目录下。对自己使用的头文件的引用请以双引号的形式，以便编译脚本能够正常工作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitm</span><br><span class="line">├── gitm.c</span><br><span class="line">├── gitm.h</span><br><span class="line">├── whateveryouwant.c</span><br><span class="line">├── whateveryouwant.h</span><br><span class="line">├── ...</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">/* gitm.c */</span><br><span class="line">#include &quot;gitm.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可以修改 Makefile，但请不要删除其中的 git 目标依赖。我们在 Makefile 中确保了你的每一次编译运行都能够自动进行 git commit。这些自动的 commit 可以帮助你回滚到自己想要的任意版本，并且在未来查重工作中产生疑问时，良好的 commit 记录将成为重要的证明。</p><p>在你的 git repo 里请包含所有编译所需的源文件，但不要出现编译不需要的多余的源文件。</p><p>尝试编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>你将看到根目录下产生了一个名为 gitm 的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gitm version</span><br></pre></td></tr></table></figure><p>你将看到一个小彩蛋（你之后可以自由地删掉它或修改掉，不影响成绩）。</p><p>注意：本次实验你编写的是一个 “命令行工具”。也就是说，我们将以和使用 git 相同的方式来使用它：在命令行里输入命令和参数。这意味着，这次你需要真正 “解析参数” （被 parse.c 支配的恐惧）。</p><p>而且，这次我们将会在运行中多次调用你的程序。也就是说，你的程序并不是在一直运行着，每一次调用都会做不同的事。你存储在内存里的数据都将随着功能完成，进程结束而消失。所以，关于 gitm repository 的有用的信息，你需要将它们持久化到磁盘上，以便进行后续的操作。因此学习 C 语言的文件操作是必不可少的。</p><p>为了实现一个 git，首先你要了解 git 的功能</p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>假设我们当前在一个文件夹 dir 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm init</span><br></pre></td></tr></table></figure><p>初始化当前的 dir 为一个 gitm repository。如果当前 dir 已经是一个 gitm repo，则不做任何操作。</p><p>此时的 gitm 中应当不存在任何 commit，gitm 的仓库中应不存在任何文件。</p><p>具体来说，你可以在当前目录下创建一个 <code>.gitm</code> 目录，用于存放一些记录仓库状态的文件。</p><blockquote><p>对，就像 git 的 .git 那样！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm commit</span><br></pre></td></tr></table></figure><p>将当前仓库中文件改动后状态作为一个提交，并记录下来。然后不重复地给出一个长度为 8 的小写十六进制数（例如 3bdc8902），用于唯一地指示这一次 commit。</p><p>git 中的提交是一个树形的结构。我们希望你在 gitm 中，同样实现这样的树形结构。</p><img src="git-brance.svg" alt="img" style="zoom: 100%;"><p>gitm 中不要求实现对分支的命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout commit</span><br></pre></td></tr></table></figure><p>checkout 用于将当前目录的状态切换到 commit 所指示的提交上。</p><p>若当前目录的状态较 gitm <strong>当前所处的 commit</strong> 有改动，则拒绝本次 checkout，并且<strong>你的 main() 函数以返回值 1 退出</strong>。</p><p>checkout 正常完成后，你目录中文件的状态（除了 .gitm 目录以外）必须与指定的 commit 相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout .</span><br></pre></td></tr></table></figure><p>特殊地，这一条命令用于将目录文件恢复到当前所处的 commit 时的状态。也就是说，放弃此时对文件的所有改动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm merge commit</span><br></pre></td></tr></table></figure><p>找到当前所处 commit 与命令指定的 commit 的公共祖先，并将两个 commit 合并起来。</p><p>具体来说，是将命令指定的 commit 相对于公共祖先的修改，应用于当前所处的 commit。</p><p>如果合并的两个 commit 相对于公共祖先，均对同一个文件产生了修改（创建、删除、编辑），那么命令直接拒绝执行，输出 “conflict\n” <strong>并使 main 函数返回 1</strong>。</p><p>在其他情况下，你需要合并，并产生一个新的 commit。逻辑上，这个 commit 将成为被合并的两个 commit 的共同后继。</p><blockquote><p>我们如何检测这一点？</p><p>假设有 commit a-g，b, c 由 a 分支而来，d 由 b, c 合并而来，e 是 b 的后继，f 是 c 的后继，g 是 d 的后继。</p><p>你的程序应当有能力找到 e, g 的公共祖先是 b，f, g 公共祖先是 c，在此基础上合并是无冲突的。如果你只能找到 a，则合并有可能产生冲突，因为 e 相对 a 改变了 a.c，而 g 相对 a 也改变了 a.c。</p></blockquote><img src="image-20230103113625830.png" alt="image-20230103113625830" style="zoom: 67%;"><h3 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h3><p>我们会将你的 repo 里所有的 C 源文件和头文件收集起来进行编译，并生成一个名为 <code>gitm</code> 的可执行文件。然后原地创建一个文件夹，作为你的 gitm 需要管理的 repository。例如（其中 &gt; 开头的行表示命令行输出）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line">../gitm init</span><br><span class="line">../gitm commit</span><br><span class="line">&gt; 3bce5ff0                       <span class="comment"># 空 commit，我们的 OJ 一定会创建一个空 commit 作为第一个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt   <span class="comment"># 创建文件并写入</span></span><br><span class="line">../gitm commit</span><br><span class="line">&gt; b926d817</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is my git&quot;</span> &gt; readme.txt</span><br><span class="line">../gitm checkout 3bce5ff0</span><br><span class="line">&gt; You<span class="string">&#x27;ve made change. Please commit or garbage your change.</span></span><br><span class="line"><span class="string">echo $?                          # 给出上一条命令的返回值。正常退出的程序应当为 0</span></span><br><span class="line"><span class="string">&gt; 1</span></span><br><span class="line"><span class="string">../gitm commit</span></span><br><span class="line"><span class="string">&gt; ef938aa6</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt readme.txt .gitm</span></span><br><span class="line"><span class="string">../gitm checkout b926d817</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt .gitm</span></span><br></pre></td></tr></table></figure><p>随着时间的流逝，我将会发布进一步的实验指南。</p><h3 id="实现要求-3"><a href="#实现要求-3" class="headerlink" title="实现要求"></a>实现要求</h3><ul><li>你创建的所有文件都要放到运行目录的 .gitm 目录下。<ul><li>+++ 对目录的体积要求：不要每一次都追踪没有发生变化的文件即可。不需要对每个文件进行增量存储。 +++</li></ul></li><li>commit 数量不会超过 10000 个。</li><li>你的 gitm 只需要管理文本类型的文件。其他类型的文件不会出现。</li><li>不要求追踪空目录</li></ul><p>本实验的测试点预计如下：</p><p>1、hello world（保留 gitm version 的打印信息即得分）</p><p>2、和上面的脚本相似的一段小测试，基础功能</p><p>3、文件数量增加，提交数量增加；但并不会出现子目录</p><p>4、在 3 的基础上，有一定的目录结构</p><p>5、在 4 的基础上，测试 merge 功能（不会很刁钻，只要该拒绝的拒绝，该成功的 merge 对就行了）</p><p>6、测试 .gitm 的空间管理，<strong>要求未发生改动的文件不重复存储，不要求单文件的增量存储</strong></p><p>能够恢复对文件就可以了，不会太刁钻。</p><h3 id="实现指南-1"><a href="#实现指南-1" class="headerlink" title="实现指南"></a>实现指南</h3><p>一个更加 naïve 的思路。从一个 commit 刚刚被提交说起…</p><p>此时，所有的目录结构和文件改动都被提交了，我们可以在当下的目录中进行新的改动。为了能够恢复到刚刚提交的“干净”状态，我们需要为当下的状态做一个暂存，以便之后进行对比。</p><p>现在我们做了一些改动，想要 commit。这里，需要记录下改动的部分，没有改动的部分则默认是保持的。我们可以用文件系统的 api 遍历当前目录和暂存下来的目录，检测文件的增删等。对于依然存在的文件，则需要逐字符对比其中的改动。当所有的改动全部检测完毕后，在 .git 下保存好本次改动中：</p><ul><li>删除了哪些文件</li><li>增加了哪些文件和这些文件的内容</li><li>编辑了哪些文件和这些文件的新版本</li></ul><p>并将本次 commit 及其父节点 commit 号记录下来。</p><p>可以使用的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;     <span class="comment">// 打开目录</span></span><br><span class="line">       <span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;  <span class="comment">// 读取目录中的项目</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;  <span class="comment">// 创建新目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;   <span class="comment">// 删除目录</span></span><br></pre></td></tr></table></figure><blockquote><p>如何更简单地判断新文件是否发生改动，特别是较大文件？</p></blockquote><p>可以对所有存储下来的文件做 <code>md5sum</code>，为文件生成一个摘要。之后再有文件变动时，先去找是否存在相同的 md5，如果新旧文件的 md5 相同，就不用重复保存了。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="废弃的旧思路（依然可以尝试）"><a href="#废弃的旧思路（依然可以尝试）" class="headerlink" title="废弃的旧思路（依然可以尝试）"></a>废弃的旧思路（依然可以尝试）</h3><p>一个 naïve 的思路。</p><p>首先介绍两个工具，一个叫做 diff，一个叫做 patch。这两个工具是大部分发行版自带的。<strong>看到这里请打开你的命令行</strong>一起尝试一下。</p><p>准备任意一个代码文件 a.c，复制到 b.c，在 b.c 中加入一些行，删去一些行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>能看到：</p><img src="Screenshot_20230115_000047.png" alt="img" style="zoom:75%;"><p>可知，diff 可以计算出两个文本文件之间的差距。</p><p>用重定向将这一结果定向到 <code>diff.out</code> 中，我们再用 patch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch a.c diff.out</span><br><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>这次什么也没有输出。a.c 和 b.c 变成一样的了。</p><p>diff 不仅可以给 a.c 打补丁，还可以把补丁从文件中拆下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -r b.c diff.out</span><br></pre></td></tr></table></figure><p>再打开 b.c，就能发现文件变回了之前  a.c 的样子。</p><p>great。所以只要你能够在 commit 的时候遍历目录中的所有文件，挨个 diff 一下，就可以算出当前版本和上个版本的差距了。然后你把这些差距全都写 .gitm 中的某一个文件，大功告成。</p><p>diff 和 patch 可以对两个目录直接计算差值和补丁&#x2F;回退。如果你学会怎么用，省去很多麻烦事。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结：在 .gitm 中我们需要存储的元素</p><ul><li>一个文件，能指示当前所处的提交</li><li>一个文件，包含了所有的提交号，并需要能够指明每个提交在树结构上的祖先节点。对于新 commit 是一个，对于 merge 是两个（这与 git 并不完全相同）</li><li>若干个目录，每个代表一个 commit；每个目录若干个文件，记录它相对祖先节点的变化：增减文件目录，编辑文件</li><li>一个目录，包含了当前 commit 的暂存状态，以便之后用于与编辑后的状态进行比较</li></ul><p>在 gitm 执行的过程中，有这样一些子功能需要实现：</p><ul><li>解析参数，执行对应功能</li><li>遍历当前文件树，与已提交的文件树对比</li><li>将对比的文件树中公共部分进行比较</li><li>分析 commit 记录，确定提交之间的关系</li><li>通过提交之间关系，决定前进或后退</li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中国哲学史 阅读笔记 I</title>
      <link href="/20230605-cphil1/"/>
      <url>/20230605-cphil1/</url>
      
        <content type="html"><![CDATA[<p>本对中哲兴致不高，但受人推荐，不宜推托，故计划分三次读完全书。</p><p>简要回顾上回读到中国哲学的精神。</p><p>中国人不那么关切宗教，是因为他们太关切哲学了。他们在哲学里找到了超越现实世界的那个存在，……。形而上学的功能不是要增长正面的知识，而是概念的澄清和心灵的提高。宗教提供有关实际的正面信息，却与科学提供的不同。因而科学前进一步，宗教后退一步。</p><p>中国哲学要解决的问题：在入世和出世的两极对立中寻求他们的综合。“内圣外王”，政治领袖应有高尚的心灵。与柏拉图的“哲学王”的观念相似。中哲关注政治思想，但也不缺少形而上学、伦理学和逻辑。名家“白马非马”，欲推是辩，以正名实，而化天下焉。（符号学家？）</p><p>表达方式上，富于暗示而不是一泻无余。言有尽而意无穷。（微软拼音输入法是真的垃圾。）得意而忘言。</p><p>中国哲学的背景</p><p>大陆国家（非海洋国家）。</p><p>农业国家的经济思想，农民的物质财产难以移动，而商人的易于转移，容易不顾国家自己逃跑。</p><p>“反者道之动”。任何事物都包含了对自己的否定。居安思危；黎明即将到来。“过犹不及”，中庸之道。</p><p>对自然的理想化。“天人合一”。对农民社会的田园诗式颂歌。</p><p>家族制度。靠土地生活因而世世代代无法离开；祖先崇拜。</p><p>入世出世。儒家游方之内，道家游方之外。方即社会。个人的社会责任，还是任内行自然自动的秉性。</p><p>艺术与诗歌（我感觉偏题了。这是背景？这不是观点吗？并没有写某个政治经济背景对哲学的影响，而是哲学思想对文化作品的影响啊。）道德的教育工具，还是心灵的自由流动。（表现论和实用论的分歧，我们要托马斯曼还是卡夫卡） </p><p>农民的眼界制约着中国哲学的方法论，认识论在中国哲学里未得到发展，因为在一个连续审视过程中，没有明确区分主观与客观的界限。（为什么？）并且中国哲学的语言是提示性的，因为它仍然关注物质世界而非理念世界，说的是具体的事而非抽象的命题。</p><p>（我懂了。意思是中哲重视感性直觉，西哲重视抽象概念。）</p><p>希腊人以贸易维持繁荣，数学发展较早且普遍，更容易理解抽象的概念。并且更加习惯变化、新奇的事物。因而工业革命发生在西方。</p><p>中国哲学虽然是过去的哲学，但仍为当今的人提供一种社会的和人生的理想。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023技科转专业机试-LRU</title>
      <link href="/20230602-LRU/"/>
      <url>/20230602-LRU/</url>
      
        <content type="html"><![CDATA[<p>LRU 代表 “Least Recently Used”（最近最少使用）。在计算机系统中，这一技巧常被用来管理较为紧缺的资源，比如内存或磁盘空间。</p><p>想象你有一个小型的缓冲区（buffer）。当你需要获取一个内存对象的时候，首先检查它是否在当中，如果有，那么就可以很快速地返回。但如果buffer里没有，就需要访问更慢的磁盘。这就需要花费更多的时间。</p><p>接下来，我们来介绍 LRU 策略。LRU 优先将最近使用过的项目保留在buffer中，并在buffer已满时优先将最近最少使用的项目移除。这一策略的根据是，如果一个对象很久没有被访问，那么之后再去访问它的概率也比较低，因而可以“腾笼换鸟”。</p><p>举例说明：</p><p>1、现有一个容量为3的buffer</p><p>2、最初，buffer为空</p><p>3、程序依次访问3个对象：A，B，C。它们都是最近使用的，因而被放在buffer中</p><p>4、再次访问C，C刚好在buffer中，称为命中（hit），返回其值</p><p>4、现在访问D。D不在buffer中，称为缺失（miss）。因为buffer满了，因此最近最少用的对象（A）被移除，将D放入</p><p>5、如果再访问A，那么需要从主存中重新读取，并放到buffer中替换掉最近最少使用的B</p><p>如此重复…</p><p>本题需要你用链表和数组模拟一个缓存-磁盘二级结构。其中磁盘为一个 int 类型的数组，能够容纳 32 * 1024 * 1024 个 int 型整数，其初始值全为0。每一个链表节点都储存一个“键-值”对，表示在“磁盘”中的一个数组下标对应其中的值。缓存有一个容量上限。需要支持以下操作：</p><ul><li>写入：给出数组下标和所赋的值，将值写入模拟的磁盘。需要首先检查cache中是否存在对应项。如果cache是满的，那么最近最少使用的对象应当被移除，以容纳新写入的对象。</li><li>读取：按照所给的下标读取值。如果buffer中存在，则返回buffer中的值，并输出hit。如果不存在，则从数组中读取，并输出miss，然后把这个键-值对放入buffer中。</li><li>调整大小：调整buffer能够存储的键-值对的个数。如果增大容量，则新的项目均为空；如果减小容量，则在旧的项目中保留最近的。</li></ul><p>输入格式：</p><p>第一行两个整数，表示buffer的初始大小和操作的数量；</p><p>之后的每行可能为下列中的一个：</p><ul><li>write $position$ $x$：向磁盘中第 $position$ 个整数的位置写入 $x$。其中 $x$ 在 <code>int</code> 范围内，$0 \leqslant position \leqslant 32*1024 * 1024$</li><li>read $position$：读出磁盘中对应位置的整数值</li><li>resize $size$：调整 buffer 大小为 $size$</li></ul><p>输出格式：</p><p>对于每次读取请求，输出一行，包括读取到的值，空一格，输出”hit”或”miss”。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结构</title>
      <link href="/20230603-structure/"/>
      <url>/20230603-structure/</url>
      
        <content type="html"><![CDATA[<p>最近思考的时候，有一个词语的出现频率很高，叫“结构”。</p><p>举个例子。我常常认为人对一切事情的经历，归根到底是出于他本身的结构。</p><p>又比如。我认为每个人的那些过去也好，内在也好，在结构上并没有什么不同。所以人的灵魂就是匮乏。</p><p>初次与普罗蒂总结的36种戏剧模式正面遭遇时，只是觉得新奇，但并未给予关注。仔细回想起来，童年时和家长看新播的电视剧时，家长常常能准确说出接下来的剧情走向。再到我吃过一点苦头之后，冷静下来，总能找到理论的影子。</p><p>现实世界的故事，如果是进行时，它就跌宕起伏；如果是完成时，它就再难以引起人心中的涟漪。</p><p>所以，坚持自己的与众不同，就是要做表面文章。</p><p>我首先是要好好地驳一驳这两点。然后不出意外，就是很难反驳。并据此分析。</p><p>我看到人都是不同的，因为善良无恶意的人们总因为互不理解而争吵；我又看到人们是相同的，因为他们的言说总是呈现了似曾相识的结构。</p><p>我主张自己的与众不同，否则我的表达与宣泄就丝毫不能给我带来快感；我又主张自己和所有人一样，否则我既不会对别人感到同情也不会被人同情。</p><p>为什么会这样，我还没想好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>答辩之前</title>
      <link href="/20230531-beforedebate/"/>
      <url>/20230531-beforedebate/</url>
      
        <content type="html"><![CDATA[<p>和磊哥、朱姐、章姐…等等人的酒局感觉以后不会再去了。有一种被排除在外的感觉。</p><p>虽然和很多人加了好友，包括赵姐，but。。？有缘再见吧。</p><p>穿越幻象不是一劳永逸的，因为幻象是接二连三地到来的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>notitle</title>
      <link href="/20230525-fans/"/>
      <url>/20230525-fans/</url>
      
        <content type="html"><![CDATA[<p>非正式发布版，随你怎么写吧。</p><p>昨晚写匡院的小作文写到5点，闭眼再一睁是9点，看到一条QQ好友请求，通过之后立刻困得放下手机继续睡了。12点又醒来，收到微信的好友请求，是同一个名字，这次的备注消息是“一个粉丝”。可能是前天晚上酒还没醒，大脑过载，没明白是什么意思。</p><p>我擦，我平时胡言乱语碎碎念的空间居然还有粉丝。一聊才知道是因为精神分析相关的内容，不过我唯一一篇提及精分的日志是从别处转载的。而且已经没怎么更新过动态了。</p><p>倒不是说没什么可更新的。</p><p>之前转载了一篇《<strong>假如你没有五十法郎寻求精神分析治疗…</strong> 》的文章，被路过的网友读到，然后以“一个粉丝”的身份加了我的好友。</p><p>这是我从没想过的。我认为过去的那些碎碎念没有任何价值，并且“言说”这件事对我来说变得越发困难起来。</p><p>原文的作者说要“写下症状，悄悄放在世界上”，将自己的疯癫絮语藏匿于广大的互联网中，以期获得大他者的沉默回应。而事实上后来的两年里他再也没能说出什么。在最后试图用痛苦来丈量自己的虔诚后，他已在倒错中噤声。</p><p>不由得想到那晚站在货架前，我掰着手指头盘算着700毫升的绝对伏特加在我本科的最后一个月要怎么才能喝完。结果我不好说我和它到底是谁在consume谁了。</p><p>不要喝酒；如果一定要喝，不要醉酒；如果一定要醉，不要断片；如果一定要断片，不要在没有朋友的地方断。</p><p>给舍友带来了一些深重的灾难，真的要磕头了。</p><p>想起上一次断片后在微信里跟学姐胡言乱语，她瞬间就理解了状况，真的温柔，我哭死。后来轮到她喝大了，听说给前男友打了十几个未接电话，什么恋爱脑。</p><p>为什么我感到越来越难以言说。</p><p>在并未醉酒的大部分时间里的大部分人只是作为透明的环节参与其中，在场上流动的只有骰子的点数、牌的大小以及杯中的液体。甚至每个人所讲述的任何话语都显得不痛不痒。清醒的人赶到已经开始一段时间的酒局，几乎只会冷静地看着剩下的人“发疯”。</p><p>醉酒后，作为原初创伤的遮蔽，构成幻想的话语变得支离破碎，症状才得以以它原来的方式显现。多数人只有在这种时候，才能够暂时地接受创伤造成的缺失。也正是这种时候人的情绪最高涨，清醒时不那么好玩的事情也变得好玩起来。</p><p>要我温和而克制地叙述那些故事，就像是用话语的垃圾袋把症状装起来扔到大路上。所谓遗忘只能是压抑，压抑后的创伤只会悄悄返回。让创伤成为创伤，承认自己的生命就是一个创伤，不要去舔舐伤口，享受你的症状。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vegas</title>
      <link href="/20230525-vegas/"/>
      <url>/20230525-vegas/</url>
      
        <content type="html"><![CDATA[<p>What happens in Vegas stays in Vegas.</p><p>What happens in the room stays in the room.</p><p>BE GENTLE ANYWAY.</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DCF 随手</title>
      <link href="/20230509-DCF/"/>
      <url>/20230509-DCF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>图片真的全部散失了。</p></blockquote><p>Paxos 算法的变种不是非此即彼的关系，在不冲突的情况下，可以组合使用</p><p><img src="image-20230509131831146.png" alt="image-20230509131831146"></p><p>DCF 是动态库</p><p>异步通知事务</p><p><img src="image-20230509132034495.png" alt="image-20230509132034495"></p><p><img src="image-20230509132148314.png" alt="image-20230509132148314"></p><p>prevote 优化</p><p><img src="image-20230509132906832.png" alt="image-20230509132906832"></p><p>dcf_interface.h</p><p>dcf_start 拉起 </p><p>然后调 write 写   日志流1个就够了</p><p>buffer是不关心内容的，只是达成一致后回调通知数据提交</p><p>但是外部业务可能需要知道。。。key是辅助的信息，回调的时候返回，这样知道是哪个数据得到了承认</p><p>index是序列里的第几个得到了承认</p><p>read 根据写的时候的 index 来读取数据</p><p>stop 就停止</p><p>回调接口，usr_cb</p><p> status_notify 状态通知，数据内核根据这个切换自己的状态</p><p>数据库对接。不重要</p><p>参数配置</p><p><img src="image-20230509133548477.png" alt="image-20230509133548477"></p><p>现在不支持空洞</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>护肤</title>
      <link href="/20230414-thoughts/"/>
      <url>/20230414-thoughts/</url>
      
        <content type="html"><![CDATA[<p>痘坑：医美</p><p>痘印：水杨甙、甘草提取物</p><p>色素沉淀：烟酰胺，维C，维E</p><p>防晒</p><p>珂岸修颜乳</p><p><img src="image-20230414162147386.png" alt="image-20230414162147386"></p><p><img src="image-20230414162245844.png" alt="image-20230414162245844"></p><p>毕生之研 五环修红精华</p><p>快速去痘印：积雪苷霜软膏，多磺酸粘多糖软膏 （临床指导）</p><p>细菌性毛囊炎：莫匹罗星软膏、夫西地酸乳膏</p><p>头上：二硫化硒洗剂</p><p>真菌：联苯苄阳台上</p><p><img src="image-20230414164146099.png" alt="image-20230414164146099"></p><p>首先停掉护肤品。然后好好洗脸。？？？？</p><p><img src="image-20230414164244622.png" alt="image-20230414164244622"></p><p>1控制住手 2洗脸后用（点涂薄涂）过氧苯甲酰凝胶</p><p><img src="image-20230414164423859.png" alt="image-20230414164423859"></p><p>去医院。</p><p><img src="image-20230414164529494.png" alt="image-20230414164529494"></p><p>每天只用一次洗面奶</p><p>先涂修复性精华。雅诗兰黛小棕瓶，好jb贵。</p><p>素森康 二裂酵母水光修护精华</p><p>快的：同一家的贻贝粘蛋白，贵的一笔</p><p>最后保湿。质地轻薄</p><p><img src="image-20230414165258347.png" alt="image-20230414165258347"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>速通纯批（一）导言与先验感性论</title>
      <link href="/20230413-PureCritique/"/>
      <url>/20230413-PureCritique/</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>半学期的哲学课给我最大的感受是，在高中三年大学四年的忽视下，我与科班出身的同学相比缺少的不是对哲学体系的把握能力，而是对理论的系统化表述能力。说得再直白一点，就是“我不会说话”。如果把哲学体系比作概念能指编织而成的一张网络，我的“网络拓扑”与那些成日泡在文本中的同学相差并不大。康德艰深晦涩，但过了最初的一关，剩下的困难几乎都在于长难句。如果把句读直接作为文本，往往会在邓老师不厌其烦的复读中，忘掉了康德论证的结构（Sorry，邓老师，您的句读还是有很大帮助的）。总之，我想说康德的体系并不困难。但自己系统化地表述又是另一个问题。在这上半学期哲学史的pre中，有太多好的例子，例如今天上午刚讲了笛卡尔的第四组反驳与答辩，我还能想起他是在讲“意志”在笛卡尔那里，处于一个什么样的位置。在我看来就已经很了不起了。一个失败的论述到最后往往连最初的观点都丢掉了。</p><p>我本打算速通纯粹理性批判，但越是读下去，以及越是尝试萨特、黑格尔，就越是感到它作为一个入门的系统性论述文本，是不可速通的。尤其在于后来者的概念往往是前者概念的延伸、歪曲、颠倒，有意无意地指涉。另外，如果没有翻过纯批里的每一座山，日后对于现象学的把握也成问题。况且理论来得稍微迟一点并不影响实践，因此这里决定多耗费些时日。</p><p>Tilnel</p><p>抽掉理性能力的一切对象，除了理性其自身及其形式以外，不与任何别的东西打交道。是为纯粹理性。</p><p>数学和逻辑学是完全纯粹的；而物理学仍然需要经验的知识作为基础。</p><p>通常，认为一切知识都必须依照其对象。然而理性究其本性不断由果溯因（我们都会追求所谓究极真理），需要自在事物本身中有一个无条件者，作为一切原因的源头，这是一定会超出经验所认知的。如果认为一切知识都要依照其对象，我们就无法无矛盾地设想一个无条件者。而只要在此作一个颠倒，即对象是依照知识的：我们关于对象的知识是自在之物在人的表象能力下作为现象，而绝非作为自在之物本身被人所认识到的。矛盾就没有了。</p><p>关于“物”，我们“先天地”认识到的只是由我们自己放到它里面去的。理性之所以能认识物，必在于其先天地有认识物的能力，这就是一种“先天知识”，是一切后天的判断中都必然包含的“先天成分。</p><p>为什么要对纯粹理性做如此批判？因人思维的本性是无限追溯事物后的原因，以至引出了三个重要问题：上帝是否存在、灵魂是否不朽、意志是否自由。在形而上学的发展中诞生了唯理论与经验论两派。只依赖理性而不顾经验导向独断论，而只依赖经验却不相信理性导向怀疑论。批判就是为了探究理性在认识的与实践的方面，其能力与界限，进而调和两种观点之间的矛盾，建立未来形而上学的大厦，一种“先验的唯心论”体系。</p><p>“理性能力本身，独立于经验有可能追求到什么样的知识？”这与一般形而上学的可能性或不可能性密切相关。</p><p>几组概念与命题</p><p>I. 纯粹知识与经验性知识</p><p>纯粹的，在康德这里几乎与“先天的”同义。即不掺杂任何经验性的。譬如 1+2&#x3D;3，一切结果必有其原因。当然“结果”与“原因”的概念似乎依然从经验中来，此处按下不表。经验性知识，如今天下雨了。</p><p>II. 先天知识的必然性与普遍性</p><p>必然性，那就是除此之外别无他种可能；普遍性，就是放之四海而皆准的。正如一切数学知识。</p><p>III. 需要规定先天知识的可能性、原则与范围</p><p>上述的人的思维本性所产生的三大课题，是完全离开经验，仅能凭借理性去思维的。但这就导致不经检验地运用理性，因为有不受限制地扩张知识的诱惑。</p><p>IV. 分析判断与综合判断</p><p>分析判断，即我们从语词的概念中即可分析出的命题。如“床是用来休息的”，这一属性能够从物的定义中分析出来。而综合判断，则是将并无关联的概念综合在一起。比如两点之间直线段最短这一命题，“直线段”是质的规定，而“最短”是量的规定。并没有从一个概念中能分析出另一个概念的可能，却连结起来而为人们深信不疑。</p><p>我们在构建知识大厦的时候，有大量的分析工作让我们迷失：分明只是分析的判断，却由于其形式上的变换，被认为是新的洞见，人很容易接受这一假象。</p><p>经验判断全都是综合的。“一切物体有重量”作为经验判断，其中包含的【经验】是[“有重量”这一谓词与“物体”这一概念有可能综合的基础]。“经验”本身是诸直观的一个综合的结合。</p><p>V. 理性的一切理论科学都包含先天综合判断的原则</p><p>数学；物理学：质量守恒；形而上学：世界必有一最初开端。</p><p>纯粹理性的总课题是：先天综合判断何以成为可能</p><p>或：人的认识能力何以成为可能</p><p>先验感性论</p><p>“一种知识不论以何种方式和通过什么手段与对象发生关系，它借以和对象发生直接关系、并且一切思维作为手段以之为目的的，还是直观”。</p><p>这是说，知识与对象发生直接关系的中介、通道、手段，是“直观”；思维一个对象的“手段”是“直观”。比如我要思维一个三角形，必要在心中先生成一个“空间中的三角形”的直观。</p><p>直观只在对象被给予我们时才发生，只会是因为对象以某种方式刺激内心。通过被对象刺激而获得表象的能力叫做“感性”。在这里可以先把它想象成人的感官能力。</p><p>借助感性，对象被给予我们；且感性给我们提供出直观。直观通过“知性”被思维，产生出概念。</p><p>举个例子。路上的远处有一个人形排列的、发出600-700nm波长的电磁波的点阵映入我的眼里，我看到了一个牌子上亮着一个红色的小人，进而知道现在是红灯。我的通俗理解是，感性从乱七八糟的物理现象：各种波长的电磁波、机械波、分子热运动中，归结出各种颜色、音调、冷暖的“感觉质料”，到这里称之为“杂多”；然后再将这些属性归到实体中，向我们呈现出最后的那一个完整的“对象”。</p><p>当我们被一个对象所刺激时，它在表象能力（感性）上产生的结果就是感觉；经过感觉与对象相关的直观就叫做经验性的直观（因此还有非经验性的，即“先天的”直观）。一个经验性的直观的（未被规定的）对象就叫做“现象”。</p><p>这里未被规定的可理解为“未被知性所思维的”。如果一个现象被知性所思维，那它就成为“概念”。这也仅仅是“概念”上的区分。</p><p>故，“现象”中，与“感觉”相关的东西，颜色、温度、气味，称为现象的质料；而在现象中，使得这些杂多得以整理的东西，称为现象的形式。现象的形式既然不是感觉，即是非经验性的，是先天的，是在排除一切经验以外的内心可以找到的，离开一切感觉仍有的。</p><p>康德在这里做了如下的思想实验：将我们对“物体”这一概念的认知不断地减少。首先抽出那些属于知性的东西，如实体性、力、可分性；再抽出属于感性的东西：颜色、温度…我们能够发现，抽出了这些属性之后，我们尚且还能够设想这样的物体——除了广延和形状：我们不能设想一个物体不占据一定的空间。</p><p>作为先天知识的原则，有两种感性直观的纯形式，即先天直观形式，空间和时间。</p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMC - A pragmatic Approach to Model Checking Real Code</title>
      <link href="/20230402-CMC/"/>
      <url>/20230402-CMC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>先说点题外话。经过长时间的感受之后，认为读文献还是用纸的好，目前打印了一批，是准备在本科期间精读完的。方便做标记，也方便找。而且不用盯着屏幕看，很舒服。</p></blockquote><p>测试分布式系统的bug往往需要非常错综复杂的执行序列，一个系统运行几小时、几天、几周。。才有可能触发代码中的问题。</p><p>检查 Bug 的方法，一是 Model Checking。它能够接受一个由实际代码简化来的系统，然后穷举系统执行的所有可能性。但是在现实中有很多缺点：建模非常困难。写模型比写代码化的时间多多了。并且检查这个抽象的模型，还是容易忽略掉实际代码实现里面的问题。</p><p>文章的贡献：</p><p>一是提出了一个新的 Model Checker，CMC，它能够直接对 C 和 C++ 代码实现进行检查，避免了抽象过程中的错误丢失，并且不用花时间去建模了。额外的好处是代码一经改动可以立即检查。</p><p>二是说明了 CMC 在实际的系统中能够得到较好的应用。通过对三个版本的 AODV 网络协议的模型检查，可以预见  CMC 能够应用于其他的系统，尤其是其他的网络协议。</p><p>复杂的系统有复杂的问题。现实中的系统有很多由错综复杂的执行顺序触发的边界情况没有在代码中得到处理。他们在系统中就像是“残渣”一样，日积月累，最后使整个系统瘫痪。我们发现了这种错误之后，通常就很难诊断问题的原因了。因为这些问题并不可复现。导致这些问题的执行流实在是太长，没有办法去重建在车祸现场之前到底发生了什么。</p><p>形式化验证是针对这种深层次的问题的一个可能的办法。它能够系统地列举系统的所有的可能状态。一个基本的模型检测从系统的一个初始状态开始，并且通过非确定地执行事件递归地生成后继的系统状态。所有的状态都被储存在一个哈希表里来确保每一个状态都至多被遍历到一次。这个过程一直持续到所有的状态都能够遍历完成，或者是所有的系统资源都耗尽。这种状态图探索的办法相较于不切实际的大量测试，能够在达到其效果地同时，避免测试当中的冗余。</p><p>传统的模型检测经常假设系统设计是以一种很高的层次，抽象掉实际实现的很多细节的。验证实际上的代码就需要从代码重建这些抽象的描述。这个过程需要大量的人工，妨碍到了模型检测在实际系统当中的应用。并且，人在手工抽象过程中的失误也会导致假阳性或漏报。这种错误既可能在构建模型的时候发生，也有可能在系统演进的过程中发生。</p><p>。。。</p><p>对实际实现进行模型检测的这个想法已经在几个工具当中被采用了。Verisoft，系统地执行 C 实现代码但是不记录状态。其他的软件模型检测工具比如说 [3][25] 是专门用于 Java 程序中的特定 Class 的。CMC 采用了多个研究当中的技术来设计，把它用于 C 和 C++ 编写的程序，它们是工业界应用到的主要语言。</p><p>我们的终极目标是检查所有的代码；但一开始我们关注网络代码。这种代码天然地遵从一种“事件驱动”的编程模型，能够很好地与模型检查工具相契合。网络代码的正确新很重要，因为它们常常处于服务的中心，并且经常是容易受攻击的对象。但是网络协议又难以设计、实现和测试因为网络中包括多台机器之间的复杂行为，并且需要处理多种网络错误，如丢包、连接失败，这些在测试环境中是很难控制的。模型检测就很擅长检查这些相互作用。</p><p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> 读文献 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毕业论文结构和部分内容</title>
      <link href="/20230401-thesis/"/>
      <url>/20230401-thesis/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>介绍 openGauss 数据库，以及作为分布式系统的特性。本工作的目标。</p><p>本节内容。</p><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>介绍分布式数据库、openGauss 和要解决的问题。</p><h2 id="研究工作"><a href="#研究工作" class="headerlink" title="研究工作"></a>研究工作</h2><p>简要介绍本文探索了哪些优化，得到了什么样的结果。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="TiKV-优化的-Raft"><a href="#TiKV-优化的-Raft" class="headerlink" title="TiKV 优化的 Raft"></a>TiKV 优化的 Raft</h3><p>TiKV 是一款开源的分布式事务型键-值数据库，采用 Raft 共识协议以保证强数据一致性和高可用性。Raft 与 Paxos 在容错和性能实现方面有很多共同点，但易于理解和实现。</p><p>在分布式系统中，“脑裂”是一个常见的问题。如果在一个 Raft 集群中发生脑裂问题，旧的 Raft Leader 节点不知道新的 Leader 已经被选出，如果此时有客户端的读取请求，则可能会读取到旧值。原版 Raft 的解决办法是让读请求前将全部 Log 按序应用到状态机，再去进行读操作，则可以保证读到的数据满足强一致性。这种方法的缺点在于每一次读请求都需要依次应用所有的 Log，引发严重的性能问题，因此实际上少有实际项目采用这种方法。Raft 协议的作者后来又在 Raft 的教学材料中提出了针对只读请求的优化方法，为 TiKV 所实现。</p><h2 id="论文组织"><a href="#论文组织" class="headerlink" title="论文组织"></a>论文组织</h2><p>这部分讲论文的结构。</p><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="openGauss"><a href="#openGauss" class="headerlink" title="openGauss"></a>openGauss</h2><h2 id="paxos-共识协议"><a href="#paxos-共识协议" class="headerlink" title="paxos 共识协议"></a>paxos 共识协议</h2><h2 id="DCF"><a href="#DCF" class="headerlink" title="DCF"></a>DCF</h2><p>openGauss-DCF 分布式共识框架是基于 Paxos 共识算法实现的一致性数据复制组件。传统的主备+集群管理采用的是主从模式，有容易触发日志分叉而重建数据、选主错误、不支持动态增删节点等缺陷。在这样的需求背景下，采用了基于一致性协议的自仲裁管理方法。</p><p>DCF 基于 Paxos 协议，扩展了多样化的节点角色：Leader 负责将日志复制到其他节点，并维持心跳；Follower 复制来自 Leader 的日志，心跳超时时转换为 Candidate，给其他 Candidate 投票；Pre-Candidate 发起新任期投票，收集来自其他节点的投票；Passive 复制来自 Leader 的日志；Logger 复制日志及给其他 Candidate 投票。</p><p>对比基本的 Paxos 协议，DCF 的实现采取了两个优化：一是 preVote 优化，通过加入 Pre-Candidate 状态，发起任期不变的预选举，成功后才进行正式选举，以避免网络断连导致节点频繁发起选主使任期持续增加。二是 Lease 优化，在 Leader 网络故障与多数派断连后主动降为 Follower，防止事实上存在两个 Leader。</p><h1 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h1>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何寻找文献</title>
      <link href="/20230331-howtosearchforpapers/"/>
      <url>/20230331-howtosearchforpapers/</url>
      
        <content type="html"><![CDATA[<p>成为了苦逼的研究生，除了要撸代码以外，更重要的是多看文献。文献看得够多，在研究中遇到的问题就总能从看过的文献中汲取灵感。</p><p>本文是我从网上搜刮完一轮之后，拼凑而成的如何找文献的总结。</p><p>网站</p><p>Web of science: apps.webofknowledge.com</p><p>Sci-hub: sci-hub.tw&#x2F;</p><p>软件</p><p>Endnote</p><p>本子和笔</p><p><a href="https://zhuanlan.zhihu.com/p/74728960">如何快速找到与研究方向相关的最新文献与权威文献？ - 知乎 (zhihu.com)</a></p><p><strong>1.读文献对于科研的意义</strong></p><p><strong>① 了解研究方向和领域</strong></p><p>科研不同于本科学习，很多知识、最前沿的进展都是从文献中获取与追踪。</p><p>在研究生初期，我们大部分人都会被导师安排先阅读哪些重要文献，对研究内容有个大致的了解，再开始具体的研究工作。</p><p><strong>② 实验idea的创造</strong></p><p>对于实验型学科，大部分的实验idea来源于文献。</p><p>所谓idea，也许就是把a方法的因素改变成为了b方法再应用于A领域，或者A领域的a方法在B领域中的应用，又或者将a方法改成b方法再应用到B领域中。</p><p>我的这个说法是一个最简单的模型，实际的科研比这个过程要复杂得多，但是有很多优秀的idea就是这么得来的。</p><p><strong>③ 撰写文章时引用</strong></p><p>现在大部分学校的博硕士毕业都是有论文发表要求的，本科不需要发表论文，但是如果有论文或者撰写论文的经历，在保研考研出国的升学过程中都是一个科研经历的亮点。</p><p>而一篇好的论文，须全面地概括本领域的现状，以及研究方法的参考。</p><p>写这部分内容需要正确地引用相关文献，所以我们在写论文之前读到这些相关文献就要保存下来、记录下相关的点，以便引用时用到。</p><p><strong>2. 如何通过文献了解本领域的概况？</strong></p><p><strong>① 阅读本领域权威综述</strong></p><p>登陆教育网或者教育网VPN，在Web of Science中输入关键词，再精炼文献类型为“REVIEW”，过滤为“领域内热点论文”。</p><p>（不方便使用教育网时请跳至下面两种方法）</p><p><img src="v2-9a87a0f91fd179600d32fccf8bd08274_720w.webp" alt="img"></p><p>Web of Science搜索文献界面</p><p><img src="v2-a4352af09d6dd888caac7cf17e8ca90f_720w.webp" alt="img"></p><p>精炼文献搜索范围为Review</p><p>然后勾选那些与自己领域密切相关、影响力大（被引用次数多）的条目，导出到“Endnote Desktop”，用Endnote软件打开就可以在本地看到了。</p><p>如何下载在第四部分再详细说明。</p><p><strong>② 阅读谷歌学术排前的论文</strong></p><p>谷歌学术的使用方法就是在谷粉学术网站中直接输入关键词，以前有个纳米人的网站也有这个功能，但是最近好像不太好使了。</p><p>谷歌学术搜索下来排前的论文一般都是被引次数多，在这个领域中产生巨大影响的论文，非常值得仔细阅读的。</p><p><strong>③ 找导师沟通</strong></p><p>如果领域中文献太多，或者是不知道导师想让你做什么样的工作，那就大大方方地直接找导师沟通吧。<br>导师肯定知道研究方向的必读论文、大牛，获得这些信息后再去找文献阅读，会事半功倍。</p><p>阅读材料：</p><p>教科书 - 专著和综述论文 - 实验性论文</p><p><strong>论文筛选算法：优秀的论文藏在优秀的期刊中</strong>：每个月跟踪期刊。</p><p><strong>本领域核心期刊、本领域牛人或主要课题组、高引用次数、研究方向相近的</strong></p><p>paper list <a href="https://www.zhihu.com/question/30026369">分布式系统领域有哪些经典论文？ - 知乎 (zhihu.com)</a></p><p>CCF 中国计算机学会推荐国际学术会议和期刊目录（2022）节选</p><table><thead><tr><th>简称</th><th>全称</th><th>出版社</th><th>网址</th></tr></thead><tbody><tr><td>TOCS</td><td>ACM Transactions on Computer Systems</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/tocs/">http://dblp.uni-trier.de/db/journals/tocs/</a></td></tr><tr><td>TOS</td><td>ACM Transactions on Storage</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/tos/">http://dblp.uni-trier.de/db/journals/tos/</a></td></tr><tr><td>TPDS</td><td>IEEE Transactions on Parallel and Distributed Systems</td><td>IEEE</td><td><a href="http://dblp.uni-trier.de/db/journals/tpds/">http://dblp.uni-trier.de/db/journals/tpds/</a></td></tr><tr><td>PODC</td><td>ACM Symposium on Principles of Distributed Computing</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/podc/">http://dblp.uni-trier.de/db/conf/podc/</a></td></tr><tr><td>ICDCS</td><td>IEEE International Conference on Distributed Computing System</td><td>IEEE</td><td><a href="http://dblp.uni-trier.de/db/conf/icdcs/">http://dblp.uni-trier.de/db/conf/icdcs/</a></td></tr><tr><td>SOSP</td><td>ACM Symposium on Operating Systems Principles</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/sosp/">http://dblp.uni-trier.de/db/conf/sosp/</a></td></tr><tr><td>OSDI</td><td>USENIX Symposium on Operating Systems Design and Implementation</td><td>USENIX</td><td><a href="http://dblp.uni-trier.de/db/conf/osdi/">http://dblp.uni-trier.de/db/conf/osdi/</a></td></tr><tr><td>OOPSLA</td><td>Conference on Object-Oriented Programming Systems, Languages, and Applications</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/oopsla/">http://dblp.uni-trier.de/db/conf/oopsla/</a></td></tr><tr><td>Middleware</td><td>International Middleware Conference</td><td>ACM&#x2F;IFIP&#x2F; USENIX</td><td><a href="http://dblp.uni-trier.de/db/conf/middleware/">http://dblp.uni-trier.de/db/conf/middleware/</a></td></tr><tr><td>TODS</td><td>ACM Transactions on Database Systems</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/tods/">http://dblp.uni-trier.de/db/journals/tods/</a></td></tr><tr><td>VLDBJ</td><td>The VLDB Journal</td><td>Springer</td><td><a href="http://dblp.uni-trier.de/db/journals/vldb/">http://dblp.uni-trier.de/db/journals/vldb/</a></td></tr><tr><td>SIGMOD</td><td>ACM SIGMOD Conference</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/sigmod/">http://dblp.uni-trier.de/db/conf/sigmod/</a></td></tr><tr><td>VLDB</td><td>International Conference on Very Large Data Bases</td><td>Morgan Kaufmann&#x2F;ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/vldb/">http://dblp.uni-trier.de/db/conf/vldb/</a></td></tr><tr><td>PODS</td><td>ACM SIGMOD-SIGACT-SIGAI  Symposium on Principles  of DatabaseSystems</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/pods/">http://dblp.uni-trier.de/db/conf/pods/</a></td></tr><tr><td>JACM</td><td>Journal of the ACM</td><td>ACM</td><td><a href="http://dblp.uni-trier.de/db/journals/jacm/">http://dblp.uni-trier.de/db/journals/jacm/</a></td></tr><tr><td>Proc. IEEE</td><td>Proceedings of the IEEE</td><td>IEEE</td><td><a href="http://dblp.uni-trier.de/db/journals/pieee/">http://dblp.uni-trier.de/db/journals/pieee/</a></td></tr></tbody></table><p>具体怎么订阅。。嗯。。没想好，这种东西每年一卷而且长的不行，建议再找时间去细细地切成臊子。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>COJ 评测机与 Main Server</title>
      <link href="/20230311-coj-server/"/>
      <url>/20230311-coj-server/</url>
      
        <content type="html"><![CDATA[<h1 id="Worker-amp-Server-of-COJ"><a href="#Worker-amp-Server-of-COJ" class="headerlink" title="Worker &amp; Server of COJ"></a>Worker &amp; Server of COJ</h1><p>大概想了一下，感觉是这样的。</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><ul><li>连接数据库，实际上管理数据</li><li>响应前端请求，鉴权，返回应用内容</li><li>响应Worker请求，提供评测相关信息</li></ul><p>本文主要设计 Server 和 Worker 的交互方式</p><p>首先由 Worker 向 Server 发起一个长连接，发送消息包含：worker 的 group，id，连接口令。Server 将 Worker 添加到评测机 pool （链表）中，并返回分配的 WorkerSeqNumber。</p><p>Server 收到前端的 submission</p><p>-&gt; 将 submission 添加到队尾（rejudge，那就是从数据里取出来放到队尾）</p><p>-&gt; 查询对应的 problem 是否有指定的评测机 group </p><p>-&gt; 取对应 group 链表头（无指定则随机选择）发送 submission 数据 </p><p>-&gt; 等待 Worker 返回，放回到对应队尾。持久化评测数据，返回数据给前端</p><p>Worker 本地不存在数据库，不与 Server 共享文件系统（分布式）。这意味着：</p><ul><li>不能从 db 查询提交详情。由 Server 直接发送。</li><li>需要向 Server 实时请求评测数据、题目信息（包括special judge、sample case、题目的分数衰减等）。<ul><li>为了节约一点，每一个 Problem 有属性 SpjEdited 和 TestEdited。只有在本地无数据最新版本数据的时候，worker 才会重新发请求。</li></ul></li><li>文件和时间戳可以保存在本地文件系统，故单机的 Worker 之间是共享这些数据的。重启后，如果版本没有更新，则不需要重新请求。</li></ul><p>Server 监听 Client 和 Worker 消息，使用两个不同的 Socket。</p><p>worker api:</p><p>&#x2F;connect?group&#x3D;{}&amp;password&#x3D;{}</p><p>返回：&gt;&#x3D;1 的未占用最小序列号</p><p>&#x2F;tests?problemid&#x3D;{}</p><p>返回：problemid 对应问题的评测数据 tarball</p><p>&#x2F;task  请求评测任务（可能很久后才返回）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;submissionId&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;problem&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hasSpj&quot;</span><span class="punctuation">:</span> Bool<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Spj&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span> (base64)</span><br><span class="line">        <span class="attr">&quot;samplecase&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span> Json of base64 encoded input/output</span><br><span class="line">        <span class="attr">&quot;testcase&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span> Json array of input/output file path and testcase weight</span><br><span class="line">        <span class="attr">&quot;validLanguage&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;skipSample&quot;</span><span class="punctuation">:</span> Bool<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> Int，</span><br><span class="line">        <span class="attr">&quot;SpjEdited&quot;</span><span class="punctuation">:</span> String<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;TestEdited&quot;</span><span class="punctuation">:</span> String</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Language&quot;</span><span class="punctuation">:</span> Int<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Src&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span> (base64)</span><br><span class="line">    <span class="attr">&quot;HasInput&quot;</span><span class="punctuation">:</span> Bool<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;UserInput&quot;</span><span class="punctuation">:</span> string<span class="punctuation">,</span> (base64)</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>&#x2F;submission</p><p>参数：id, score, message, failedOn, verdict, judgedAt, memory, time…</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><ul><li>读取配置文件。包含本地文件的存储路径，server 的 ip:port，worker 的分组及 cpuset</li><li>fork 出对应数量个进程，并设置进程绑定 cpuset</li><li>连接 Server，得到自身的 workerSeqNo（用作本地 isolate 容器编号。这样就不会被多个 worker 混用了）</li><li>请求任务-处理-返回</li></ul><p>重点说一下处理：</p><p>请求到评测任务后，先检查评测数据版本。如果最新版本不存在，则向 Server 请求，然后丢到本地目录，并加上时间戳。</p><p>再检查如果有 spj，是否有最新版本二进制。如果没有，就重新编译。</p><p>然后就和 dotoj 的流程差不多了…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Compile(code):</span><br><span class="line">  switch code.Language:</span><br><span class="line">    case C:</span><br><span class="line">      Exec(gcc, -o, main, ...)</span><br><span class="line">    case Cpp:</span><br><span class="line">      Exec(g++, -o, main, ...)</span><br><span class="line">    default:</span><br><span class="line">      return COMPILE_NO_SUCH_LANGUAGE</span><br><span class="line"></span><br><span class="line">RunCase(cases):</span><br><span class="line">  for case in cases:</span><br><span class="line">    Exec(main, case.input)</span><br><span class="line">    if (hasSpj)</span><br><span class="line">      spj(case.answer, case.output)</span><br><span class="line">    else</span><br><span class="line">      diff(case.answer, case.output)</span><br><span class="line"></span><br><span class="line">RunSubmission():</span><br><span class="line">  if language == Lab:</span><br><span class="line">    return RunLab()</span><br><span class="line">  if hasSpj:</span><br><span class="line">    if stat(checker + date) == ENOENT:</span><br><span class="line">      Compile(spj)</span><br><span class="line">  Compile(src);</span><br><span class="line">  if hasInput:</span><br><span class="line">    Exec(main, CustomInput)</span><br><span class="line">    return Output</span><br><span class="line">  if !skipSample:</span><br><span class="line">    result = runCase(Samples)</span><br><span class="line">    if result != AC:</span><br><span class="line">      return WA with X</span><br><span class="line">  result = runCase(Tests)</span><br><span class="line">  return Result, ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> COJ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二月</title>
      <link href="/20230308-summary/"/>
      <url>/20230308-summary/</url>
      
        <content type="html"><![CDATA[<p>到校一个月之后，我终于算是建立起了还算正常的作息，以及一套日常工作的机制流程。</p><p>买平板是一个收益和损失并存的决策。首先确实各处都更方便了，不用背着纸质资料到处跑；损失就在于摸鱼更方便了，而且还花了很多钱。</p><p>我在犹豫是否购买的时候，有这样一种想法：我在不断地衡量这次消费是否“值”。我是把它作为一种投资来看，而投资确实就是一种“赌博”。一个东西有没有用，要去试试才知道。当然这几天使用下来，最好的一点其实是它在不断地提醒我要及时充电…</p><p>我是一个没有什么电量焦虑的人，所以经常忘记充电。冬天的时候手机的电尤其不经用，在外面走着走着手机就歇逼了。虽然我没什么情绪，但终究还是造成了不少的麻烦。另外一个是我的笔记本的续航可以说是完全烂掉了，指望它就不太可能。这些问题还是慢慢地引起了我的新的需求，就是方便携带又续航强大的电子设备。其实这类设备最理想的形态，是一个联网的远程桌面client：它仅仅需要搭载这一功能即可，这样无论到哪里，都可以在同一个设备上继续工作。但毕竟还是太天真的愿景。</p><p>目前用这个来看文献也是很方便。但我似乎主要是用来实时地查一些东西，以及作为多媒体设备…主要是因为阅读的主力部分还没开始做。</p><p>想来我前两天列举的要做的事，已经成为本周的目标了。但是没问题，只要在做了在做了，就没问题。。。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ramfs 调分内幕</title>
      <link href="/20230305-ramfs-score/"/>
      <url>/20230305-ramfs-score/</url>
      
        <content type="html"><![CDATA[<p>调分：</p><p>按测试点通过率，1，2， 3一档，5， 6一档，9 一档，4 一档，7，8 一档</p><p>20 + 20 + 15 + 15 &#x3D; 70</p><p>8 + 7 85</p><p>5 90</p><p>4 94</p><p>3 + 3 100</p><p>然后 20 分写了的，就酌情加分</p><p>（调分后，平均分仅仅提升2分到81）</p><p>算了，应该这样：20，60，70，78，84，88，92，96，98，100</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>COJ 后端设计方案（初步）</title>
      <link href="/20230301-coj/"/>
      <url>/20230301-coj/</url>
      
        <content type="html"><![CDATA[<p>Dependencies:</p><ul><li>gcc</li><li>make</li><li>postgresql14</li><li>libpq5</li><li>davidmoreno&#x2F;onion</li><li>isolate</li><li>To be continued..</li></ul><p>主要特性：</p><p>评测机可部署在多台不共享文件系统的机器上</p><p>对异构多核可以将评测机分组并限制在对应核心</p><p>数据库中的数据对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Administrator 0x7  <span class="comment">// all</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UserManager 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ContestManager 0x2  <span class="comment">// 管理 Contests 和 Problems</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SubmissionManager 0x4   <span class="comment">// rejudge, 提交作废，手动评测，之类的</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> Id[<span class="number">32</span>]; <span class="comment">// uuid</span></span><br><span class="line">    <span class="type">char</span> Email[<span class="number">32</span>]; <span class="comment">// smail.nju, null terminated</span></span><br><span class="line">    <span class="type">char</span> ContestantId[<span class="number">32</span>]; <span class="comment">// 学号, like 2312xxxxx; 或者老师、助教的自定义名称。用作登录名</span></span><br><span class="line">                           <span class="comment">// null terminated，仅限数字、字母、下划线</span></span><br><span class="line">    <span class="type">char</span> ContestantName[<span class="number">32</span>]; <span class="comment">// null terminated，用作排行榜显示。任意 &lt;= 31 字节的 utf-8 字符串</span></span><br><span class="line">    <span class="type">char</span> Password[<span class="number">32</span>]; <span class="comment">// null terminated, libcrypt 加密后存储</span></span><br><span class="line">    <span class="type">int</span> ClassId; <span class="comment">// 班级号</span></span><br><span class="line">    <span class="type">uint32_t</span> Roles; <span class="comment">// 用户组 flags                           </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Class</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">char</span> Name[<span class="number">16</span>]; <span class="comment">// e.g. 2021SE1, 2022SZ6, GUEST, NOCLASS.</span></span><br><span class="line">    <span class="comment">// null terminated.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bulletin</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">int</span> Weight;</span><br><span class="line">    <span class="type">char</span> *Content;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">PublishAt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ExpireAt</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Problem</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">int</span> ContestId;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Ordinary, TestKitLab &#125; Type;</span><br><span class="line">    <span class="type">char</span> Title[<span class="number">128</span>]; <span class="comment">// null terminated</span></span><br><span class="line">    <span class="type">char</span> *Description;</span><br><span class="line">    <span class="type">char</span> *InputFormat;</span><br><span class="line">    <span class="type">char</span> *OutputFormat;</span><br><span class="line">    <span class="type">char</span> *FootNote;</span><br><span class="line">    <span class="type">double</span> TimeLimit;  <span class="comment">// s</span></span><br><span class="line">    <span class="type">int</span> MemoryLimit;  <span class="comment">// KiB</span></span><br><span class="line">    <span class="type">bool</span> HasSpecialJudge;</span><br><span class="line">    <span class="type">bool</span> SkipSample;</span><br><span class="line">    <span class="type">int</span> SampleCasesCnt;</span><br><span class="line">    <span class="type">char</span> **SampleCasesInput;  <span class="comment">// Base64</span></span><br><span class="line">    <span class="type">char</span> **SampleCasesOutput;  <span class="comment">// Base64</span></span><br><span class="line">    <span class="type">int</span> TestCasesCnt;</span><br><span class="line">    <span class="type">char</span> **TestCasesInputPath;  <span class="comment">// $DATA_ROOT/tests/problemId/&#123; path &#125;</span></span><br><span class="line">    <span class="type">char</span> **TestCasesOutputPath;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">SpjEdited</span>;</span>  <span class="comment">// 用于 spj 更新，worker 重新编译</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">TestEdited</span>;</span>  <span class="comment">// 用于测试点更新，worker 重新请求</span></span><br><span class="line">    <span class="type">bool</span> IsGroupLimited; <span class="comment">// Worker Group 限制</span></span><br><span class="line">    <span class="type">char</span> *WorkerGroup;  <span class="comment">// 仅可由对应组 Worker 评测</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Contest</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> *description;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Public, Private, Protected &#125; Visibility; </span><br><span class="line">    <span class="comment">// protected，考试中模式，做对了也不能看别人代码</span></span><br><span class="line">    <span class="comment">// Private，仅管理员与存在提交记录者可见。不再有 Contestant 的设定</span></span><br><span class="line">    <span class="comment">// Public，Contest 开始时间后就公开，做对可查看所有源码</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> Practice, CodeForces, ACM, OI &#125; ContestMode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">BeginTime</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">SoftDDL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">HardDDL</span>;</span></span><br><span class="line">    <span class="type">bool</span> HasDecay;</span><br><span class="line">    <span class="type">bool</span> IsDecayLinear;</span><br><span class="line">    <span class="type">int</span> Decay[<span class="number">3</span>];  <span class="comment">// percent</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">DecayTime</span>[3];</span> <span class="comment">// before DecayTime[i], has Decay[i]</span></span><br><span class="line">    <span class="comment">// After DecayTime[2], Score *= Decay[2] %</span></span><br><span class="line">    <span class="comment">// After HardDDL, Score = 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Submission</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> Id;</span><br><span class="line">    <span class="type">char</span> UserId[<span class="number">32</span>];</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> C, Cpp, Rust &#125; Language; <span class="comment">// </span></span><br><span class="line">    <span class="type">int</span> ProblemId;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">SubmittedAt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">JudgedAt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FAILED, REJECTED, TESTOK, PENDING, JUDGING, ACCEPTED, WRONGANSWER,</span><br><span class="line">         TIMELIMITEXCEEDED, COMPILEERROR, MEMORYLIMITEXCEEDED,</span><br><span class="line">         PARTIALLYACCEPTED, RUNTIMEERROR, NGLANGUAGE, DRPRECATED &#125; Verdict;</span><br><span class="line">    <span class="type">char</span> *SourceCode;  <span class="comment">// Base64</span></span><br><span class="line">    <span class="type">int</span> Time; <span class="comment">// ms</span></span><br><span class="line">    <span class="type">int</span> Memory; <span class="comment">// KiB</span></span><br><span class="line">    <span class="type">int</span> Score; <span class="comment">// 0 - 100</span></span><br><span class="line">    <span class="type">bool</span> HasInput;  <span class="comment">// T</span></span><br><span class="line">    <span class="type">char</span> *UserInput;  <span class="comment">// 自定测试, Base64</span></span><br><span class="line">    <span class="type">char</span> *Message;  <span class="comment">// Base64, Manual or CompilerOutput, or RuntimeStdErr</span></span><br><span class="line">    <span class="type">char</span> *JudgedBy;  <span class="comment">// groupId-groupSeqNo or Manual</span></span><br><span class="line">    <span class="type">char</span> *FailedOn; <span class="comment">// Base64, given by Worker</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有请求和返回值都用 <strong>json</strong></p><p>分为 Controller 和 Service 模块。其中 Controller 模块根据对应功能调用 Service 中的函数，并依此来判断 http 返回状态与内容。</p><p>Service 模块执行鉴权、实际的业务逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> COJ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计开题</title>
      <link href="/20230225-bishe/"/>
      <url>/20230225-bishe/</url>
      
        <content type="html"><![CDATA[<p>研究背景 + 意义，附参考文献 &gt; 600</p><p>中国计算机学会数据库专委会在《“十四五”数据库发展趋势与挑战报告》中指出分布式数据库是未来数据库系统发展的重要方向。据 IDC 调研，超过 90% 的企业认可分布式数据库的部署效果。分布式数据库以其高性能、高可用、高扩展、高弹性为其主要优势。</p><p>openGauss 是国内热门的开源分布式数据库项目，脱胎于华为的 GaussDB 数据库，相比其他开源数据库而言，提供了面向多核架构的并发控制技术，针对了当前多核 NUMA 架构的趋势，可结合硬件优化提升系统整体性能。同时作为一个高可用分布式数据库，支持主备同步、异步、级联的部署模式，提供基于 Paxos 分布式一致性协议的日志复制和选主框架[1]。在开发过程中，引入许多成熟的技术，做到了极致性能、高可靠性、高安全性。在中国数据库排行中，长期位于前3。</p><p>在单机性能方面，openGauss 已经做了诸多优化，如 CBO 查询优化、LLVM 查询动态编译执行，以及各种基于 NUMA 硬件架构的优化。但作为分布式高可用数据库，往往为了副本一致性，增加了通讯开销与等待时间，使得跨节点的性能较为低下。本研究基于 openGauss 现有架构，围绕其高可用分布式一致性协议，对其实现方法、执行流程中的各环节进行考察，在保持副本一致性的同时，通过协议、架构的优化降低其开销。</p><p>国产数据库作为基础软件，产业化道路时间短，基础薄弱，尚未实现市场收益与自身投入的良性循环；同时受制于国际厂商垄断：Oracle 形成的事实上的垄断。且作为数据库产品，用户对其产品成熟度、品牌影响力与信心更加敏感，因为数据的可靠性是用户最看重的。阿里的 OceanBase 在内部被采用，到 TPCC 测试登顶也是一个漫长的过程。因此，对分布式数据库的研究，切合了当下国产基础软件研发的需要。</p><p>国内外研究现状 &gt; 800</p><p>国产原生分布式数据库中，由阿里自主从0开始研发的 OceanBase 是领导者，在 TPCC 和 TPCH 测试上都刷新了世界纪录，并且已经在商用领域得到广泛使用。其基于 Paxos 协议实现高可用三地三中心五副本容灾，同时支持高扩展与 HTAP 混合负载。PingCAP 自主设计研发的开源分布式关系型数据库 TiDB 则坚持开源作为创新引擎，通过全球社区协作开发，为企业级用户提供不断迭代和演进的产品服务。腾讯云 TDSQL 历史较久，对内服务微信支付、腾讯会议、音乐等业务。其提供事务型、云原生、分析型多种产品架构，在国家级别政务民生、金融核心系统上支撑关键业务，支持了第七次全国人口普查全面电子化。其技术创新领先，在11个权威期刊发布论文；同时持续回馈开源社区，多位腾讯工程师凭借对 MySQL 8.0 版本的贡献荣获 MySQL 社区开源贡献大奖。</p><p>在分布式一致性协议方面，openGauss 自身提出了 DCF 分布式一致性框架，基于 Paxos 算法，实现数据同步强一致。其算法结合了 Raft 的主机选举方法，同时灵活地增加了 Logger 角色，只进行日志复制；另外实现了单级级联备，主备间也可以以异步方式进行同步，降低了对主机的压力。但级联备机只能从备机同步，意味着如果备机需要全量 build，级联备也必须重新全量 build，无论其副本是否与主机一致。同时不支持多级级联。</p><p>国内其他的分布式数据库中，以 TiKV 为例，基于 Raft 算法实现了线性一致性的分布式系统。客户端将请求发送给 Leader，Leader 再通过 Raft 将请求复制到主备机的 Log，最终 Commit。各 TiKV 自行应用 Log 到 DB，其状态不能同时一致，若此时发生主机切换，有可能违反线性一致性；若依次全部应用，则无法并发操作状态机，性能较差。于是 TiKV 社区提出了两种优化 ReadIndex 与 LeaseRead， 在保证线性一致性的同时，大幅提升了系统性能。</p><p>国际主流的开源分布式数据库中，以 MariaDB Galera Cluster 为例，它采用多主同步复制，既保持了整个集群的数据一致性，也允许在集群的所有节点上并行执行事务，提高读写性能。但传统同步复制通常采用两阶段提交（2PC）或分布式锁实现，随着节点数量增加，事务冲突和死锁概率增加。为解决这一问题，Galera 的同步复制采用了组通信、写集、数据库状态机、事务重排序等技术，称之为“虚拟同步复制”，使其性能目标得以实现。</p><p>主要研究或解决的问题和拟采用的方法</p><p>主要研究：openGauss 分布式一致性协议的事务、备份性能分析及调优。</p><p>拟采用的方法：</p><p>性能度量方面，通过 perf 对函数执行时间进行分析；监视主备机的各项性能负载；编写测试，对固定 workload 计算时间开销。</p><p>协议优化方面，尝试对日志同步实现 ReadIndex 优化，甚至 LeaseRead 优化；同时实现多级联备机特性。保证仍满足线性一致性。</p><p>工作进度计划 （每2周）</p><p>1、实验环境搭建，阅读项目文档及代码</p><p>2、考察分布式一致性框架，梳理完整协议工作流程</p><p>3、确定测试的数据库工作负载，形成测试代码</p><p>4、对数据库进行初步调整，并测试，形成初步优化方向</p><p>5、根据优化方向，调整协议机制，形成新的工作流程</p><p>6、将调整后的机制实现为代码</p><p>7、测试、再调整，形成最终结果</p><p>8、整理资料与总结分析，撰写毕业论文</p><p>这歌一股霉味？</p><p>问题是改进的需求。不优化是哪里？</p><p>面向openGauss数据库的副本一致性协议优化技术研究</p><p>评测 性能 有问题</p><p>设计度量，数据集，方法，通过xx技术发现瓶颈</p><p>针对瓶颈发现问题，然后原理，然后优化</p><p>以国产开源openGauss分布式数据库为研究对象。在前期的了解过程中，观察到其副本一致性协议中，将Log异步复制到各个备机，再由备机重放到 DB 并持久化的过程，若在状态不一致时发生主机切换则违反线性一致性；若保证按序全部应用，则协议效率降低。本研究借鉴 TiKV 对一致性协议的优化，在保持副本一致性的同时，优化 openGauss 数据库的主备同步效率。</p><p>以国产开源openGauss分布式数据库为研究对象。在前期的了解过程中，观察到其副本一致性协议中，将Log异步复制到各个备机，再由备机重放到 DB 并持久化的过程，若在状态不一致时发生主机切换则违反线性一致性；若保证按序全部应用，则协议效率降低。本研究的主题是通过优化 openGauss 数据库的副本一致性协议，在保证一致性的同时，加速主备同步，进而提升事务执行的效率。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Nginx 下用 proxy—pass 配置多个 location</title>
      <link href="/20230225-nginx/"/>
      <url>/20230225-nginx/</url>
      
        <content type="html"><![CDATA[<p> 给出以下 server 配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> s.tilnel.com;</span><br><span class="line">    <span class="section">location</span> /proxy &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 <code>http://s.tilnel.com/proxy/xxx</code> 时，会转发为 <code>http://127.0.0.1:8080/proxy/xxx</code>。这显然不是本意。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> s.tilnel.com;</span><br><span class="line">    <span class="section">location</span> /proxy/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/; <span class="comment"># backslash is important here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> = /proxy &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">302</span> /proxy/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成。</p><p>但有一点：比如 rslsync 这种毒瘤 Web 控制台自己就会重写 URL。那就别费劲整了。。。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 mdadm 创建软件 raid</title>
      <link href="/20230224-mdadm-raid0/"/>
      <url>/20230224-mdadm-raid0/</url>
      
        <content type="html"><![CDATA[<p>有很多平时配置的细节都丢失了。。需要趁机记录一下，防止以后全忘了。</p><p>1 sector &#x3D; 1 LBA &#x3D; 512 Bytes</p><p>1 block &#x3D; 1 KiB</p><p><code>mdadm</code> 可以用来管理软件 raid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -C /dev/md0 -l raid0 -n 2 /dev/sdX /dev/sdY</span><br></pre></td></tr></table></figure><p>有的时候需要单独操作 <code>/dev/sdX</code>，此时就需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --stop /dev/md0</span><br></pre></td></tr></table></figure><p>然后设备就消失了。之后依然可以用相同的办法重建，但不知道是否需要用相同的顺序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D /dev/md0</span><br></pre></td></tr></table></figure><p>显示 raid 的信息。</p><p>直接在设备上创建 ext4 文件系统实操不行，必须要有分区表；必须要创建至少一个分区。</p><p>重新组装 raid：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm --assemble /dev/md0 /dev/sdX /dev/sdY</span><br></pre></td></tr></table></figure><p>保存当前 raid 配置，并自动执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -E -s -v &gt;&gt; /etc/mdadm/mdadm.conf</span><br></pre></td></tr></table></figure><p>注意记得修改 <code>/etc/fstab</code></p><p>如果 raid 出了问题，记得加 ro 挂载为只读</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o ro /dev/md0p1 /mnt/storage</span><br></pre></td></tr></table></figure><p>一些其他文件系统的操作：</p><p>查看文件占用的扇区号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs -R <span class="string">&quot;stat /path&quot;</span> /dev/blockdevice</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdparm --fibmap /path</span><br></pre></td></tr></table></figure><p>扫描坏扇区（这次不知道为什么，屁都没扫到）：</p><p>non-destructive write test:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">badblocks -svn -o output_file /dev/sdXn</span><br></pre></td></tr></table></figure><p>read-only test:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">badblocks -sv -o output_file /dev/sdXn</span><br></pre></td></tr></table></figure><p>查看占用文件的进程（和 lsof 有什么区别？）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fuser -m path</span><br><span class="line"><span class="comment"># kill all</span></span><br><span class="line">fuser -m -v -i -k path <span class="comment"># interactive</span></span><br></pre></td></tr></table></figure><blockquote><p>fuser is more useful in identifying process id opening a particular file. lsof is useful to find out all file(s) opened by particular process. Save this answer.</p></blockquote><p>写入卡住了，想找坏道，但是没找到，然后发现它自己好了。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Extensible Distributed Coordination</title>
      <link href="/20230125-ExtensibleDistributedCoordination/"/>
      <url>/20230125-ExtensibleDistributedCoordination/</url>
      
        <content type="html"><![CDATA[<p>Abstract</p><p>数据中心的很多服务都有赖于基于分布式锁和消息队列原语的协调和同步操作。我们认为将这些系统当中的协调服务设计为可扩展的是一件非常重要的事。如果不恁能够扩展协调服务的功能，有可能到头来一直在用一个不好的协调算法，最后导致低性能。而添加了扩展性，则需要一些机制来约束扩展以能够作出合理的安全性和性能的保证。我们提出了一个方案，它允许我们以安全的方式，动态地引入和移除扩展。为了避免设计差的插件带来性能上的开销，它限制了扩展对资源的访问。最终的测试中，扩展版本的 ZooKeeper 和 DepSpace 都在分布式的队列中获得了一个数量级的性能提升 （17x for Zookeeper, 24x for DwpSpace），并且其依赖的协调核心能够保持很小的体积。</p><p>Introduction</p><p>现代的 Web-scale 服务很复杂，很难设计和维护。一部分复杂性来源于满足可扩展性和容错；另外一部分来源于使用极其复杂的分布式协议，它们出了名地难实现。于是协调服务就被提出并投入使用，以在对外给出更加简洁的接口的同时，提供同样的服务。</p><p>简而言之，协调服务提供了一个一致的、高可用的数据存储，拥有足够的同步能力以应对客户端进程对基本任务的执行，如互斥操作和领导选举，并且储存重要的系统配置。这样的客户端通常是在上百上千服务器集群上部署的服务进程。协调服务的两个特性解释了它们成功的原因：1、它们为更大的分布式系统提供了一个坚实可信的锚点（基础？），使用坚固的状态机复制协议实现来避免所有的单点错误，并且 2、它们的少而有限的接口，也叫做协调内核，能够以简单的 RPC 的形式被调用，就算不是分布式计算编程的专家，也能够凭直觉弄懂。</p><p>尽管简化了使用，有限的协调内核也有一个明显的缺点：受限在一组特定的原语之内。更加复杂的协调任务，比如一个分布式队列，必须被实现为一组多个 RPC 调用，在性能上非常吃亏。例如，因为 ZooKeeper 没有提供在数据节点当前值的基础上更新值的原语，这样的一个操作必须用一个读再根据情况写入来实现，导致在资源抢占较频繁的条件下的性能非常糟糕。这种缺陷是有限的协调内核天生就有的。一种办法是增加新的原语，然而这也就导致丢失了上面所说的有限接口的好处。</p><p>在这篇工作中，我们因此而采用了不同的办法：让协调服务变为可扩展的。因此，我们展示了一个模型，它允许客户端动态地、安全地扩展一个协调服务，通过一小段定制的代码在服务端原子地运行。另外，我们设计了一个沙盒来约束这些扩展不要降低或干碎整个系统的性能。</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Project 2 客观题杂谈</title>
      <link href="/20230120-summary/"/>
      <url>/20230120-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Project-2-客观题杂谈"><a href="#Project-2-客观题杂谈" class="headerlink" title="Project 2 客观题杂谈"></a><center>Project 2 客观题杂谈</center></h1><center>南京大学 孙博文<br>tilnel@smail.nju.edu.cn</center><p>谢谢选题的同学们，过程中出了一些波折，年前选做的同学被折腾得厉害，算是共同完成了客观题的出题完善工作。</p><p>分低不要担心，我会 curve 到和主观题相似的分布和平均分。分数过低的，我会看一眼完成度再给主观打分；ddl 前提交初始 repo 的同学，得准时与诚信分 20，看情况可能更高点。</p><p>认真独立做这两题的学习效果绝对不赖。</p><p>通过客观题的法宝就是充分测试。</p><p>[toc]</p><h2 id="Ramfs"><a href="#Ramfs" class="headerlink" title="Ramfs"></a>Ramfs</h2><p>ramfs 的测试点到 9 就算完结了。1 月 19 的晚上，sbw 躺在床上想破头也没想到如何构造与现实应用场景类似，又重 IO，又好用这几个捉襟见肘的 API 写出来的测试。于是干脆就直接取消了：反正 10 不管怎么写，估计都不会超过 1-9 的测试量了。</p><p>下面给出一些比较通用的建议。</p><h3 id="输入合规检查"><a href="#输入合规检查" class="headerlink" title="输入合规检查"></a>输入合规检查</h3><p>实现 API 的时候，要对输入数据进行 validate。test4 里的那个 rread(-100000000) 就已经足够惊悚，大家最后都改过来了。但如果在某一个数据点里偷偷再安插一个 rwrite(1000000)，你改正过一次的程序，也能应对这种摧残吗？…这种已经属于很初级的要求。但我们的数据点也并未再从边角料里挖两个坑给大家跳：手册里提过的那些边界情况，对了这次就对了。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>主张：分配的时候，就想好是谁最终释放。比如 ropen 中分配的空间，肯定是 rclose 释放；O_CREAT 分配的空间，最终肯定是 unlink 去释放。如果一段空间不需要跨函数使用，那么尽量做到谁分配，谁释放。</p><p>譬如，有这样的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">generate_some_string</span><span class="params">(<span class="type">int</span> arguments)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ret = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">char</span> *pathname, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *something = generate_some_string(args);</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc 的这段空间，由 generate 分配，主要由 ropen 实际使用，最终也只能在 ropen 中回收。但是孤立地看 ropen，并不一定意识得到它调用了一个会分配一段空间的函数而没有释放掉。所以，更好的做法是由 ropen 进行分配，将指针作为参数传给被调用者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">generate_some_string</span><span class="params">(<span class="type">char</span> *destination, <span class="type">int</span> arguments)</span> &#123;</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">char</span> *pathname, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *something = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    generate_some_string(something, args);</span><br><span class="line">    <span class="comment">/* statements */</span></span><br><span class="line">    <span class="built_in">free</span>(something);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，free 和 malloc 就对应起来了。</p><p>管理内存的另外一点，就是注意函数的所有出口之前，释放掉用完的所有空间。有的时候函数中遇到某些异常状态，提前终止执行了，这个时候可能已经分配了一些内存。然而有的时候，只会想到在最终正常执行返回之前释放内存，疏忽了那些“分支”。</p><p>就算 coding 再怎么精打细算，也逃不掉释放不完的命。这种时候就要利用工具了：</p><p>address sanitizer。在 Makefile 的 gcc 后面加一个参数 <code>-fsanitize=address</code>，即可看到泄漏的内存总大小、泄漏位置。<strong>是 Linux 专属武器</strong>。</p><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>实验评测的时间是充裕的，但仅限你没有写出非常消耗时间的垃圾设计。必要的循环遍历、链表遍历并不会让你得到时间超限。譬如，从 0 到 4095 循环来找到一个空闲的 fd；譬如，遍历子目录的 sibling 链表找到名称匹配的那一个。你不需要写节约时间（某种意义讲，也挺浪费时间的）高级数据结构，比如哈希表，etc。也不需要用倍增等方式去节约 realloc 的调用。</p><blockquote><p>Premature optimization is the root of all evil. –Donald Knuth</p></blockquote><blockquote><p>Keep it simple, stupid.</p></blockquote><p>讲一个我看到的案例。一位同学某测试点超时，我把测试点拆成两半，仅运行前半耗时 6s，仅运行后半耗时 5s。但如果放在一起，总耗时就会变成 90s：前半的时间不变，后半拖慢了很多。最终分析下来结果是这样的：前半执行时，他代码中的某个循环条件会增加。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cond; i++) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个 cond 不断地增长。后半受到这个增长的影响，每次又都跑完了整个循环，时间就炸了。</p><p>但其实这是可以避免的！因为这个循环是“找到了就可以退出”的循环。他只是忘记写 break…当然他后来自己凭借肉眼找到了，我觉得很牛逼。</p><p>除了肉眼，我们还有什么办法做性能测试呢？当然一切的前提是：自己写了测试点。</p><p>以 789 三个点为例，7 是大文件测试，那少说也得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwrite(fd, buf, <span class="number">400</span> MB);</span><br></pre></td></tr></table></figure><p>像这样顶着上限去测试。</p><p>8 是文件树测试，这就更容易了，无非就是宽度和深度。</p><p>9 是 fd 管理。那就是频繁 ropen, rclose，以及多个 fd 一起读写。OJ 测试的上限是 4096，自己测就往极限去靠就 OK 了。</p><p>有了测试点以后，我们就可以运行了。测试点在设计上，要能够灵活地修改规模。在不同规模下，对同一性质的测试点做多次测试，可以总结一些规律。也可以对测试的运算量的数量级以及运行时间做预测。如果结果比预测慢很多。就可以去被测函数的代码里寻找性能下降的原因，比如 fd 资源紧张因此分配变慢，这是合理的；但 fd 资源空闲时依旧分配较慢，这就不太对劲。</p><blockquote><p>目前大多数个人计算机的效率在每秒 1e8 次循环的数量级。</p></blockquote><p>有什么工具能定位性能问题？</p><p>Linux Perf.</p><h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p>老规矩，先用测试把问题暴露出来。在此基础上，gdb 也好，IDE 的断点调试、内存监视也好。</p><h2 id="Gitm"><a href="#Gitm" class="headerlink" title="Gitm"></a>Gitm</h2><p>gitm 目前有一位同学选做，做得还是很用心的。估计后续没人想选做，就摸了。这题比起 ramfs，系统设计的味儿更浓一点。</p><p>这题的原型是去年 Project-2 的 git–。我去年是期待出成今年这个形式的，最后原操刀人出成了标准输入交互程序。大家都喜欢写熟悉的 OJ，看到是客观题就被骗进来，但是因为难度不低，最后分数惨淡，不得不 curve。Ramfs 还算离传统 OJ 的形式近一点；再近一点，无非是我把函数调用改成格式化的输入，用 scanf 代替编译链接 main.c。设计成这样就是为了让大家不得不学学 Makefile，命令行这些东西。gitm，就走得更远了，它要求你的程序和自身以外的更多东西打交道了：参数解析，数据持久化，外部命令…整个程序的逻辑非常好想，但是搞明白每一样东西怎么用，怎么将它们配合起来，就比较困难啦。</p><p>这题其实是有捷径可以走的。只要会组合一点命令行，配合 diff 和 patch，就能轻松写出一个 200 行以内的形 C 实 shell 的 gitm，能得到 80 以上的分数。</p><h2 id="测试思路"><a href="#测试思路" class="headerlink" title="测试思路"></a>测试思路</h2><p>difftest：用一个正确的实现和你的实现做对比。</p><p>ramfs 的正确实现这不是就很好找吗？把 ramfs 的 API 用真实文件系统 API 去实现，这就是标准实现啦，至多需要把两者的差异做一个适配，写下来也就没几行代码。这样的标准实现，首先它可以用来证明你的测试写得没问题。</p><p>注意 Linux 默认进程打开的文件描述符上限是 1024，并且开局已经占去了 3 个。但是这也够你自己的实现喝一壶的了。</p><p>其次就是用来做 difftest：你做一步，我做一步，然后我们看看结果是不是一样呗？</p><p>gitm 也是类似的思路。这不是有 git 可以参考嘛，我们只需要两边各做一步，然后对比结果，就好了。。。记得用脚本而不是傻乎乎地每次都手敲。</p><h2 id="扩充知识"><a href="#扩充知识" class="headerlink" title="扩充知识"></a>扩充知识</h2><p>全是关于 ramfs 的。但不能帮助你写 ramfs。</p><p>Linux 文件系统 API 的实际情况和 ramfs 有差异：</p><p>open 其实不支持 O_WRONLY | O_RDWR，会打开失败。</p><p>使用 O_APPEND，不管 rseek 到哪，永远都是在结尾 write。此时 offset 只能对读操作生效。</p><p>打开已有目录时，O_CREAT 会导致失败。</p><p>unlink 时如果文件仍在打开中，会把 unlink 交由 fd 来做。即最后一个引用文件的 fd 被关闭时，文件（的这一链接）被删除。</p><blockquote><p>什么是链接？为什么叫 unlink 而不叫 remove、rmfile？</p></blockquote><p>文件只是节点。这一节点可以在多处被多次引用，这就是链接的实质。对同一文件的多个硬链接只占1份空间。文件系统管理时使用“引用计数”，只有在引用计数归零的那一次 unlink 时，文件内容真正从文件系统中消失。</p><p>目录是可以 open 的。我们不能 read 或 write，但是可以 openat（在 fd 指向的目录中打开文件），getdents（获得 fd 指向目录中的子目录项）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>人生苦短，多用工具。</p><p>有 bug 不要盯着看。如果本地跑过了，就想办法写点测试让它跑不过；如果本地跑不过，但是看不出问题，就跑起来看（调试器）。</p><p>内存泄漏和段错误有 sanitizer；答案错误可以打 Log 看看是哪一步出问题；时间超限有 perf。</p><p>学习新的工具，每样学 10 分钟，能节省 90% 的瞪眼时间。浪费的时间都够读个 PhD 毕业了（别骂了）。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gitm final ver</title>
      <link href="/20230114-gitm-final/"/>
      <url>/20230114-gitm-final/</url>
      
        <content type="html"><![CDATA[<h1 id="Gitm-实验手册与指南"><a href="#Gitm-实验手册与指南" class="headerlink" title="Gitm - 实验手册与指南"></a><center>Gitm - 实验手册与指南</center></h1><center>南京大学 孙博文<br>tilnel@smail.nju.edu.cn</center><p>随意的项目要求 + 很简单的指导，主要是设计思路 + 可利用的工具。</p><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>git 是当今世界上最流行的版本控制系统。本实验要求你通过提交 git repo 的方式来提交一个迷你版的命令行工具 gitm(inus)。</p><p><strong>注意：本实验将只能在 Linux 操作系统中完成</strong>，因为你不得不使用系统调用，而 OJ 是 Linux 的。提交 Windows 上可以编译运行的代码，在评测机上注定不可兼容。</p><p>首先，你需要学习 git ，否则你将完全不明白 gitm 的功能，并且也无法用 git 来管理本次作业的代码。</p><blockquote><p>是的！我们将会发布一个由 git 管理的框架代码，并且要求你一直使用 git 来管理，最终提交一个 git repo。</p></blockquote><p>获取框架代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.nju.edu.cn/Tilnel/gitm.git</span><br></pre></td></tr></table></figure><h2 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h2><p>所有代码，包括 .c 和 .h 文件需要放在 git repo 的根目录下。对自己使用的头文件的引用请以双引号的形式，以便编译脚本能够正常工作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitm</span><br><span class="line">├── gitm.c</span><br><span class="line">├── gitm.h</span><br><span class="line">├── whateveryouwant.c</span><br><span class="line">├── whateveryouwant.h</span><br><span class="line">├── ...</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">/* gitm.c */</span><br><span class="line">#include &quot;gitm.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可以修改 Makefile，但请不要删除其中的 git 目标依赖。我们在 Makefile 中确保了你的每一次编译运行都能够自动进行 git commit。这些自动的 commit 可以帮助你回滚到自己想要的任意版本，并且在未来查重工作中产生疑问时，良好的 commit 记录将成为重要的证明。</p><p>在你的 git repo 里请包含所有编译所需的源文件，但不要出现编译不需要的多余的源文件。</p><p>尝试编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>你将看到根目录下产生了一个名为 gitm 的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gitm version</span><br></pre></td></tr></table></figure><p>你将看到一个小彩蛋（你之后可以自由地删掉它或修改掉，不影响成绩）。</p><p>注意：本次实验你编写的是一个 “命令行工具”。也就是说，我们将以和使用 git 相同的方式来使用它：在命令行里输入命令和参数。这意味着，这次你需要真正 “解析参数” （被 parse.c 支配的恐惧）。</p><p>而且，这次我们将会在运行中多次调用你的程序。也就是说，你的程序并不是在一直运行着，每一次调用都会做不同的事。你存储在内存里的数据都将随着功能完成，进程结束而消失。所以，关于 gitm repository 的有用的信息，你需要将它们持久化到磁盘上，以便进行后续的操作。因此学习 C 语言的文件操作是必不可少的。</p><p>为了实现一个 git，首先你要了解 git 的功能</p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>假设我们当前在一个文件夹 dir 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm init</span><br></pre></td></tr></table></figure><p>初始化当前的 dir 为一个 gitm repository。如果当前 dir 已经是一个 gitm repo，则不做任何操作。</p><p>此时的 gitm 中应当不存在任何 commit，gitm 的仓库中应不存在任何文件。</p><p>具体来说，你可以在当前目录下创建一个 <code>.gitm</code> 目录，用于存放一些记录仓库状态的文件。</p><blockquote><p>对，就像 git 的 .git 那样！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm commit</span><br></pre></td></tr></table></figure><p>将当前仓库中文件改动后状态作为一个提交，并记录下来。然后不重复地给出一个长度为 8 的小写十六进制数（例如 3bdc8902），用于唯一地指示这一次 commit。</p><p>git 中的提交是一个树形的结构。我们希望你在 gitm 中，同样实现这样的树形结构。</p><img src="git-brance.svg" alt="img" style="zoom: 100%;"><p>gitm 中不要求实现对分支的命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout commit</span><br></pre></td></tr></table></figure><p>checkout 用于将当前目录的状态切换到 commit 所指示的提交上。</p><p>若当前目录的状态较 gitm <strong>当前所处的 commit</strong> 有改动，则拒绝本次 checkout，并且<strong>你的 main() 函数以返回值 1 退出</strong>。</p><p>checkout 正常完成后，你目录中文件的状态（除了 .gitm 目录以外）必须与指定的 commit 相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout .</span><br></pre></td></tr></table></figure><p>特殊地，这一条命令用于将目录文件恢复到当前所处的 commit 时的状态。也就是说，放弃此时对文件的所有改动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm merge commit</span><br></pre></td></tr></table></figure><p>找到当前所处 commit 与命令指定的 commit 的公共祖先，并将两个 commit 合并起来。</p><p>具体来说，是将命令指定的 commit 相对于公共祖先的修改，应用于当前所处的 commit。</p><p>如果合并的两个 commit 相对于公共祖先，均对同一个文件产生了修改（创建、删除、编辑），那么命令直接拒绝执行，输出 “conflict\n” <strong>并使 main 函数返回 1</strong>。</p><p>在其他情况下，你需要合并，并产生一个新的 commit。逻辑上，这个 commit 将成为被合并的两个 commit 的共同后继。</p><blockquote><p>我们如何检测这一点？</p><p>假设有 commit a-g，b, c 由 a 分支而来，d 由 b, c 合并而来，e 是 b 的后继，f 是 c 的后继，g 是 d 的后继。</p><p>你的程序应当有能力找到 e, g 的公共祖先是 b，f, g 公共祖先是 c，在此基础上合并是无冲突的。如果你只能找到 a，则合并有可能产生冲突，因为 e 相对 a 改变了 a.c，而 g 相对 a 也改变了 a.c。</p></blockquote><img src="image-20230103113625830.png" alt="image-20230103113625830" style="zoom: 67%;"><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>我们会将你的 repo 里所有的 C 源文件和头文件收集起来进行编译，并生成一个名为 <code>gitm</code> 的可执行文件。然后原地创建一个文件夹，作为你的 gitm 需要管理的 repository。例如（其中 &gt; 开头的行表示命令行输出）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line">../gitm init</span><br><span class="line">../gitm commit</span><br><span class="line">&gt; 3bce5ff0                       <span class="comment"># 空 commit，我们的 OJ 一定会创建一个空 commit 作为第一个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt   <span class="comment"># 创建文件并写入</span></span><br><span class="line">../gitm commit</span><br><span class="line">&gt; b926d817</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is my git&quot;</span> &gt; readme.txt</span><br><span class="line">../gitm checkout 3bce5ff0</span><br><span class="line">&gt; You<span class="string">&#x27;ve made change. Please commit or garbage your change.</span></span><br><span class="line"><span class="string">echo $?                          # 给出上一条命令的返回值。正常退出的程序应当为 0</span></span><br><span class="line"><span class="string">&gt; 1</span></span><br><span class="line"><span class="string">../gitm commit</span></span><br><span class="line"><span class="string">&gt; ef938aa6</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt readme.txt .gitm</span></span><br><span class="line"><span class="string">../gitm checkout b926d817</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt .gitm</span></span><br></pre></td></tr></table></figure><p>随着时间的流逝，我将会发布进一步的实验指南。</p><h2 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h2><ul><li>你创建的所有文件都要放到运行目录的 .gitm 目录下。<ul><li>+++ 对目录的体积要求：不要每一次都追踪没有发生变化的文件即可。不需要对每个文件进行增量存储。 +++</li></ul></li><li>commit 数量不会超过 10000 个。</li><li>你的 gitm 只需要管理文本类型的文件。其他类型的文件不会出现。</li><li>不要求追踪空目录</li></ul><p>本实验的测试点预计如下：</p><p>1、hello world（保留 gitm version 的打印信息即得分）</p><p>2、和上面的脚本相似的一段小测试，基础功能</p><p>3、文件数量增加，提交数量增加；但并不会出现子目录</p><p>4、在 3 的基础上，有一定的目录结构</p><p>5、在 4 的基础上，测试 merge 功能（不会很刁钻，只要该拒绝的拒绝，该成功的 merge 对就行了）</p><p>6、测试 .gitm 的空间管理，<strong>要求未发生改动的文件不重复存储，不要求单文件的增量存储</strong></p><p>能够恢复对文件就可以了，不会太刁钻。</p><h2 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h2><p>一个更加 naïve 的思路。从一个 commit 刚刚被提交说起…</p><p>此时，所有的目录结构和文件改动都被提交了，我们可以在当下的目录中进行新的改动。为了能够恢复到刚刚提交的“干净”状态，我们需要为当下的状态做一个暂存，以便之后进行对比。</p><p>现在我们做了一些改动，想要 commit。这里，需要记录下改动的部分，没有改动的部分则默认是保持的。我们可以用文件系统的 api 遍历当前目录和暂存下来的目录，检测文件的增删等。对于依然存在的文件，则需要逐字符对比其中的改动。当所有的改动全部检测完毕后，在 .git 下保存好本次改动中：</p><ul><li>删除了哪些文件</li><li>增加了哪些文件和这些文件的内容</li><li>编辑了哪些文件和这些文件的新版本</li></ul><p>并将本次 commit 及其父节点 commit 号记录下来。</p><p>可以使用的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;     <span class="comment">// 打开目录</span></span><br><span class="line">       <span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;  <span class="comment">// 读取目录中的项目</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;  <span class="comment">// 创建新目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;   <span class="comment">// 删除目录</span></span><br></pre></td></tr></table></figure><blockquote><p>如何更简单地判断新文件是否发生改动，特别是较大文件？</p></blockquote><p>可以对所有存储下来的文件做 <code>md5sum</code>，为文件生成一个摘要。之后再有文件变动时，先去找是否存在相同的 md5，如果新旧文件的 md5 相同，就不用重复保存了。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="废弃的旧思路（依然可以尝试）"><a href="#废弃的旧思路（依然可以尝试）" class="headerlink" title="废弃的旧思路（依然可以尝试）"></a>废弃的旧思路（依然可以尝试）</h3><p>一个 naïve 的思路。</p><p>首先介绍两个工具，一个叫做 diff，一个叫做 patch。这两个工具是大部分发行版自带的。<strong>看到这里请打开你的命令行</strong>一起尝试一下。</p><p>准备任意一个代码文件 a.c，复制到 b.c，在 b.c 中加入一些行，删去一些行，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>能看到：</p><img src="Screenshot_20230115_000047.png" alt="img" style="zoom:75%;"><p>可知，diff 可以计算出两个文本文件之间的差距。</p><p>用重定向将这一结果定向到 <code>diff.out</code> 中，我们再用 patch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch a.c diff.out</span><br><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure><p>这次什么也没有输出。a.c 和 b.c 变成一样的了。</p><p>diff 不仅可以给 a.c 打补丁，还可以把补丁从文件中拆下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -r b.c diff.out</span><br></pre></td></tr></table></figure><p>再打开 b.c，就能发现文件变回了之前  a.c 的样子。</p><p>great。所以只要你能够在 commit 的时候遍历目录中的所有文件，挨个 diff 一下，就可以算出当前版本和上个版本的差距了。然后你把这些差距全都写 .gitm 中的某一个文件，大功告成。</p><p>diff 和 patch 可以对两个目录直接计算差值和补丁&#x2F;回退。如果你学会怎么用，省去很多麻烦事。</p><p>如何调用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结：在 .gitm 中我们需要存储的元素</p><ul><li>一个文件，能指示当前所处的提交</li><li>一个文件，包含了所有的提交号，并需要能够指明每个提交在树结构上的祖先节点。对于新 commit 是一个，对于 merge 是两个（这与 git 并不完全相同）</li><li>若干个目录，每个代表一个 commit；每个目录若干个文件，记录它相对祖先节点的变化：增减文件目录，编辑文件</li><li>一个目录，包含了当前 commit 的暂存状态，以便之后用于与编辑后的状态进行比较</li></ul><p>在 gitm 执行的过程中，有这样一些子功能需要实现：</p><ul><li>解析参数，执行对应功能</li><li>遍历当前文件树，与已提交的文件树对比</li><li>将对比的文件树中公共部分进行比较</li><li>分析 commit 记录，确定提交之间的关系</li><li>通过提交之间关系，决定前进或后退</li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Art Performance Lecture Notes</title>
      <link href="/20230113-artperformance/"/>
      <url>/20230113-artperformance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>晚上听课里说的一个剧 阿喀琉斯进场<br><img src="image-20230113023838864.png" alt="image-20230113023838864"></p></blockquote><p>精神分析视角看阿布拉莫维奇的行为艺术作品</p><p>本文中提出的反思是通过分析行为艺术家玛丽娜·阿布拉莫维奇的作品 Rythm0, Rythm 10, Imponderables, Rest Energy 和对视引发的。</p><p>自传中写到，玛丽娜·阿布拉莫维奇 1946 年出生于贝尔格莱德，当时塞尔维亚人正处于战争的结束和前南斯拉夫共产主义政权的开始。她是获得勋章的共产主义战争英雄的长女，即使没有盟军的政治和物质支持，也依旧坚持对轴心国军队的武装抵抗。这让阿布拉莫维奇夫妇对他们的国家有着共同的自豪感。他们有两个孩子和一间房子，里面有严格的纪律教育，有既定的规则，需要严格遵守最勤奋的士兵。母亲是遥远而几乎冷漠的冷漠的化身。她有条不紊，并制定了女儿每天必须遵守的规则。如果由于某种原因忽略了一些小细节，她将受到毒打的惩罚。</p><p>因此不难理解，在阿布拉莫维奇的作品中，为什么常常涉及强制、痛苦和规则。这些作品是对她童年期经历的一种重建。[1] 她的作品中，总是体现着非常强烈的对抗性，无论是与乌雷合作的作品中，还是在她独立完成的作品中。与某种权力或力量对抗是重要的主题，它包含了一种二元论的色彩。文化运动五月风暴对二元论进行了消解，通过政治斗争和话语争鸣，多元化、多样性和差异性逐渐成为政治正确性的内容，但这无法回避自由世界需要借助二元论来维系其整体性、其在价值谱系中的崇高地位。[2]。但阿布拉莫维奇的作品则将二元对立中的价值判断问题重新搬了出来：强调多元化、差异性的政治正确仅仅是对一个内在被需求的对抗性结构的遮蔽。她的作品即成为了言说、宣泄这种二元性的空间。</p><p>Rythm0 中，阿布拉莫维奇最初穿着黑色的 T 恤站在那里。她对观众给出了两个信号，一是“桌子上的72种工具”：口红、子弹、枪、菜刀、鞭子。其中这些危险物品的暗示着“伤害”、“死亡”……二是“对她做任何事都是可以的”，看似中性的描述，实则是对围观者的一种怂恿、挑动。很快，她身上的黑色 T 恤被剪开，有人用上了膛的枪指着她；同时，也有人自动对她进行保护。最终在人们的保护中，这件作品自然地结束了。在这里，对立的双方是什么？是阿布拉莫维奇和外界的一切？还是毫无顾忌地对她“做任何事”的观众，与保护着她的观众的对立？我认为这里最终呈现的效果无疑是后者。更准确地说，是“自由冲动”与“道德感”的对立。这其实是一个非常重要，并且结论并不是那么明确的论题。</p><p>这里的“冲动”，并不是“原始冲动”所指的人的动物性。从源头上来看，它与“道德感”是产生于同样的阶段的，都是拉康意义下的“自我”。同时，也不能单单认为只有“道德感”是受到社会规训、异化而来的。这两种态度都应当被认为是在大写他者的欲望驱使下产生的态度。没有哪一个是更本真的，如果抛弃一切预设的立场，想要对两种行为做出价值判断，则变得更加困难。</p><p>Rest Energy 中，阿布拉莫维奇和乌雷两人合作着拉开了一支弓，并把箭头对准了阿布拉莫维奇的心脏。二人的胸口都装了录音器，在长达 4 分 10 秒的时间里，加速的心跳清晰可闻。这是一个既危险又浪漫的场景，当然是表明了一种绝对的信任关系。另一个主流的解读是，展现了生命的脆弱。弓在其中是一种危险感的代表，生与死的界限仅仅在于一个微不足道的改变甚至失误。</p><p>我在这件作品中，看到它是主体间关系的一种形象的表达。黑格尔发现了“我在我的存在中依赖别人”，或者说，“我是一个由于一个别人才是自为的存在”。他们承认着他们自己，因为他们彼此相互地承认着他们自己。但当自我意识处在自在阶段时，那另一个对方却带有“否定性的性格”，所以，我与他人的初始关系是极端对立的，这表现为一种斗争，一场“生死的斗争”。[3] 这里就出现了由对象反射得来的物性镜像式的关系：通过它的对方才是它自己。</p><p>总结</p><p>浅浅地把这学期所斜视的两个领域的东西无端地结合起来。事实上我在看到作品的时候这就是我产生的第一反应，但是事后再去想就非常牵强。最后匆忙地写下来，字数也未达标，望谅解。</p><p>[1] Simões, L. and Passos, M. (2018)  玛丽娜·阿布拉莫维奇的行为艺术作为一种变革性体验。<em>心理学</em>，<strong>9</strong>，1329-1339. DOI：<a href="https://doi.org/10.4236/psych.2018.96081">10.4236&#x2F;Psych.2018.96081</a></p><p>[2] 翟晶，没有他者性的他者:论三位当代艺术家，《世界美术》 2016 年 04 期</p><p>[3] 张一兵：《拉康哲学映像——不可能的存在之真》修订版，上海人民出版社，第 107 页</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并行 LU 分解</title>
      <link href="/20230112-mpp-lu/"/>
      <url>/20230112-mpp-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="实验2-LU-分解-（OMP-与-MPI-实现）"><a href="#实验2-LU-分解-（OMP-与-MPI-实现）" class="headerlink" title="实验2 LU 分解 （OMP 与 MPI 实现）"></a>实验2 LU 分解 （OMP 与 MPI 实现）</h1><p>191240046 孙博文</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>在线性代数中，LU 分解是矩阵分解的一种，可以将一个矩阵分解为一个下三角矩阵和一个上三角矩阵的乘积（有时是它们和一个置换矩阵的乘积）。LU分解主要应用在数值分析中，用来解线性方程、求反矩阵或计算行列式。</p><p>在 LU 分解的过程中主要的计算是利用主行 i 对其余各行 就 (j &gt; i)  做初等行变化，各行计算之间没有数据相关关系。因此可以对矩阵按行划分来实现并行计算。考虑到计算过程中处理器负载的均衡，对矩阵采用行交叉划分；假设处理器个数为 p，矩阵的阶数为 n，则每个处理器处理的行数为 $m &#x3D; \lceil n &#x2F; p\rceil$。</p><p>OpenMP 是基于线程的编程模型，设计基于多线程的 OpenMP 的 LU 分解算法，其主要思想为：外层设置一个列循环，在每次循环中开设 THREAD_NUMS 个线程，每个线程处理的矩阵 A 的行为上述的 m，一次循环过后则完成对应列的变换，这样在 n 次循环过后便可完成矩阵 A 的 LU 分解。即 L 为 A 中下三角部分的元素，其对角线上元素为 1，其他为 0。U 为 A 中 的上三角部分。</p><p>对于 MPI 而言，则是将矩阵数据由 0 进程按行交叉划分发送到各个进程中。在计算过程中，主行数据所在的进程将主行的数据广播到其他各进程。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>核心伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Begin</span><br><span class="line">  对所有处理器，同时执行如下算法：</span><br><span class="line">  for i = 0 to m - 1 do</span><br><span class="line">    for j = 0 to p - 1 do</span><br><span class="line">      if (my_rank=j) then</span><br><span class="line">        v = i * p + j   // 主行</span><br><span class="line">        for k = v to n - 1 do</span><br><span class="line">          f[k] = a[k, v]</span><br><span class="line">        end for</span><br><span class="line">        将 f 广播到所有处理器</span><br><span class="line">      else</span><br><span class="line">        v = i * p + j</span><br><span class="line">        接收广播的主行到 f</span><br><span class="line">      end if</span><br><span class="line">      u = i * p + my_rank</span><br><span class="line">      if (my_rank &lt;= j) then</span><br><span class="line">        for k = u + my_rank to n - 1 step p do</span><br><span class="line">          a[k, v] = a[k, v] / f[v]</span><br><span class="line">          for w = v + 1 to n - 1 do</span><br><span class="line">            a[k, w] = a[k, w] - f[w] * a[k, v]</span><br><span class="line">          end for</span><br><span class="line">        end for</span><br><span class="line">      else</span><br><span class="line">        for k = u to n - 1 step p do</span><br><span class="line">          a[k, v] = a[k, v] / f[v]</span><br><span class="line">          for w = v + 1 to n - 1 do</span><br><span class="line">            a[k, w] = a[k, w] - f[w] * a[k, v]</span><br><span class="line">          end for</span><br><span class="line">        end for</span><br><span class="line">      end if</span><br><span class="line">    end for</span><br><span class="line">  end for</span><br><span class="line">End     </span><br></pre></td></tr></table></figure><p>对于 MPI 来说，仅仅是使用 Bcast 而已；而对于 OMP 编程，除了对第二层循环添加 <code>#pragma omp parallel</code> 以外，还要在 j 循环的末尾加上 <code>#pragma omp barrier</code>，保证当前主行的运算全部结束后，才能选出下一个主行。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="OMP"><a href="#OMP" class="headerlink" title="OMP"></a>OMP</h3><p>在 LU 分解运算开始之前用 <code>omp_get_wtime()</code> 记录下开始的时间，在运算完成后再用当前时间减去开始时间得到运算过程持续的时间。</p><p>输入的矩阵阶数 $n &#x3D; 1000$，是一个下三角矩阵和上三角矩阵的乘积。期望 LU 分解能将其还原。</p><div>$$A = \begin{aligned}\begin{bmatrix}1 & 0 & 0 & ... & 0\\2 & 1 & 0 & ... & 0\\3 & 2 & 1 & ... & 0\\... & ... & ... & ... & ...\\n & n - 1 & n - 2 & ... & 1\\\end{bmatrix}\begin{bmatrix}1 & 2 & 3 & ... & n\\0 & 1 & 2 & ... & n - 1\\0 & 0 & 1 & ... & n - 2\\... & ... & ... & ... & ...0 & 0 & 0 & ... & 1\\\end{bmatrix}\end{aligned}$$</div><p>编译时开启优化选项 <code>-O2</code>，得到的可执行程序在 6 核心 12 线程，3.4GHz 的平台上，得到计算过程的运行时间结果如下：</p><table><thead><tr><th>线程数</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>1</td><td>0.233030</td><td>0.150938</td><td>0.093188</td><td>0.069713</td><td>0.108846</td></tr><tr><td>2</td><td>0.226725</td><td>0.146629</td><td>0.097024</td><td>0.066818</td><td>0.113264</td></tr><tr><td>3</td><td>0.244155</td><td>0.170408</td><td>0.094506</td><td>0.069337</td><td>0.151547</td></tr><tr><td>4</td><td>0.259125</td><td>0.161575</td><td>0.096396</td><td>0.070211</td><td>0.186803</td></tr><tr><td>5</td><td>0.215795</td><td>0.149947</td><td>0.099653</td><td>0.072364</td><td>0.166726</td></tr><tr><td>AVG</td><td>0.235766</td><td>0.155899</td><td>0.096153</td><td>0.069689</td><td>0.145437</td></tr><tr><td>加速比</td><td>1.00</td><td>1.51</td><td>2.45</td><td>3.38</td><td>1.62</td></tr><tr><td>效率</td><td>1.00</td><td>0.75</td><td>0.61</td><td>0.42</td><td>0.10</td></tr></tbody></table><h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h3><p>输入与上述相同，结果为：</p><table><thead><tr><th>线程数</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>1</td><td>0.252182</td><td>0.177158</td><td>0.065233</td><td>0.066492</td><td>0.086463</td></tr><tr><td>2</td><td>0.240585</td><td>0.173630</td><td>0.077885</td><td>0.064615</td><td>0.086954</td></tr><tr><td>3</td><td>0.251120</td><td>0.156510</td><td>0.083122</td><td>0.062328</td><td>0.101553</td></tr><tr><td>4</td><td>0.223808</td><td>0.168837</td><td>0.077668</td><td>0.067501</td><td>0.087048</td></tr><tr><td>5</td><td>0.289730</td><td>0.164849</td><td>0.085826</td><td>0.066900</td><td>0.138214</td></tr><tr><td>AVG</td><td>0.251485</td><td>0.168197</td><td>0.077947</td><td>0.065567</td><td>0.100046</td></tr><tr><td>加速比</td><td>1.00</td><td>1.49</td><td>3.23</td><td>3.84</td><td>2.51</td></tr><tr><td>效率</td><td>1.00</td><td>0.75</td><td>0.81</td><td>0.48</td><td>0.16</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并行矩阵乘法</title>
      <link href="/20230112-mpp-mul/"/>
      <url>/20230112-mpp-mul/</url>
      
        <content type="html"><![CDATA[<h1 id="实验1-矩阵乘法"><a href="#实验1-矩阵乘法" class="headerlink" title="实验1 矩阵乘法"></a>实验1 矩阵乘法</h1><p>191240046 孙博文</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>设 A 和 B 是两个 $n\times n$ 矩阵，它们的乘积也是 $2\times 2$ 矩阵。根据乘积关系，我们有<br>$$<br>C[i, j] &#x3D; \Sigma^{n}_{i &#x3D; 1}A[i, k]\times B[k, j]<br>$$<br>串行程序中，C 的每个元素需要 n 次乘法和 n - 1 次加法。因此，C 的计算复杂度为 $O(n^3)$。</p><p>实际上，C 中个元素的计算在本质上是独立的，可以将矩阵划分成多个块，这样串行矩阵乘法中矩阵元素的乘-加运算代换为子矩阵的乘-加运算，然后指派给不同的处理器，实现并行运算。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在运算的最外层循环前加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="comment">/* calculate */</span></span><br></pre></td></tr></table></figure><p>让 omp 自动对计算过程进行划分。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>在矩阵乘法运算开始之前用 <code>omp_get_wtime()</code> 记录下开始的时间，在运算完成后再用当前时间减去开始时间得到运算过程持续的时间。</p><p>输入的矩阵阶数 $n &#x3D; 1000$，</p><div>$$\begin{aligned}A = \begin{bmatrix}1 & 2 & 3 & ... & n\\2 & 3 & 4 & ... & n + 1\\... & ... & ... & ... & ...\\n + 1 & n + 2 & n + 3 & ... & 2n - 1\\\end{bmatrix}\ \ \ \ B = \begin{bmatrix}1 & ... & 1\\... & ... & ...\\1 & ... & 1\\\end{bmatrix}\end{aligned}$$</div><p>编译时开启优化选项 <code>-O2</code>，得到的可执行程序在 6 核心 12 线程，3.4GHz 的平台上，得到计算过程的运行时间结果如下：</p><table><thead><tr><th>线程数</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>1</td><td>0.981532</td><td>0.521334</td><td>0.265093</td><td>0.294094</td><td>0.338403</td></tr><tr><td>2</td><td>0.914313</td><td>0.487340</td><td>0.262216</td><td>0.462756</td><td>0.356789</td></tr><tr><td>3</td><td>0.937469</td><td>0.493963</td><td>0.262745</td><td>0.273746</td><td>0.352335</td></tr><tr><td>4</td><td>0.863467</td><td>0.519115</td><td>0.270767</td><td>0.273420</td><td>0.347093</td></tr><tr><td>5</td><td>0.981426</td><td>0.510974</td><td>0.263687</td><td>0.412166</td><td>0.320763</td></tr><tr><td>AVG</td><td>0.935641</td><td>0.506545</td><td>0.264902</td><td>0.343236</td><td>0.343077</td></tr><tr><td>加速比</td><td>1.00</td><td>1.85</td><td>3.53</td><td>2.73</td><td>2.73</td></tr><tr><td>效率</td><td>1</td><td>0.92</td><td>0.88</td><td>0.34</td><td>0.17</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra - A Decentralized Structured Storage System</title>
      <link href="/20230110-Cassandra/"/>
      <url>/20230110-Cassandra/</url>
      
        <content type="html"><![CDATA[<p>Abstract</p><p>Cassandra 是一个分布式存储系统，用来管理一大堆结构化的数据，在许多服务器上。</p><p>高科用，没有单点错。</p><p>用于在上百个节点的基础设施上运行。可能分数据中心。</p><p>这个规模下，大小错误频发。Cassandra 在许多方面重组了数据库并且借鉴了许多实现和策略，但是并没有支持完整的关系数据模型。但是它提供了一个简单的数据模型来支持动态控制数据布局和格式。Cassandra 被设计用于廉价的家用（商用）硬件，在保持高写吞吐量时并未牺牲读取的效率。</p><p>Intro</p><p>Facebook 作为世界上最大的社交网络平台，用户和内容的增长速度非常快。急需高性能、可靠、高效、可扩展的平台。并且软件系统需要将服务器的 failure 作为一种常态而不是意外来处理（容错）。因此开发了 Cassandra。</p><p>Cass 融合了很多有名的技术来提高可扩展性和可用性。最初是为了满足  Inbox Search 服务的存储需求而开发的。在 Facebook 中，这项特性允许用户搜索他们的 Facebook Inbox。这意味着需要处理非常高的写吞吐，大约十亿每天的写操作，并且随着用户数量的增加还会增长。用户从地理上分布的数据中心请求数据，因此降低搜索延迟的核心是跨数据中心的数据复制。从2008年的1亿用户到2010年的2.5亿，Cassandra展现出了它的潜力，现在成为了Facebook许多产品服务的存储服务后端。</p><p>2 相关工作，影响了设计的</p><p>3 数据模型</p><p>4 客户端 api</p><p>5 系统设计和分布式算法</p><p>6 开发中的经验，优化</p><p>7 future work</p><p>DATA MODEL</p><p>表：分布式的多维 map，由 key 来 索引。</p><p>value 是一个高度结构化的数据对象</p><p>表的行key是一个没有大小限制的字符串，一般16-36bytes。</p><p>在每个副本中，对一行的操作是原子化的，无论修改了多少列。</p><p>列可以分组到一起放到集合中，叫做“列族”。</p><p>Cass 内置了两种 column families，Simple 和 Super column families。应用程序可以在其中指定列的排序依据为时间或名称，用来适应服务的需要。</p><p>API </p><p>insert(table, key, rowMutation)</p><p>get(table, key, columnName)</p><p>delete(table, key, columnName)</p><p>columnName 可以是列族中的列，可以是列族，可以是 Super cf，或 SCF 中的列。</p><p>SYSTEM ARCHITECTURE</p><p>分片 Partitioning</p><p>因为需要很高的扩展性，为了动态地将数据分布到节点上，使用一致性hash。一致性hash是基于一个数环来实现的。所有的hash值都对同一个上限去取模，系统中的每一个节点也将被分配一个随机值，并放到数环当中。每一个数据对象通过其key 的hash找到其在环中的位置，顺着环向下走的第一个数据节点即是该对象存放的节点。因此，每一个数据节点都只需要负责其前一个数据节点到它自身之间的hash值即可。</p><p>一致性hash 的好处就是节点的增减只会影响它的直接邻居，其他节点都不受影响。不过这样的设计也有一些问题。第一是为节点分配随机值，可能导致数据和负载分配的不均匀。另外这样的算法考虑不到节点之间的性能差距。一般来说有两个方法能够解决这一问题：一是让一个节点在环上存在多个位置，二是分析环中的负载信息，让轻负载节点在环中移动，以缓解负载重的节点压力。Cassandra 采取了第二种。</p><p>复制 Replication</p><p>Cassandra 使用了复制技术以实现高可用和持久化。每个数据对象都有 N 个副本。</p><p>每一个对象的key k都会在hash环中被分配给一个协调者节点。它管理着数据的复制。除了在本地存储一份外，协调者节点还会将它复制到环中的 N-1 个节点。Cassandra 为客户端提供了数据复制方法的多种选择。“Rack Unaware”, “Rack Aware”(within datacenter) and “Datacenter Aware”. 备份的选择是基于应用选择的策略。如果选择 RU，那么复制到协调者的 N-1 个后继节点上；对于RA和DA策略会稍微复杂一点。Cass 会在节点之间选举一个 leader（Zookeeper）。所有的节点在加入集群的时候，都会与 leader 通讯来获取它们的备份范围。并且 leader 会保证不会有节点负责超过 N-1 个范围。所有的节点所负责的范围的 metadata 会在每一个节点中以 Zookeeper 的容错机制进行本地缓存，以便从错误中恢复的节点也能找回自己负责的部分。此外，对于每一个被负责的范围，都有一个负责节点的“优先列表”。</p><p>每一个节点都有关于其他所有节点的知识。Cassandra 通过放松多竖排的要求，为可能出现的节点故障和网络分区问题提供了持久的保证。有时可能一整个数据中心会因为不可抗力失效。Cassandra 保证每一个数据行都会有跨数据中心的副本。在上文中的“优先列表”即是为了保证其中的节点是分布在多个数据中心的。这些数据中心之间有高速网络连接。跨中心的复制允许我们既能处理数据中心的错误，又能够避免服务中断。</p><p>Membership。这是什么？成员资格</p><p>通过 Gossip 来维护整个集群的成员状态。Gossip 大概是每一个成员每个 T 秒进行一次 heartbeat，选择其他的 member 发送它的优先列表，然后将自己的列表和收到的列表合并起来。</p><p>错误检测。Cassandra 采用了一个 $\Phi$ Accrual Failure Detector (SRDS 2004) 的修改版本。错误检测常见的模式就是采用心跳，如果心跳超时则认为对端失败。在实际使用中，由于网络延迟的抖动会导致误判。系统使用如下方法提高基于心跳探测方式的准确率：</p><p>1、假设心跳消息符合某一概率模型。例如定期发送的心跳消息在有网络延迟的情况下，接受到消息的 interval 符合正态分布。</p><p>2、利用接受到的历史数据（滑动窗口），对概率模型参数进行极大似然估计。</p><p>3、利用估计得出的参数代入模型，计算在当前时刻接收到心跳消息的概率。</p><p>得到概率后，并不直接得出对端是否存活的判断，而向上层应用返回这一概率，由应用自行解释。</p><p>在 Cassandra 中，认为指数分布是较好的近似。</p><p>Bootstrapping 初次启动</p><p>当一个节点初次启动的时候，它会随机选择一个 token来产生节点在环上的位置。为了容错，映射会被持久化到磁盘本地以及 Zookeeper 中。然后 token 的信息会通过 Gossip 在集群当中传播。这就使得每一个节点都能够将请求路由到正确的节点上。在 bootstrap 程序中，如果节点想要加入一个集群，会先读取一个包含了几个通讯点的配置文件，我们把最初的这几个通讯点叫做集群的“种子”。种子也可以通过 Zookeeper 这样的服务来确定。</p><p>Scaling the Cluster 集群扩容</p><p>当一个新节点加入到系统当中时，它会按照优先缓和负载较重的节点的目的来分配 token，这会导致新的节点将原来节点的负责范围划走一半。Cassandra 的 bootstrap 算法是通过操作员通过系统中其他的节点的命令行或者是 Cassandra 的 web 管理面板来启动的。原节点通过 kernel-kernel 的复制技术将数据流转移到新的节点上。</p><p>Local Persistence 本地持久性 （落盘？）</p><p>Cassandra 是依赖于本地文件系统来完成数据持久化的。数据在磁盘上是以可自我恢复的形式存储的。一般的数据写入操作都包含了对 commit log 的写入来保证持久性和可恢复性，以及对内存中数据结构的更新。对内存数据结构的写入仅在 commit log 写入成功后进行。每台机器上都有一块专门的硬盘用于 commit log 的存储，以最大化磁盘的吞吐量。当磁盘中数据结构的规模达到一定的上限，它就会将自己写入到磁盘当中。所有的磁盘写入都是顺序的，并且写入时会产生一个索引以实现基于行 key 的高效查询。这些索引也会随着数据文件一同被持久化。长期运行中，可能会产生许多的索引文件，因此在后台运行了一个合并进程来合并文件。这一过程与 Bigtable 系统中的压缩非常类似。</p><p>一个正常的读操作首先查询内存中的数据结构，然后才会查询磁盘中的文件。文件查询的顺序是从新到旧。当一个磁盘查询发生的时候，我们可能会在磁盘中的很多个文件中查找同一个 key。为了减少不必要的查询，每一个文件都又一个 bloom filter。它聚合了文件中存在的所有 key 值，存放在数据文件当中，且在内存中也有一份。这个过滤器会在查询到来时首先判断被查询的 key 在给定的文件中是否存在。</p><p>实际体验</p><p>深刻的一课：如果没有理解一个新特性产生的影响，就不要添加它。</p><p>许多麻烦的场景其实不是因节点失效或网络分区问题而产生的。</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>On the Nature of Progress (OPODIS&#39;11)</title>
      <link href="/20230109-onthenatureofprogress/"/>
      <url>/20230109-onthenatureofprogress/</url>
      
        <content type="html"><![CDATA[<p>这份工作确定了一个关系，它可以统一看似无关的 progress conditions : 从基于锁的系统的 deadlock-free 和 starvation-free 性质，到 obstruction-freedom （无障碍），lock-freedom（无锁），wait-freedom（无等待） 这样的非阻塞条件。</p><p>所有的性质可以按照两个维度来分类。</p><p>我大概懂意思。但是不想写这篇。</p><p>我到底是为什么这几天都没干活来着？？？</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>临行</title>
      <link href="/20230105-asa/"/>
      <url>/20230105-asa/</url>
      
        <content type="html"><![CDATA[<p>重要的准备</p><p>1、早上去图书馆把书借了</p><p>2、主机，线材，硬盘，耳机，显示器（数码产品）</p><p>3、衣服，鞋</p><p>4、印文献</p><p>5、运动装备</p><p>6、杂物：伞，咖啡，文具，药品，温度计，包，帽子。。</p><p>7、调试主机的连通性，是否能 wol，测试 remote。比去年好的地方在于有跳板了</p><p>8、收拾垃圾</p><p>（感觉东西太多了，少带点衣服）</p><p>回家去可不轻松啊…要写点 openGauss 的总结了。这票干完，就可以开始看书了。</p><p>（想啥呢，项目还要出数据的）</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>找回记忆</title>
      <link href="/20230105-yoru/"/>
      <url>/20230105-yoru/</url>
      
        <content type="html"><![CDATA[<p>找回记忆，其实就是把之前手写的日记录回到电脑里面。这样就可以看到自己较为连续性的变化了。</p><p>我需要这些回忆，好好分析一下大学这段时间里——甚至是高中的时间里，到底什么在影响我，走向什么样的未来。如果不知道自己从何处而来，想必也不可能真正知道自己将往何处去。</p><p>近几年对我最大的影响就是，以往有明确看法的人事物，现在我倾向于悬置判断。这并不是说我没有任何看法，而是下结论变成了一件困难的事，因为本来就很困难。相比于给出一个最终决断，我更习惯于给出一个临时的、局部的看法，并且不急于发表它。</p><p>这好吗？不一定。表面上看是更加谨慎，考虑更加周全，但变得犹犹豫豫，非常迟疑。实际上有一个很大的漏洞，即我不做判断的原因在于我缺乏这样的能力。而悬置判断恰好又让我没有动力去增长这一能力。比起短期内受损，我同样担心长久下去自己形不成一套稳定的看法，而永远都在以相对的眼光去做判断。</p><p>但话说到这里，我又不确定这两样到底是哪一样比较好了。这就是理论不扎实。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C 语言中的宏</title>
      <link href="/20230103-macro/"/>
      <url>/20230103-macro/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c</span><br></pre></td></tr></table></figure><p>做了什么？</p><p>example</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mian main</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出了一大串代码…</p><p><img src="image-20230103141627581.png" alt="image-20230103141627581"></p><p><img src="image-20230103141708387.png" alt="image-20230103141708387"></p><p>是不是有一点熟悉…翻到最后的话<br><img src="image-20230103141739040.png" alt="image-20230103141739040"></p><p>这下你明白了：</p><p>预处理就是字符串替换</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A B</span></span><br></pre></td></tr></table></figure><p>它的作用就是，把代码里以“词法单元”形式出现的 A 全都替换成 B。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.val = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A B</span></span><br><span class="line">A.val = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>预处理试试</p><h1 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo() &#123; return 1; &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>宏函数可以有参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(a) &#123; return a; &#125;</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">0</span>);</span><br><span class="line">foo(a + b);</span><br><span class="line">foo(a, b);  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>可变参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(a, ...) &#123; bar(__VA_ARGS__, a); &#125;</span></span><br><span class="line"></span><br><span class="line">foo(m);</span><br><span class="line">foo(m, n);</span><br><span class="line">foo(m, n, p);</span><br></pre></td></tr></table></figure><p>普通的函数也可以有可变参数列表！（你没想过 printf 是怎么做到的吗？）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>man va_args</p><p>注意点1：参数的括号与运算优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> add(a, b) a + b</span></span><br><span class="line"></span><br><span class="line">c = d * add(a, b) * e;   <span class="comment">///???</span></span><br></pre></td></tr></table></figure><p>注意点2：语法语义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo()  bar(); baz();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond) foo();   <span class="comment">// how will it expand?</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> foo() &#123; bar(); baz(); &#125;</span></span><br><span class="line"><span class="keyword">if</span> (cond) foo();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// Syntax error</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> foo() do &#123; bar(); &#125; while(0)   <span class="comment">// jeez!</span></span></span><br></pre></td></tr></table></figure><p>注意点3：副作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">max(a++, b);  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><h1 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A undefined!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A defined!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>条件编译也可以嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> A</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> B</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A B both defined!\n&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;B undefined!\n&quot;</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;A undefined!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也可以做条件判断！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> A &lt;= 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A &lt;= 2!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A &gt; 2!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>只能判断数字。如果没有指定值的话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> A == 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A == 0!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A != 0!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>error</p><p>但如果随便指定一个不存在的东西…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A SOMESTRANGESTUFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> A == 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A == 0!\n&quot;</span>);    <span class="comment">// THIS IS CHOSEN</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A != 0!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这就是玄学了（</p><h1 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h1><p>在预处理时有两个特殊的运算符。一是一元运算符 #，表示将文本替换成字符串；二是二元运算符 ##，表示将两个文本相连</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print(a) printf(#a)</span></span><br><span class="line"></span><br><span class="line">concat(hello, world);</span><br><span class="line">print(hello world);</span><br></pre></td></tr></table></figure><p><img src="image-20230103165611133.png" alt="image-20230103165611133"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVAL(expr) printf(#expr <span class="string">&quot; = %d\n&quot;</span>, expr)</span></span><br><span class="line"></span><br><span class="line">EVAL(<span class="number">1</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>但上面的定义有一点小问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> this that</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">concat</span><span class="params">(this, Func)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">// =&gt; int thisFunc(int a, int b);</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> this that</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat_temp(a, b) a ## b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) concat_temp(a, b);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">concat</span><span class="params">(this, Func)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">// =&gt; int concat_temp(that, Func)(int a, int b);</span></span><br><span class="line"><span class="comment">// =&gt; int thatFunc(int a, int b);</span></span><br></pre></td></tr></table></figure><h1 id="一些常用的自带宏"><a href="#一些常用的自带宏" class="headerlink" title="一些常用的自带宏"></a>一些常用的自带宏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__FILE__: 当前代码所处的文件名</span><br><span class="line"></span><br><span class="line">__LINE__: 当前代码在文件中的行数</span><br><span class="line">__TIME__: 当前文件在编译时的时间</span><br><span class="line"></span><br><span class="line">__x86_64__: 是否为 X86_64 架构编译</span><br></pre></td></tr></table></figure><p><img src="image-20230103171422726.png" alt="image-20230103171422726"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 a.c   <span class="comment"># ?</span></span><br><span class="line">gcc -m64 a.c</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Log(fmt, ...) fprintf(stderr, <span class="string">&quot;[in file %s, line %d, function %s] &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, __func__, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Log(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;print a log&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPL-Project2-ramfs</title>
      <link href="/20230102-ramfs/"/>
      <url>/20230102-ramfs/</url>
      
        <content type="html"><![CDATA[<ul><li>题面&#x2F;讲义&#x2F;api手册</li><li>提交方式</li><li>分数分布</li><li>测试点</li><li>代码框架</li><li>参考实现</li></ul><p>前言</p><p>这可能是大家第一次做类似的工作：你不是编写一个完整的程序，而是按照要求实现一些函数。这些函数将会被我们调用，以检测是否实现了所要求的功能</p><p>题面</p><p>文件系统是操作系统的重要组成部分。调用文件系统 api，我们可以轻松地将数据持久化到磁盘上。C 语言中为我们提供了一组 api，它们基于操作系统 api，允许我们对文件进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Linux 操作系统中，上述的 C 文件操作 api 是基于一组操作系统的文件 api 实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现要求你实现一个内存文件系统（ramfs）。顾名思义，这个文件系统的所有数据并不持久化到磁盘上，而是保存到内存当中，是一个易失性的文件管理系统。</p><p>文件系统的规定</p><p>与 Linux 的树形结构一致。在初始状态下，只存在根目录 “&#x2F;“。文件系统中存在两类对象，目录与文件。目录下可以存放其他对象，而文件不可以。即在树形结构中，文件只能是叶子节点。</p><p>例 (#)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── 1.txt            &quot;/1.txt&quot;</span><br><span class="line">├── 2.txt            &quot;/2.txt&quot;</span><br><span class="line">└── dir              &quot;/dir&quot;</span><br><span class="line">    ├── 1.txt        &quot;/dir/1.txt&quot;</span><br><span class="line">    └── 2.txt        &quot;/dir/2.txt&quot;</span><br></pre></td></tr></table></figure><p>可以看到，在根目录下一共有 3 个项目：两个文件，一个目录 dir，而 dir 下还可以拥有两个文件。右侧的字符串称为对象的“绝对路径”。</p><p>单个文件和目录名长度 &lt;&#x3D; 32 字节，仅包含字母、数字、英文句点。对于存在不合法的文件名的路径，你的文件系统 api 应当统一通过返回 -1 来拒绝此类操作。</p><p>路径长度 &lt;&#x3D; 1024 字节。（变相地说，文件系统的路径深度存在上限）。</p><p>文件系统 api 统一使用绝对路径，即以 ‘&#x2F;‘ 开头。在未创建任何文件时，即存在 “&#x2F;“ 指向的根目录。该目录可打开，不可删除，其余性质与一般目录一致。</p><p>我们要求你实现如下的 api，以实现文件系统的管理。其具体行为将会在 api 说明部分阐释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>注意，我们要求你实现的是内存操作系统。故你的程序应当使用内存管理 api（malloc、free）来存放文件所需的数据结构，以及文件的所有内容。我们保证整个文件系统的所有文件内容不会超过 512 MiB，且给予 1GiB 的内存限制。请小心地管理好内存注意不要超限。</p><p>开始你的项目</p><p>我们为你准备了一个 git repo。请基于这个 git repo 进行你的项目。如果你不会 git，请学着使用。</p><p>在 git repo 中我们为你提供了一个自动编译脚本 Makefile。并且为你配置好了记录自动追踪。请不要随意修改 Makefile。你的修改记录将成为查重时证明独立完成的重要证据。</p><p>推荐在 Linux 操作系统中完成本作业。如果你要使用 Windows，产生的问题由你自己解决。</p><p>获取代码框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://git.nju.edu.cn/Tilnel/ramfs.git&quot;</span></span><br></pre></td></tr></table></figure><p>注意：请在默认的 master 分支上进行开发。最终 OJ 的评分也将以你的 master 分支为准。</p><p>你应当在 ramfs.c 中包含你的所有实现（包括指定的函数和你使用的所有数据结构）。评测机会用我们自己的 Makefile（和分发版本一致）、ramfs.h（和分发版本一致）、main.c（包含更强力的测试用例）进行编译运行。因此你对 ranfs.h 和 main.c 以及 Makefile 的修改在 OJ 上不会产生效果。</p><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make submit TOKEN=<span class="variable">$&#123;你的token&#125;</span></span><br></pre></td></tr></table></figure><p>请在题目中“打开代码编辑器”后，获取你的提交 token。注意在校园网环境下提交。然后你就能在提交列表中看到你的提交。</p><p>注意在 make submit 之前，你需要将最新的改动 commit。同样注意保持你的工作目录整洁，如果你的 git repo 超过 20MiB（这一定是因为你放了很多很多奇怪的玩意），则没有办法提交。</p><p>你的 git repo 中不应当包含各种形式的编译产生的中间文件、编译结果。我们的 Makefile 只会在 build 目录下产生文件，我们也会配置好 .gitignore 文件避免 track 这些文件。</p><p>API 手册</p><p>注意两个对象的定义：文件（file），目录（directory）</p><p>最重要的对象：文件描述符 (file descriptor)</p><p>它是所有<strong>打开的文件和目录的标志</strong>，为一个非负整数。在 Windows 操作系统中称之为“句柄”。我们使用路径打开一个文件或目录，操作系统就会为这一次文件的打开分配一个文件描述符，它就像是一个“把手”一样。我们用这个文件描述符来指示打开的文件，进行对文件的操作。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);  <span class="comment">// open 返回一个文件描述符</span></span><br><span class="line">read(fd, buf, <span class="number">5</span>);                   <span class="comment">// 从打开的 fd (1.txt) 中读取五个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>打开 ramfs 中的文件。如果成功，返回一个文件描述符（一个非负整数），用于标识这个文件。</p><p>如果打开失败，则返回一个 -1。</p><p>pathname 为一个字符串，为文件的绝对路径。对于所有存在的文件和目录，你的 ropen 调用都应当成功。特别地，在指示一个目录时，pathname 的末尾可以有多余的 ‘&#x2F;‘。pathname 中同样可以有冗余的 ‘&#x2F;‘。</p><p>例如，在上文的例 (#) 中，以下的绝对路径是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dir/        =/dir</span><br><span class="line">////dir       =/dir</span><br><span class="line">/1.txt        =/1.txt</span><br><span class="line">//dir/1.txt   =/dir/1.txt</span><br></pre></td></tr></table></figure><p>以下的绝对路径是不存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/3.txt</span><br><span class="line">/1.txt/       (文件路径后不可以有多余的&#x27;/&#x27;)</span><br><span class="line">/di/r/1.txt   (不存在这个路径)</span><br></pre></td></tr></table></figure><p>flag 指示打开方式，其取值有如下可能（或可以是它们的组合）：</p><p>注意，在 C 中，以 0 开头的数字采用 8 进制表示法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND  02000 以追加模式打开文件。即打开后，文件描述符的偏移量指向文件的末尾。若无此标志，则指向文件的开头</span><br><span class="line">O_CREAT   0100 如果 pathname 不存在，就创建这个文件，但如果这个目录中的父目录不存在，则创建失败；如果存在则正常打开</span><br><span class="line">O_TRUNC   01000 如果 pathname 是一个存在的文件，并且同时以可写方式 (O_WRONLY/O_RDWR) 打开了文件，则文件内容被清空</span><br><span class="line">O_RDONLY  00 以只读方式打开</span><br><span class="line">O_WRONLY  01 以只写方式打开</span><br><span class="line">O_RDWR    02 以可读可写方式打开</span><br></pre></td></tr></table></figure><p>这些标志位的组合方式是使用按位的或运算。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_TRUNC | O_RDWR   (可读可写，打开时清空)</span><br><span class="line">O_CREAT | O_WRONLY (若不存在，创建后以读写方式打开；否则以读写方式直接打开)</span><br><span class="line">O_APPEND   (文件描述符的偏移量指向文件末尾，但因为只有此一个标志位，既不可读也不可写)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭打开的文件描述符，并返回 0。如果不存在一个打开的 fd，则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>向 fd 中的<em><strong>偏移量</strong></em>（马上解释）位置写入以 buf 开始的至多 count 字节，覆盖文件原有的数据（如果 count 超过 buf 的大小，仍继续写入），将 fd 的<em><strong>偏移量</strong></em>后移 count，并返回实际成功写入的字节数。如果写入的位置超过了原来的文件末尾，则自动为该文件扩容。</p><p>如果 fd 不是一个可写的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>在本实验中，ramfs 中同时存在的文件大小不会超过限制。因此你的 rwrite 对于一个能够写入的文件，事实上总应返回 count。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>从 fd 中的<em><strong>偏移量</strong></em>位置读出至多 count 字节到 buf 指向的内存空间当中，将<em><strong>偏移量</strong></em>后移 count，并返回实际读出的字节数。因为可能会读到文件末尾，因此返回值有可能小于 count。</p><p>如果 fd 不是一个可读的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>偏移量（offset）</p><p>想象你用手指指着读一本书，offset 相当于你手指指向的位置。你每读一个字，手指就向前前进一个字；如果你想改写书本上的字，每改写一个字，手指也向前前进一个字。</p><p>每一个文件描述符都拥有一个偏移量，用来指示读和写操作的开始位置。这个偏移量对应的是文件描述符，而不是“文件”对象。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/1.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);</span><br><span class="line">write(fd1, <span class="string">&quot;helloworld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">read(fd2, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时 buf 中将从文件的开头读到字符串”hello\0”。但如果换一种方式：</p><p>假设 “&#x2F;1.txt” 中原来有数据 “helloworld\0”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDWR);</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">read(fd, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时，write 在读取时，将文件指针前移了 5 个字节。于是read在读取的时候，将会从第6个字节开始读取。也即，read 将会读到 “world\0”。对于同一个文件描述符，读取和写入操作是共享偏移量的；对于不同的文件描述符，它们的偏移量则是各自独立的。</p><p>对于 open 操作，如果没有 O_APPEND 标志来将偏移量指向末尾，那么默认指向文件开头。</p><p>如何自由地修改和获取文件描述符的偏移量呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于修改 fd 表示的文件描述符的偏移量，并返回当前文件的实际偏移量。</p><p>whence有三种取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEEK_SET 0   将文件描述符的偏移量设置到 offset 指向的位置</span><br><span class="line">SEEK_CUR 1   将文件描述符的偏移量设置到 当前位置 + offset 字节的位置</span><br><span class="line">SEEK_END 2   将文件描述符的偏移量设置到 文件末尾 + offset 字节的位置</span><br></pre></td></tr></table></figure><p>rseek 允许将偏移量设置到文件末尾之后的位置，但是并不会改变文件的大小，直到它在这个位置写入了数据。在 超过文件末尾的地方写入了数据后，原来的文件末尾到实际写入位置之间可能出现一个空隙，我们规定应当以 “\0” 填充这段空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>创建目录，成功则返回 0。如果目录的父目录不存在或此路径已经存在，则失败返回 -1。</p><p>如，原来系统中只存在根目录 “&#x2F;“，调用：<code>rmkdir(&quot;/path/to/dir&quot;)</code> 返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个空目录，成功则返回 0。如果目录不存在或不为空，或 pathname 指向的不是目录，返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个文件，成功则返回 0。如果文件不存在或 pathname 指向的不是文件，则返回 -1。</p><p>额外的一个 api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_ramfs();</span><br></pre></td></tr></table></figure><p><strong>可以</strong>用于初始化你的文件系统。比如创建根目录。我们用于测试的 main() 将总会包含它。（要在里面做什么取决于你自己！）</p><p>我们的测试用例长什么样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* our main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();     <span class="comment">// 你的初始化操作</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/dir&quot;</span>) == <span class="number">0</span>);   <span class="comment">// 应当成功</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;//dir&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为目录已存在</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/a/b&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为父目录不存在</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  assert((fd = ropen(<span class="string">&quot;//dir///////1.txt&quot;</span>, O_CREAT | O_RDWR)) &gt; <span class="number">0</span>);  <span class="comment">// 创建文件应当成功</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 应当完整地写入</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_CUR) == <span class="number">5</span>);  <span class="comment">// 当前 fd 的偏移量应该为 5</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">0</span>);  <span class="comment">// 应当成功将 fd 的偏移量复位到文件开头</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">7</span>];</span><br><span class="line">  assert(rread(fd, buf, <span class="number">7</span>) == <span class="number">5</span>);   <span class="comment">// 只能读到 5 字节，因为文件只有 5 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>);   <span class="comment">// rread 应当确实读到 &quot;hello&quot; 5 个字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">3</span>, SEEK_END) == <span class="number">8</span>);  <span class="comment">// 文件大小为 5，向后 3 字节则是在第 8 字节</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 再写 5 字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">5</span>, SEEK_SET) == <span class="number">5</span>);  <span class="comment">// 将偏移量重设到 5 字节</span></span><br><span class="line">  assert(rread(fd, buf, <span class="number">8</span>) == <span class="number">8</span>);   <span class="comment">// 在第 8 字节后写入了 5 字节，文件大小 13 字节；那么从第 5 字节后应当能成功读到 8 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0world&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>); <span class="comment">// 3 字节的空隙应当默认填 0</span></span><br><span class="line">  assert(rclose(fd) == <span class="number">0</span>); <span class="comment">// 关闭打开的文件应当成功</span></span><br><span class="line">  assert(rclose(fd + <span class="number">1</span>) == <span class="number">-1</span>); <span class="comment">//关闭未打开的文件应当失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会在框架代码中提供几份测试代码供大家参考。大家可以自由地改动测试代码，并使用 <code>make test</code> 进行测试。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/20230111-ramfs-final/"/>
      <url>/20230111-ramfs-final/</url>
      
        <content type="html"><![CDATA[<h1 id="Ramfs-实验手册与指南"><a href="#Ramfs-实验手册与指南" class="headerlink" title="Ramfs - 实验手册与指南"></a><center>Ramfs - 实验手册与指南</center></h1><center>南京大学 孙博文<br>tilnel@smail.nju.edu.cn</center><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这可能是大家第一次做类似的工作：你不是编写一个完整的程序，而是按照要求实现一些函数。这些函数将会被我们调用，以检测是否实现了所要求的功能。</p><p><strong>本要求为（基本上是）最终版本。其中重要的描述修正将以这样的形式标出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+++ 这里是修改过的描述，请注意检查 +++</span><br></pre></td></tr></table></figure><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文件系统是操作系统的重要组成部分。调用文件系统 api，我们可以轻松地将数据持久化到磁盘上。C 语言中为我们提供了一组 api，它们基于操作系统 api，允许我们对文件进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Linux 操作系统中，上述的 C 文件操作 api 是基于一组操作系统的文件 api 实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现要求你实现一个内存文件系统（ramfs）。顾名思义，这个文件系统的所有数据并不持久化到磁盘上，而是保存到内存当中，是一个易失性的文件管理系统。</p><h2 id="文件系统的约定"><a href="#文件系统的约定" class="headerlink" title="文件系统的约定"></a>文件系统的约定</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>Ramfs 的目录结构与 Linux 的树形结构一致。在初始状态下，只存在根目录 “&#x2F;“。文件系统中存在两类对象，目录与文件。目录下可以存放其他对象，而文件不可以。即在树形结构中，文件只能是叶子节点。</p><p>例 (#)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── 1.txt            &quot;/1.txt&quot;</span><br><span class="line">├── 2.txt            &quot;/2.txt&quot;</span><br><span class="line">└── dir              &quot;/dir&quot;</span><br><span class="line">    ├── 1.txt        &quot;/dir/1.txt&quot;</span><br><span class="line">    └── 2.txt        &quot;/dir/2.txt&quot;</span><br></pre></td></tr></table></figure><p>可以看到，在根目录下一共有 3 个项目：两个文件，一个目录 dir，而 dir 下还可以拥有两个文件。右侧的字符串称为对象的“绝对路径”。</p><p>单个文件和目录名长度 &lt;&#x3D; 32 字节，</p><h6 id="修订1"><a href="#修订1" class="headerlink" title="修订1"></a>修订1</h6><p>+++ <strong>是字母、数字、英文句点的任意组合。例如，’.’ 不是当前目录，’..’ 也不是上级目录</strong> +++</p><p>对于存在<strong>不合法文件名</strong>的路径，你的文件系统 api 应当统一通过返回 -1 来拒绝此类操作。</p><p>所有 api 调用中，路径长度 &lt;&#x3D; 1024 字节。（也就是说，文件系统的路径深度是存在上限的）。</p><p>文件系统 api 统一使用绝对路径，即以 ‘&#x2F;‘ 开头。在未创建任何文件时，就已经存在 “&#x2F;“ 指向的根目录。该目录可打开，不可删除，其余性质与一般目录一致。</p><h3 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h3><p>整个文件系统同时存在的所有文件内容不会超过 512 MiB（不含已经删去的文件和数据），给予 1GiB 的内存限制。</p><p>同时存在的文件与目录不会超过 65536 个。</p><p>同时活跃着的文件描述符不会超过 4096 个。</p><p>对于所有数据点，文件操作读写的总字节数不会超过 10GiB。时限将给到一个非常可观的量级。</p><p>各数据点的性质：</p><ol><li><p>如原始的 main.c</p></li><li><p>根目录下少量文件创建 + ropen + rwrite + rclose</p></li><li><p>在 2 的基础上，测试 O_APPEND，rseek</p></li><li><p>在 3 的基础上扩大规模</p></li><li><p>少量子目录创建（&lt;&#x3D; 5 层）+ 文件创建与随机读写</p></li><li><p>在 5 的基础上，测试 rrmdir, runlink。</p></li><li><p>大文件测试。多 fd 对少量大文件大量读写 + rseek + O_TRUNCATE</p></li><li><p>复杂的文件树结构测试。大量的 O_CREAT，rmkdir, rrmdir, runlink。少量读写</p></li><li><p>文件描述符管理测试。大量 ropen、rclose，多 fd 单文件</p></li><li><p>综合场景的大型测试。模拟真实的系统。</p></li></ol><p>错误将会分散在各个数据点中。你需要保证你的 API 能正确地判断错误的情况并按照要求的返回值退出。</p><p>如果你获得 ”Wrong Answer“，说明仅仅是程序行为与 API 不一致。如读写的结果不正确，应该打开失败的文件却成功了…</p><p>如果获得 ”Runtime Error”，说明你的程序会出现运行错误而 crash。比如你在遍历文件树时，解引用了空指针…</p><h3 id="接口简述"><a href="#接口简述" class="headerlink" title="接口简述"></a>接口简述</h3><p>我们要求你实现如下的 api，以实现文件系统的管理。其具体行为将会在 api 说明部分阐释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>注意，我们要求你实现的是内存操作系统。故你的程序应当使用内存管理 api（malloc、free）来存放文件所需的数据结构，以及文件的所有内容。请小心地管理好内存注意不要超限。</p><h2 id="开始你的项目"><a href="#开始你的项目" class="headerlink" title="开始你的项目"></a>开始你的项目</h2><p>我们为你准备了一个 git repo。请基于这个 git repo 进行你的项目。如果你不会 git，请学着使用。</p><p>在 git repo 中我们为你提供了一个自动编译脚本 Makefile。并且为你配置好了记录自动追踪。请不要随意修改 Makefile。你的修改记录将成为查重时证明独立完成的重要证据。</p><p>推荐在 Linux 操作系统中完成本作业。如果你要使用 Windows，产生的问题由你自己解决。</p><p>获取代码框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://git.nju.edu.cn/Tilnel/ramfs.git&quot;</span></span><br></pre></td></tr></table></figure><p>注意：请在默认的 master 分支上进行开发。最终 OJ 的评分也将以你的 master 分支为准。</p><p><strong>你应当在 ramfs.c 中包含你的所有实现</strong>（包括指定的函数和你使用的所有数据结构）。评测机会用我们自己的 Makefile（和分发版本一致）、ramfs.h（和分发版本一致）、main.c（包含更强力的测试用例）进行编译运行。因此你对 ranfs.h 和 main.c 以及 Makefile 的修改在 OJ 上不会产生效果。</p><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make submit TOKEN=<span class="variable">$&#123;你的token&#125;</span></span><br></pre></td></tr></table></figure><p>请在题目中“打开代码编辑器”后，获取你的提交 token。注意在校园网环境下提交。然后你就能在提交列表中看到你的提交。</p><blockquote><p>由于服务器现可以通过 public.oj.cpl.icu 访问，你可以对 Makefile 中 submit 目标下的 url 进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@ -25,5 +25,5 @@ submit:</span><br><span class="line">        @cd .. &amp;&amp; zip -qr $&#123;FILE&#125; $&#123;BASE&#125;/.git</span><br><span class="line">        @echo &quot;Created submission archive $&#123;FILE&#125;&quot;</span><br><span class="line">        @curl -m 5 -w &quot;\n&quot; -X POST -F &quot;TOKEN=$&#123;TOKEN&#125;&quot; -F &quot;FILE=@$&#123;FILE&#125;&quot; \</span><br><span class="line">-               https://oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">+               http://public.oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">        @rm -r $&#123;TEMP&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意在 make submit 之前，你需要将最新的改动 commit。同样注意保持你的工作目录整洁，如果你的 git repo 超过 20MiB（这一定是因为你放了很多很多奇怪的玩意），则没有办法提交。</p><p>你的 git repo 中不应当包含各种形式的编译产生的中间文件、编译结果。我们的 Makefile 只会在 build 目录下产生文件，我们也会配置好 .gitignore 文件避免 track 这些文件。</p><h2 id="API-手册"><a href="#API-手册" class="headerlink" title="API 手册"></a>API 手册</h2><h6 id="修订2"><a href="#修订2" class="headerlink" title="修订2"></a>修订2</h6><p>+++ <strong>你的实现不应当有任何输出</strong> +++</p><p>以下注意区分两种对象的定义：文件（file），目录（directory）。</p><p>另一个重要的对象是：文件描述符（file descriptocr），简称 FD。它是所有<strong>打开的文件和目录的指示符</strong>，为一个非负整数。在 Windows 操作系统中称之为“句柄”。我们使用路径打开一个文件或目录，操作系统就会为这一次文件的打开分配一个文件描述符，它就像是一个“把手”一样。我们用这个文件描述符来指示打开的文件，进行对文件的操作。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);  <span class="comment">// open 返回一个文件描述符</span></span><br><span class="line">read(fd, buf, <span class="number">5</span>);                   <span class="comment">// 从打开的 fd (/1.txt) 中读取五个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><h6 id="修订3"><a href="#修订3" class="headerlink" title="修订3"></a>修订3</h6><p>+++ 打开 ramfs 中的<strong>文件或目录</strong>。如果成功，返回一个文件描述符（一个非负整数），用于标识这个对象。+++</p><p>如果打开失败，则返回一个 -1。</p><p>pathname 为一个字符串，为一个绝对路径。<strong>对于所有存在的文件和目录，你的 ropen 调用都应当成功</strong>。特别地，在指示一个目录时，pathname 的末尾可以有多余的 ‘&#x2F;‘。pathname 中间同样可以有冗余的 ‘&#x2F;‘。</p><p>例如，在上文的例 (#) 中，以下的绝对路径是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dir/        =/dir</span><br><span class="line">////dir       =/dir</span><br><span class="line">/1.txt        =/1.txt</span><br><span class="line">//dir/1.txt   =/dir/1.txt</span><br></pre></td></tr></table></figure><p>以下的绝对路径是不存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/3.txt</span><br><span class="line">/1.txt/       (文件路径后不可以有多余的&#x27;/&#x27;)</span><br><span class="line">/di/r/1.txt   (不存在这个路径)</span><br></pre></td></tr></table></figure><p>flag 指示打开方式，这些打开方式仅对<strong>文件</strong>起作用。如果被打开的是目录则自动忽略。其取值有如下可能（或可以是它们的组合）：</p><p>注意，在 C 中，以 0 开头的数字采用 8 进制表示法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND  02000 以追加模式打开文件。即打开后，文件描述符的偏移量指向文件的末尾。若无此标志，则指向文件的开头</span><br><span class="line">O_CREAT   0100 如果 pathname 不存在，就创建这个文件，但如果这个目录中的父目录不存在，则创建失败；如果存在则正常打开</span><br><span class="line">O_TRUNC   01000 如果 pathname 是一个存在的文件，并且同时以可写方式 (O_WRONLY/O_RDWR) 打开了文件，则文件内容被清空</span><br><span class="line">O_RDONLY  00 以只读方式打开</span><br><span class="line">O_WRONLY  01 以只写方式打开</span><br><span class="line">O_RDWR    02 以可读可写方式打开</span><br></pre></td></tr></table></figure><p>这些标志位的组合方式是使用按位的或运算。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_TRUNC | O_RDWR   (可读可写，打开时清空)</span><br><span class="line">+++ O_CREAT | O_WRONLY (若不存在，创建后以只写方式打开；否则以只写方式直接打开) +++ （原来写成读写了）</span><br><span class="line">+++ O_APPEND   (文件描述符的偏移量指向文件末尾，并可读) +++</span><br></pre></td></tr></table></figure><h6 id="修订8"><a href="#修订8" class="headerlink" title="修订8"></a>修订8</h6><p>+++ O_TRUNC 但文件以只读方式打开时，在 Linux 中为 unspecified 行为。此处约定为正常只读打开而不清空。 （1.15 聊天记录）+++</p><h6 id="修订4"><a href="#修订4" class="headerlink" title="修订4"></a>修订4</h6><p>+++ 注意点：+++</p><p>+++ <code>O_RDWR | O_WRONLY</code> 共同存在时，取只写的语义； +++</p><p>+++ 由于 <code>O_RDONLY</code> 是 0，因此若未指定任何读写方式时，默认是只读的； +++</p><p>+++ 同时，易得 <code>O_RDONLY | O_WRONLY == O_WRONLY</code>。因此组合只读只写得到的结果是只写。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭打开的文件描述符，并返回 0。如果不存在一个打开的 fd，则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>向 fd 中的<em><strong>偏移量</strong></em>（马上解释）位置写入以 buf 开始的至多 count 字节，覆盖文件原有的数据。如果 count 超过 buf 的大小，仍继续写入（数据保证不因此而产生段错误），将 fd 的<em><strong>偏移量</strong></em>后移 count，并返回实际成功写入的字节数。如果写入的位置超过了原来的文件末尾，则自动为该文件扩容。</p><p>如果 fd 不是一个可写的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><p>在本实验中，ramfs 中同时存在的文件大小不会超过限制。因此你的 rwrite 对于一个能够写入的文件，事实上总应返回 count。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>从 fd 中的<em><strong>偏移量</strong></em>位置读出至多 count 字节到 buf 指向的内存空间当中，</p><h6 id="修订5"><a href="#修订5" class="headerlink" title="修订5"></a>修订5</h6><p>+++ 将<em><strong>偏移量</strong></em>后移实际读出的字节数，并返回实际读出的字节数。+++</p><p>因为可能会读到文件末尾，因此返回值有可能小于 count。</p><p>如果 fd 不是一个可读的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p><h3 id="偏移量（offset）"><a href="#偏移量（offset）" class="headerlink" title="偏移量（offset）"></a>偏移量（offset）</h3><p>想象你用手指指着读一本书，offset 相当于你手指指向的位置。你每读一个字，手指就向前前进一个字；如果你想改写书本上的字，每改写一个字，手指也向前前进一个字。</p><p>每一个文件描述符都拥有一个偏移量，用来指示读和写操作的开始位置。这个偏移量对应的是文件描述符，而不是“文件”对象。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/1.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);</span><br><span class="line">write(fd1, <span class="string">&quot;helloworld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">read(fd2, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h6 id="修订6"><a href="#修订6" class="headerlink" title="修订6"></a>修订6</h6><p>--- 此时 buf 中将从文件的开头读到”hello\0”。但如果换一种方式： ---  </p><p>+++ 此时 buf 中将从文件的开头读到”hellow”。但如果换一种方式： +++</p><p>假设 “&#x2F;1.txt” 中原来有数据 “helloworld\0”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDWR);</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">read(fd, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>此时，write 在读取时，将文件指针前移了 5 个字节。于是read在读取的时候，将会从第6个字节开始读取。也即，read 将会读到 “world\0”。对于同一个文件描述符，读取和写入操作是共享偏移量的；对于不同的文件描述符，它们的偏移量则是各自独立的。</p><p>对于 open 操作，如果没有 O_APPEND 标志来将偏移量指向末尾，那么默认指向文件开头。</p><p>如何自由地修改和获取文件描述符的偏移量呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>这个函数用于修改 fd 表示的文件描述符的偏移量，并返回当前文件的实际偏移量。</p><p>whence有三种取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEEK_SET 0   将文件描述符的偏移量设置到 offset 指向的位置</span><br><span class="line">SEEK_CUR 1   将文件描述符的偏移量设置到 当前位置 + offset 字节的位置</span><br><span class="line">SEEK_END 2   将文件描述符的偏移量设置到 文件末尾 + offset 字节的位置</span><br></pre></td></tr></table></figure><p>rseek 允许将偏移量设置到文件末尾之后的位置，但是并不会改变文件的大小，<strong>直到它在这个位置写入了数据</strong>。在 超过文件末尾的地方写入了数据后，原来的文件末尾到实际写入位置之间可能出现一个空隙，我们规定应当以 “\0” 填充这段空间。</p><p>+++ 但不允许将偏移量设置到文件开头之前，也就是一个负数的绝对偏移量。这种情况下返回 -1。 +++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>创建目录，成功则返回 0。如果目录的父目录不存在或此路径已经存在，则失败返回 -1。</p><p>如，原来系统中只存在根目录 “&#x2F;“，调用：<code>rmkdir(&quot;/path/to/dir&quot;)</code> 返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个空目录，成功则返回 0。如果目录不存在或不为空，或 pathname 指向的不是目录，返回 -1。测试保证不对打开的 pathname 做 rrmdir。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>删除一个文件，成功则返回 0。如果文件不存在或 pathname 指向的不是文件，则返回 -1。测试保证不对打开的 pathname 做 runlink。</p><p>额外的一个 api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_ramfs();</span><br></pre></td></tr></table></figure><p><strong>可以</strong>用于初始化你的文件系统。比如创建根目录。我们用于测试的 main() 将总会包含它。（要在里面做什么取决于你自己！）</p><p>我们的测试用例长什么样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* our main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();     <span class="comment">// 你的初始化操作</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/dir&quot;</span>) == <span class="number">0</span>);   <span class="comment">// 应当成功</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;//dir&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为目录已存在</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/a/b&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为父目录不存在</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  assert((fd = ropen(<span class="string">&quot;//dir///////1.txt&quot;</span>, O_CREAT | O_RDWR)) &gt; <span class="number">0</span>);  <span class="comment">// 创建文件应当成功</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 应当完整地写入</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_CUR) == <span class="number">5</span>);  <span class="comment">// 当前 fd 的偏移量应该为 5</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">0</span>);  <span class="comment">// 应当成功将 fd 的偏移量复位到文件开头</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(rread(fd, buf, <span class="number">7</span>) == <span class="number">5</span>);   <span class="comment">// 只能读到 5 字节，因为文件只有 5 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>);   <span class="comment">// rread 应当确实读到 &quot;hello&quot; 5 个字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">3</span>, SEEK_END) == <span class="number">8</span>);  <span class="comment">// 文件大小为 5，向后 3 字节则是在第 8 字节</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 再写 5 字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">5</span>, SEEK_SET) == <span class="number">5</span>);  <span class="comment">// 将偏移量重设到 5 字节</span></span><br><span class="line">  assert(rread(fd, buf, <span class="number">8</span>) == <span class="number">8</span>);   <span class="comment">// 在第 8 字节后写入了 5 字节，文件大小 13 字节；那么从第 5 字节后应当能成功读到 8 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0world&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>); <span class="comment">// 3 字节的空隙应当默认填 0</span></span><br><span class="line">  assert(rclose(fd) == <span class="number">0</span>); <span class="comment">// 关闭打开的文件应当成功</span></span><br><span class="line">  assert(rclose(fd + <span class="number">1</span>) == <span class="number">-1</span>); <span class="comment">//关闭未打开的文件应当失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="修订7"><a href="#修订7" class="headerlink" title="修订7"></a>修订7</h6><p>+++ 我们将会在这份手册的最后，提供几份测试代码供大家参考。大家可以将这些代码放到你的 <code>main.c</code> 中，并使用 <code>make run</code> 进行测试。+++</p><h2 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h2><p>首先是目录树。这里给出一个参考的文件对象结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FILE_NODE, DIR_NODE &#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">dirents</span>;</span>  <span class="comment">// if it&#x27;s a dir, there&#x27;s subentries</span></span><br><span class="line">    <span class="type">void</span> *content;         <span class="comment">// if it&#x27;s a file, there&#x27;s data content</span></span><br><span class="line">    <span class="type">int</span> nrde;              <span class="comment">// number of subentries for dir</span></span><br><span class="line">    <span class="type">int</span> size;              <span class="comment">// size of file</span></span><br><span class="line">    <span class="type">char</span> *name;            <span class="comment">// it&#x27;s short name</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure><p>目录的子项的数量会变化；文件的内容大小也会变化。因次我们可能需要对 <code>dirents</code> 或 <code>content</code> 的内存大小进行动态的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>这一函数会创建一段新的空间，将原来的内容复制到新的空间上，并释放原来的指针。注意原有指针一定也是动态分配的。</p><p>其次是文件描述符。对于文件描述符来说，其重要的只有这几个属性：读写性质，偏移量，指向的实际文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FD</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    node *f;</span><br><span class="line">&#125; FD;</span><br></pre></td></tr></table></figure><p>最初的根文件可以直接定义成全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node root;</span><br></pre></td></tr></table></figure><p>然后在 <code>init_ramfs</code> 中进行初始化。</p><p>接下来的事情，就很显然了：</p><p>添加文件和目录，就是往树里添加节点；</p><p>删除文件，就是删除节点；</p><p>读取内容，就是从 content 里复制出一段…</p><p>一个小建议：使用 <code>memcpy</code> 而不是 <code>strcpy</code>。（区别在哪？读手册）</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>第一个数据点已经给出。</p><p>test2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">notin</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[i] == fd) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">genfd</span><span class="params">(<span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (notin(i, fds, n))</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();</span><br><span class="line">  <span class="type">int</span> fd[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(ropen(<span class="string">&quot;/abc==d&quot;</span>, O_CREAT) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_RDONLY)) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    assert(rwrite(fd[<span class="number">0</span>], <span class="string">&quot;\0\0\0\0\0&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">1</span>], <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">2</span>], <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">3</span>], <span class="string">&quot;\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  assert(rclose(genfd(fd, <span class="number">4</span>)) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0\0\0\0\0\0\0\0&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hellohello&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;worldworld&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x001\x002\x003\x0fe\x0ff\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他的请再等等吧（</p><p>2023.1.14 补：</p><p>上线了测试点 4，在 main() 的开头做了一件事：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rread(<span class="number">-100000000</span>, buf, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>所有人都炸掉了。但按照手册，它应该返回 -1。这只是测试中不合理数据的一角，请大家保证自己的实现的可靠性。</p><p>如果你对某些特例会产生什么行为抱有疑问，欢迎提问。</p><h6 id="修订9"><a href="#修订9" class="headerlink" title="修订9"></a>修订9</h6><p>+++ 再次强调请小心地管理内存，否则内存容易超限，特别是注意释放掉已经不用的空间。</p><p>+++ OJ 评测结果解释：</p><p>+++ 答案错误：你的函数行为与规定的行为不一致。可能是文件系统中的内容不一致，也可能是函数返回值不符合约定。</p><p>+++ 运行错误：你的函数在内部崩溃了。</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gitm</title>
      <link href="/20221228-git/"/>
      <url>/20221228-git/</url>
      
        <content type="html"><![CDATA[<p>git 是当今世界上最流行的版本控制系统。本实验要求你通过提交 git repo 的方式来提交一个迷你版的命令行工具 gitm(inus)。</p><p><strong>注意：本实验将只能在 Linux 操作系统中完成</strong>，因为你不得不使用系统调用，而 OJ 是 Linux 的。提交 Windows 上可以编译运行的代码，在评测机上注定不可兼容</p><p>首先，你需要学习 git ，否则你将完全不明白 gitm 的功能，并且也无法用 git 来管理本次作业的代码。</p><blockquote><p>是的！我们将会发布一个由 git 管理的框架代码，并且要求你一直使用 git 来管理，最终提交一个 git repo。</p></blockquote><p>获取框架代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.nju.edu.cn/Tilnel/gitm.git</span><br></pre></td></tr></table></figure><h2 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h2><p>所有代码，包括 .c 和 .h 文件需要放在 git repo 的根目录下。对自己使用的头文件的引用请以双引号的形式，以便编译脚本能够正常工作。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitm</span><br><span class="line">├── gitm.c</span><br><span class="line">├── gitm.h</span><br><span class="line">├── whateveryouwant.c</span><br><span class="line">├── whateveryouwant.h</span><br><span class="line">├── ...</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">/* gitm.c */</span><br><span class="line">#include &quot;gitm.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可以修改 Makefile，但请不要删除其中的 git 目标依赖。我们在 Makefile 中确保了你的每一次编译运行都能够自动进行 git commit。这些自动的 commit 可以帮助你回滚到自己想要的任意版本，并且在未来查重工作中产生疑问时，良好的 commit 记录将成为重要的证明。</p><p>在你的 git repo 里请包含所有编译所需的源文件，但不要出现编译不需要的多余的源文件。</p><p>尝试编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>你将看到根目录下产生了一个名为 gitm 的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gitm version</span><br></pre></td></tr></table></figure><p>你将看到一个小彩蛋（你之后可以自由地删掉它或修改掉，不影响成绩）。</p><p>注意：本次实验你编写的是一个 “命令行工具”。也就是说，我们将以和使用 git 相同的方式来使用它：在命令行里输入命令和参数。这意味着，这次你需要真正 “解析参数” （被 parse.c 支配的恐惧）。</p><p>而且，这次我们将会在运行中多次调用你的程序。也就是说，你的程序并不是在一直运行着，每一次调用都会做不同的事。你存储在内存里的数据都将随着功能完成，进程结束而消失。所以，关于 gitm repository 的有用的信息，你需要将它们持久化到磁盘上，以便进行后续的操作。因此学习 C 语言的文件操作是必不可少的。</p><p>为了实现一个 git，首先你要了解 git 的功能</p><h2 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h2><p>假设我们当前在一个文件夹 dir 下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm init</span><br></pre></td></tr></table></figure><p>初始化当前的 dir 为一个 gitm repository。如果当前 dir 已经是一个 gitm repo，则不做任何操作。</p><p>此时的 gitm 中应当不存在任何 commit，gitm 的仓库中应不存在任何文件。</p><p>具体来说，你可以在当前目录下创建一个 <code>.gitm</code> 目录，用于存放一些记录仓库状态的文件。</p><blockquote><p>对，就像 git 那样！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm commit</span><br></pre></td></tr></table></figure><p>将当前仓库中文件改动后状态作为一个提交，并记录下来。然后不重复地给出一个长度为 8 的小写十六进制数（例如 3bdc8902），用于唯一地指示这一次 commit。</p><p>git 中的提交是一个树形的结构。我们希望你在 gitm 中，同样实现这样的树形结构。</p><p><img src="git-brance.svg" alt="img"></p><p>gitm 中不要求实现对分支的命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout commit</span><br></pre></td></tr></table></figure><p>checkout 用于将当前目录的状态切换到 commit 所指示的提交上。</p><p>若当前目录的状态较 gitm <strong>当前所处的 commit</strong> 有改动，则拒绝本次 checkout，并且<strong>你的 main() 函数以返回值 1 退出</strong>。</p><p>checkout 正常完成后，你目录中文件的状态（除了 .gitm 目录以外）必须与指定的 commit 相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout .</span><br></pre></td></tr></table></figure><p>特殊地，这一条命令用于将目录文件恢复到当前所处的 commit 时的状态。也就是说，放弃此时对文件的所有改动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm merge commit</span><br></pre></td></tr></table></figure><p>找到当前所处 commit 与命令指定的 commit 的公共祖先，并将两个 commit 合并起来。</p><p>具体来说，是将命令指定的 commit 相对于公共祖先的修改，应用于当前所处的 commit。</p><p>如果合并的两个 commit 相对于公共祖先，均对同一个文件产生了修改（创建、删除、编辑），那么命令直接拒绝执行，输出 “conflict\n” <strong>并使 main 函数返回 1</strong>。</p><p>在其他情况下，你需要合并，并产生一个新的 commit。逻辑上，这个 commit 将成为被合并的两个 commit 的共同后继。</p><blockquote><p>我们如何检测这一点？</p><p>假设有 commit a-g，b, c 由 a 分支而来，d 由 b, c 合并而来，e 是 b 的后继，f 是 c 的后继，g 是 d 的后继。</p><p>你的程序应当有能力找到 e, g 的公共祖先是 b，f, g 公共祖先是 c，在此基础上合并是无冲突的。如果你只能找到 a，则合并有可能产生冲突，因为 e 相对 a 改变了 a.c，而 g 相对 a 也改变了 a.c。</p></blockquote><p><img src="image-20230103113625830.png" alt="image-20230103113625830"></p><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>我们会将你的 repo 里所有的 C 源文件和头文件收集起来进行编译，并生成一个名为 <code>gitm</code> 的可执行文件。然后原地创建一个文件夹，作为你的 gitm 需要管理的 repository。例如（其中 &gt; 开头的行表示命令行输出）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line">../gitm init</span><br><span class="line">../gitm commit</span><br><span class="line">&gt; 3bce5ff0                       <span class="comment"># 空 commit，我们的 OJ 一定会创建一个空 commit 作为第一个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt   <span class="comment"># 创建文件并写入</span></span><br><span class="line">../gitm commit</span><br><span class="line">&gt; b926d817</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is my git&quot;</span> &gt; readme.txt</span><br><span class="line">git checkout 3bce5ff0</span><br><span class="line">&gt; You<span class="string">&#x27;ve made change. Please commit or garbage your change.</span></span><br><span class="line"><span class="string">echo $?                          # 给出上一条命令的返回值。正常退出的程序应当为 0</span></span><br><span class="line"><span class="string">&gt; 1</span></span><br><span class="line"><span class="string">../gitm commit</span></span><br><span class="line"><span class="string">&gt; ef938aa6</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt readme.txt .gitm</span></span><br><span class="line"><span class="string">../gitm checkout b926d817</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt .gitm</span></span><br></pre></td></tr></table></figure><p>随着时间的流逝，我将会发布进一步的实验指南。</p><h2 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h2><ul><li>你创建的所有文件都要放到运行目录的 .gitm 目录下。<ul><li>注意目录不要膨胀得过大。把每一个 commit 都完整地保存下来是一个方法，但 OJ 会给你扣分的</li></ul></li><li>commit 数量不会超过 10000 个。</li><li>你的 gitm 只需要管理文本类型的文件。其他类型的文件不会出现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>年终盘点</title>
      <link href="/20221221-EndYear/"/>
      <url>/20221221-EndYear/</url>
      
        <content type="html"><![CDATA[<p>1、1.7 首次参与组织200多人的机考：自己的机器，挪用的系统，紧张的安排，垃圾的性能，随时会崩…但渡劫成功</p><p>2、1.21 看白色巨塔</p><p>3、2.6 第一次滑冰</p><p>4、2.11</p><p> <img src="image-20221221214315009.png" alt="image-20221221214315009"></p><p>5、2.14</p><p><img src="image-20221221214352111.png" alt="image-20221221214352111"></p><p><img src="image-20221221214357552.png" alt="image-20221221214357552"></p><p>当然后来真的见面然后寄了</p><p>6、2.19 看长江去了<img src="image-20221221214753639.png" alt="image-20221221214753639"></p><p>7、3.1 人体成分分析体脂率 22.1，开始两个月的减脂</p><p>8、3.12 中山忌辰</p><p>9、3.13 半夜在学校里鬼混，后来的故事懂的都懂了</p><p>10、4.12 2022年第一把冷水澡</p><p>11、4.21 完美洗牌</p><p>12、4.22 M记限时新品汉堡，苏炳添代言</p><p>13、5.3 两个月减脂结束，体脂率降到 16.1</p><p>14、5.14 Deadlift 100 kg。立下 flag 是一年到 200</p><p>15、5.19</p><p>17、6.1 新鞋，国家队同款</p><p><img src="IMG_20220603_000551.jpg" alt="IMG_20220603_000551"></p><p>18、6.17 Deadlift 120kg</p><p><img src="image-20221221220110346.png" alt="image-20221221220110346"></p><p>19、6.23 做10个引体向上</p><p>20、6.26 从手洗转向洗衣机</p><p>21、6.26 Squat 100kg</p><p><img src="image-20221221220236367.png" alt="image-20221221220236367"></p><p>22、6.28 Bench Press 70kg</p><p>23、7.9 新衣回</p><p>24、8.14 在宿舍打地铺睡觉，因为太几把热了</p><p>25、8.22 骑自行车骑嗨了压弯摔了个寄</p><p><img src="image-20221221221015346.png" alt="image-20221221221015346"></p><p><img src="image-20221221221019675.png" alt="image-20221221221019675"></p><p>26、9.18 Squat 120</p><p>27、9.28 保研 + 递补学硕</p><p>28、10.3 Deadlift 150kg</p><p>29、10.10</p><p>30、10.23 第一次配好 vim</p><p>30.5、11.11 2022年最后一次冷水澡</p><p>31、11.15 Squat 130kg</p><p>32、11.18- 后来的事懂的都懂</p><p>33、12.12 看到 Abramovic 和 Ulay 的 Rest energy</p><p>34、12.17 Deadlift 160kg 本年度最满意的一次试举：无腰带，丝滑，锁定到位（就是鞋子穿错了）</p><p><img src="image-20221221222314347.png" alt="image-20221221222314347"></p><p>35、12.19 冠军！</p><p>36、12.21 发烧退烧直播当场干两斤米饭</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Axioms for Memory Access in Asynchronous Hardware Systems</title>
      <link href="/20221221-MISRA1986/"/>
      <url>/20221221-MISRA1986/</url>
      
        <content type="html"><![CDATA[<p>问题与系统定义</p><p>（选择这篇的理由是，它描述了一个“从底层硬件的公设出发推导出读写序列的Serializability”的过程。在分布式系统中，同样也是通过一些底层的访问控制、执行的约束来保证最终结果的一致性。同时，这篇文章的问题构造与证明中，出现了大量的“序”关系。这也是理解分布式系统执行的关键。）</p><p>这份工作的动机是硬件设计中，如何解决对寄存器的异步并发访问的问题。只有基于寄存器行为的一些假设，才能证明其所允许的并发访问的正确性。然而直接从寄存器的物理电气特性去分析行为非常复杂。因此这份工作提出了一个研究寄存器的公理基础，即如果一个寄存器满足特定的公理，就可以称之为一个“serial device”（对其的操作是一个动作组成的序列）。因此有关寄存器的正确性的问题就被大大简化了。这份工作同样证明了他们提出的公理是满足这一要求所需的最弱的条件。在与硬件设计者讨论后，他们认为满足这些要求的设备是物理上可实现的。</p><p>在并发系统的研究当中，常常会假设内存的引用是非并发的。两个同时发生的操作会以任意的一个顺序执行，造成结果的不确定性。对寄存器的非并发访问可以通过锁来实现，使得一个写操作不能与任何其他操作并发。在底层硬件中，flip-flop 是一种可以存储一个 bit 的单元。而想要锁定这个寄存器则必须再实现一个基于 flip-flop 的 lock bit，开销过大并且降低了系统的并发度。于是这份工作考虑去设计一种寄存器，使得并发访问对外显得非并发，而非并发访问会保留它们的顺序。</p><p>定义 valid schedules：</p><blockquote><p>A sequence of operations whose effect is equivalent to some sequential (nonconcurrent) executions of these operations</p></blockquote><p>其影响与结果相当于这些操作的某个顺序执行</p><p>Section 3 Axioms for register</p><p>Section 4 Axioms define only valid schedules (and are the weakest)</p><p>​               (给定调度有效性的简单的充要条件)</p><p>Axioms &lt;&#x3D;&gt; Validity Conditions &lt;&#x3D;&gt; Valid</p><p>基本概念</p><p>操作：读或写。每个操作对应一个值。约定所有写操作的值都是可区分的，这样我们可以知道哪个值是由哪次写操作产生的，并且可以将读取到一个值的读操作与产生它的写操作对应起来。</p><p>每个操作都分为 start 和 end 事件。用 |op:x 和 op:x| 来标注。</p><p>调度：</p><p>一个 start 和 end 的序列，对于每一个 |op 都存在唯一的 op| 与之对应，反之亦然。</p><p>precedes 关系：</p><p>事件在另一事件前发生。|op1:x precesed |op2:y 指 op1 比 op2 先开始。</p><p>op1 precedes op2 指 op1| precedes |op2。即操作整体在先</p><p>concurrent：</p><p>neither op1 precedes op2 nor op2 precedes op1</p><p>nonconcurrent: otherwise</p><p>valid schedule:</p><p>对于一个调度S，能够通过重新安排操作，使得所有的操作都是非并发的，所有的S中的非并发操作保留它们原有的 precedes 序关系，且读操作的返回值与写操作一致。</p><p>形式地说，S 是一个有效调度，当且仅当存在 S 的排列 S’ 使得下列 validity conditions 成立：</p><p>VC1. 对于所有 S‘ 中的操作， |op precedes op| （合法）</p><p>VC2. 任一对 S’ 中的操作非并发</p><p>VC3. 如果 op1 precedes op2 in S, then op1 precedes op2 in S’</p><p>VC4. 在 S’ 中，每个读操作存在一个在前的写操作。并且如果 w:x 是 r:y 的最近的一次写操作，则 y &#x3D; x</p><p>寄存器操作的公理</p><p>在没有歧义的时候，用 |op 和 op| 来表示 op 开始和结束的时间点。</p><p>当我们说 时间点 t within op 时，意味着 |op \leqslant t \leqslant op|</p><p>Axioms</p><p>A1. 对于每个 r:x 存在某个时间点 within r，寄存器的值是 x</p><p>A2. 如果时间点 t 时寄存器的值为 x，并且一个写操作 w:y 在 t 后开始，在 t’ 前结束（t &lt; t’），那么 t’ 时寄存器的值一定不是 x （它可能是未定义的）</p><p>A3. 如果时间点 t’ 时寄存器的值为 x，那么存在某个时间点 t （t\leqslant t’），使得 t within w:x 且 在<br>t 时，寄存器的值为 x</p><p>A4. 如果时间点 t 和 t‘ 时寄存器的值为 x，那么 x 的值在 t 和 t’ 之间一直都是 x</p><p>可以看出这四条公理都是非常直观的：</p><p>A1 相当于在说读取操作一定是有寄存器当中的依据的</p><p>A2 表示一个写操作一定会对寄存器的值产生影响</p><p>A3 在说寄存器中的值一定由某个写操作产生</p><p>A4 是说一个值不可能在不连续的两段时间里出现。也就是说，写操作只会尝试写一次</p><p>Notation. 在一个调度中使用 (x) 来表示在某个时间点，寄存器的值为 x，直到调度中有某个 (y) 出现</p><p>有效调度的性质</p><p>对于任意调度 S，对操作的值定义关系 before：</p><p>(1) x before x, 如果存在 r:x precedes w:x 或不存在 w:x</p><p>(2) x before y, y \neq x，如果对于某两个 op1, op2, op1:x precedes op2:y</p><p>(3) x before z, 如果对于某个 y，x before y 且 y before z</p><p>在这篇文章中，作者将集合上的偏序关系重新定义为：反自反，反对称，传递的关系。</p><p>反自反是为了保证对于调度 S，不存在 r:x 先于 w:x 这样的顺序。</p><p>Theorem 1. 一个调度有效，当且仅当与它相关的 before 关系是一个偏序关系</p><p>\Rightarrow: 从偏序关系，构造任意全序，证明 VC1 - VC4</p><p>\Leftarrow: 对于有效调度 S，存在某个排列 S‘ 满足 VC1-4，其中关于某个值 x 的操作一定是连续的。它规定了值之间的“全序”关系 before。这个全序必须和 S 上的偏序一致，故 S 上的 before 一定是偏序关系，否则不存在与之一致的全序。</p><p>对于任意在满足 A1-A4 的寄存器的调度 S 上的 x 定义：</p><p>Rx &#x3D; {t | 时间点 t 寄存器的值为 x}，这里将其成为 x 的时域</p><p>Observetion1 Rx 是一段连续的时间。如果 t1, t2 \in Rx, 那么 \forall t, t1 &lt; t &lt; t2, t \in Rx (A4)</p><p>Observation2 如果 Rx 非空，那么对于每一个 op:x 中都有某个时间点 within op，寄存器的值为 x (A1, A3)</p><p>Theorem 2. 任何满足 A1, A2, A3 和 A4 的调度都是有效的</p><p>为了证明调度有效，我们要从四条公理证明调度上的 before 关系是偏序的。</p><p>从 A1，A3 可以得到 irreflexive；</p><p>由 Observation1、2 可知 antisymmetric；</p><p>由 before 的定义可知 transitive。</p><p>Theorem 3. 对于一个有效调度，总能在某些特定的时间点对寄存器赋值，从而使得 A1, A2, A3, A4 被满足。</p><p>这里用的是先构造，再证明的方法。其构造方式大致如下：</p><p>找到 S 的满足 VC 的排列 S’, 将操作从 1-n 编号为 op_i，其对应值为 v_i （可能重复）。然后按如下规则进行赋值：</p><p>(1) (v1) 在 |op1 后立刻赋值</p><p>(2) (vi), i &gt; 1，在 |op_i 或 (v_{(i - 1)}) 后立即赋值（取较晚的那个）</p><p>至此，四条公理已被证明是调度有效的充要条件。</p><p>最后，文章又通过构造满足四条公理之三而不满足另外一条，导致调度无效的反例来证明四条公理并无相互蕴含的关系，保证了结果是最简的。</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tenhou账号</title>
      <link href="/20221218-tenhou/"/>
      <url>/20221218-tenhou/</url>
      
        <content type="html"><![CDATA[<p>Selenium ID1DEC0A1F-c4TbfgF7</p><p>可能以后不会打天凤了，姑且存着</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>体育与当代社会课程论文</title>
      <link href="/20221217-sports/"/>
      <url>/20221217-sports/</url>
      
        <content type="html"><![CDATA[<blockquote><p>她是这么教我的。先写个提纲，然后往里面填。虽然我平时大致也是在用这样的方式，但感觉依然言之无物。今天在此就小水一下，整个2000字好了。</p></blockquote><p>Structure</p><p>题名，姓名，学号，院系，中文摘要，关键词</p><p>正文</p><p>参考文献 what，我真的有什么东西可以参考吗</p><p>从“吕小军”品牌的发展看未来退役运动员的出路</p><p>孙博文 191240046</p><p>南京大学 匡亚明学院</p><p>摘要：中国国家举重队员“吕小军”征战3届奥运会连续获得金牌，并多次创下世界纪录。在备战2024年巴黎奥运会的同时，其运动装备品牌“吕小军举重”也在很好地发展着。运动员退役后出路不佳是一个老生常谈的问题，而吕小军的个人品牌则让我们看到了未来退役运动员的发展方向。</p><p>关键词：运动员 退役</p><p>一、吕小军的个案</p><p>2009 年 11 月，吕小军获得第 77 届世界举重锦标赛男子 77 公斤级冠军，并打破世界纪录，在举重界书写下了他自己的姓名。此后在各大比赛上多次打破记录、获得冠军，并蝉联三届奥运会冠军（伦敦奥运会 77 公斤级、里约奥运会 77 公斤级、东京奥运会 77 公斤级。之后在 2022 年宣布将要备战 2024 年巴黎奥运会，或将降为 73 公斤级。</p><p>由于出色的成绩，他本人成为了一个世界性的“网红”。在外网上流传着国际网友剪辑的许多吕小军个人训练的视频，甚至被转发回国内。吕小军在举重上成绩优秀，同时身材也好，被国际上的粉丝成为“绝世美人”。2017 年，吕小军参加儿童举重训练营，认为这些孩子需要更好的装备。那时他有一个想法，在中国为专业和业余举重运动员制造举重设备，于是“吕小军举重”品牌应运而生。</p><p>如今，“吕小军举重”已经有能力制造许多运动装备与器械，包括杠铃、杠铃片、深蹲架、腰带、护腕、套膝等。这似乎与吕小军的粉丝人群有关。在吕小军的粉丝当中，有不少都是健美、力量举、CrossFit 的爱好者，而品牌也把握到了这一特性，将自己打造为这一人群提供商品的品牌。目前在 B 站上，有“奥运冠军吕小军”和“吕小军举重”两个账号。前者是吕小军的个人账号，而后者是品牌账号，可以看出他们还在不断地经营社交媒体，以扩大自身在圈内的影响力。</p><p>总结而言，“吕小军”品牌的发展让吕小军作为举重运动员在退役后，依然拥有自己的事业和收入。</p><p>二、过去的问题</p><p>过去，一个运动员退役后的去处较为局限。对于名气不高的田径、体操、举重项目的运动员，出路并不明朗。而球类项目，雪山项目，水上项目的条件要稍微好一点，因为对于这些方面的培训需求较高，尤其是青少年培训。对于事业编制的运动员，退役后除了国家给钱以外，安排事业单位进行工作。没有编制的就要自己想办法。曾经也出现过体操冠军退役后街头卖艺求生、“亚洲第一大力士”没钱治病的极端案例，引发了国内对运动员退役后的境遇的大讨论。</p><p>三、现状和分析</p><p>如今，退役运动员的生存空间已经大大改善了。</p><p>又是一个案例。在 B 站上有一个 “DNT举重俱乐部” 的账号，粉丝数 1.6 万。训练馆本身位于成都，受聘的教练有袁光弟（1983-1988 中国国家举重队）和周伟剑（安徽省冠军）等。训练馆的人气很足，账号也会不定期发布教学与线下训练的视频。他们一方面可以通过线下开课来赚取学费，另一方面也可以通过线上上课、发布视频的方式为训练馆增长人气。</p><p>我们也可以看到不断有更多的运动员账号进驻，包括服役与退役的。他们都可以借助网络的平台，分享自己专项的训练知识，将自己推广出去。</p><p>当下退役运动员境况改善的原因主要有三。</p><p>一是社交网络的发展让线上交流越来越方便了。如果是以前的文字上网时代，即使在线上能够交流，也达不到可以教学的信息量。同时视野的开阔让人们能够多样化地选择自己感兴趣的运动项目了。我们无法想象在以前只有电视的情况下，能够有如此多的人对于“举重”这一项目产生兴趣。以往的举重运动员，如吕小军是因为在田径比赛中拿奖而被选中；“东方力王”占旭刚则是为了农转非而碰巧练举重。</p><p>二是社会发展对于健康的认识提高了，人们对于运动更加重视了，对于运动项目的教练的需求增加了。很多项目具有较高的专业性，有一定门槛，不容易上手。那么找一个老师就成为了很有必要的事。同时对于专业训练装备的需求也在增加，对于运动基础设施的需求在增加，这就有了运动品牌入场的机会。</p><p>三是公众对于体育赛事越来越热情，越来越多的人在以运动员为其精神榜样。运动员们开启社交账号，分享自己的训练或生活日常，即可收获很多粉丝。这无疑是运动员们向外界推销自身的绝佳渠道。</p><p>四、总结</p><p>当下退役运动员的出路已大大改善。除了体系内运动员分配事业编制以外，还能够成为运动教练、经营自己的装备品牌、活跃于网络成为“网红”接代言等。这下不但让运动员拥有出路，还能够让运动员围绕着自己的运动专项来规划自己的终身事业。</p><p>“吕小军”品牌的成功无疑是一个强心剂。即使不是每一位运动员的名声都像吕小军那样响亮，但是发展品牌，并以个人社交账号来促进品牌的发展的模式是值得借鉴的。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我们现在都懒得起标题了</title>
      <link href="/20221216-whatthefuck3/"/>
      <url>/20221216-whatthefuck3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>把“我”打成我们，是一个无意识的失误</p></blockquote><p>正文部分，我想参照张一兵的剧幕写法尝试一下。形式大概是这样：</p><ul><li>场灯。幕布。</li><li>舞台上？舞台下？</li><li>文本</li><li>音乐</li><li>。。。</li><li>分析</li></ul><p>内容上：</p><p>我的处所即是舞台；</p><p>行动：</p><ul><li>手机聊天（蜷缩着）</li><li>阅读（书在腿上）</li><li>喝酒（啜饮）</li></ul><p>思维：</p><ul><li>爱情在哪里</li><li>我想要什么，不停被大他者夺舍</li><li>意识消失，大笑，歌唱，发疯</li></ul><p>这个设想有点困难，演员的行为需要被转写，不能原样表达场景（就是他妈的难改）。我们还是写第一人称吧。</p><p>去符号，但是忠实地写出来</p><p>大约晚上九点，带上书，水和酒钻进了一个人的角落。在其他人的视线里活得久了，将要独处一夜这件事让我兴奋不已。</p><p>戴着耳机坐在椅子上，身体下陷到屁股快要离开座位，跷起二郎腿当作架书的地方。拧开酒瓶盖，一边小口地啜饮一边心不在焉地翻着电子书，就这样过了午夜，在酒精的作用下已经读不进书了。打开手机，和朋友小聊几句。自诩乐观主义的我一时有很多问题难解：答案似乎写好了，我似乎也相信，但总归无法接受。他的心态倒是好，但从我的视角看又过于冷静了，冷静地像是死掉了一样。</p><p>讨论结束已经是接近断片的状态，意识几乎要融化了，我开始胡言乱语内心的真实，记忆中含妈量极高。然后大约陷入了昏睡。睡着时体温下降得极快，我直接被冻醒了。醒来之后几乎本能地抄起热水壶兑上带来的凉掉的水猛灌，又看了一眼手机，发现几条写得乱七八糟的动态，挠破头皮都想不起来自己写过了。大约喝了半小时热水之后，体温逐渐恢复，这时发现酒瓶已经掉到地上，里面还剩一口的量，想也没想就喝掉了，然后捧着书一直坐到阳光照进窗户。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rest Energy</title>
      <link href="/20221213-restenergy/"/>
      <url>/20221213-restenergy/</url>
      
        <content type="html"><![CDATA[<p><em><strong>Rest Energy</strong></em></p><p><img src="42580.jpg" alt="img"></p><p>Marina Abramović 和 Ulay 的行为艺术作品。在 4 分 10 秒的时间里，两人拉着一支有真实杀伤力的合成弓，并对准了 Marina Abramović 的心脏。在他们的心脏附近装着麦克风，现场可以清楚地听到自己的心跳随着时间的流逝逐渐激烈。</p><p>两人是现实中的情侣，一起创作了许多行为艺术作品，其中 <em>The Lovers</em> （情人·长城）还与中国颇有渊源。二人 1988 访问中国期间，原计划二人从长城两头分别开始步行，直到在中间会面，作为整个作品。然而 Ulay 爱上了来自中国的翻译，二人在相遇后坦白，只好以各自继续前进走完长城来完成这件作品。</p><p>后来在 2010 年，Marina Abramović 的《对视》中，Ulay 再次出现。作品的所有关注者无一不深受感动：22 年后的二人迎来和解。然而（这个是独家八卦）当时二人正处在知识产权的官司当中，那些感动一下又变成完全的滑稽了。</p><p><img src="3fccea50e537ce836171d29ef4b02ed6_720w.webp" alt="img"></p><p>说回 <em><strong>Rest Energy</strong></em>。这件作品最显然的解释，也是 Abramović 自己对此的解释是完全的相信。为了一个作品冒着受伤甚至死亡的风险，将箭矢对准自己，将弓弦交给对方。似乎行为艺术就是有好勇斗狠的传统，像台湾艺术家谢德庆的五件一年行为表演：一年每天24小时每小时打一次卡（会死人的！）；一年不进入任何建筑物（活得下来吗？）。行为艺术不是静态的图像，而是一种“现在进行时”，它作为一个事件在发生。刚看到图的时候，或许会误认为画面里的弓箭只是道具，只是为了用一个形象唤醒人思想中的某个<strong>意象</strong>（imago）。而当了解到真正在发生的事件后，便立即要人哑口无言。</p><p>它成为我最近最钟爱的一件作品，还在于其中暗合了一个经典的结构（也可能是因为我最近在看所以无论什么都能合上）。Lacan 的论文中有这样一个病例，38 岁的埃梅因刺杀法国知名演员达弗洛斯而被捕。其内在逻辑是将他人的形象作为镜像，并加以认同形成了一个实际上是他者的“理想自我”，作为一个追求的对象。真正欲望着一个人的时候，你就会自己去变成那个人，这中间通常包含了非常强烈的反差，以至于主体通过精神分裂的方式直接将幻想实现。对他者的认同，即标志着自我的立即的死亡，“他”对于我是一种杀戮的关系。</p><p>在这副作品中，欲望与死亡恰好是两个鲜明的标志。二人面对面针锋相对，彼此的欲望显露无疑，在你死我活的斗争中，千方百计地置对方于死地。因为“我是一个由于一个别人才是自为的存在”，某种意义上这是一场对“承认”的斗争。而现实的结局是一方臣服于另一方。</p><blockquote><p>因为他们最初是等同的，并且是正相反对的，而它们朝着统一的返回又还没有达到，所以它们就会以两个正相反对的意识的形态而存在。其一为一种独立的意识，它的本质是自为存在，另一为依赖的意识，它的本质是为对方而生活或为对方而存在。前者是<strong>主人</strong>，后者是<strong>奴隶</strong>。[1]</p></blockquote><p>[1] [德] 黑格尔：《精神现象学》</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9-more-pointers 题解</title>
      <link href="/20221208-more-pointers/"/>
      <url>/20221208-more-pointers/</url>
      
        <content type="html"><![CDATA[<h1 id="9-more-pointers-题解"><a href="#9-more-pointers-题解" class="headerlink" title="9-more-pointers 题解"></a>9-more-pointers 题解</h1><p>[toc]</p><blockquote><p>由战犯 Tilnel 贡献本次题解。</p><p>如果有你没见过的函数（用法），请尽量弄懂它。花10分钟学一下，省掉考场上一点自己造轮子的时间。</p></blockquote><h2 id="A-不太简单的词法分析器-tokenizer-c"><a href="#A-不太简单的词法分析器-tokenizer-c" class="headerlink" title="A-不太简单的词法分析器 (tokenizer.c)"></a>A-不太简单的词法分析器 (tokenizer.c)</h2><blockquote><p>本题数据的特性就是，不存在一个连续的字符串里有多个分号的情况。例如：<br><code>return;return;return;return;return;</code></p><p>所以对于分号，你可以当作只有：</p><p>1、在开头<br>2、在末尾<br>3、在中间有一个<br>4、没有<br>5、字符串里只有分号</p><p>这几种情形</p></blockquote><p>根据题目注解写的思路：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">  <span class="type">char</span> *position = <span class="built_in">strchr</span>(s, <span class="string">&#x27;;&#x27;</span>);   <span class="comment">// if there&#x27;s no &#x27;;&#x27; in s, it returns NULL.</span></span><br><span class="line">  <span class="keyword">if</span> (position == <span class="literal">NULL</span>) process(s);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    process(s 中分号前的部分);</span><br><span class="line">    在输出末尾加个换行;</span><br><span class="line">    process(s 中分号后的部分);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单地想到我们可以直接逐个处理，并把输出记录到字符串当中。</p><p>由于我们要求，要么输出完整的结果，要么只输出 Compile Error，而完整的结果是逐词累积的。如何在一个字符串的末尾去 append 新的内容呢？答案是：<code>strcat()</code>，或 <code>sprintf()</code>。</p><blockquote><p>NAME<br>       strcat, strncat - concatenate two strings</p><p>SYNOPSIS<br>       #include &lt;string.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></blockquote><p><code>strcat()</code> 的做法是把 src 拼到 dest 的后面。需要 dest 有足够的空间。并且只能操作纯字符串。而 <code>sprintf()</code> 可以在指定的位置放置一个格式化输出的字符串。同学们可以自行 RTFM。</p><p>那么，我们就开一个大的字符串去存放输出结果，每次更新。如果出错就输出报错，然后直接返回；否则在最后把结果输出。</p><p>如何分割字符串？以 “abcd;efgh” 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char s[] = &quot;abcd;efgh&quot;;</span><br><span class="line">s[4] = 0;</span><br><span class="line">printf(&quot;%s, %s\n&quot;, s, s + 5);</span><br></pre></td></tr></table></figure><p>它的输出结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd, efgh</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;abcd;efgh&quot;</span>;</span><br><span class="line">s[<span class="number">4</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码将会给出 segmentation fault。</p><p>在 C 语言中，”” 所给出的字符串字面量都将是常量，也就是说它会放在只读的内存空间中。<br><code>char *s = &quot;a string&quot;;</code> 的作用，是将这段只读内存空间的指针赋给 <code>s</code>。因此你不能重新对 <code>s</code> 中的字符进行修改。<br>而 <code>char s[] = &quot;a string&quot;;</code> 是分配一段可读写的内存空间，并将其中的值初始化为该字符串。</p></blockquote><p>在 C 中，字符串是以 ‘\0’ 结尾的。因此我们只需要让我们所需要的字符串部分的后一位为 ‘\0’，即可得到字符串的这一局部。因此想要将字符串按照 ‘;’ 割成两段，非常简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *semi = <span class="built_in">strchr</span>(s, <span class="string">&#x27;;&#x27;</span>);   <span class="comment">// find position of semicolon</span></span><br><span class="line"><span class="keyword">if</span> (semi) &#123;   <span class="comment">// strchr() returns NULL if there&#x27;s no semicolon</span></span><br><span class="line">  *semi = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  process(s);</span><br><span class="line">  process(semi + <span class="number">1</span>);    <span class="comment">// what&#x27;s after semicolon is another part</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  process(s);</span><br></pre></td></tr></table></figure><p>对于 <code>process()</code>，我们的要求则是：</p><ul><li>如果一个词符合五种规则，则追加一条解析</li><li>如果不符合，则直接输出 “Compile Error” 并退出</li></ul><p>直接退出程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure><p>不同于 return，它直接将整个程序正常结束。</p><p>那么，剩下最后一件事：解析规则。根据规则，一个字符串只可能属于其中的一种。故对五个规则依次判断。要注意的是，保留字均符合变量的条件，因此要先判出保留字，再去判变量。</p><h3 id="保留字和运算符"><a href="#保留字和运算符" class="headerlink" title="保留字和运算符"></a>保留字和运算符</h3><p>策略很简单：把所有保留字（运算符）放在一个字符串数组里，碰到以后逐个 <code>strcmp()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **reserved = <span class="built_in">malloc</span>(<span class="number">16</span> * <span class="keyword">sizeof</span>(<span class="type">char</span> *));   <span class="comment">// char **, 实质上是一个 (char *)的数组</span></span><br><span class="line">*(reserved + <span class="number">0</span>) = <span class="string">&quot;const&quot;</span>;</span><br><span class="line">*(reserved + <span class="number">1</span>) = <span class="string">&quot;int&quot;</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s, *(reserved + i))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// is a reserved</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// is not</span></span><br></pre></td></tr></table></figure><p>运算符同理</p><p>其实还有一个偷懒的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *operators = <span class="string">&quot; + - * / &lt; &gt; = == &gt;= &lt;= != &quot;</span>; <span class="comment">// why there is space?</span></span><br><span class="line"><span class="type">char</span> *tmp = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %s &quot;</span>, s);   <span class="comment">// add space in the front and rear of s</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(operators, tmp)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// !!</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>保留字是同理。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对于开头，检查是否是字母或下划线；对于后续，检测是否是字母、数字或下划线。</p><p>活用 <code>isalpha()</code>, <code>isdigit()</code>…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || *s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (s++; *s != <span class="number">0</span>; s++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || <span class="built_in">isdigit</span>(*s) || s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><code>isdigit()</code> 过一遍就好</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><code>isdigit()</code> 过一遍，但有一个位置可以是 ‘.’</p><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *reserved = <span class="string">&quot; break char const double enum extern float goto int long return static struct typedef union void &quot;</span>;</span><br><span class="line"><span class="type">char</span> *operators = <span class="string">&quot; + - * / &gt; &lt; &gt;= &lt;= == = != &quot;</span>;</span><br><span class="line"><span class="type">char</span> *tmp, *output;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isinteger</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; *s; s++) <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isfloat</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; *s; s++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*s)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*s == <span class="string">&#x27;.&#x27;</span>) cnt++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isreserved</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %s &quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(reserved, tmp) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isvariable</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || *s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (s++; *s != <span class="number">0</span>; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">isalpha</span>(*s) || <span class="built_in">isdigit</span>(*s) || *s == <span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isoperator</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot; %s &quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strstr</span>(operators, tmp) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*s) <span class="keyword">return</span>;  <span class="comment">// empty string while splitted by semicolon</span></span><br><span class="line">    <span class="keyword">if</span> (isinteger(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;integer &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isreserved(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;reserved &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isoperator(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;operator &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isfloat(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;float &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isvariable(s)) <span class="built_in">strcat</span>(output, <span class="string">&quot;variable &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Compile Error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">    output = <span class="built_in">malloc</span>(<span class="number">8192</span>);</span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">        <span class="type">char</span> *semi = <span class="built_in">strchr</span>(s, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!semi) process(s);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            *semi = <span class="number">0</span>;</span><br><span class="line">            process(s);</span><br><span class="line">            <span class="built_in">strcat</span>(output, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            process(semi + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="B-字符串拼接-stringcat-c"><a href="#B-字符串拼接-stringcat-c" class="headerlink" title="B-字符串拼接 (stringcat.c)"></a>B-字符串拼接 (stringcat.c)</h2><p>从长到短找出最长的公共部分。注意 A 有可能比 B 长，有的同学对于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ababacd ababa</span><br></pre></td></tr></table></figure><p>这样的一组，在寻找公共部分的时候，从 A 的第一个字符找起。显然 5 个字符全匹配了，但匹配部分并不是 A 的后缀。</p><p>偷懒：</p><p>对于一个字符串 B 的前缀 P, 总有</p><p>$strstr(B, P) &#x3D;&#x3D; B$</p><p>那么…</p><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="type">char</span> *a = <span class="built_in">malloc</span>(<span class="number">1001</span>), *b = <span class="built_in">malloc</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b);</span><br><span class="line">        <span class="type">int</span> la = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="type">int</span> lb = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (la &gt; lb) ? la - lb : <span class="number">0</span>; i &lt;= la; i++) &#123;   <span class="comment">// 为什么是 &quot;&lt;=&quot; ?</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(b, a + i) == b) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s%s\n&quot;</span>, a, b + la - i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：为什么这里是 “&lt;&#x3D;”</p><p>思考：<code>strstr(s, &quot;&quot;)</code> 的结果</p><h2 id="C-参数传递-parse-c"><a href="#C-参数传递-parse-c" class="headerlink" title="C-参数传递 (parse.c)"></a>C-参数传递 (parse.c)</h2><blockquote><p>Saki 放上去的参考代码里，有一份我的原实现。那是纯纯的超纲写法。<br>不需要 getopt()。那是 GNUC 的玩意。<br>也不需要 dup2()，这纯纯的 Linux 系统调用。</p></blockquote><p>思路是，从前往后扫就完事了。</p><p>有的同学发现，option requires an argument 只会在最后出现，于是先去看最后一个参数。</p><p>考虑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b:c:</span><br><span class="line">program -b -c</span><br></pre></td></tr></table></figure><p>只看 -c，你可能已经想报错了。但这个 -c 其实应当作为 -b 的值。</p><p>输出与报错的实现思路，和 A 是一致的。</p><blockquote><p>嘿，可以学一下 <code>sprintf()</code> 的使用！</p></blockquote><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *output = <span class="built_in">malloc</span>(<span class="number">4096</span>), *rules = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="type">char</span> *name = <span class="built_in">malloc</span>(<span class="number">1024</span>), *arg = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">char</span> *value = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, rules, name);</span><br><span class="line">    pos += <span class="built_in">sprintf</span>(output + pos, <span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, arg) != EOF)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*arg != <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">char</span> *rule = <span class="built_in">strchr</span>(rules, *(arg + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (rule != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(rule + <span class="number">1</span>) == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, value) == EOF) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s: option requires an argument -- &#x27;%c&#x27;\n&quot;</span>, name, *rule);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    pos += <span class="built_in">sprintf</span>(output + pos, <span class="string">&quot;%c=%s\n&quot;</span>, *rule, value);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                pos += <span class="built_in">sprintf</span>(output + pos, <span class="string">&quot;%c\n&quot;</span>, *rule);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: invalid option -- &#x27;%c&#x27;\n&quot;</span>, name, *(arg + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Takeaways-TL-DR"><a href="#Takeaways-TL-DR" class="headerlink" title="Takeaways (TL;DR)"></a>Takeaways (TL;DR)</h2><ul><li>字符串如何终止<ul><li>null byte</li></ul></li><li>学习简单的库函数让你在编程时偷懒<ul><li>但是要搞清楚这些函数的行为</li><li>用好了能节省大量时间</li><li>所以前提是学习的时候不偷懒</li></ul></li><li>指针难写<ul><li>去学断点调试</li><li>去学 GDB</li></ul></li><li>还不知道如何处理 SIGSEGV &#x2F; Segmentation fault ？？？<ul><li>STFW+自己调试，或惨挂</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-pointer 题解</title>
      <link href="/20221207-pointer/"/>
      <url>/20221207-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="8-pointer-题解"><a href="#8-pointer-题解" class="headerlink" title="8-pointer 题解"></a>8-pointer 题解</h1><p>[toc]</p><p>本周均属于简单的编程题。可以先用数组写了再转成指针写法。</p><h2 id="A-内存解释器-interpreter-c"><a href="#A-内存解释器-interpreter-c" class="headerlink" title="A-内存解释器 (interpreter.c)"></a>A-内存解释器 (interpreter.c)</h2><blockquote><p>不需要思考小端存储的事，不需要考虑浮点数非数的情况。<br>这是一道简单题，<strong>别想复杂</strong>，想得越复杂，越难做对。<br>也就是说，代码<strong>不应该超过10行</strong>，不然很可能只能拿部分分……别怪我没提醒。<br>当然，如果你足够强，可以化简为繁，挑战100行的写法。</p></blockquote><p>思路是很显然的，不过在那之前，我们可以稍微 dip into 一下 C 的类型系统，尤其是指针类型系统。</p><h3 id="常规类型"><a href="#常规类型" class="headerlink" title="常规类型"></a>常规类型</h3><p><code>int, float, double, long, long long...</code></p><p>每一种类型都对应了相应的<strong>字长</strong>。如 <code>int</code> 字长为 4，<code>long long</code> 字长为 8，而 <code>long</code> 的字长是机器相关的。在 32 位机上，它是 4 字，而在 64 位机上，它就是 8 字。机器相关的好处就在于，你可以编写可移植的代码。</p><p>当你在函数中写下 <code>int a;</code> 的时候，编译器可以在程序的栈空间里留下 4 个连续的字节空间用以存放这一整数。</p><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p><code>int *, float *, char *...</code></p><p>在 C 里，所有的指针类型都是机器相关的。指针长度与机器位宽相等，用来指示内存当中的某个位置。</p><p>对于 <code>int *</code> 变量进行解引用，如对 <code>int *a</code> 进行 <code>*a</code> 的操作，则 <code>*a</code> 的类型会自动还原为 <code>int</code>。其他常规类型同理。</p><p><code>void *</code></p><p>这种类型没有指定其解引用后的原类型。但它依然是一个指针。</p><h4 id="指针类型的强制类型转换"><a href="#指针类型的强制类型转换" class="headerlink" title="指针类型的强制类型转换"></a>指针类型的强制类型转换</h4><p>对于任意类型的指针，由于它们的字长是相同的，因此它们之间可以无阻碍地进行强制转换。如对于某个 <code>int *a</code>， 可以通过 <code>(double *)a</code> 来获取一个 <code>double *</code> 类型的指针。那么毫无疑问，如果你对这个指针进行解引用，即 <code>*(double *)a</code>，则机器会按照 <code>double</code> 的类型约定，来解析从指针位置开始的 8 字节作为解引用的值。于是题目就迎刃而解了。</p><p>STD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%u\n%f&quot;</span>, a, a, *(<span class="type">float</span>*)&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-子串的位置-substr-c"><a href="#B-子串的位置-substr-c" class="headerlink" title="B-子串的位置 (substr.c)"></a>B-子串的位置 (substr.c)</h2><p>认真阅读 C 库函数的手册，</p><blockquote><p>NAME<br>    strstr, strcasestr - locate a substring</p><p>SYNOPSIS<br>    #include &lt;string.h&gt;</p><p>​    char *strstr(const char *haystack, const char *needle);</p><p>DESCRIPTION<br>       The  strstr()  function finds the first occurrence of the substring needle in the string haystack.  The terminating null bytes (‘\0’) are not compared</p></blockquote><p>……</p><p>现成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">malloc</span>(<span class="number">100005</span>), *t = <span class="built_in">malloc</span>(<span class="number">100005</span>), *tmp = s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t);</span><br><span class="line">    <span class="keyword">while</span> ((tmp = <span class="built_in">strstr</span>(tmp, t)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tmp - s);</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有接触过 <code>strstr()</code>，那么至少也要想到，把<strong>从字符串里找到一个子串的位置</strong>这个功能封装为一个函数，毕竟要多次调用。</p><h2 id="C-搞个大新闻-title-c"><a href="#C-搞个大新闻-title-c" class="headerlink" title="C-搞个大新闻 (title.c)"></a>C-搞个大新闻 (title.c)</h2><blockquote><p>敬爱的江泽民同志永垂不朽</p></blockquote><p>既然说了是逐词以空格分开，那就可以这样的方式读入（一定要学会！）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF)) &#123;</span><br><span class="line">   <span class="comment">// process(s);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要么就在第 9 次作业再吃一次苦</p><p>C 还有两个库函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><p>只需要对第一个无脑 <code>toupper()</code>，剩下的全都 <code>tolower()</code> 就完事了…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  *s = <span class="built_in">toupper</span>(*s);</span><br><span class="line">  <span class="keyword">for</span> (s++; *s != <span class="number">0</span>; s++)</span><br><span class="line">    *s = <span class="built_in">tolower</span>(*s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *s = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF) &#123;</span><br><span class="line">    convert(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式与并行算法 - 实验</title>
      <link href="/20221204-parallel/"/>
      <url>/20221204-parallel/</url>
      
        <content type="html"><![CDATA[<p>个人使用了 C 语言。环境为 Linux on 12x 3.4GHz (6核12线程）。</p><p>代码编译方式：</p><p>对于并行的 mpqsort.c, mpenum.c, mpmerge.c:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mpqsort.c -O2 -lpthread -o mpqsort</span><br></pre></td></tr></table></figure><p>运行方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mpqsort</span><br></pre></td></tr></table></figure><p>对于串行的 qsort.c, enum.c, merge.c:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc qsort.c -O2 -o qsort</span><br></pre></td></tr></table></figure><p>对于6个程序，可以在路径下用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>一同生成。</p><h2 id="并行算法伪代码"><a href="#并行算法伪代码" class="headerlink" title="并行算法伪代码"></a>并行算法伪代码</h2><p>快速排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">para_quicksort(data, i, j, m, id)</span><br><span class="line">    <span class="keyword">if</span> (j - i) &lt;= k or m = <span class="number">0</span> then</span><br><span class="line">        P_id call quicksort(data, i, j)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        P_id: r = partition(data, i, j)</span><br><span class="line">        P_id: send data[r + <span class="number">1</span>, j] to P_id + <span class="number">2</span>^(m - <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        para_quicksort(data, i, r - <span class="number">1</span>, m - <span class="number">1</span>, id)</span><br><span class="line">        para_quicksort(data, r + <span class="number">1</span>, j, m - <span class="number">1</span>, id + <span class="number">2</span> ^ (m  - <span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line">        P_id + <span class="number">2</span>^m - <span class="number">1</span> send data[r + <span class="number">1</span>, j] back to P_id</span><br><span class="line">    end <span class="keyword">if</span> </span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>枚举排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">para_esort(i, j)</span><br><span class="line">    将区间 [i, j] 划分为 nr_thrd 个区间 [Pi, Qi]</span><br><span class="line">    par <span class="keyword">do</span> <span class="title function_">esort</span><span class="params">(Pi, Qi)</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure><p>归并排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">para_mergesort(i, j)</span><br><span class="line">    <span class="keyword">if</span> (j - i) &lt;= len / nr_thrd then</span><br><span class="line">        mergesort(i, j)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m = (i + j) / <span class="number">2</span></span><br><span class="line">        par <span class="keyword">do</span> para_mergesort(i, m)</span><br><span class="line">        par <span class="keyword">do</span> para_mergesort(m + <span class="number">1</span>, j)</span><br><span class="line">        merge</span><br><span class="line">    end <span class="keyword">if</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><table><thead><tr><th></th><th>串行</th><th>并行</th></tr></thead><tbody><tr><td>快排</td><td>5ms</td><td>4ms</td></tr><tr><td>枚举</td><td>2244ms</td><td>273ms</td></tr><tr><td>归并</td><td>5ms</td><td>3ms</td></tr></tbody></table><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>对于快排和归并来说，由于可以并行的部分较少，耦合度较高，导致提升并不大。而对于枚举排序，则因为各线程耦合较松，共享内存可以同时读如，导致并行后优化较好。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>openGauss 内容准备</title>
      <link href="/20221128-openGauss/"/>
      <url>/20221128-openGauss/</url>
      
        <content type="html"><![CDATA[<p>45分钟，分块</p><p>1、DB 概述 1-2 min</p><p>2、初次上手 2-3 min 加吐槽</p><p>3、项目基本结构介绍 3-4 min</p><p>4、分布式事务有的没的各种技术 20min</p><p>5、事务以外的各种技术 10min</p><p>6、社区，前景。2min</p><h2 id="DB-概述"><a href="#DB-概述" class="headerlink" title="DB 概述"></a>DB 概述</h2><p>openGauss是关系型数据库，采用客户端&#x2F;服务器，单进程多线程架构；支持单机和一主多备部署方式，同时支持备机可读、双机高可用等特性。</p><p>支持标准SQL，到2003，有2011的大部分核心特性和一些可选。</p><p>开发接口 ODBC， JDBC</p><p>混合存储引擎支持</p><p>openGauss数据库支持行存储引擎、列存储引擎和内存存储引擎等。行存分为“inplace update” 和 “append update”两种模式，前者通过单独的回滚段（undo log）来保留元组的前像以解决读写冲突，可以更自然的支持数据更新；后者将更新记录混杂在数据记录中，通过新旧版本的形式来支持数据更新，对于旧版本需要定期做vacuum操作来支持磁盘空间的回收。列存支持数据快速分析，更适合OLAP（Online Analytical Processing，联机分析处理）业务。内存引擎支持实时数据处理，对有极致性能要求的业务提供支撑。</p><p>事务支持 ACID。显式 - 隐式。主要关注事务。</p><p>显式有：</p><p>Start transaction</p><p>Commit</p><p>Rollback</p><p>Set transaction 设置隔离级别，读写模式，可推迟模式</p><p>对基于 ARM 架构的 鲲鹏 有一些特殊优化</p><p>从华为的 Gauss db T (oltp) 开源而来，支持单节点，一主多备，不支持集群。</p><p>基于postgresql v8</p><h2 id="初次上手："><a href="#初次上手：" class="headerlink" title="初次上手："></a>初次上手：</h2><p>东西很多。基础设施比较充分。编译可以有3种，release | debug | memcheck</p><p>随 src 附带一些测试。还有一些脚本工具，包括 ctags 的自动生成。</p><p>代码的移植性比较垃圾，在 CentOS 7.9 上用 gcc 7.3.0 编译。</p><p>必须用官方发布的第三方依赖库和相同发行版。否则问题超级多。</p><p>不知道 -enable-thread-safety 是什么实际作用。总之检查一直不过，只好 disable。</p><p>总之，更加现代的 bear、clangd 还没能成功整好…也许只能靠 IDE。</p><p>规模是140万行 c。</p><p>第一次dive in这种规模的项目…</p><h2 id="基本结构："><a href="#基本结构：" class="headerlink" title="基本结构："></a>基本结构：</h2><p>公共组件</p><ul><li>系统表，数据库初始化，多线程架构，线程池，内存管理，监控，模拟信号。</li></ul><p>系统表 - 元数据。有数据库列表，拥有者，字符集 之类</p><p>初始化 - initdb + openGauss 进程</p><p>多线程 - 由 PostgreSQL 多进程改造而来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Postmaster 监听，监控子线程。</span><br><span class="line">Startup 数据库启动。REDO日志。如果不是备机就退出。如果是备机就运行，REDO收到的新日志。</span><br><span class="line">Bgwriter 周期性写回 bufferpool</span><br><span class="line">Checkpointer 完成数据库周期性检查和执行检查点命令</span><br><span class="line">Walwriter 周期性持久化（数据库）日志缓冲区</span><br><span class="line">Stat 运行信息。统计。供优化分析和垃圾清理。</span><br><span class="line">Sysloger 写运行日志</span><br><span class="line">VacuumLaunch 通知Postmaster启动垃圾清理线程；平衡多个清理的负载</span><br><span class="line">Vacuumworker 垃圾清理线程</span><br><span class="line">Arch 日志归档。把在线日志拷到归档目录</span><br><span class="line">Postgres 服务线程。每个客户端连接对应一个服务线程。接收客户端操作请求，完成操作</span><br></pre></td></tr></table></figure><p>​</p><p>当然我们的重点是事务</p><p><img src="v2-458771758040c3e831461f1f20ae3b5e_720w.webp" alt="img"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>存储的子模块。</p><p>ACID</p><p>单机到分布式，双层的架构</p><p>GTM - CoordinatorNode - DataNode</p><p><img src="v2-28fa2431148513d3725fec9d2d62e95a_720w.webp" alt="img"></p><p>(1)GTM(GlobalTransaction Manager,全局事务管理器),负责全局事务号的分发、事务提交时间戳的分发以及全局事务运行状态的登记。对于采用多版本并发控制(Multi-Version Concurrency Control,MVCC)的事务模型,GTM 本质上可以简化为一个递增序列号(或时间戳)生成器,其为集群的所有事务进行了全局的统一排序,以确定快照(Snapshot)内容并由此决定事务可见性。在本文openGauss并发控制中,将进一步详述 GTM的作用。</p><p>(2)CN(CoordinatorNode,协调者节点),负责管理和推进一个具体事务的执行流程,维护和推进事务执行的事务块状态机。</p><p>(3)DN(DataNode,数据节点),负责一个具体事务在某一个数据分片内的所有读写操作。本文主要介绍显式事务和隐式事务执行流程中,CN 和 DN 上事务块状态机的推演,以及单机事务和分布式事务的异同。</p><p>主要代码在 src&#x2F;gausskernel&#x2F;storage&#x2F;access&#x2F;transam</p><p>事务管理器 xact.cpp 8000行。xact &#x3D; transaction</p><p>​        two-phase.cpp 3800 Lines. 二阶段提交</p><p>日志 xlog.cpp 19000 行 transaction log</p><p>clog.cpp  transaction-commit log</p><p>csnlog.cpp: tracking commit sequence numbers and in-progress subtransactions</p><p>线程管理 procarray.cpp </p><p>MVCC 多版本并发控制</p><p>锁管理 写并发控制。isolation</p><p>首先是 transaction，执行的全貌。显式隐式，子事务，执行时的并发控制</p><h3 id="（一）事务状态机"><a href="#（一）事务状态机" class="headerlink" title="（一）事务状态机"></a>（一）事务状态机</h3><p>openGauss将事务系统分为上层（事务块TBlockState）以及底层（TransState）两个层次。</p><p>通过分层的设计，在处理上层业务时可以屏蔽具体细节，实现灵活支持客户端各类事务执行语句（BEGIN&#x2F;START TRANSACTION&#x2F;COMMIT&#x2F;ROLLBACK&#x2F;END）。</p><p>（1） 事务块TBlockState：客户端query的状态，用于提高用户操作数据的灵活性，用事务块的形式支持在一个事务中执行多条query语句。</p><p>（2） 底层事务TransState：内核端视角，记录了整个事务当前处于的具体状态。</p><p>首先是显式事务块，也就是由 BEGIN &#x2F; START TRANSACTION 开启的事务。</p><p><img src="v2-42c47056ee587dad7f667d586a0213fc_720w.webp" alt="img"></p><p>在无异常情形下，一个事务块的状态机如图2所示按照默认（TBLOCK_DEFAULT）-&gt;已开始（TBLOCK_STARTED）-&gt;事务块开启（TBLOCK_BEGIN）-&gt;事务块运行中（TBLOCK_INPROGRESS）-&gt;事务块结束（TBLOCK_END）-&gt;默认（TBLOCK_DEFAULT）循环。剩余的状态机是在上述正常场景下的各个状态点的异常处理分支。</p><p>（1） 在进入事务块运行中（TBLOCK_INPROGRESS）之前出错，因为事务还没有开启，直接报错并回滚，清理资源回到默认（TBLOCK_DEFAULT）状态。</p><p>（2） 在事务块运行中（TBLOCK_INPROGRESS）出错分为2种情形。事务执行失败：事务块运行中（TBLOCK_INPROGRESS）-&gt;回滚（TBLOCK_ABORT）-&gt;回滚结束（TBLOCK_ABORT_END）-&gt;默认（TBLOCK_DEFAULT）；用户手动回滚执行成功的事务：事务块运行中（TBLOCK_INPROGRESS）-&gt;回滚等待（TBLOCK_ABORT_PENDING）-&gt;默认（TBLOCK_DEFAULT）。</p><p>（3） 在用户执行COMMIT语句时出错：事务块结束（TBLOCK_END）-&gt;默认（TBLOCK_DEFAULT）。由图2可以看出，事务开始后离开默认（TBLOCK_DEFAULT）状态，事务完全结束后回到默认（TBLOCK_DEFAULT）状态。</p><p>（4） openGauss同时还支持隐式事务块，当客户端执行单条SQL语句时可以自动提交，其状态机相对比较简单：按照默认（TBLOCK_DEFAULT）-&gt;已开始（TBLOCK_STARTED）-&gt;默认（TBLOCK_DEFAULT）循环。</p><p>子事务块 TBLOCK SUBxxx。基本就和事务块类似。。</p><p>TransState 也是类似的，只是是从事务真正执行的视角去看的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TABLE1;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>BEGIN, 开启事务块。</p><p>SELECT，开启一个底层事务执行该语句。</p><p>END 提交退出底层事务，结束事务块</p><p>几个函数，in tcop&#x2F;postgres.cpp 这个文件是 traffic cop 的主模块。</p><p>BEGIN;</p><p><code>exec_simple_query</code> 处理 begin 命令。</p><p>然后，它调用 <code>start_xact_command</code> 开始命令</p><ul><li>调用 <code>StartTransactionCommand</code> ，从 TBLOCK_DEFAULT 开始，</li><li>先调用（底层）<code>StartTransaction</code> ，于是 TRANS_START。</li><li>完成内存，缓冲区，锁初始化。</li><li>TRANS_INPROGRESS</li><li>返回，设为 TBLOCK_STARTED</li></ul><p><code>PortalRun</code> 处理 BEGIN 语句，最后在 BeginTransactionBlock 里 TBLOCK_BEGIN.</p><p><code>finish_xact_command</code> 结束命令。调用 CommitTransactinCommand 设置 TBLOCK_INPROGESS。等待读取下一条命令。</p><p>SELECT;</p><p>exec_simple_query</p><p>start_xact_command，此时是 INPROGRESS，已经在事务块内部，直接返回不改变任何状态。</p><p>PortalRun 执行。ExecutorRun，根据执行计划，最优路径查询。</p><p>finish_xact_command 结束 query 命令。调用 CommitTransactionCommand，而事务块仍为 TBLOCK_INPROGRESS。不改变任何状态</p><p>END;</p><p>exec_simple_query</p><p>start_xact_command 不改变</p><p>PortalRun -&gt; processUtility -&gt; EndTransactionBlock，set TBLOCK_END</p><p>finish_xact_command -&gt; CommitTransactionCommand，当前为 TBLOCK_END，继续调用CommitTransaction提交事务，设置底层状态为 TRANS_COMMIT，并且清理事务资源。最后 TRANS_DEFAULT。返回，上层事务块状态为 TBLOCK_DEFAULT。事务块结束。</p><h3 id="（二）事务ID分配-and-CLOG-x2F-CSNLOG"><a href="#（二）事务ID分配-and-CLOG-x2F-CSNLOG" class="headerlink" title="（二）事务ID分配 and CLOG&#x2F;CSNLOG"></a>（二）事务ID分配 and CLOG&#x2F;CSNLOG</h3><p>1 xid</p><p>transaction id ,  xid uint64 单调增。写在 HeapTupleHeader 的两个位置 xmin 代表插入的 xid, xmax 代表删除或修改的xid。</p><p>为节省空间，在 Page 上写 xid_base， 在 tuple 写 32 位 offset。</p><p>(溢出有调节)</p><p>只有写事务有 xid。“懒分配”。否则用太快。</p><p>子事务用到xid时，如果父务还没分配，则先分配父。确保子 &gt; 父。（越晚越大）。</p><p>2 log，维护映射关系</p><p>CLOG: xid -&gt; commit log</p><p>CSNLOG: xid -&gt; CommitSeqNo log</p><p>内存资源有限，长事务可能存在，所以内存会放不下。因此要写盘。写了盘就要记下哪条是哪个事务…</p><blockquote><p>CLOG以及CSNLOG分别维护事务ID-&gt;CommitLog以及事务ID-&gt;CommitSeqNoLog的映射关系。由于内存的资源有限，并且系统中可能会有长事务存在，内存中可能无法存放所有的映射关系，此时需要将这些映射写盘成物理文件，所以产生了CLOG（XID-&gt;CommitLog Map）、CSNLOG（XID-&gt;CommitSeqNoLog Map）文件。CSNLOG以及CLOG均采用了SLRU（simple least recently used，简单最近最少使用）机制来实现文件的读取及刷盘操作。</p></blockquote><p>CLOG，xid 到提交状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_IN_PROGRESS 0x00  表示事务未开始或还在运行中（故障场景可能是crash）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_COMMITTED 0x01 表示该事务已经提交</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_ABORTED 0x02 表示该事务已经回滚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOG_XID_STATUS_SUB_COMMITTED 0x03 表示子事务已经提交而父事务状态未知</span></span><br></pre></td></tr></table></figure><p> CSNLOG用于记录事务提交的序列号。openGauss为每个事务id分配8个字节uint64的CSN号，所以一个8k<strong>B</strong>页面能保存1k个事务的CSN号。CSNLOG达到一定大小后会分块，每个CSNLOG文件块的大小为256kB。同xid号类似，CSN号预留了几个特殊的号。CSNLOG定义代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_INPROGRESS UINT64CONST(0x0) 表示该事务还未提交或回滚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_ABORTED UINT64CONST(0x1) 表示该事务已经回滚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_FROZEN UINT64CONST(0x2) 表示该事务已提交，且对任何快照可见</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_FIRST_NORMAL UINT64CONST(0x3) 事务正常的CSN号起始值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMITSEQNO_COMMIT_INPROGRESS (UINT64CONST(1) &lt;&lt; 62) 事务正在提交中</span></span><br></pre></td></tr></table></figure><h3 id="（三）MVCC-可见性判断机制"><a href="#（三）MVCC-可见性判断机制" class="headerlink" title="（三）MVCC 可见性判断机制"></a>（三）MVCC 可见性判断机制</h3><p>MVCC：</p><p>openGauss行存储表支持多版本元组机制，即为同一条记录保留多个历史版本的物理元组以解决对同一条记录的读、写并发冲突（读事务和写事务工作在不同版本的物理元组上）。</p><p>astore存储格式为追加写优化设计，其多版本元组产生和存储方式如图5所示。当一个更新操作将v0版本元组更新为v1版本元组之后，如果v0版本元组所在页面仍然有空闲空间，则直接在该页面内插入更新后的v1版本元组，并将v0版本的元组指针指向v1版本的元组指针。在这个过程中，新版本元组以追加写的方式和被更新的老版本元组混合存放，这样可以减少更新操作的I&#x2F;O开销。然而，需要指出的是，由于新、老版本元组是混合存放的，因此在清理老版本元组时需要的清理开销会比较大。因此，astore存储格式比较适合频繁插入、少量更新的业务场景。</p><p><img src="v2-847adb1622283c44e87b474f942bab7e_720w.webp" alt="img"></p><p>多版本并发控制来维护一致性。扫描数据的时候，每个事务看到的只是拿到快照当时的数据，而不是最新的数据。这样就避免看到并发事务的更新导致不一致了。读写就互相不阻塞，两个锁不冲突。</p><p>CSN 机制</p><p><img src="v2-85f56ddab9dfecbe315fcae1e291df6a_720w.webp" alt="img"></p><p>每个非只读事务在运行过程中会取得一个xid号，在事务提交时会推进CSN，同时会将当前CSN与事务的xid映射关系保存起来（CSNLOG）。图5-12中，实心竖线标识取snapshot（快照）时刻，会获取最新提交CSN（3）的下一个值4。TX1、TX3、TX5已经提交，对应的CSN号分别是1、2、3。TX2、TX4、TX6正在运行，TX7、TX8是未来还未开启的事务。对于当前snapshot而言，严格小于CSN号4的事务提交结果均可见；其余事务提交结果在获取快照时刻还未提交，不可见。</p><p><img src="v2-069ad49a3f3c496a19ea55d64283ceab_720w.webp" alt="img"></p><p>（1） xid大于等于snapshot.xmax时，该事务id不可见。</p><p>（2） xid比snapshot.xmin小时，说明该事务id在本次事务启动以前已经结束，需要去CLOG查询事务的提交状态，并在元组头上设置相应的标记位。</p><p>（3） xid处于snapshot.xmin和snapshot.xmax之间时，需要从CSN-XID映射中读取事务结束的CSN；如果CSN有值且比snapshot.csn小，表示该事务可见，否则不可见。</p><p>提交流程</p><p><img src="https://pic1.zhimg.com/80/v2-2d4109a47c4b4d75be8e9bc9bc9f639c_720w.webp" alt="img"></p><p>（1） 设置CSN-XID映射commit-in-progress标记。</p><p>（2） 原子更新NextCommitSeqNo值。</p><p>（3） 生成redo日志，写CLOG，写CSNLOG。</p><p>（4） 更新PGPROC将对应的事务信息从PGPROC中移除，xid设置为InvalidTransactionId、xmin设置为InvalidTransactionId等。</p><p>多版本快照</p><p>事务结束，快照记录到 环形缓冲区队列内存。别的线程获取快照就不用持有共享锁了，二是原子操作获取最新快照并加引用计数。拷贝完再减。引用计数为0时就可以释放。</p><p>比如我事务结束了。我放进去。只要没有新的版本，就可以留着。这个时候引用了，计数 + 1。然后我又更新，因为引用计数在，所以刷不掉这一项。</p><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>自旋锁（spinlock）、轻量级锁（LWLock，light weight lock）和常规锁（或基于这3种锁的进一步封装）。</p><p>spin用于加锁时间短的场合。编码保证无死锁。尽量用 CAS。</p><p>LWLock轻量锁： 原子操作 + 等待队列 + 信号量。</p><ul><li>两种，共享锁与排他锁</li></ul><p>共享锁可供多个进程；排他锁是独占。</p><p>轻量级锁使线程睡眠阻塞。用于内部临界区操作比较长的场合。</p><p>加锁和解锁可能跨越函数。编码保证不产生死锁。openGauss 提供了检测机制。</p><p>LWLockReleaseAll 事务中出错，会把持有的所有锁全部回滚释放。</p><p>常规锁：哈希表实现。用于业务访问的数据库对象加锁。</p><p>有等待队列，并提供死锁检测。检测到死锁是，选择一个事务回滚。</p><p>提供了8个锁级别分别用于不同的语句并发：1级锁一般用于SELECT查询操作；3级锁一般用于基本的INSERT、UPDATE、DELETE操作；4级锁用于VACUUM、analyze等操作；8级锁一般用于各类DDL语句，具体宏定义及命名代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AccessShareLock 1  <span class="comment">/* SELECT语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowShareLock 2     <span class="comment">/* SELECT FOR UPDATE/FOR SHARE语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RowExclusiveLock 3 <span class="comment">/* INSERT, UPDATE, DELETE语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareUpdateExclusiveLock  \</span></span><br><span class="line"><span class="meta">    4 <span class="comment">/* VACUUM (non-FULL),ANALYZE, CREATE INDEX CONCURRENTLY语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareLock 5 <span class="comment">/* CREATE INDEX (WITHOUT CONCURRENTLY)语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ShareRowExclusiveLock                \</span></span><br><span class="line"><span class="meta">    6 <span class="comment">/* 类似于独占模式, 但是允许ROW SHARE模式并发 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ExclusiveLock                  \</span></span><br><span class="line"><span class="meta">    7 <span class="comment">/* 阻塞ROW SHARE，如SELECT...FOR UPDATE语句 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AccessExclusiveLock              \</span></span><br><span class="line"><span class="meta">    8 <span class="comment">/* ALTER TABLE, DROP TABLE, VACUUM FULL, LOCK TABLE语句 */</span></span></span><br></pre></td></tr></table></figure><p><img src="v2-5570aadf455dc9f6168b77ae0137041e_720w.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCKTAG</span> &#123;</span></span><br><span class="line">    uint32 locktag_field1;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint32 locktag_field2;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint32 locktag_field3;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint32 locktag_field4;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint16 locktag_field5;      <span class="comment">/* 32比特位*/</span></span><br><span class="line">    uint8 locktag_type;          <span class="comment">/* 详情见枚举类LockTagType*/</span></span><br><span class="line">    uint8 locktag_lockmethodid; <span class="comment">/* 锁方法类型*/</span></span><br><span class="line">&#125; LOCKTAG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">LockTagType</span> &#123;</span></span><br><span class="line">    LOCKTAG_RELATION, <span class="comment">/* 表关系*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_RELATION的ID信息为所属库的OID+表OID；如果库的OID为0表示此表是共享表，其中OID为openGauss内核通用对象标识符 */</span></span><br><span class="line">    LOCKTAG_RELATION_EXTEND, <span class="comment">/* 扩展表的优先权*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_RELATION_EXTEND的ID信息 */</span></span><br><span class="line">    LOCKTAG_PARTITION,          <span class="comment">/* 分区*/</span></span><br><span class="line">    LOCKTAG_PARTITION_SEQUENCE, <span class="comment">/* 分区序列*/</span></span><br><span class="line">    LOCKTAG_PAGE,               <span class="comment">/* 表中的页*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_PAGE的ID信息为RELATION信息+BlockNumber（页面号）*/</span></span><br><span class="line">    LOCKTAG_TUPLE, <span class="comment">/* 物理元组*/</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_TUPLE的ID信息为PAGE信息+OffsetNumber（页面上的偏移量） */</span></span><br><span class="line">    LOCKTAG_TRANSACTION, <span class="comment">/* 事务ID (为了等待相应的事务结束) */</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_TRANSACTION的ID信息为事务ID号 */</span></span><br><span class="line">    LOCKTAG_VIRTUALTRANSACTION, <span class="comment">/* 虚拟事务ID */</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_VIRTUALTRANSACTION的ID信息为它的虚拟事务ID号 */</span></span><br><span class="line">    LOCKTAG_OBJECT, <span class="comment">/* 非表关系的数据库对象 */</span></span><br><span class="line">    <span class="comment">/* LOCKTAG_OBJECT的ID信息为数据OID+类OID+对象OID+子ID */</span></span><br><span class="line">    LOCKTAG_CSTORE_FREESPACE, <span class="comment">/* 列存储空闲空间 */</span></span><br><span class="line">    LOCKTAG_USERLOCK, <span class="comment">/* 预留给用户锁的锁对象 */</span></span><br><span class="line">    LOCKTAG_ADVISORY, <span class="comment">/* 用户顾问锁 */</span></span><br><span class="line">    LOCK_EVENT_NUM</span><br><span class="line">&#125; LockTagType;</span><br></pre></td></tr></table></figure><p>5个field 逐级标识被上锁的对象。type 为类型，比如 table, tuple, transaction.  很多很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LOCK</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 哈希键 */</span></span><br><span class="line">    LOCKTAG tag; <span class="comment">/* 锁对象的唯一标识 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 数据 */</span></span><br><span class="line">    LOCKMASK grantMask;           <span class="comment">/* 已经获取锁对象的位掩码 */</span></span><br><span class="line">    LOCKMASK waitMask;            <span class="comment">/* 等待锁对象的位掩码 */</span></span><br><span class="line">    SHM_QUEUE procLocks;          <span class="comment">/* 与锁关联的PROCLOCK对象链表 */</span></span><br><span class="line">    PROC_QUEUE waitProcs;         <span class="comment">/* 等待锁的PGPROC对象链表 */</span></span><br><span class="line">    <span class="type">int</span> requested[MAX_LOCKMODES]; <span class="comment">/* 请求锁的计数 */</span></span><br><span class="line">    <span class="type">int</span> nRequested;               <span class="comment">/* requested数组总数 */</span></span><br><span class="line">    <span class="type">int</span> granted[MAX_LOCKMODES];   <span class="comment">/* 已获取锁的计数 */</span></span><br><span class="line">    <span class="type">int</span> nGranted;                 <span class="comment">/* granted数组总数 */</span></span><br><span class="line">&#125; LOCK;</span><br></pre></td></tr></table></figure><p>常规锁LOCK结构，tag是常规锁对象的唯一标识，procLocks是将该锁所有的持有、等待线程串联起来的结构体指针。</p><p>死锁检测</p><p>LWLock 有独立监控线程。watchdog + 时间戳。请求进入时记录时间，wait 的默认 timeout 为 5s。如果超过了，就触发真正的死锁检测。避免性能浪费。实际的检测就是根据锁的依赖关系进行线程之间的有向无环图判定。治愈死锁就是从环里调一个线程退出。</p><p>常规锁 冲突时设置定时器，再唤起进行死锁检测。</p><p>事务隔离级别</p><p>在openGauss中,隔离级别的实现基于 MVCC和快照机制,因此这种隔离方式被称为 快 照 隔 离 (Snapshot Isolation,SI)。目 前,openGauss 支 持 读 已 提 交 (Read Committed)和可重复读(Repeatable Read)这两种隔离级别。两者实现上的差别在于在一个事务中获取快照的次数。</p><p>如果采用读已提交的隔离级别,那么在一个事务块中每条语句的执行开始阶段,都会去获取一次最新的快照,从而可以看到那些在本事务块开始以后、在前面语句执行过程中提交的并发事务的效果。如果采用可重复读的隔离级别,那么在一个事务块中,只会在第一条语句的执行开始阶段,获取一次快照,后面执行的所有语句都会采用这个快照,整个事务块中的所有语句均不会看到该快照之后提交的并发事务的效果。</p><p>这三个事务的并发执行顺序可能交错。SELECT - INSERT - SELECT - INSERT - SELECT</p><p>考虑 T3事务三条查询的返回结果。如果采用“读已提交”的隔离级别,那么在第一条查询开始时,首次获取快照,T1和T2均没有提交,因此它们都在快照中,查询结果不会包含它们插入的新记录;在第二条查询开始时,第二次获取快照,T1已经提交,在第二条查询语句的快照中,只有T2,因此可以查询到 T1插入的记录 v1;同理,在第三条查询开始时,第三次获取快照,T1和 T2均已经提交,它们都不在第三条语句的快照中,因此可以查询到它们插入的记录v1和v2。</p><p>另一方面,如果采用可重复读的隔离级别,对于 T3中的三条查询语句,均会采用第一条语句执行开始时的快照,而 T1和 T2均不在该快照中,因此在该隔离级别下,T3的三条查询语句均不会返回v1和v2。</p><h2 id="然后是持久化和故障恢复"><a href="#然后是持久化和故障恢复" class="headerlink" title="然后是持久化和故障恢复"></a>然后是持久化和故障恢复</h2><p>WAL 日志 (write ahead log，预写日志)</p><p>行存储持久化和检查点。</p><p>如果数据库系统在事务提交之后、异步写入磁盘的脏页写入磁盘之前发生宕机，那么需要在数据库再次启动之后，首先把那些宕机之前还没有来得及写入磁盘的脏页上的修改所对应的日志进行回放，使得这些脏页可以恢复到宕机之前的内容。</p><p>基于如上原理，可以得出数据库持久化的一个关键是：在宕机重启的时候，通过某种机制确定从WAL的哪个LSN开始进行恢复；可以保证在该LSN之前的那些日志，它们涉及的数据页面修改已经在宕机之前完成写入磁盘。这个恢复起始的LSN，即是数据库的检查点。</p><p>脏页通过 bgwriter 和 pagewriter（作为唯一消费者） 写入磁盘。采用无锁的全局脏页队列数组记录。</p><p>pagewriter 实际写入磁盘（其实是缓存！）。Checkpointer 线程来 fsync （确保持久化）并推进 LSN。</p><p>故障恢复，从 checkpoint 开始回放 log。日志有多种类型，回放逻辑由各自的资源管理器实现。</p><p>当数据库发生宕机重启之后需要从检查点位置开始回放之后所有的日志。不同类型的日志的回放逻辑由对应的资源管理器来实现。</p><p>当用户业务压力较大时会同时有很多业务线程并发执行事务和日志记录的插入，单位时间内产生的日志量是非常大的。对此openGauss采用多种回放线程组来进行日志的并行回放，各个回放线程组之间采用高效的流水线工作方式，各个回放线程组内采用多线程并行的工作方式，以便保证日志的回放速率不会明显低于日志产生的速率。</p><h2 id="最后是主备同步"><a href="#最后是主备同步" class="headerlink" title="最后是主备同步"></a>最后是主备同步</h2><p>日志复制。备机就回放。</p><p>walsender（主）walreceiver（备）</p><p>主机修改产生日志后，事务commit前需要同步日志到备机。采用Quorum一致性复制协议。多数备机完成日志同步即提交。这个过程中作为事务提交参考的是同步备，其他备机是异步备，作为冗余备份。</p><p>故障切换 failover：只有备机发生，主机异常了。</p><p>计划内切换 switchover： 主机降备，备机 failover。</p><p>leader 负责将自己的日志复制到其他节点，并维持心跳 </p><p>follower 复制接受来自leader的日志，心跳超时时转换为candidate，给其 他candidate投票 </p><p>Pre-Candidate Candidate 发起新任期投票，收集来自其他节点的投票 </p><p>passive 复制接受来自leader的日志 </p><p>logger 复制接受来自leader的日志，给其他candidate投票</p><p>preVote优化：  为防止网络断连导致节点频繁发起选主请求，term持续增加  在Follower变为Candidate前加入pre-candidate状态，发起term不变的 预选举流程，成功后才将term++发起正式选主流程 Lease优化：  Leader与多数派断连主动降备，防止事实双主  在lease时间内不响应term更高的选主消息</p><p>复制流程</p><p>Client：日志复制线程</p><p>调接口，写 Buffer。每次写分配 idx。完事一致之后会有一个异步线程通知它已经多数派承认了，日志已提交。</p><p>进复制队列，工作线程会组包 + 压缩之类，传输到备机</p><p>备机收到后，会通过回放接口通知到数据库内核日志模块，去把日志replay一下。</p><p>日志采用全异步进行发送，不采用一问一答同步方式，提高系统整体吞吐量 Leader发送完一批log之后，直接更新next index，下次发送从这个点持续发送，不等follower响应回来； Follower等落盘线程写完一批log之后，将最新的落盘match_index发送给leader，持续反馈最新的落盘index； Leader通过这个来更新各节点的最新match_index，推进commit_index；</p><p>（多数派把一个Log落盘之后，一个事务就可以commit了）</p><p>总结：</p><p>一个备份级联，备到备是未来的方向。这是社区自己说的</p><p>一个是整体性能很强。AI 优化和多线程优化很猛。到处都是异步。</p><p>社区很活跃。</p><p>这次讲解也只是一点。以单机事务为主。分布事务讲得比较笼统。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI 课程报告草稿</title>
      <link href="/20221124-AI/"/>
      <url>/20221124-AI/</url>
      
        <content type="html"><![CDATA[<p>在感知技术的选择上，我们采用了 SLAM 的策略。SLAM 的概念是：同时进行自身定位与地图构建。因为在当下大多数无人驾驶的场景下，机器人事先并不会有关于地图的全部知识，需要在运动的过程中边建图边决策，并且在建图之后就可以运用旧有的地图知识进行导航而并不需要每一次都重新分析，减小了地图更新的代价。</p><p>SLAM 技术路线按照传感器分类有如下几种：</p><table><thead><tr><th>类型</th><th>适用场景</th><th>特点</th></tr></thead><tbody><tr><td>二维激光SLAM</td><td>室内</td><td>成本低</td></tr><tr><td>三维激光SLAM</td><td>室外</td><td>成本高、信息量较大</td></tr><tr><td>视觉SLAM</td><td>室内室外通用</td><td>信息量丰富</td></tr></tbody></table><p>激光 SLAM 比视觉 SLAM 起步早，在理论、技术与产品上都比较成熟。而视觉 SLAM 现在也有基于 RGBD 的深度摄像机，比如 Kinect。以及基于单目、双目和鱼眼摄像头的。其中 RGBD 深度摄像机具有信息量大的优势，我们可以额外借助颜色信息来判断位姿的变化以及选取参考点，可以更好地帮助我们进行场景相关的决策。另一方面，激光雷达的成本较高，而摄像头的成本就要低很多。</p><p>不过视觉 SLAM 也有一些缺点，一是受环境光的影响较大，在光线较暗的场景或无纹理的区域无法工作。并且运算负荷也比较大，另外在地图构建的时候还存在累计误差。为了解决这一问题，我们需要设计有回环检验的 SLAM 算法。于是我们选择 ORB3-SLAM 框架。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>夜里的故事</title>
      <link href="/20221123-tale/"/>
      <url>/20221123-tale/</url>
      
        <content type="html"><![CDATA[<p>我有点糊涂了，竟然在问她为什么如此相信我。我不能这么没有信心。这种冷不丁的话语很容易引起大家突然摸不着头脑，然后就寄了。</p><p>享受当下。</p><p>不过后来话题转到其他方面，转到家庭，又变成她说一些让我震惊的话，然后开始安慰我了。</p><p>人有自由意志吗？我们只是必然性的代理罢了。不过必然性说到底还是我自己的规定性。虽然说法不太一样，但我清楚她是明白这些的。</p><p>分离的结局有那么必然吗？我想不是。至少这个 eventually 的定义还有待发展。只要超越了大学这几年，我认为我很有机会挣脱家庭、传统婚姻的束缚，幸福地走下去。</p><p>不能老伤心吧。天天emo是会被讨厌的。</p><p>这几天有一些任务，大概梳理一下：</p><ul><li>论文报告。这个还有3页，差不多是一大堆要读。。</li><li>出一个项目。参考实现可以省一省</li><li>出AI的报告，wdnmd</li><li>做 opengauss 的报告。下周三讲</li></ul><p>三项就压在这几天。</p><p>不过我明天整完AI一些，带着出项目。后天先是比赛，晚上要出去做爱。</p><p>周六上午天文台，下午合唱团。周日可能去爬山。</p><p>那还做尼玛的报告？</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPL-Tetris</title>
      <link href="/20221121-Tetris/"/>
      <url>/20221121-Tetris/</url>
      
        <content type="html"><![CDATA[<p>题目描述</p><p>“俄罗斯方块”（Tetris）是一个经久不衰的小游戏。我们这就来做一个：</p><p>Tetra 是 4。我们做一个 Extended Edition</p><p>硬性要求：不做掉大分。</p><ul><li><p>掉落的方块，在原游戏基础上增加几种：</p><p>3方块的L 和 l, 5 方块的L。你可以在不影响可玩性的同时加点。</p></li><li><p>容纳方块大小至少为 12 列 16 行。自适应当前终端，如果不够，则不能启动。</p></li><li><p>使用方向键！方向键！方向键！实时控制方块旋转与下落，直到方块的下表面与已有方块接触，则刷出下一个方块</p></li><li><p>旋转前后，如果没有卡上游戏 tick （即向下掉落一格的时刻），方块的最下端高度不应变化</p></li><li><p>输入不合法的字符，不应使你的程序卡顿、崩溃、异常。</p></li><li><p>行填满必须消除。并计分。</p></li><li><p>屏幕内给出操控指示。支持暂停，重新开始等。</p></li></ul><p>软性：</p><ul><li><p>最好打印出较为标准的正方形。比如打印两个黑方块▇▇来组成一个。否则方块旋转后会<del>很丑</del></p></li><li><p>按下 方向下键 时方块速度增加</p></li><li><p>支持计分榜</p></li></ul><p>本实验选题不会奖励写图形界面的同学。如果图形界面有bug还可能导致多的扣分。</p><p>但命令行界面可以适当精致。</p><p>参考实现效果：Tilnel</p>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Time, Clocks, and the Ordering of Events in a Distributed System</title>
      <link href="/20221120-Lamport1978/"/>
      <url>/20221120-Lamport1978/</url>
      
        <content type="html"><![CDATA[<p>Lamport 原来是马萨诸塞的。</p><p>读文章的目标：搞清楚</p><ul><li>基本模型，基本假设：分布式系统的基本模型往往比较复杂。实际论文中的模型与课本中的模型<br>比，要精细地多。大家需要按照课上讲的框架，把论文中模型的各个纬度都讨论清楚。</li><li>基本问题：是否是经典问题。即使对于经典问题（e.g. consensus），也有很多的变体。把问题全<br>面认识清楚，与解决问题一样重要。对于一些不经典的问题，可以参照课上的学习，将问题全面<br>地认识清楚，解释清楚。</li><li>主要贡献：对于论文贡献的深入解释，往往是一个具体的模型、算法、分析技术。技术的细节不<br>是最重要的，简单copy原文更是大忌。课程看重的是，从课程中所学习的视角进行分析解读，进<br>行原理性的提炼、阐述等。另外，虽然我们是偏理论的课程，但是对于实现、实验、系统的解读<br>也是欢迎的，例如，系统设计、实现的背后，理论建模与分析是如何发挥指导性作用的，等等。</li></ul><p>分布式系统中的时间，时钟，和事件的序关系</p><p>前言</p><p>构造一个“事件发生在另一事件前”的偏序关系。</p><p>提出分布式算法，用以同步一个逻辑时钟系统，实现事件的全序。</p><p>使用一个解决同步问题的方法来刻画全序的作用。</p><p>然后提出一个同步物理时钟的算法特例，给出了时钟偏离同步的上界。</p><p>分布式系统中，时间不同步导致事件之间的序关系不确定。</p><p>我们讨论偏序，然后给一个算法来把偏序扩展成所有事件的满足consistency 的全序。这个算法就对我们实现分布式系统很有帮助。</p><p>之后呢我们会解决一个简单的同步问题，来展示它的用法。</p><p>意外的是，当算法给出的序和用户观察到的不一致的时候，不正常的行为就会发生。我们可以通过引入真实的物理时钟来避免这个问题。我们描述了一个简单的方法来同步这些时钟，并且求出了偏差的上界。</p><p>不用物理时间定义偏序，因为可能不准。</p><p>系统定义：</p><p>假设系统由一堆进程组成。每一个都是事件的序列。一个子程序可以是事件，一条机器指令也可以是时间。假设他们形成一个序关系，</p><blockquote><p>a occurs before b in this sequence if a happens before b</p></blockquote><p>单线程，就是一组事件的全序。</p><p>假设收发消息是一个事件，那么我们可以定义“发生在前”关系（happens before），denoted by <code>-&gt;</code></p><p>Def. The relation “-&gt;”, on the set of events of a system is the smallest relation satisfying the following three conditions:</p><p>(1) If a and b are events in the same process, and a comes before b, then a-&gt;b.</p><p>(2) If a is the sending of a message by one precess and b is the receipt of the same message by another process, then a-&gt;b.</p><p>(3) If a-&gt;b and b-&gt;c then a-&gt;c.</p><p>简单来说：线程内有序；同一消息的收发有序；传递性。</p><p>Concurrent iff not a-&gt;b and not b-&gt;a.</p><p>For all a, not a-&gt;a. Irreflexive</p><p>我们可以画时空图来表明这种序关系。</p><p>我们只考虑已经发送的消息，而不考虑可能将会发送的消息。这是更实际的。</p><p>现在我们引入逻辑时钟。其实就是给每个事件赋一个时间戳。</p><p>对每个进程Pi定义时钟Ci，它可以给进程中的每个事件都发一个时间戳。整个时钟系统就表示为一个函数 C，为事件产生时间数 C<b>.</b></p><p>C<b> &#x3D; Cj<b> 如果 b 是 Pj 的一个事件。现在我们并不对这个时间与物理时间进行关系的假设。所以我们只认为这是逻辑时钟。有可能只是个计数器。</b></b></p><p>现在我们考虑，这个系统的“正确性”到底是什么意思。</p><p>Clock Condition. For any events a, b:</p><p>​if a-&gt;b, then C<a>  &lt;  C<b></b></a></p><p>BUT Reverse not holds:</p><p>Suppose $C\langle a \rangle &lt; C\langle b\rangle \implies a\rightarrow b$</p><p>Then $\neg a\to b \implies \neg C\langle a\rangle &lt; C\langle b \rangle$</p><p>$Concurrence \iff \neg a\to b \and  \neg b\to a$</p><p>$\iff \neg C\langle a\rangle &lt; C\langle b\rangle\and \neg C\langle b\rangle &lt; C\langle a\rangle$</p><p>$\iff C\langle a\rangle &#x3D; C\langle b\rangle$</p><p>但是并发事件并不一定是同时进行。</p><p>时钟序成立，如果：</p><ul><li>C1. If $a$ and $b$ are events in process $P_i$, and $a$ comes before $b$, then $C_i\langle a\rangle &lt; C_i \langle b\rangle$.</li><li>C1. If $a$ is the sending of a message by process $P_i$ and $b$ is the receipt of that message by process $P_j$, then $C_i\langle a\rangle &lt; C_j\langle b\rangle$</li></ul><p>我们从时空图来考虑时钟。想象进程的时钟遍历每一个数字，每两个连续的事件之间都有（可能多次）“拨动”的操作。</p><p>然后对不同的线程，我们把它们相同的tick用虚线连起来。C1 就是说同线程中的两个事件之间必然有一条tick线。C2 则是说每一条消息线必须穿过一条 tick 线。</p><p>tick 线就是 笛卡尔 坐标系上的等时线（space-time）。我们把这玩意捋直了，这就表示了时间顺序了，还不用物理时钟。</p><p>这玩意你把它想象成三维的时空图也行。</p><p>假设线程是算法，事件代表其中的特定行为。</p><p>Pi 的时钟由一个寄存器 Ci 来代表，所以 Ci<a> 就是事件 a 时寄存器的值。寄存器会在事件之间改变，所以这个改变并不构成事件。</a></p><p>为了保证系统满足 Clock Condition，我们要确保 C1, C2。C1 很简单。线程只要遵守这个实现规则：（Implementation Rule）</p><p>IR1. Each process $P_i$ increments $C_i$ between any two successive events.</p><p>C2，我们需要每个消息 m 包含一个时间戳 Tm，为消息发出的时间。然后在收到以 Tm 标识的消息时，进程时钟必须跳到 Tm 以后。更准确的说：</p><p>IR2. (a) If event $a$ is the sending of a message $m$ by process $P_i$, then the message $m$ contains a timestamp $T_m &#x3D; C_i\langle a\rangle$.</p><p>(b) Upon receiving a message $m$, process $P_j$ sets $C_j$ greater than or equal to its present value and greater than $T_m$.</p><p>然后我们就可以排全序啦。</p><p>但是为了避免 ties，我们用一个任意的全序。我们定义关系 $\Rightarrow$:</p><p>if $a$ is an event in process $P_i$ and $b$ is an event in process $P_j$, then $a\Rightarrow b \iff (i) C_i\langle a\rangle &lt; C_j\langle b\rangle \or (ii)C_i\langle a\rangle &#x3D; C_j\langle b\rangle \and P_i \prec P_j$</p><p>什么意思呢？就是我们给线程随便指定一个优先级。然后遇到时间戳相同的事件，就按照他们的线程优先级来排事件的序。</p><p>我们用这玩意来构建一个满足</p><ul><li>互斥</li><li>先到先服务</li><li>Liveness</li></ul><p>的互斥资源请求算法。假设资源一开始已经分配给了一个进程。</p><p>这个并不简单。比如 P1 向 P0 请求后，向 P2 发一个消息。然后 P2 也向 P0 请求。第二个请求可能到的比一个早，这就 violation。</p><p>所以我们需要 IR1 + IR2 构造的一个时钟，来定义事件的全序。那么为了解决上述的问题，我们让每一个进程都了解到全局所有进程的操作。</p><p>简化问题，避免实现细节上的混乱，我们假设：</p><ul><li>固定两个进程之间单向的消息是按序到达的。</li><li>消息一定会送到。</li></ul><p>（我：现在TCP就很方便了。）</p><p>每个进程维护自己的<em>请求队列</em>，对其他进程不可见。一开始队列里存在一个 T0：P0 <em>requests resourse</em> ，即初始时的资源状态。T0比所有时钟都要小。</p><p>现提出5规则的算法，每条规则都包含于一个事件。</p><ol><li><p>请求资源， $P_i$ 发送 $T_m : P_i$ <em>requests resource</em> 给所有的其他进程，并且把这个消息放到自己的请求队列里。</p></li><li><p>$P_j$ 收到请求消息的时候，放到请求队列里，并返回一个带时间戳的 ACK （如果已经发了一个 &gt; Tm 的消息，则不用再返回）</p></li><li><p>释放资源，则从请求队列里弹出，并向其他所有人发送。</p></li><li><p>收到释放，则也弹出。</p></li><li><p>$P_i$ 在下列情况满足时获得资源</p><ul><li>在它自己的队列里，存在 $\Rightarrow$ 关系上的最小消息 $T_m : P_i$ <em>requests resource</em>. （消息的序就取决于其所在的事件的序）</li><li>$P_i$ 收到了所有人的比 $T_m$ 更晚的消息。</li></ul><p>上述两条都是 Thread Local 的条件</p></li></ol><p>这些东西加起来，肯定就满足了互斥、FCFS 和 Liveness。</p><p>5-2 结合按序到达性质，就保证了 $P_i$ 知道了自己的请求之前的所有请求。（我自己弄了一个两线程的实示例。实际上意思就是，假如双向消息的交付不按物理时间序，是交错的，后发消息的线程在另一个线程取得资源之前，是不会收到全部的回复的。也就保证了互斥。）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RAFT I - MIT 6.824</title>
      <link href="/20221118-RAFT/"/>
      <url>/20221118-RAFT/</url>
      
        <content type="html"><![CDATA[<p>Replication system.</p><p>A critical decision on who’s going to be primary?</p><ul><li>Single point failure</li></ul><p>real heart is put in a corner. single entity to decide</p><p>(or split brain)</p><p>Majority Vote</p><p>Irreflexive</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期安排和想法</title>
      <link href="/20221117-arrangement/"/>
      <url>/20221117-arrangement/</url>
      
        <content type="html"><![CDATA[<p>昨天还在这里写自己是试用期男友，现在就已经正式入职了。</p><p>感觉说了很多不得了的话呢。。呜呜</p><p>今天晚上要去答疑。</p><p>明天就去搞人工智能，后天就写写分布式的作业，以及分布式的作业。。。居然是两门</p><p>这两天需要穿插跳远之类的训练的。否则真烂完了。</p><p>邀请女朋友来看比赛吧？</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Primary Backup Replication</title>
      <link href="/20221116-PrimaryBackupReplication/"/>
      <url>/20221116-PrimaryBackupReplication/</url>
      
        <content type="html"><![CDATA[<p>Failures</p><p>​fail-stop failure</p><p>not covered: (software &#x2F; hardware) bugs, design defects.</p><p>Whether its worthwhile. –expensive. it’s an economic question</p><p>Ways of replica</p><p>State transfer</p><ul><li>Primary sends.</li></ul><p>Replicated state machine</p><ul><li><p>send external events. arriving Input. Operation from clients. (otherwise, the executions are deterministic function)</p></li><li><p>usually small</p></li><li><p>complicated. rely on sort of assumptions</p></li></ul><p>How to close sync if primary fails? </p><p>cut-over, anomalies</p><p>new replicas are hard to create.</p><p>What state to replicate?</p><p>application level replication if more efficient</p><p>level of machine? memory &amp; registers.</p><ul><li>downside: slow</li></ul><p>VMware FT</p><p> Non-deterministic-events</p><p>​Inputs-packet-date + interrupt</p><p>​    Weird instructions</p><p>​    Multicore</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>演戏</title>
      <link href="/20221103-daily/"/>
      <url>/20221103-daily/</url>
      
        <content type="html"><![CDATA[<p>生活一如既往地平淡如水。虽说享乐不是我们的主题，但是过于呆板也不好。</p><p>推完千晶线之后，虽然在上帝视角对于她本人一开始的态度并不能接受，但拥有精彩的演技其实是一件好事。偶尔有一些ooc的举动，或者从演技的角度来说，跳脱出自己原有的性格；或者是增强自己原有的性格。这些都是具有戏剧性的，从中我大概能获得平均以上的快感吧？</p><p>我觉得头脑里大概就要有这样的规划。既然大学这个阶段，人与人之间的连结是很少的， 不如在不同的人面前试图维持分裂的形象好了。其实以前也一直在做这样的事，但总是能保持微妙的平衡。矛盾的多面放到一起就非常合理。我不知道打破这样的平衡究竟是对是错，但是至少能给我的生活带来一些波澜，我觉得差不多就可以了。毕竟真正做到千晶那样是不可能的；毕竟我没有观众；毕竟我没有演对手戏的演员。</p><p>而总的来说，将要演的形象必须是正面的；为了保护自己的身心健康，也需要适当地分隔开人物的情感和自己的情感。这些都是理所当然的。</p><p>四季跟我说，他觉得千晶那种时刻在演的状态反而是最本真的。这里面的辩证关系我并不能理清楚。这学期的现代艺术表演课程中也提到过这样的问题，即我们日常生活当中的行为可不可以都将他们看作是一种表演。如果拿到一般的语境中，那么一般会被认为是过度解读。如果稍微接触到一点辩证法，则会采取一种模糊不清的解释方式。。我可能是意会了，但并不是很会。总之理论太难，我选择实践一下？</p><p>最近确实也有一些素材可以用。一是和小郝的交往，二是终于不用和李景荣、安禹赫这种人说话了。前者的要点在于如何饰演好有点害羞、有成熟的一面的大叔形象。后者一是维持好态度，不要没有条件地绷不住；二是处理和剩下的人之间的关系。</p><p>第一个就纯粹是看气氛吧。昨天晚上脑子一热把绝好的机会扔掉了。。（指随口就把唱歌这个剧情点给过掉了）。第二个，阿卞和波波，甚至盖伟业都好说。剩下的其实无所谓？然后在ljr面前绷住就好了。没啥事就保持微笑，别的没了。然后我也是真的真的不想再和谭森琪说话了。见到了就赶紧跑吧。</p><p>昨天晚上我想到了第一个任务点。正式地表述出来是，发一条动态，来展示我所有合理人格当中的公共部分。要求比较详细地说出自己当前的想法。并不需要是真实的自己，因为关于真实的自己，我并没有什么太好说的。</p><p>基础的设定可以灵活一点、甚至是离谱一点。</p><ul><li>被朋友包围的我感到幸福。即使并不互相理解</li><li>日常忙碌但没有不满。希望自己不要懒惰</li><li>比较实诚；甚至是nerd</li><li>语言要活泼一点，不要整得绝望了一样</li></ul><blockquote></blockquote><blockquote><p>想要干劲满满，但是下午看课的时候昏昏欲睡，没撑多久就去小睡了。醒来再继续的时候，发现之前我走神了好几分钟。人在电脑前面，但是什么都没听进去。</p><p>最近确实不是很有精神，所幸心情比较好。对于我来说，讲那么多，不如坐下来吃俩汉堡，啃只鸡，啥都好了，跟哥们出门就一个爽吃。任何语言和理解都显得单薄和多余。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GFS (MIT 6.824)</title>
      <link href="/20221103-GFS/"/>
      <url>/20221103-GFS/</url>
      
        <content type="html"><![CDATA[<p>Why is it hard? (Big store system)</p><p>Performance -&gt; Sharding -&gt; constant faults</p><p>Faults -&gt; fault tolerant systems</p><p>Tolerance -&gt; Replication</p><p>Replication -&gt; In consistency</p><p>Consistency -&gt; Low Performance</p><p>Consistency: like talking to one server</p><p>STRONG CONSISTENCY</p><p>Master - mapping : filename, and position</p><p>Chunk server 0</p><p>Chunk server 1</p><p>…</p><p>64MB per chunk</p><p>Master Data:</p><p>2 main tables:   (On ram)</p><ul><li><p>filename -&gt; array of chunk handles (nv)</p></li><li><p>chunk handles -&gt;list of chunk servers (v)</p><p>​version number (nv)</p><p>​                            primary (v)</p><p>​                            lease expiration (v)</p></li></ul><p>Will store some on disk</p><p>LOG, checkpoint(snapshot) - disk</p><p>n - not v - volatile</p><p>restart: recover to snapshot and replay LOG.</p><p>READ</p><ul><li><p>client send filename and offset to mcoinaster</p></li><li><p>master sends handle, list of servers</p><p>(cached. Next time, won’t ask master)</p></li><li><p>client -&gt; chunk servers: find the file</p><ul><li>&lt;- return the data</li></ul></li></ul><p>WRITES</p><p>if NO PRIMARY? - ON MASTER</p><p>find up to date replica (with version number)</p><p>pick primary and secondary</p><p>increment version number</p><p>tells primary, secondary the version number - lease</p><p>master write version number to disk</p><p>primary picks an offset</p><p>all replicas told to write at offset</p><p>if all “yes”, primary “success” -&gt; client</p><p>else “no” -&gt; client, and client reissue</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>稍微注意一下皮肤，谢谢。。</title>
      <link href="/20221101-misc/"/>
      <url>/20221101-misc/</url>
      
        <content type="html"><![CDATA[<p> 脓包、囊肿型痤疮：维A酸，异维A酸，阿达帕林（抑制炎症反应）</p><p>克林霉素磷酸酯、夫西地酸乳膏、过氧化苯甲酰（杀灭痤疮丙酸杆菌）</p><p>保湿，油性皮肤：薇诺娜、芙丽芳丝、倩碧、瑷尔博士</p><p>瑷尔博士微晶水</p><p><img src="image-20221101112606462.png" alt="image-20221101112606462"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC and Threads (MIT 6.824)</title>
      <link href="/20221030-RPCandThreads/"/>
      <url>/20221030-RPCandThreads/</url>
      
        <content type="html"><![CDATA[<p><em>Effective Go</em></p><p>Remote Procedure Call</p><p>Why is thread so important?</p><p>I&#x2F;O concurrency.  Allowing activities waiting and proceeding</p><p>Parallelism. Use all of the cores on your machine</p><p>Convenience. Daemon thread.</p><ul><li>fire a goroutine and send heartbeat pack</li></ul><p>OR event-driven programming. (Asyncronous)</p><p>One problem with the scheme is that is a little bit pain to program.</p><p>And it’s not parallelized.</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Buffer Pools (CMU DataBase Systems 2019 fall)</title>
      <link href="/20221030-BufferPools/"/>
      <url>/20221030-BufferPools/</url>
      
        <content type="html"><![CDATA[<p>DATABASE WORKLOADS</p><p>On-Line Transaction Processing</p><p>On-Line Analytical Processing</p><p>Hybrid Transaction + Analytical Processing</p><p>Spacial control: </p><ul><li>Where to write pages on disk</li><li>The goal is to keep pages that are used together often as physically close together as possible on disk.</li></ul><p>Temporal Control:</p><ul><li>When to read pages to memory, and when to write them to disk.</li><li>The goal is minimize the number of stalls from having to read data from disk.</li></ul><p>TODAY’S AGENDA</p><p>Buffer Pool Manager</p><p>Replacement Policies</p><p>Other Memory Pools</p><p>Memory region organized as an array of fixed-size pages.</p><p>An array entry is called a frame.</p><p>when the DBMS requests a page, an exact copy is places into one of these frame.</p><p>The page table keeps track of pages that are currently in memory</p><p>Also maintains additional meta-data per page:</p><ul><li>Dirty Flag</li><li>Pin&#x2F;Reference Counter</li></ul><p>Locks vs Latches</p><p>Locks:</p><ul><li>Protects the database’s logical contents from other transactions.</li><li>Held for transaction duration.</li><li>Need to be able to rollback changes.</li></ul><p>Latches:   –mutex</p><ul><li>Protects the critical sections of the DBMS’s internal data structure from other threads.</li><li>Held for operation duration.</li><li>Do not need to be able to rollback changes.</li></ul><p>SCAN SHARING</p><p>Queries can reuse data retrieved from storage or operator computations.</p><ul><li>This is different from result caching.</li></ul><p>Allow multiple queries to attach to a single cursor that scans a table.</p><ul><li>Queries do not have to be exactly the same.</li><li>Can also share intermediate results.</li></ul><p>Buffer Replacement Policies</p><ul><li>Least-recently used: Maintain a timestamp of when each page was last accessed</li><li>Clock<ul><li>Approximation of LRU without needing a separate timestamp per page<ul><li>Each Page has a reference bit</li><li>When a page is accessed, set to 1</li></ul></li><li>Organize the pages in a circular buffer with a “clock hand”:<ul><li>Upon sweeping, check if a page’s bit is set to 1.</li><li>If yes, set to zero. If no, then evict.</li></ul></li></ul></li></ul><p>Problems</p><p>LRU and CLOCK replacement policies are susceptible to sequential flooding.</p><ul><li>A query preforms a sequential scan that reads every page.</li><li>This pollutes the buffer pool with pages that are read once and then never again.</li></ul><p>The most recently used page is actually the most unneeded page.</p><p>Better Policies: LRU-K</p><p>Track the history of last K references to each page as timestamps and compute the interval between subsequent accesses.</p><p>The DBMS then uses this history to estimate the next time that page is going to be accessed.</p><p>Better Polices: Localization</p><p>The DBMS chooses which pages to evict on a per txn&#x2F;query basis. This minimizes the pollution of the buffer pool from each query.</p><ul><li>Keep track of the pages that a query has accessed.</li></ul><p>Example: Postgres maintains a small ring buffer that is private to the query.</p><p>Better Policies: Priority Hints</p><p>The  DBMS knows that the context of each page during query execution.</p><p>It can provide hints to the buffer pool on whether a page is important or not.</p><p>DIRTY PAGES</p><p>Fast: If a page in the buffer pool is not dirty, then the DBMS can simply “drop” it.</p><p>SLOW: I f a page is dirty , then the DBMS must write back to disk to ensure that its changes are persisted.</p><p>Trade-off between fast evictions versus dirty writing pages that will not be read again in the future.</p><p>BACKGROUND WRITING</p><p>The DBMS can periodically walk through the page table and write dirty pages to disk.</p><p>when a dirty page is safely written, the DBMS can either evict the page or just unset the dirty flag.</p><p>Need to be careful that we don’t write dirty pages before their log records have been written.</p><p>CONCLUSION</p><p>The DBMS can manage that sweet, sweet memory better then the OS.</p><p>Leverage the semantics about the  query plan to make better decisions:</p><ul><li>Evictions</li><li>Allocations</li><li>Pre-fetching</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Database Storage II (CMU Database Systems 2019 Fall)</title>
      <link href="/20221030-DatabaseStorageII/"/>
      <url>/20221030-DatabaseStorageII/</url>
      
        <content type="html"><![CDATA[<p>Log&#x3D;structured file organization</p><p>Instead of storing tuples in pages , the DBMS only stores log records.</p><p>The system appends log records to the file of how the database was modified:</p><ul><li>inserts store the entire tuple</li><li>Deletes mark the tuple as deleted</li><li>Updates contain the delta of just the attributes that were modified</li></ul><p>why?</p><ul><li>easy to roll   back</li><li>fast</li></ul><p>Obvious downside: reads…</p><p>To read a record, the DBMS scans the log backwards and “recreates” the tuple to find what it needs.</p><p>Build indexed to allow it to jump to locations in the log</p><p>Periodically compact the log.</p><p>Today’s agenda</p><ul><li>Data representation</li><li>system catalogs</li><li>storage models</li></ul><p>Tuple storage</p><p>The DBMS’s catalogs contain the schema information about tables that the system uses to figure out the tuple’s layout.</p><p>INTEGER&#x2F;BIGINT&#x2F;SMALLINT&#x2F;TINYINT</p><ul><li>C&#x2F;C++ Representation</li></ul><p>FLOAT&#x2F;REAL vs. NUMERIC&#x2F;DECIMAL</p><ul><li>IEEE-754 STANDARD &#x2F; Fixed-point Decimals</li></ul><p>VARCHAR&#x2F;VARBINARY&#x2F;TEXT&#x2F;BLOB</p><ul><li>Header with length, followed by data bytes.</li></ul><p>TIME&#x2F;DATE&#x2F;TIMESTAMP</p><ul><li>32&#x2F;64-bit integer of (micro)seconds since Unix epoch</li></ul><p>Fixed precision numbers</p><p>Numeric data types with arbitrary precision and scale. Used when round errors are unacceptable.</p><ul><li>Example: NUMERIC, DECIMAL</li></ul><p>Typically stored in a exact, variable-length binary representation with additional meta-data</p><ul><li>like a varchar but not stored as a string</li></ul><p>Large Values</p><p>Most DBMSs don’t allow a tuple to exceed the size of a single page.</p><p>To store values that are larger than a page, the DBMS uses separate overflow storage pages.</p><ul><li>Postgres: TOAST( &gt; 2 KB)</li><li>MySQL: Overflow (&gt; 1&#x2F;2 size of page)</li><li>SQL Server: Overflow( &gt; size of page)</li></ul><p>To BLOB or Not To BLOB: Large Object Storage in a Database of a Filesystem?</p><p>256 KiB seems to be a division</p><p>System Catalogs</p><p>A DBMS stores meta-data about database in its internal catalogs</p><p>-Tables, columns, indexed, views</p><p>Users, permissions</p><p>Internal statistics</p><p>Almost every DBMS stores their a database’s catalog in itself.</p><ul><li>Wrap object abstraction around tuples</li><li>Specialized code for “bootstrapping” catalog tables.</li></ul><p>You can query the DBMS’s internal INFORMATION_SCHEMA catalog to get info about the database.</p><ul><li>ANSI standard stet of read-only views that provide info about all of the tables, views, columns, and procedures in a database.</li></ul><p>DBMSs also have non-standard shortcuts to retrieve this information.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELSCT <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> table_catalog <span class="operator">=</span> <span class="string">&#x27;&lt;db name&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight postgres"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">DESC &lt;table name&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.schema &lt;table name&gt;;</span><br></pre></td></tr></table></figure><p>observation</p><p>The relational model does not specify that we have to store all of a tuple’s attributes together in a single page.</p><p>This may not actually be the best layout for some workloads…</p><p>OLTP</p><p>Online Transaction Processing:</p><ul><li>Simple queries that read &#x2F; update a small amount of data that is related to a single entity in the database.</li></ul><p>This is usually the kind of application that people build first.</p><p>OLAP</p><p>Online Analytical Processing</p><ul><li>Complex queries that read large portions of the database spanning multiple entities</li><li>You execute these workloads on the data you have collected from your OLTP applications(s).</li></ul><p>N-ARY STORAGE MODEL</p><p>Advantages</p><ul><li>Fast inserts, updates, and deletes.</li><li>Good for queries that need the entire tuple.</li></ul><p>disadvantages</p><ul><li>Not good for scanning large portions of the table and &#x2F; or a subset of the atreibutes.&#x2F;</li></ul><p>DECOMPOSITION STORAGE MODEL(DSM)</p><p>The DBMS stores the values of a single attribute for all tuples contiguously in a page</p><ul><li>Also known as a “column store”.</li></ul><p>Tuple Identification</p><p>Choice #1: fixed-length Offsets</p><ul><li>Each value is the same length for an attribute</li></ul><p>Choice #2: Embedded Tuple Ids</p><ul><li>Each value is stored with its tuple id in a column</li></ul><p>Advantages</p><ul><li>Reduces the amount wasted I&#x2F;O because the DBMS only reads the data that it needs</li><li>Better query processing and data compression (more on this later)</li></ul><p>Disadvantages</p><ul><li>slow for point queries, inserts, updates, and deletes because of tuple splitting&#x2F;stitching</li></ul><p>CONCLUSION</p><p>The storage manager is not entirely independent from the rest of the DBMS.</p><p>It is important to choose the right storage model for the target workload:</p><ul><li>OLTP &#x3D; Row Store</li><li>OLAP &#x3D; Column Store</li></ul><p>![](20221030-DatabaseStorageII.assets&#x2F;屏幕截图 2022-10-30 185728.png)</p><p>Next:</p><ul><li>How the DBMS manages its memory and move data back-and-forth from disk</li></ul><p>MIX OF TWO? engineering overhead too much</p><p>hybrid storage systems</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PXE</title>
      <link href="/20221027-PXE/"/>
      <url>/20221027-PXE/</url>
      
        <content type="html"><![CDATA[<p>Environment:</p><p>Host: Ubuntu 20.04.1, Oracle VM VirtualBox Manager</p><p>第一步，创建一个虚拟机</p><p><code>vboxmanage</code> 没什么好说的，读文档</p><p>首先要创建一个 natnetwork</p><p>然后根据 build.sh 的参数决定虚拟机的名称。创建虚拟磁盘并加载</p><p>第二步，准备 PXE 启动环境</p><p>首先搭一个 tftp 服务器，在里面准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pxelinux.0</span><br><span class="line">pxelinux.cfg/default</span><br><span class="line">jammy/vmlinuz</span><br><span class="line">jammy/initrd</span><br><span class="line">jammy/meta-data</span><br><span class="line">jammy/user-data</span><br></pre></td></tr></table></figure><p>挂一个 http 服务器，在里面准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu.iso</span><br><span class="line">ssh/id_rsa</span><br><span class="line">ssh/id_rsa.pub</span><br><span class="line">id.conf   # 返回机器编号的 nginx configuration</span><br></pre></td></tr></table></figure><p>问题一，我在 Ubuntu 20.04.3 上 <code>apt download pxelinux</code> 解包得到的 <code>pxelinux.0</code> 6.0.4，在 PXE 启动后就中止了，界面停留在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PXELINUX 6.04 PXE 20190223 Copyright (C) 1994-2014 H. Peter Anvin et al</span><br></pre></td></tr></table></figure><p>既不运行，也不报错。无论我如何写 .cfg，也没有用。在经过几小时的反复横跳后，我从 mirror 上随便找了一个 6.03，顺利启动了。。。</p><p>为了让每台机器配置的时候带上自己的机器编号（如 ip 配置所需要的），我把 tftp 服务器下的目录结构又改了一下：</p><p><img src="image-20221028174547322.png" alt="image-20221028174547322"></p><p>每个 vm-id 目录都是在 build.sh id 运行时自动生成。共用的文件用硬链接（tftp不识别软链接），需要修改的配置文件，用一个变量名把需要修改的地方标注，然后用 <code>sed</code> 替换为与各自的 id 相关的字符串。</p><p>自动安装的 user-data，主要是配置 hostname, username, password, ssh 等。以及安装后需要执行的命令。这里用 <code>echo</code> 创建了 systemd service，以及开机自动执行的脚本。</p><p>开机配置 ip 和 ssh 的公私钥，通过 <code>systemd</code> 执行一个脚本。</p><p>返回机器 id 的 http 服务器，我安装了 <code>nginx</code> 。配置文件在自动安装时用 <code>wget</code> 获取了。</p><p><img src="image-20221028180406208.png" alt="image-20221028180406208"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Distributed Algorithm - Partially ordered set and lattice - and applications in Distributed System</title>
      <link href="/20221027-Distrigute_Algorithm_setandlattice/"/>
      <url>/20221027-Distrigute_Algorithm_setandlattice/</url>
      
        <content type="html"><![CDATA[<p>Outline</p><ul><li><p>Partially Ordered Set</p></li><li><p>Lattice</p></li><li><p>Boolean Algebra</p></li><li><p>Global Snapshot Lattice</p></li><li><p>Consistency Model Lattice</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10-27 所想</title>
      <link href="/20221027-daily/"/>
      <url>/20221027-daily/</url>
      
        <content type="html"><![CDATA[<p>最近好像变得很有时间写这一类东西了。。也不是，就是想起来了。倾诉的欲望正在高涨，然而翻翻好友列表，却不会有合适的人选。这到底是因为什么呢？</p><p>昨天实在是忍不了了，在小群里打了个QQ电话，稍微交流了一下。但是作用也不大，因为想要说的不是完全没能说出去嘛。</p><p>最近白学病又犯了，起初好像是为了探寻一下春希作为一个工作狂，到底是为什么能一直不累、一直有动力的。然后又想要借此机会了解一下千晶线。But 在推完了千晶 NE 之后，我的内心实在是不能平静，催促着我去把千晶 TE 也看一看。这下就又花了大把的时间了，昨天晚上一直玩到28点半。。嗯。。。</p><p>其实本来是想集中处理千晶线的，谁知道中间碰到了一个有趣的二连选项。我就是好奇了一下，在这种情况下，我都选一遍的话会发生什么事。</p><p>所以还是进了一次小春线。</p><p>回到千晶，我推到了千晶和雪菜以真是身份友好交流的那一部分。当下的我认为，千晶至少对于春希是一个迷人的女性。但站在玩家的上帝视角来说，并不容易自然地接受这样的一个角色。春希是善良的，出了什么问题都会认为是自己的责任，但我不是。如果我是当事人，也许我。。。就不了了之了。但我是玩家，我很想看看丸户会怎么把春希的情感裂缝给缝合上。</p><p>要上课了，一会儿再回来写。。</p><p>说是这样，其实一整节课都睡过去了呢。。。睡得太少，精神太差。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>行动起来</title>
      <link href="/20221025-Daily/"/>
      <url>/20221025-Daily/</url>
      
        <content type="html"><![CDATA[<p>看了一节数据库系统和一节分布式。今天总算是没有浪费时间。</p><p>接下来要把 MapReduce 理解好，并且做了实验才行。</p><p>虽然我不是党员，但是二十大开完之后我的精神依然为之一振。今年习总应该是69岁，依然奋斗在重要的岗位上。并且从常委的名单来看，接下来的五年将会是剧变的五年。</p><p>那么，就更不能懈怠了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction (MIT 6.824)</title>
      <link href="/20221025-Introduction%20(MIT%206.824)/"/>
      <url>/20221025-Introduction%20(MIT%206.824)/</url>
      
        <content type="html"><![CDATA[<p>Why?</p><p>parallelism</p><p>fault tolerance</p><p>physical reasons</p><p>security goals &#x2F; isolated</p><p><strong>challenges</strong></p><ul><li><p>concurrency</p></li><li><p>partial failure</p></li><li><p>performance</p></li></ul><p>Infrastructure - Abstractions</p><ul><li>Storage</li><li>Communication   more: 6.829</li><li>Computation</li></ul><p>Implementation</p><ul><li>RPC, threads, concurrency control</li></ul><p>Performance</p><p>scalability</p><ul><li>2x computers -&gt; 2x throughput</li></ul><p>Fault Tolerance</p><p>Single Computer can stay up for years</p><p>Scale turns small problem into constant problems. There’s always failures</p><ul><li>Availability<ul><li>keep operating while failure happens</li></ul></li><li>Recoverability</li></ul><p>Consistency</p><p>K-V db</p><p> Put(k, v)  Get(k)-&gt;v</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>consider: word count</p><p>INPUT 1 -&gt; Map -&gt; (a, 1), (b, 1)</p><p>INPUT 2 -&gt; Map -&gt; (b, 1)</p><p>INPUT 3 -&gt; Map -&gt; (a, 1), (c, 1)</p><p>(a, 1), (a, 1) -&gt; Reduce -&gt; a, 2</p><p>…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map(k, v)</span><br><span class="line">  split v into words</span><br><span class="line">  for each word w</span><br><span class="line">  emit(w, &quot;1&quot;)</span><br><span class="line">Reduce(k, v)</span><br><span class="line">  emit(len(v))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Database Storage I (CMU Databases Systems Fall 2019)</title>
      <link href="/20221024-DatabseStorage/"/>
      <url>/20221024-DatabseStorage/</url>
      
        <content type="html"><![CDATA[<p>Query Planning</p><p>Operator Execution</p><p>access Methods</p><p>Buffer Pool Manager</p><p>Disk Manager</p><p>The DBMS’s assumes that the primary storage location of the database is on non-volatile disk.</p><p>The DBMS’s components manage the movement of data between non-volatile and volatile storage.</p><p>Storage hierarchy</p><ul><li>cpu registers</li><li>cpu caches </li><li>dram   &#x2F;&#x2F; Volatile: need contant power</li><li>ssd   &#x2F;&#x2F; Non-Volatile  </li><li>hdd</li><li>network storage</li></ul><p>Intel Optane : Non-Volatile Memory</p><ul><li>Is the future</li><li>not widely available</li></ul><p>System Design Goals</p><p>Allow the DBMS to manage databases that exceed the amount of memory available.</p><p>Reading&#x2F;writing to disk is expansive, so it must be managed carefully to avoid large stall and performance degradation.</p><p>Why not use the os? </p><ul><li>One can use memory mapping(mmap) to store the contents of a file into a  process’ address space</li><li>The OS is responsible for moving data for moving the files’ pages in and out of memory</li></ul><p>What if we allow multiple threads to access the mmap files to hide page fault stalls?</p><p>This works good enough for read-only address. It is complicated when there are multiple writers.</p><p>There are some solutions to this problem:</p><p>madvise: Tell the os how you expect to read certain pages</p><p>mlock: tell the os that memory ranges cannot be paged out</p><p>msync: tell the os to flush memory ranges out to disk</p><p>DBMS (almost) always wants to control things itself and can do a better job at it</p><p>-&gt; flushing dirty pages to disk in the correct order</p><p>-&gt; specialized prefetching</p><p>-&gt; Buffer replacement policy</p><p>-&gt; thread&#x2F;process scheduling</p><p>The OS is <strong>NOT</strong> your friend</p><p>Problem #1: How the DBMS represents the database in files on disk.  &lt;– this lecture</p><p>Problem #2: How the DBMS manages its memory and move back-and-forth from disk</p><h2 id="TODAY’S-AGENDA"><a href="#TODAY’S-AGENDA" class="headerlink" title="TODAY’S AGENDA"></a>TODAY’S AGENDA</h2><p>File Storage</p><p>Page Layout</p><p>Tuple Layout</p><p>The DBMS stores a database as one or more files on disk.</p><ul><li>The OS doesn’t know anything about the contents of these files.</li></ul><p>Different DBMS manage pages in files on disk in different ways</p><ul><li>Heap file organization</li></ul><p>A heap file is an unordered collection of pages where tuples that are stored in random order</p><ul><li>Create&#x2F;Get&#x2F;Write&#x2F;Delete Page</li><li>Must also support iterating over all pages</li></ul><p>Need meta-data to keep track of what pages exist and which ones have free space.</p><ul><li>Linked List</li><li>Page Directory</li></ul><p>The DBMS maintains special pages that tracks the location of data pages in the database files.</p><p>The directory also records the number of free slots per page.</p><p>The DBMS has to make sure that the directory pages are in sync with the data pages.</p><p>Page Layout</p><p>![](20221024-DatabseStorage.assets&#x2F;屏幕截图 2022-10-25 150909.png)</p><p>Tuple Layout</p><p>![](20221024-DatabseStorage.assets&#x2F;屏幕截图 2022-10-25 151039.png)</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Transaction Information System - Chapter 01</title>
      <link href="/20221010-txn-chapter1/"/>
      <url>/20221010-txn-chapter1/</url>
      
        <content type="html"><![CDATA[<p>Foreword</p><p>This book unifies <strong>concurrency control</strong> and <strong>recovery for both the page and object models</strong></p><p>It is likely to become the standard reference in out field for many years to come.</p><p>Preface</p><blockquote><p>Teamwork is essential. It allows you to blame someone else.  –Anonymous (kusa)</p></blockquote><p>Book’s Mission</p><p>For 3 decades transaction procession has been a cornerstone of modern information technology: it is an indispensable asset in banking, stock trading, airlines, travel agencies, and so on.</p><p>Fortunately, the success of the transaction concept does not solely rely on clever system inplementations, but builds on and leverages scientifically rigorous foundations that have been developed in the research community.</p><p>For above reason this book emphasizes scientific fundamentals of long-term validity and value, and does not cover specific system products, which tend to become quickly outdated.</p><h5 id="Organizations"><a href="#Organizations" class="headerlink" title="Organizations"></a>Organizations</h5><p>The two key components of a transaction information system are <strong>concurrency control</strong>, to ensure the correctness of data when many clients simultaneously access shared data, and <strong>recovery</strong>, to protect the data against system failures.</p><p>In addition, the <em>coordination of distributed transactions</em> becomes a vital issue that will be covered in Part IV.</p><h1 id="Chapter-1-What-Is-It-All-About"><a href="#Chapter-1-What-Is-It-All-About" class="headerlink" title="Chapter 1. What Is It All About?"></a>Chapter 1. What Is It All About?</h1><blockquote><p>If I had had more time, I could have written you a shorter letter.</p></blockquote><blockquote><p>There are two mistakes one can make along the road to truth–not going all the way, and not starting. –Buddha</p></blockquote><ul><li>Why transactions are a good idea</li><li>Why transactions form a reasonable abstraction concept for certain classes of real-life data management and related problems</li><li>What can and what cannot be done with the transaction concept</li></ul><p><em>Online transaction processing, OLTP</em></p><p>The key problem that the transaction concept solves in a very elegant way is to cope tith the subtle and often difficult issues of keeping data consistent even in the presence of highly cuncurrent data accesses and despite all sorts of failures.</p><p>An additional key property of transactions is that this is achieved in a generic way that is essentially invisible to the application logic (and to application development), so that application developers are completely freed from the burden of dealing ith such system issues. This is why transactions are an <em>abstract concept</em>, and why this concept is a cornerstone of modern information technology.</p><p>Database System is the most important concrete instantiation of a transactional data server.</p><p>Conceptual properties of a transaction–namely, atomicity, durability, and isolation–together provide the key abstraction that allows application developers to disregard concurrency and failures, yet the transactional server guarantees the consistency of the underlying data and ultimately the correctness of the application.</p>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Advanced SQL (CMU Databases Systems Fall 2019)</title>
      <link href="/20220925-AdvancedSQL/"/>
      <url>/20220925-AdvancedSQL/</url>
      
        <content type="html"><![CDATA[<p>Relational Languages</p><ul><li>User only needs to specify the answer that they want, not how to compute it.</li><li>The DBMS is responsible for efficient evaluation of the query.<ul><li>Query optimizer: re-orders operations and generates query plan</li></ul></li></ul><p>Originally SEQUEL from IBM’s System R prototype</p><ul><li>Structured English Query Language</li></ul><p>IBM releases DB2 in 1983</p><p>ANSI Standard in 1986. ISO in 1987</p><ul><li>Structured Query Language</li></ul><p>Important: SQL is base on bags (duplicates)</p><p>Aggregations + Group By</p><p>String &#x2F; Date &#x2F; Time Operations</p><p>Output Control + Redirection</p><p>Nested Queries</p><p>Common Table Expressions</p><p>Window Functions</p><p>Aggregates</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVG</span>(col)</span><br><span class="line"><span class="built_in">MIN</span>(col)</span><br><span class="line"><span class="built_in">MAX</span>(col)</span><br><span class="line"><span class="built_in">SUM</span>(col)</span><br><span class="line"><span class="built_in">COUNT</span>(col)</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(login) <span class="keyword">as</span> cnt</span><br><span class="line">  <span class="keyword">from</span> student <span class="keyword">where</span> login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="operator">/</span><span class="operator">/</span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> cnt</span><br><span class="line">  <span class="keyword">from</span> student whare login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line">  </span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> <span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line">  <span class="keyword">from</span> student whare login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(s.gpa), e.cid</span><br><span class="line">  <span class="keyword">from</span> enrolled <span class="keyword">as</span> e, student <span class="keyword">as</span> s</span><br><span class="line"> <span class="keyword">where</span> e.sid <span class="operator">=</span> s.sid</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> e.cid</span><br></pre></td></tr></table></figure><p>Non-aggregated values in SELECT output clause must appear in GROUP BY clause</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">not</span> aggr<span class="string">&#x27;d yet</span></span><br><span class="line"><span class="string">select avg(s.gpa) as avg_gpa, e.cid</span></span><br><span class="line"><span class="string">from enrolled as e, student as s</span></span><br><span class="line"><span class="string">where e.sid = sid</span></span><br><span class="line"><span class="string">and avg_gpa &gt; 3.9</span></span><br><span class="line"><span class="string">group by e.cid</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># right</span></span><br><span class="line"><span class="string">select avg(s.gpa) as avg_gpa, e.cid</span></span><br><span class="line"><span class="string">from enrolled as e, student as s</span></span><br><span class="line"><span class="string">where e.sid = sid</span></span><br><span class="line"><span class="string">group by e.cid</span></span><br><span class="line"><span class="string">having avg_gpa &gt; 3.9</span></span><br></pre></td></tr></table></figure><p>Strings</p><p>all strings have to be case sensitive and declared with single quotes ‘’</p><p>sqlite: “” is ok </p><p>mysql is case insensitive</p><p>Like is used for stirng matching.String-matching operators</p><ul><li>‘%’ Matches any substring (including empty strings.)</li><li>‘_’ Match any one character</li></ul><p>SQL-92 defines string functins</p><ul><li>Many DBMSs also have theri onw unique functions</li></ul><p>Can be used ineither output and predicxates</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UBSTRING(name, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">UPPER</span>(e.name)</span><br></pre></td></tr></table></figure><p>SQL standartd says to use || operator to concatenate two or ,more stirng together.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;an&#x27; &#x27;dy &#x27; &#x27;pavlo&#x27;;</span><br><span class="line">&gt; andy pavlo  # only mysql</span><br></pre></td></tr></table></figure><p>Date &#x2F; Time operations</p><ul><li>operations to manipulate and mudify date &#x2F; time attributes.</li><li>Can be used in either output and predicates</li><li>Spport &#x2F; syntax varies wildly…</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select NOW();  # current timestamp</span><br><span class="line">select current_timestamp();</span><br><span class="line">select current_timestamp;</span><br></pre></td></tr></table></figure><p>sqlite: no such function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select current_timestamp;  # keyword</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> extract <span class="keyword">day</span>(<span class="keyword">day</span> <span class="keyword">from</span> <span class="type">date</span>(‘<span class="number">2018</span><span class="number">-08</span><span class="number">-29</span><span class="string">&#x27;));  # only pavlo</span></span><br><span class="line"><span class="string">select date(&#x27;</span><span class="number">2919</span><span class="number">-08</span><span class="number">-29</span><span class="string">&#x27;) - date(&#x27;</span><span class="number">2018</span><span class="number">-01</span><span class="number">-01</span><span class="string">&#x27;) as days;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">select round((unix_timestamp(date()) - unix_timestamp(date())) / (60 * 60 * 24), 0) as days</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sqlite</span><br><span class="line">select cast((julianday(current_timestamp) - julianday(&#x27;2018-01-01&#x27;)) as int) as days;</span><br></pre></td></tr></table></figure><p>!!! but sqlite is the most popular</p><p>Photoshop runs sqlite inside</p><p>cause there is no copyright on sqlite. But oracle has mysql</p><p>Output redirection</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">into</span> courseids</span><br><span class="line">  <span class="keyword">from</span> enrolled;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> courseids (</span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> enrolled);</span><br></pre></td></tr></table></figure><p>Don’t take it out for me. Write it to this table.</p><p>Insert tuplesfrom query into another table:</p><ul><li>Inner select must generatge the same columns as the target table.</li><li>dbmss have different options &#x2F; syntax on what to do with duplicates.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> courseids</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> enrolled);</span><br></pre></td></tr></table></figure><p>(implements will vary widely)</p><p>Output control</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, grade <span class="keyword">from</span> enrolled</span><br><span class="line">  <span class="keyword">where</span> cid <span class="operator">=</span> <span class="string">&#x27;15-721&#x27;</span></span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> grade;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line"> whhere cid <span class="operator">=</span> <span class="string">&#x27;15-721&#x27;</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> grade <span class="keyword">desc</span>, sid <span class="keyword">asc</span>;   # grade <span class="keyword">not</span> <span class="keyword">in</span> input but OK</span><br></pre></td></tr></table></figure><p>LIMIT <count> [offset]</count></p><ul><li>limit the # of tuples returned in output.</li><li>can set an offset rto return a “range”</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line"> limit <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> login <span class="keyword">like</span> <span class="string">&#x27;%@cs&#x27;</span></span><br><span class="line"> limit <span class="number">20</span> <span class="keyword">offset</span> <span class="number">10</span>;    # pagination</span><br></pre></td></tr></table></figure><p>Nested queries</p><ul><li>Queries containing other queries</li><li>They are often difficult to optimize.</li><li>Inner queries can appear (almost)anywhere in query.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> student <span class="keyword">where</span></span><br><span class="line"> sid <span class="keyword">in</span> (<span class="keyword">select</span> sid <span class="keyword">from</span> enrolled);</span><br></pre></td></tr></table></figure><p>WHERE</p><ul><li><p>ALL</p></li><li><p>ANY</p></li><li><p>IN</p></li><li><p>EXISTS</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> student </span><br><span class="line">whiere sid <span class="operator">=</span> <span class="keyword">any</span>(</span><br><span class="line"><span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line"><span class="keyword">where</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> s.name <span class="keyword">from</span> stucent <span class="keyword">as</span> s</span><br><span class="line">         <span class="keyword">where</span> s.sid <span class="operator">=</span> e.sid) <span class="keyword">as</span> sname</span><br><span class="line">  <span class="keyword">from</span> enrolled <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">where</span> cid <span class="operator">=</span> <span class="string">&#x27;15-445&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> sid <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">all</span>(</span><br><span class="line">  <span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line">);</span><br><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> sid <span class="keyword">in</span> (</span><br><span class="line">  <span class="keyword">select</span> <span class="built_in">max</span>(sid) <span class="keyword">from</span> enrolled</span><br><span class="line">);</span><br><span class="line"><span class="keyword">select</span> sid, name <span class="keyword">from</span> student</span><br><span class="line"> <span class="keyword">where</span> sid <span class="keyword">in</span> (</span><br><span class="line">  <span class="keyword">select</span> sid <span class="keyword">from</span> enrolled</span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span> sid <span class="keyword">desc</span> limit <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>find all coursed that has no students enrolled in it.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> enrolled</span><br><span class="line">  <span class="keyword">where</span> course.cid <span class="operator">=</span> enrolled.cid</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>window functions</p><ul><li>Performs a calculation across a set of tuples that related to a single row.</li><li>Like an aggregation but tuples are not grouped into a single output tuples.</li></ul><p>Special window functions:</p><ul><li>row_number() -&gt; # of the current row</li><li>rank() -&gt; order position of the current row</li></ul><p>The over keyword specifies how to group together tuples when computing the window function.</p><p>Use partition by to specify group</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select cid, sid,</span><br><span class="line">  row_number() over (partition by sid)</span><br><span class="line"> from enrolled</span><br><span class="line">order by cid;</span><br></pre></td></tr></table></figure><p>Find the student with the highest grade fro each course.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> cid</span><br><span class="line">                <span class="keyword">order</span> bygrace <span class="keyword">asc</span>)</span><br><span class="line">    <span class="keyword">as</span> rank</span><br><span class="line">   <span class="keyword">from</span> enrolled) <span class="keyword">as</span> ranking</span><br><span class="line"><span class="keyword">where</span> ranking.rank <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>postgres is the only one supports.</p><p>Common table expressions</p><ul><li>provides a way to write auxiliary statements for use in a larger query.<ul><li>think of it like a temp table just for one query.</li></ul></li></ul><p>Alternative to nested queries and views.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ctename (col1, col2) <span class="keyword">as</span> (</span><br><span class="line"> <span class="keyword">select</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> col1 <span class="operator">+</span> col2 <span class="keyword">from</span> ctename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ctesource (maxid) <span class="keyword">as</span> (</span><br><span class="line"> <span class="keyword">select</span> <span class="built_in">max</span>(sid) <span class="keyword">from</span> enrolled</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> student, ctesource</span><br><span class="line"> <span class="keyword">where</span> student.sid <span class="operator">=</span> ctesource.max;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># recursion</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> ctesource (counter) <span class="keyword">as</span> (</span><br><span class="line"> (<span class="keyword">select</span> <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"> (<span class="keyword">select</span> counter <span class="operator">+</span> <span class="number">1</span> <span class="keyword">from</span> ctesource</span><br><span class="line">   <span class="keyword">where</span> counter <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ctesource;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Course Introduction Relational Model (CMU Databases Systems Fall 2019)</title>
      <link href="/20220925-DBsystem/"/>
      <url>/20220925-DBsystem/</url>
      
        <content type="html"><![CDATA[<p>TEXTBOOK: Database System Comcepts 7th Edition</p><p>Silberschatz, Korth, &amp; Sudarshan</p><p>Database:</p><ul><li>Organized collextion of inter-related data that models some aspect of the real-world</li></ul><p>E.g. Create a database that models a digital music store to keep track of artists and albums</p><p>Store our database as comma-separated value (CSV) files that we manage in out own code.</p><ul><li>Use a separate file per entity.</li><li>The application has to parse the files each time they want to read &#x2F; update records</li></ul><p>Artist(name, year, country) Album(name, artist ,year)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file</span><br><span class="line">  record = parse(line)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;Ice Cube&quot;</span> == record[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">print</span> <span class="built_in">int</span>(record(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>Flat files: data integrity</p><ul><li>How do we ensure that the artist is the same for each album entry?</li><li>What if somebody overwrites the album year with an invalid string?</li><li>How do we store that there are multiple artists on an album?<ul><li>array or string?</li></ul></li><li>How do you find a particular record?<ul><li>three lines pretty fast</li><li>a Billion?</li></ul></li><li>What if we now want to create a new application that uses the same database?</li><li>What if two threads try to write to the same file at the same time?<ul><li>first writes something, and second overwrites</li></ul></li><li>What if the machine crashes while our program is updating a record?</li><li>What if we want to replicate the database on multiple machines for high availabiility?</li></ul><p>DBMS is software that allows applications to store and analyze information in a database.</p><p>A general-purpose DBMS is designed to allow the definition, creation, querying, update, and administration of databases.</p><ul><li>reuse</li><li>no reinventing wheels</li></ul><p>There’s no courses bout browsers, but there is course about DB.</p><p>So it’s a kind of special software.</p><p>Early DBMSs</p><ul><li>Database application were difficult to build and maintain.</li><li>Tight coupling between logical and physical layers.</li><li>You have to (roughly) know what queries your app would execute before you deployed the database.</li></ul><p>Ted Cotton: people are wasting time write DBMS again and again.</p><p>Database abstraction to avoid this maintenance:</p><ul><li>Store database in simple data structures</li><li>Access data through high-level language.</li><li>Physical storage left up to implementation.</li></ul><p>Noway software can never produce query.</p><p>Physical storage of data is transparent to applications.</p><p>Data Models</p><ul><li>A data model is collecition of concepts for describing the data in a databasde.</li><li>A schema is a description of a particular  colection of data, using a given data model.</li></ul><p>Data Model</p><ul><li>Relational  &lt;- SQL</li><li>Key&#x2F;Value  &lt;- NoSQL</li><li>Graph</li><li>Document</li><li>Column-family</li><li>Array&#x2F;Matrix  &lt;- Machine Learning</li><li>Hierarchical &lt;- Obsolete &#x2F; Rare</li><li>Network</li></ul><p>Relational Mods</p><ul><li>Structure: The definition of relations and their contents.</li><li>Integrity: Ensure the database’s contents satisfy constraints.</li><li>Manipulation: how to access and modify a database’s contents.</li></ul><p>A relation is unordered set that contain the relation ship of attributes that represent entities</p><p>A tuple is a set of atribute values (also known as its domain) in the relation.</p><ul><li>Values are (normally) atomic &#x2F; scalar.</li><li>The special value NULL is a member of every domain.</li></ul><p>A relation’s primary key uniquely identifies a single typle.</p><p>Some DBMSs automatically create an internal primarykley if you don’t define one.</p><p>A foreign key specifils that an attrebute from one relation has to map to a tyuple in another relation.</p><ul><li>Album -&gt; Multiple Artists</li><li>a separate cross reference table ArtistAlbum(artist_id, album_id), both are foreign keys.</li></ul><p>The relational model is independent of any query language implementation.</p><p>SQL is the <em>de facto</em> standard.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span> <span class="keyword">FROM</span> artists</span><br><span class="line">  <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Ice Cuve&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Distributed Algorithm - syllabus</title>
      <link href="/20220922-Distributed_Algorithm_syllabus/"/>
      <url>/20220922-Distributed_Algorithm_syllabus/</url>
      
        <content type="html"><![CDATA[<p>Syllabus</p><p>从基础问题到研究问题，到系统和工具</p><ul><li><p>Model of computation</p><ul><li>Different dimensions in defining a computation model</li></ul></li><li><p>Basic problems</p><ul><li>Basic message-passing algorithms</li><li>Leader election in rings</li><li>Mutual exclusion in shared memory</li><li>Fault-tolerant consensus</li></ul></li><li><p>Research problems</p><ul><li>Distributed algorithms<ul><li>Consensus algorithms: Paxos, Raft, Zab</li><li>Specificaiton, verification, testing</li></ul></li></ul></li><li><p>From algorithms to systems</p><ul><li>Data replication: TPaxos, ParallelRaft (Ali PolarDB)</li><li>Coordination service: Zookeeper (Apache)</li><li>…</li></ul></li></ul><p>Outline</p><ul><li><p>Distrubuted Algorithms (DAs)</p><ul><li>Fundamental concepts</li></ul></li><li><p>Model of computation</p><ul><li>Basic idea</li><li>RAM model for sequential algorithms</li></ul></li><li><p>Model of computationsfor DAs</p><ul><li>Communication medium, Timing model</li><li>Failure model, progress condition</li><li>Correctness condition: specification of the problem</li><li>Simulation among models</li></ul></li><li><p>Algorithms</p><ul><li>Abstract: designed over an abstract machine (the model of computation)</li><li>Formal: rigid mathematical treatments</li></ul></li><li><p>Distributed algotrithms</p><ul><li>Model of distributed computation</li><li>Mathematical proofs, analysis, …</li><li>In relation to other concepts<ul><li>Distributed conputing theory</li><li>Distributed systems</li></ul></li></ul></li></ul><p>Computing and Computer</p><ul><li><p>The computer seems to be able to do anything</p></li><li><p>But something cannot be efficiently done by a computer</p></li><li><p>Computing</p><ul><li>Encoding everything into ‘0’s and ‘1’s</li><li>Operations over ‘1’s and ‘0’s</li><li>Decoding the ‘1’s and ‘0’s</li></ul></li><li><p>Computer</p><ul><li>A set of operations it can do<ul><li>Limited operations, unlimited combinations</li></ul></li><li>Perform specified operations<ul><li>Quickly, inexhaustibly, with no intelligence</li></ul></li></ul></li></ul><p>计算机只能做简单重复的事情。</p><p>Algorithm</p><ul><li><p>Algorithm is the spirit of computing</p><ul><li>To solve a specific problem (so called an algorithmic problem)</li><li>Combination of basic operations<ul><li>in a precise and elegant way</li></ul></li></ul></li><li><p>Essential issues</p><ul><li>Model of computation</li><li>Algorithm design</li><li>Algorithm analysis</li></ul></li></ul><p>Model of Computation</p><ul><li><p>Problem 1</p><ul><li>Why the algorithms we learn can run almost everywhere?</li></ul></li><li><p>Problem 2</p><ul><li>Why the algorithms we learn can be implemented in any language?</li></ul></li><li><p>Machine-independent algorithms run on an abstract machine</p><ul><li>Turing machine: over-qualify</li><li>RAM model: simple but powerful</li></ul></li></ul><p>Turing Machine</p><ul><li><p>Tape in</p><ul><li>Encoding the input</li></ul></li><li><p>Tape out</p><ul><li>Recording the output</li></ul></li><li><p>Control of the read-write head</p><ul><li>Operations the machine can do</li></ul></li></ul><p>RAM Model</p><ul><li><p>Each simple operation takes one time step</p><ul><li>E.g., key comparison, +&#x2F;-, memory access, …</li></ul></li><li><p>Complex operations shoule be decomposed</p><ul><li>Loop, Subroutine</li></ul></li><li><p>Memory</p><ul><li>Memory access is a simple operation</li><li>Unlimited memory</li></ul></li></ul><p>Model of Computation for DAs</p><p>Communicaion medium: message passing &amp; shared memory</p><p>Progess method: synchronous &amp; asynchronous</p><p>Why one model can’t cover DA?</p><ul><li><p>Single serialized machine: low complexity to cover</p></li><li><p>Distributed systems vary</p></li></ul><p>Message-passing Model</p><ul><li><p>Processors</p><ul><li>p_0, p_1, …, p_n-1 are nodes of the graph</li><li>Each modeled as a state machine</li></ul></li><li><p>Channel from p_i to p_j</p><ul><li>outbuf variable of p_i (physical channel)</li><li>inbuf variable of p_j (incoming message queue)</li></ul></li></ul><p>Comfiguraition of the System</p><ul><li><p>A snapshot of the entire system</p><ul><li>Processor states</li><li>Channels states</li></ul></li><li><p>Formally, a vector of </p><ul><li>Local variables</li><li>Incoming message queues</li><li>outbufs</li></ul></li></ul><p>Event: Delivery (送达)</p><ul><li>Moves a message from sender’s outbuf to receiver’s inbuf<ul><li>Message will be abailable next time receiver takes a step</li></ul></li></ul><p>Event: Computation</p><ul><li><p>Start with old accessible state</p><ul><li>Local vars + incoming messages</li></ul></li><li><p>Apply the state machine transition function</p><ul><li>Handle all incoming messages</li></ul></li><li><p>End with new accessible state</p><ul><li>Empty inbufs</li><li>New outgoing messages</li></ul></li></ul><p>Asynchronous Execution</p><ul><li><p>System execution</p><ul><li>&lt;config, event, config, event, config, …&gt;</li></ul></li><li><p>Initial configuration</p><ul><li>Esch processor is in its initial state</li><li>All inbufs are empty</li></ul></li><li><p>System progress</p><ul><li>&lt;config_old, event, config_new&gt;<ul><li>config_new is the same as config_old except:<ul><li>a) if delivery (msgReceive) event<ul><li>Spedified msg is transgerred from sender’s outbur to receiver’s inbuf</li></ul></li><li>b) if computation event<ul><li>Specified processor’s state (including outbufs) change according to transition function</li></ul></li></ul></li></ul></li></ul></li><li><p>An execution is admissible in a (reliable) asynchronous model if</p><ul><li>Every message in an outbuf is eventually delivered</li><li>Every processor takes an infinite number of steps</li><li>No constraints on when these events take place<ul><li>Arbitrary message delays</li><li>Relative processor speeds</li></ul></li></ul></li><li><p>Reliability lies in that</p><ul><li>No message is lost</li><li>No processor stops working</li></ul></li></ul><p>Complexity Measures</p><ul><li>Message complexity (发多少消息才能完成这件事)<ul><li>Maximum number of messages sent in any admissible execution</li></ul></li><li>Time complexity<ul><li>Maximum “time” until all processes terminalte in any admissible execution</li><li>How to measure time in an asynchronous execurion?<ul><li>Produce a timed execution by assigning non-decreading real times to events so that time between sengding and receiving any message is at most  1.</li><li>Time complexity: maximum time until termination in any timed admissible execution.</li></ul></li></ul></li></ul><p>Synchronous Executions</p><ul><li>Admissible execution<ul><li>An infinite sequence of rounds<ul><li>A round is a sequence of deliver events moving all messages in transit into inbufs, followed by a sequence of computation events, one for each processor</li></ul></li><li>Progress in lockstep<ul><li>Every message sent is delivered</li><li>Every processor takes an infinite number of steps</li></ul></li></ul></li><li>Time complexity<ul><li>The number of rounds until termination</li></ul></li></ul><p>Shared Memory Model</p><ul><li>Processors communicate via a set of shared variables (also called shared registers)<ul><li>Each shared variable has a type, defining a set of primitive operations (performed atomiacally)</li></ul></li><li>Shared variables<ul><li>read, write</li><li>compare &amp; swap (CAS)</li><li>read-modify-write (RMW)</li></ul></li></ul><p>Execution</p><ul><li><p>Configuration</p><p>(q0, q1, …, qn-1, r0, r1, …, rm-1)</p><p> process states      shared variables</p></li><li><p>Events</p><ul><li>Computation steps taken by the process</li><li>At each computation step, the shared variable is accessed</li></ul></li><li><p>Admissible execution</p><ul><li>An execution is admissible if evety processor takes infinite number of steps</li></ul></li><li><p>Shared variable access</p><ul><li><p>At each computation step by p_i, the following happen atomically:</p><p>a) p_i chooses a ashared variable to access with a specific operation, based on p_i’s current state;</p><p>b) The specified operation is performed on the shared variable;</p><p>c) p_i’s state changes according to p_i’s transition function, based on p_i’s current state and the value the shared memory operation performed.</p></li></ul></li></ul><p>Complexity Measures</p><ul><li>Shared variables<ul><li>Number of distinct shared variables required</li></ul></li><li>Shared space<ul><li>Amount of shared space</li><li>E.g, # of bits, # of distinct values, …</li></ul></li></ul><p>Changes from the MSG Model</p><ul><li>Communication medium changes<ul><li>No inbuf and outbuf state components</li><li>Configuration includes values for shared variables</li></ul></li><li>Execution manner changes<ul><li>One event type: one computation step by a process<ul><li>p_i’s state in old configuration specifies whith shared variable is to be accessed and with which primitive</li><li>shared variable’s value in the new configuration changes according to the primitive’s semantics</li><li>p_i’s state in the new configuration changes according to its old state and the result of the primitive</li></ul></li></ul></li></ul><p>Google: data center as a computer</p><p>Correctness Condition</p><ul><li>How to specify an algorithmic problem?<ul><li>E.g., GCD(Euclid), Sorting</li></ul></li><li>How to speicify a distributed-algorithmic problem?<ul><li>A reactive system</li><li>Safety</li><li>Liveness</li></ul></li></ul><p>DAs are always running.</p><p>不同模型可以互相模拟</p><p>Simulation among MoCs</p><ul><li>Example 1: Synchronizer<ul><li>Illusion of synchronous rounds</li><li>Over asynchronous communication</li></ul></li><li>2: Distributed Shared Memory (DSM)<ul><li>Illusion of a shared memory</li><li>Over message passing</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> DisAlg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>克服焦虑 - 慢慢改</title>
      <link href="/20220911-rest/"/>
      <url>/20220911-rest/</url>
      
        <content type="html"><![CDATA[<p>现在是白天。</p><p>之前没有仔细想。生活状态的转换应该还是要慢慢来？很多要求就一个个去满足就好了。比如先把作息和饮食调整好，再想训练的事。一开始不用一下子全都做好。</p><p>也许，把桌面收拾好，慢慢保持住；把衣柜整理整理。都是值得做出的改变。</p><p>随便摘一首诗</p><p>西江月·井冈山</p><p>山下旌旗在望，三头鼓角相闻。敌军围困千万重，我自岿然不动。</p><p>早已森严壁垒，更加众志成城。黄洋界上炮声隆，报道敌军霄遁。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>焦虑</title>
      <link href="/20220911-postmidAutumn/"/>
      <url>/20220911-postmidAutumn/</url>
      
        <content type="html"><![CDATA[<p>中秋节后夜。</p><p>如同我自己感觉到的，每到此时，心中便会生出焦虑，仿佛这一天仍有未尽之事宜。实际上原本就没有做安排。正因为任务模糊不清，而整日又无所事事，才产生了如此的心情。</p><p>我自己分明是有事可做的，且</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>答问：随着时间我会释怀吗？</title>
      <link href="/20220407-relief/"/>
      <url>/20220407-relief/</url>
      
        <content type="html"><![CDATA[<p>让人释怀的，并不是时间。</p><p>借用别人的理解，释怀就是：对过去的事，不再怀念；对离开的人，不再纠缠；对做不到的，不再自责；对得不到的，不再留恋。</p><p>我的总结就是：得过且过，放过自己。</p><p>以我的这种解法，每一次“释怀”，都一定会在心里打一个疙瘩。它一点也不痛，我很少为之烦恼。只是有一点点，一点点膈应罢了。偶尔会想，“要是这件事的结果好一点，那我的人生就变得更完美了”。但是也并不极力追求完美。就像是身上长了一个不痛不痒的疙瘩，虽然没感觉，但是时不时地就想去摸两下，然后就作罢了。偶尔也在想，就算这些疙瘩当初没产生，也必然会有别的什么新的问题…</p><p>对于我而言，比较激烈的情绪没有隔夜的。一个让我难受的想法想了一周之后也就烦了。我是一个热爱现实的人，我愿意把精力更多地放在自己的能力范围之内，而不是空耗在自己所不能触及的地方。我谈政治，学哲学，但最多的还是想今天吃什么，做什么，与他人进行何种交流。当把精力放在自己能够触及的地方，便觉得世界是具体的可把握的；当精力放在够不到的地方，则只能看到虚假的世界中无力的自己。在时空上已经远离我们的那些人和事，本应对我们很难造成实际的影响，而我们却很容易高估了他们。</p><p>把握好自己能把握的领域，是唯一的出路。过多地把精力放在那些已经离你远去的人和事上，不管过了多长时间，都不会释怀，并且会非常受挫。</p><p>初中喜欢了3年的女生，我们之间发生过很多矛盾（我犯的错），然后又在一段时间的冷静后，我们能够正常地做朋友——当然现在也是像普通朋友一样渐行渐远。我无数次好奇她最后对我到底是什么样的看法，但始终没有发消息去问。现在我只是不时看一看她的朋友圈，就像是身上哪里长了一个不痛不痒的疙瘩，时不时就想起来摸一摸。</p><p>高中曾有其他学校的女生向我敞开怀抱，并且还是两次，我沉溺于这种暧昧的感觉，每一次都接受了。我对她是喜欢的，但也非常混蛋。我不敢相信，就像是永尾完治遇上赤名莉香，对于女生的主动，反而无所适从，并且怀疑对方对自己的感情。也很多次想要向她确证。但有两个完全相反的想法共同阻拦着我：一方面认为这样优秀、人际关系良好的女生根本不可能喜欢上我；另一方面认为她明明是在明示我，如果我再去问会显得很蠢，说不定还会让她生气。我逃避了，我与其他人恋爱，我错过了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如梦如幻的周末</title>
      <link href="/20220304-yumemitai/"/>
      <url>/20220304-yumemitai/</url>
      
        <content type="html"><![CDATA[<p>我走在一组团路上，想到的是，这样梦幻的日子，我还能过多久？</p><p>周五晚上群里照常，又是赵佩璇和安禹赫小组出去喝酒了，开始夺舍对方的qq号。但很快，佩璇开始诉说苦恼：想要早点死。</p><p>我与赵佩璇是在大二下学期第一回见，是我还留着长头发的时候。是典型的大城市、富裕家庭来的孩子，尤其是早年经历这方面至少比我这个从南京这个小城出来的要丰富很多。由于种种原因不喜欢在北京待着，恰好高考分数高，才来到南京大学。给人的印象就是非常非常开朗，什么都不在意的类型。</p><p>于是我很惊讶。虽然外表看起来开朗的人，内心多少也会有点小疙瘩，但是觉得人生活腻了，一心寻死的，还是从来没有见过。她又补充到，非常担心大家讨厌她。更是奇怪。</p><p>在我的脑子里，一直就有这样一个三人组：赵佩璇、安禹赫、翟竞波。他们分别来自北京、天津、新疆，但是到了这里，很快成为了非常非常要好的朋友。至少表面很要好吧。。。佩璇自己都承认，他俩对她真的很好。但时不时仍然怀疑他们讨厌自己。</p><p>你也知道，我见不得美少女伤心，就随便和她聊俩句试图开导一下。我看她没胆子寻死就放心了， 然后她给我留了个线索，说了解她的过去就知道为什么现在这样了。</p><p>第二天晚上我就奔运动场去了。清风阵阵，绿树围绕着跑道，天色晚得深蓝，佩璇独自坐在看台上。认出我来，打个招呼。我们聊了一点过去，大致是：初高中同学纷纷表示对她不喜欢，好朋友当面关系好却要应和大家以至于不能确定是否是真好朋友。对于不受欢迎的原因完全无处了解，总结起来为“就是不喜欢这个人”。我深受震撼，原来连人际关系都与我的经历大相径庭。应该说，找不到第二个相同的。事后重新思考的时候，私以为隐瞒了很多重要的情节。只知道一两条信息是分析不出结果的，一定要从头到尾理顺了。（在写的时候，我深深感到佩璇大概知道自己到底是什么问题，但隐藏了）</p><p>佩璇，我，安禹赫，顾天纬四人，为了不回宿舍，在外面干等了一夜。我就这样掉进坑里。</p><p>我们前半夜聊天，什么都聊。院里不喜欢谁，谁的八卦，</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于三界的描述</title>
      <link href="/20220304-cite/"/>
      <url>/20220304-cite/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知道是从哪里抄的</p></blockquote><p>象征界与想象界甚至可以说是作为实在界的马赛克而存在的。主体通过象征界与想象界而无需直接面对实在界。实在界本身喻示了语言的无力、欲望的虚假等等诸多“真实”。主体无法控制自身的一切，自我是被捏造的虚假存在，一切的最终都是毫无意义的。</p><p>作为欲望与焦虑的小客体a</p><p>把他者的欲望看作是自己的欲望终究只是主体的欲望的幻象。其在主体身上引发的与其说是欲望的满足，不如说是焦虑，因为那个作为欲望之原因的小a根本上是一个欠缺，是主体实在界打开的一个空洞……我们总是以他者的欲望来规定自己的欲望，总之，我们的欲望并非我们自己的，而是在他者中且通过他者被结构的。可是，他者究竟欲望什么？主体对此完全不知，他者的欲望之谜令主体焦虑不已，在他者欲望的煎逼之下，在欲望满足的失败中，主体一次又一次遭遇到自身的残余性。</p><p>于是，焦虑的原因就显得明了了，主体并非因为欲望对象远离与推迟而感到焦虑，而是因为过分靠近对象本身感到创伤性焦虑。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面纱</title>
      <link href="/20211129-veil/"/>
      <url>/20211129-veil/</url>
      
        <content type="html"><![CDATA[<p>一周一度的电脑没电时间。</p><p>我常常会因为不懂辩证法而感到与世界格格不入。</p><p>这一周没学到什么新的，不过有一个表象与本质的辩证关系。提问：表象的背后是什么？</p><p>是虚无吗？“无”作为一种规定性是抹平全部差异的巨大力量。Nothing is expensive。</p><p>是自我吗？这代表了一种自我的二分。里面外面全都是“我”，这是在本体论上无法操控的，也就变成了一种他者。</p><p>是表象吗？表象后永远是表象，意味着真实的东西永远不会到来，这是一种危险的玩味。</p><p>是本质吗？当然本质仍然有一个本质。于是本质变成了表象之表象。</p><p>都对，都不对。答案是一个合题。</p><p>爱情是遮蔽在“见色起意”之上的一层“painted veil”。它是一个美丽的幌子，而且你还揭不开——它就是本质，本质就是你的冲动。这里没有高尚和低俗的二分。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>身体状况</title>
      <link href="/20211124-sick/"/>
      <url>/20211124-sick/</url>
      
        <content type="html"><![CDATA[<p>身体状况变差了。</p><p>昨晚心血来潮跑个步，夜里睡眠质量急剧下降：0530醒了一次，很久才睡着。做的梦也不是很友好。</p><p>检查一下手环，发现夜里有异常心率。身体上也感觉到肺内吸足气时胸口有点酸痛。上次这种感觉还是在高中强度最高的时候。类似的状况其实是调理可以恢复的，不过要不要今天就去测一下血压呢。。</p><p>身体重要。不过睡眠质量稍微有点无解，这似乎也和夜间心率状况有点关系。最低的心率能到40，感觉不太寻常。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>凝视</title>
      <link href="/20211123-gaze/"/>
      <url>/20211123-gaze/</url>
      
        <content type="html"><![CDATA[<p>当我对任何人的凝视都感到无所谓的时候我才是真的变强了。</p><p>仿佛在感知着他人的目光，只是感知，而不是在事实上确认到的那一瞬间，主体作为客体而存在了。</p><p>第一时间不是感受到自己的情绪，而是一个矮化的那个 “Tilnel”。自己的丑态浮现在自己的头脑中。</p><p>所以人真能完全无视那种眼神吗？</p><p>也许有两条路径。一是感知不到，二是感知到了但不去思考。第一条主要又是不要自动把第一人称视角改成第三人称。第二条恐怕就是摆烂了，或者是相信自己不会有任何丑态被捕捉到。真的能这么自信吗？</p><p>第一条有点像是对抗一种刻在DNA中的本能。第二条则不是什么实事求是的姿态，而是诉诸于臆想，只是对自己不忠诚。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Universality of Consensus</title>
      <link href="/20211121_Consensus/"/>
      <url>/20211121_Consensus/</url>
      
        <content type="html"><![CDATA[<p>Universality of Consensus</p><p>How to prove statements of the form “there is no wait-free implementation of $X$ by $Y$”?</p><h3 id="6-2-Universality"><a href="#6-2-Universality" class="headerlink" title="6.2 Universality"></a>6.2 Universality</h3><p>A class $C$ is <em>universal</em> if one can construct a wait-free implementation of any object from some number of objects of $C$ and some number of read-write registers.</p><h3 id="6-3-A-Lock-Free-Universal-Construction"><a href="#6-3-A-Lock-Free-Universal-Construction" class="headerlink" title="6.3 A Lock-Free Universal Construction"></a>6.3 A Lock-Free Universal Construction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SeqObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Response <span class="title function_">apply</span><span class="params">(Invocation invoc)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(the <code>apply()</code> method applies the invocation and returns a response).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Invoc invoc;</span><br><span class="line">    <span class="keyword">public</span> Consensus&lt;Node&gt; decideNext;<span class="comment">// decide next Node in list</span></span><br><span class="line">    <span class="keyword">public</span> Node next;<span class="comment">// the next node</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> seq;<span class="comment">// sequence number</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Invoc invoc)</span> &#123;</span><br><span class="line">        invoc = invoc;</span><br><span class="line">        decideNext = <span class="keyword">new</span> <span class="title class_">Consensus</span>&lt;Node&gt;();</span><br><span class="line">        seq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">max</span><span class="params">(Node[] array)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (max.seq &lt; array[i].seq)</span><br><span class="line">                max = array[i];</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This shows a universal construction that transforms any sequential object into a lock-free linearizable concurrent object. This construction assumes that sequential objects are <em>deterministic</em>: if we apply a method to an object in a particular state, then there is only one possible response, and one possible new object state. We can represent any object as a combination of a sequential object in its initial state and a <em>log</em>: a linked list of nodes representing the sequence of method calls applied to the object (and hence the object’s sequence of state transitions).</p><p>我们只要存下调用序列就可以知道状态了。</p><p>那么怎么让它并发呢？也就是 <code>apply()</code> 能够并发地被调用。</p><p>只要在调用 <code>apply()</code> 的时候，都创建一个 <code>node</code>，通过一个 $n$-线程的共识协议来竞争哪一个节点被添加到调用序列当中。</p><p>赢者得到执行（什么达尔文），它把对象复制到本地，然后顺序执行（真的不计内存消耗了？）最后返回自己的结果。</p><p>败者就必须继续竞争（所以不是 wait-free）</p><p>详细的暂时不看了。</p><h3 id="6-4-A-Wait-Free-Universal-Construction"><a href="#6-4-A-Wait-Free-Universal-Construction" class="headerlink" title="6.4 A Wait-Free Universal Construction"></a>6.4 A Wait-Free Universal Construction</h3><p>Core: help less fortunate threads to complete their calls. <em><strong>helping</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Universal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] announce;<span class="comment">// array added to coordinate helping</span></span><br><span class="line">    <span class="keyword">private</span> Node[] head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">node</span>(); tail.seq = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; head[j] = tail; announce[j] = tail; &#125;</span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">apply</span><span class="params">(Invoc invoc)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">        announce[i] = <span class="keyword">new</span> <span class="title class_">Node</span>(invoc);</span><br><span class="line">        head[i] = Node.max(head);</span><br><span class="line">        <span class="keyword">while</span> (announce[i].seq == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">before</span> <span class="operator">=</span> head[i];</span><br><span class="line">            <span class="type">Node</span> <span class="variable">help</span> <span class="operator">=</span> announce[(before.seq + <span class="number">1</span> % n)];</span><br><span class="line">            <span class="keyword">if</span> (help.seq == <span class="number">0</span>)</span><br><span class="line">                prefer = help;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prefer = announce[i];</span><br><span class="line">            after = before.decideNext.decide(prefer);</span><br><span class="line">            before.next = after;</span><br><span class="line">            after.seq = before.seq + <span class="number">1</span>;</span><br><span class="line">            head[i] = after;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SeqObject</span> <span class="variable">MyObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqObject</span>();</span><br><span class="line">        current = tail.next;</span><br><span class="line">        <span class="keyword">while</span> (current != announce[i]) &#123;</span><br><span class="line">            MyObject.apply(current.invoc);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head[i] = announce[i];</span><br><span class="line">        <span class="keyword">return</span> MyObject.apply(current.invoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的智商不够看懂这个（懒）</p><p>7 就是 spinlock 了，终于有锁了，流下了激动的眼泪。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - The Relative Power of Primitive Synchronization Operations</title>
      <link href="/20211121_sync_op/"/>
      <url>/20211121_sync_op/</url>
      
        <content type="html"><![CDATA[<p>Consensus Numbers</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consensus</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">decide</span><span class="params">(T value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>consistent: all threads decide the same value,</li><li>valid: the common decision value is some thread’s input.</li></ul><p><em>Def 5.1.1</em> A class <em>C</em> solves $n$-thread consensus if there exist a consensus protocol using any number of objects of class <em>C</em> and any number of atomic registers.</p><p><em>Def 5.1.2</em> The <em>consensus number</em> of a class <em>C</em> is the largest $n$ for which that class solves $n$-thread consensus. If no largest $n$ exists, we say the consensus number of the class if <em>infinite</em>.</p><p><em>Corollary 5.1.1</em> Suppose one can implement an object of class <em>C</em> from one or more objects of class <em>D</em>, together with some number of atomic registers. If class <em>C</em> solves $n$-consensus, then so does class <em>D</em>.</p><p>A protocol state is <em>critical</em> if:</p><ul><li>It is bivalent, and</li><li>if any thread moves, the protocol state becomes univalent.</li></ul><p><em>Lemma</em> 5.1.3. Every wait-free consensus protocol has a critical state.</p><h3 id="5-2-Atomic-Registers"><a href="#5-2-Atomic-Registers" class="headerlink" title="5.2 Atomic Registers"></a>5.2 Atomic Registers</h3><blockquote><p>Whether we can solve consensus using atomic registers?</p><p>– no</p></blockquote><p>There is no binary consensus protocol for two threads.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ConsensusProtocol</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Consensus</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> T[] proposed = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[N];</span><br><span class="line">    <span class="comment">// announce my input value to the other threads</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">propose</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        proposed[ThreadID.get()] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// figure out which thread was first</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> T <span class="title function_">decide</span><span class="params">(T value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是，你都有互斥的 Queue 了，那不是等同于作弊么</p><h3 id="5-4-FIFO-Queues"><a href="#5-4-FIFO-Queues" class="headerlink" title="5.4 FIFO Queues"></a>5.4 FIFO Queues</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueConsensus</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ConsensusProtocol</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WIN</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// first thread</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOSE</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// second thread</span></span><br><span class="line">    Queue queue;</span><br><span class="line">    <span class="comment">// initialize queue with two items</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueConsensus</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">        queue.enq(WIN);</span><br><span class="line">        queue.enq(LOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// figure out which thread was first</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">decide</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        propose(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> queue.deq();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">        <span class="keyword">if</span> (status == WIN) <span class="keyword">return</span> proposed[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> proposed[<span class="number">1</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Corollary</em> 5.4.1 It is impossible to construct a wait-free implementation of a queue, stack, priority queue, set, or list from a set of atomic registers.</p><h3 id="5-5-Multiple-Assignment-Objects"><a href="#5-5-Multiple-Assignment-Objects" class="headerlink" title="5.5 Multiple Assignment Objects"></a>5.5 Multiple Assignment Objects</h3><h3 id="5-6-Read-Modify-Write-Operations"><a href="#5-6-Read-Modify-Write-Operations" class="headerlink" title="5.6 Read-Modify-Write Operations"></a>5.6 Read-Modify-Write Operations</h3><p>Many, if not all, of the classical synchronization operations provided by multiprocessors in hardware can be expressed as <em>read-modify-write</em> (RMW) operations, or, as they are called in their object form, <em>read-modify-write registers</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getAndSet(v);</span><br><span class="line">getAndIncrement();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RMWConsensus</span> <span class="keyword">extends</span> <span class="title class_">ConsensusProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// initialize to v such that f(v) != v</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RMWRegister</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMWRegister</span>(v);</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">decide</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    propose(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ThreadID.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> - i;</span><br><span class="line">        <span class="keyword">if</span> (r.rmw() == v)</span><br><span class="line">            <span class="keyword">return</span> proposed[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Foundations of Shared Memory</title>
      <link href="/20211121-shared_memory/"/>
      <url>/20211121-shared_memory/</url>
      
        <content type="html"><![CDATA[<p>Foundations of Shared Memory</p><p>At the hardware level, threads communicate by reading and writing shared memory.</p><p>How to implement linearizable read and write register for multiple readers and writers?</p><p>Can any data structure implemented from the most powerful registers we define also be implemented from the weakest?</p><p>The weakest form of persistent synchronization if (arguably) the ability to set a single persistent bit in shared memory, and the weakest form of synchronization is (unarguably) none at all: if the act of setting a bit does not overlap the act of reading that bit, then the value read is the same as the value written Otherwise, a read overlapping a write would return any value.</p><p>A single-writer, multi-reader register implementation is <em>safe</em> if –</p><ul><li>A <code>read()</code> call that does not overlap a <code>write()</code> call returns the value written by the most recent <code>write()</code> call.</li><li>Otherwise, if a <code>read()</code> call overlaps a <code>write()</code> call, then the <code>read()</code> call may return any value within the register’s allowed range of values (for example, $0$ to $M - 1$ for an $M$-valued register)</li></ul><p>The term <em>safe</em> is a historical accident. Because they provide such weak guarantees, “safe” registers are actually quite unsafe.</p><p><img src="image-20211121200633192.png" alt="image-20211121200633192"></p><p>我至今还是不知道为什么 Boolean 不是 Regular 而只能是 safe。这真的能返回出奇怪的值吗？</p><p>我想跳过这个了</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Concurrent Objects</title>
      <link href="/20211121-object/"/>
      <url>/20211121-object/</url>
      
        <content type="html"><![CDATA[<p>Concurrent Objects</p><p>有锁数据结构真好写</p><h5 id="Sequence-Consistency"><a href="#Sequence-Consistency" class="headerlink" title="Sequence Consistency"></a>Sequence Consistency</h5><p><img src="image-20211121164314180.png" alt="image-20211121164314180"></p><p>p 和 q 都是顺序一致的。（可以平移）</p><p>但是这个执行过程并不是顺序一致的（有环）</p><h4 id="Linearizability"><a href="#Linearizability" class="headerlink" title="Linearizability"></a>Linearizability</h4><p>顺序一致性不可合成。</p><p><em>Principle</em>: Each method call should appear to take effect instantaneously at some moment between its invocation and response.</p><p>Every linearizable execution is sequentially consistent, but not vice versa.</p><p>The usual way to show that a concurrent object implementation is linearizable is to identify for each method a <em>linearization</em> point where the method takes effect.</p><p>For lock-based implementations, each method’s critical section can serve as its linearization point. For implementations that do not use locking, the linearization point is typically a single step where the effects of the method call become visible to other method calls.</p><p><img src="image-20211121181745189.png" alt="image-20211121181745189"></p><p>看懂了没？</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency - Mutual Exclusion</title>
      <link href="/20211121-mutex/"/>
      <url>/20211121-mutex/</url>
      
        <content type="html"><![CDATA[<p>Mutual Exclusion</p><p>Reasoning about concurrent computation is mostly about time. Reason about complicated conditions involving how multiple time intervals can overlap, or, sometimes, how they cannot.</p><p>A thread is a <em>state machine</em>, and its state transitions are called <em>events</em>.</p><p>Events are <em>instantaneous</em></p><p>j-th occurence of an event a_i: a_i^j</p><p>a <em>precedes</em> b: a\to b</p><p>The <em>precedence</em> relation “\to” is a total order on events.</p><p>Interval I_A &#x3D;(a_0, a_1), I_B &#x3D; (b_0, b_1), I_A\to I_B if a_1\to b_0.</p><p><strong>Mutual Exclusion</strong> Critical sections of different threads do not overlap. For threads A and B, and integers j and k, either CS_A^k \to CS_B^j or CS_B^j \to CS_A^k.</p><p><strong>Freedom from Deadlock</strong> If some thread attempts to acquire the lock, then some thread will succeed in acquiring the lock. If thread A calls <code>lock()</code> but never acquires the lock, then other threads must be completing an infinite number of critical sections.</p><p><strong>Freedom from Starvations</strong> Every thread that attempts to acquire the lock eventually succeeds. Every call to <code>lock()</code> eventually returns. This property is sometimes called <em>lockout freedom</em>.</p><p>NOTE that starvation freedom implies deadlock freedom.</p><h2 id="2-3-2-Thread-Solutions"><a href="#2-3-2-Thread-Solutions" class="headerlink" title="2.3 2-Thread Solutions"></a>2.3 2-Thread Solutions</h2><h5 id="LockOne"><a href="#LockOne" class="headerlink" title="LockOne"></a>LockOne</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LockOne implements Lock &#123;</span><br><span class="line">    private boolean[] flag = new boolean[2];</span><br><span class="line">    // thread-local index, 0 or 1</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        int j = 1 - i;</span><br><span class="line">        flag[i] = true;</span><br><span class="line">        while (flag[j]) &#123;&#125;  // wait</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        flag[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutual excluded but deadlock.</p><h5 id="LockTwo"><a href="#LockTwo" class="headerlink" title="LockTwo"></a>LockTwo</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class LockTwo implements Lock &#123;</span><br><span class="line">    private volatile int victim;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        victim = i;</span><br><span class="line">        while (victim == i) ()</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="The-Peterson-Lock"><a href="#The-Peterson-Lock" class="headerlink" title="The Peterson Lock"></a>The Peterson Lock</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Peterson implements Lock &#123;</span><br><span class="line">    // thread-local index, 0 or 1</span><br><span class="line">    private volatile boolean[] flag = new boolean[2];</span><br><span class="line">    private volatile int victim;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        int j = 1 - i;</span><br><span class="line">        flag[i] = true; // I&#x27;m interested</span><br><span class="line">        victim = i; // you go first</span><br><span class="line">        while (flag[j] &amp;&amp; victim == i) &#123;&#125;; // wait</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        flag[i] = false;    // I&#x27;m not interested</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutual excluded and starvation free</p><p>Work for n threads: </p><h5 id="The-Filter-Lock"><a href="#The-Filter-Lock" class="headerlink" title="The Filter Lock"></a>The Filter Lock</h5><p><em>a direct generalization of Peterson lock to multipe threads</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Filter implements Lock &#123;</span><br><span class="line">    int[] level; </span><br><span class="line">    int[] victim;</span><br><span class="line">    public Filter(int n) &#123;</span><br><span class="line">        level = new int[n];</span><br><span class="line">        victim = new int[n]; // use 1..n - 1</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            level[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int me = ThreadID.get();</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;   // attempt level 1</span><br><span class="line">            level[me] = i;</span><br><span class="line">            victim[i] = me;</span><br><span class="line">            // spin while comflicts exist</span><br><span class="line">            while ((\exist k != me)(level[k] &gt;= i &amp;&amp; victim[i] == me)) &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int me = ThreadID.get();</span><br><span class="line">        level[me] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Threads run through levels, until 1 level (CS)</p><h5 id="Lamport’s-Bakery-Algorithm"><a href="#Lamport’s-Bakery-Algorithm" class="headerlink" title="Lamport’s Bakery Algorithm"></a>Lamport’s Bakery Algorithm</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Bakery implements Lock &#123;</span><br><span class="line">    boolean[] flag;</span><br><span class="line">    Label[] label;</span><br><span class="line">    public Bakery(int n) &#123;</span><br><span class="line">        flag = new boolean[n];</span><br><span class="line">        lavel = new Label[n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            flag[i] = false; label[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int i = ThreadID.get();</span><br><span class="line">        flag[i] = true;</span><br><span class="line">        label[i] = max(label[i], ..., label[n - 1]) + 1;</span><br><span class="line">        while ((\exist k != i)(flag[k] &amp;&amp; (label[k], k) &lt;&lt; (label[i], i))) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        flag[ThreadID.get()] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lexicographical ordering &lt;&lt; （字典序）, to break symmetry caused by same label.</p><p>In the waiting part, a thread repeatedly rereads the labels one after the other in some arbitrary order until it determines that no thread with a raised flag has a lexicographically smaller label&#x2F;id pair.</p><p>Each thread’s labels are strictly increasing.</p><p>本质上就是排队，先到先执行。</p><p>Any algorithm that is both deadlock-free and <em>first-come-first-served</em> is also starvation-free.</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回忆乐怡</title>
      <link href="/20211101-jly/"/>
      <url>/20211101-jly/</url>
      
        <content type="html"><![CDATA[<p>我是很想不明白为什么要把爱情看得那么复杂的。所谓“一段好的感情一定要互相使对方成为更好的人”啦之类的。。顾虑？（录者：这可能不是一种顾虑，而是一种贪婪）</p><p>都是人类的情感，你不去掌握它，却要让它来掌控你，凭什么？感情的好坏是通过社会关系合乎理性的方式来决定的吗？</p><p>最近很容易想起金乐怡。我在金陵中学，她在南师附中，我已经不记得我们初见到底是怎么回事了，但可能先是在网上认识的。某天去学而思上课，我脑子一热就穿着汉服出街了，高中生还真是有这些闲心思。于是在王绳慧的数学课上我就认识了她。似乎从那以后，我就变成了穿汉服的“小哥哥”。到这里我有点受宠若惊，不过一想到她似乎和所有人的关系都能处得很友好，甚至是亲密，我只能认为这也许只是她的行事风格。（录者：赤名莉香并感）</p><p>我们一边在网络上聊天，却在现实中难得见面。高二美食节展台的背后，我在准备候场，而她也来到我们学校，在那里找到了我。她向我张开双臂，我立即会意，像是很熟悉一样迎了上去。没有预告、没有暗示，甚至没有情感流露。我已经不记得说了什么，但拥抱的感觉…我也记不太清了。</p><p>感觉还是很浑蛋。我的确不相信这里包含了什么多余的感情。对方和我才几面之缘，而且说到底各方面都比我强，我没理由认为人家喜欢我的。我笃信她原本就是如此热情的人。后来就是她小高考失利，逐渐没在网络上出现了。我也隐隐约约地有了一切其他牵绊。在烦恼中，竞赛也打完，回归了高考，于是产生更多的烦恼，直到一天早上。</p><p>我们的英语口语考试在南大附中考点，碰巧南师附中也是，只是比我们早一个时间段。我们一大早就在考点门口等着。当时也算是冬天，我拎着袋子搓着手坐在学校对面的小公园，也并没有和朋友们聚着聊天，眼神有些飘忽。我在焦虑，也在寻找着她。我预感自己一定会遇到她。</p><p>起身转悠，却首先被她发现。我已经忘记当时我是怎么打招呼的了，但好像……我们一见面就不管不顾地抱在一起。我的心思可能并不单纯，在于我有点希望同班的女生也看见这副场景。事后诸葛亮的话，这可能是最优情况，但是没有发生这样的事情。</p><p>但当时附近只有她的同学。她只是对着金乐怡会心一笑，而金乐怡可能是羞涩着否认了一下吧。我们有一搭没一搭地交谈，但也许很开心。</p><p>没了。</p>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生活回到正轨</title>
      <link href="/20211027_back_on_track/"/>
      <url>/20211027_back_on_track/</url>
      
        <content type="html"><![CDATA[<p>一周的奔波忙碌，为了一张身份证跑了两个下午。顺路回家吃了了顿饭。。。</p><p>本来第二次晚上也是回家吃饭的，但是我想到自己还和同事约好了帮他看电脑，所以和家里说回学校了。结果人家和同学去海底捞“讨论课程前景”，只能在宿舍坐着，晚上9点去便利店随便吃点。。。</p><p>周二下午从十字街派出所往回走的时候，我的内心差不多是绝望的。一想到自己只是个学生，还未经世事，但仅仅是这样一点小事就害得自己白跑一下午，不知道以后成为真正的社会人以后还会有多少这样的事情发生。这件事情其实也是坏在自己想当然，什么都没带就往办事处跑，又出发得晚，没有多少时间给我纠错。这样想想仿佛不应该怨天尤人。但这样想一想，心情会变得更加差。所以我直接进行一个家的回。特别是一个月没有回家的这个时间点，也不算是想家，就算是和父母互相看着都能变得更加顺眼一点。</p><p>回家把米一淘，妈回来了，出门弄只烤鸭；爸回来了，拎着一盆酸菜鱼。临时凑出一桌好饭好菜，有吃有聊，聊的都是些老话，但一来一回总归是很舒服：不要动脑子，没有压迫感，家人都支持你。心情不好的时候回家就可以充满电。</p><p>但是我想，经常回家的条件恐怕是越来越没有了。往后只会越来越忙，但是充电桩只有一个。而且其实我也有很多事情没有办法和家里说，毕竟是21岁的男人，渐渐地该反过来让家里依靠自己了。我何尝不想谈对象呢？平时我说，实在不行就单身到30岁然后慢慢相亲去，总是不至于没有婚结。爱情什么的早就体验过了。。吧。暧昧的有过，确认关系的也有过，几段经历加起来，除了没有临门一脚以外，似乎…没什么能够期待的？c</p><p>当然有。我认为缺少的部分是从爱情向亲情的升华。首先真的是升华吗？缺少论证。这个过程的特点其实就是热情消退，剩下的是稳固、平和的另一种东西。从短时间的冲动转变为一种长久的、甚至永恒的平淡啊。那么到底哪一个更好？我觉得这里是没有定论的。这应该由每个人自己来决定。那么我到底认为什么重要？</p><p>我一度认为我是更加需要亲情，但写到这里我发现我是错的：我可能只是作为一个平凡人，已经把热情、激情这种同样本真的东西自我阉割了，因为发现自己得不到，而这一空缺就在那个位置存在着，非常折磨。我不相信自己能够拥有。</p><p>发送版：</p><p>爱情是属于人类的本真的情感。也就是说，这玩意神秘个屁，根本就是没有门槛的。你想像它有什么神圣的、崇高的背面，没有！你一想爱情这么圣洁，自己是什么寄吧，自己一定得不到。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>白给周报 1-types-io</title>
      <link href="/20211025-baigei_week1/"/>
      <url>/20211025-baigei_week1/</url>
      
        <content type="html"><![CDATA[<p>视角：Tilnel</p><p>小心<strong>匿名处刑</strong></p><p>同步发布于 <a href="http://blog.tilnel.com/">blog</a></p><p>[toc]</p><h2 id="Ascii"><a href="#Ascii" class="headerlink" title="Ascii"></a>Ascii</h2><p>非常和平的签到题，一点问题都没有。</p><h2 id="Change"><a href="#Change" class="headerlink" title="Change"></a>Change</h2><p>贪心思想，先用最大的，直到用不了再换小一点的…</p><p>看到 std 的做法，突发脑溢血：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n%d\n&quot;</span>, n / <span class="number">20</span>, (n % <span class="number">20</span>) / <span class="number">10</span>, ((n % <span class="number">20</span>) % <span class="number">10</span>) / <span class="number">5</span>, (((n % <span class="number">20</span>) % <span class="number">10</span>) % <span class="number">5</span>));</span><br></pre></td></tr></table></figure><blockquote><p>直接 n % 5 不好吗，为什么要 (((n % 20) % 10) % 5) …</p></blockquote><p><strong>更脑溢血的写法</strong>：从 0 张 20 元开始，用 <code>for</code> 循环一张一张累加，直到超了，换成 10 元继续累加…</p><blockquote><p>这份代码的作者处理 10 元的时候还弄错了，导致 1 元必须累加到超过 <code>INT_MAX</code> 变成某个负数才能停止循环，于是时间超限了。</p></blockquote><h2 id="Equation"><a href="#Equation" class="headerlink" title="Equation"></a>Equation</h2><p>&#x3D;&#x3D;重灾区&#x3D;&#x3D;</p><p>主要问题：爆完 <code>int</code> 爆 <code>long long</code>。因为 <code>a</code>, <code>c</code> 在 <code>int</code> 范围，故有可能出现 $4 \times a \times c$ 也超过了 <code>int64_t</code> 范围的情况。解决办法是全都用 <code>double</code>。</p><p>double 的精度是十进制的15位左右，本题求一个小数点后 3 位只能说是绰绰有余。</p><p>白给示例：</p><p><img src="QQ%E5%9B%BE%E7%89%8720211025011332.jpg" alt="1"></p><h2 id="Gray"><a href="#Gray" class="headerlink" title="Gray"></a>Gray</h2><p>提交通过率达到惊人的 56.3%</p><h2 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h2><p>这题数据出锅了，后来题面补了前导零的描述。</p><h2 id="Pi"><a href="#Pi" class="headerlink" title="Pi"></a>Pi</h2><p>最大的问题是有人不使用百度，直接在代码里写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi_1 = <span class="number">16</span> * arctan(<span class="number">0.2</span>) - <span class="number">4</span> * arctan(<span class="number">1.0</span> / <span class="number">239</span>);</span><br></pre></td></tr></table></figure><p>然后非常自然地得到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pi.c: In function ‘main’:</span><br><span class="line">pi.c:5:22: warning: implicit declaration of function ‘arctan’; did you mean ‘atan’? [-Wimplicit-function-declaration]</span><br><span class="line">    5 |   double pi_1 = 16 * arctan(0.2) - 4 * atan(1.0 / 239);</span><br><span class="line">      |                      ^~~~~~</span><br><span class="line">      |                      atan</span><br><span class="line">/usr/bin/ld: /tmp/ccC2GESl.o: in function `main&#x27;:</span><br><span class="line">pi.c:(.text+0x1a): undefined reference to `arctan&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>但是又不会看 warning，其实编译器已经问你是不是 <code>atan</code> 了。</p><p>第二个问题还是 <strong>数据类型溢出</strong>。</p><ul><li><p>当你在 C 里写下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">640320</span> * <span class="number">640320</span> * <span class="number">640320</span>;</span><br></pre></td></tr></table></figure><p>时，640320 被自动认为是 <code>int</code> 类型。而这整个乘法算式的 3 个数字都是 <code>int</code> 类型，所以表达式的结果也将会是 <code>int</code> 类型。显然是装不下的。</p></li><li><p>但凡写出一个 <code>640320.0</code>，这个计算的性质就变了：</p><p>根据 <a href="https://baike.baidu.com/item/%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87/2635753">类型提升规则</a>，因为 640320.0 的类型是 <code>double</code>，所以它参与的运算的结果也被提升成了 <code>double</code> 类型。</p></li></ul><p>什么时候不提升：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2147483648</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">1.0</span> + a * a;</span><br></pre></td></tr></table></figure><p>由于运算优先级的关系，这里首先执行 <code>a * a</code>，两者都是 <code>int</code> 类型，于是得出了一个溢出的 <code>int</code> 类型结果，再与 1.0 相加（而不是先被提升成 <code>double</code> 类型再相乘。</p><h3 id="白给示范"><a href="#白给示范" class="headerlink" title="白给示范"></a>白给示范</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> pi_1 = <span class="number">16</span> * atanf(<span class="number">0.2</span>) - <span class="number">4</span> * atanf(<span class="number">1.0</span> / <span class="number">239</span>);</span><br><span class="line">  <span class="type">double</span> pi_2 = <span class="built_in">log</span>(<span class="number">1.0</span> * <span class="number">640320</span> * <span class="number">640320</span> * <span class="number">640320</span> + <span class="number">744</span>) / <span class="built_in">sqrt</span>(<span class="number">163</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.15lf\n%.15lf\n&quot;</span>, pi_1, pi_2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.141592741012573</span><br><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure><blockquote><p>为什么差这么多？</p></blockquote><p><img src="image-20211025012134558.png" alt="2"></p><p><code>double</code> 的精度比起 <code>float</code> 不知道高到哪里去了。。。</p><h2 id="Planck"><a href="#Planck" class="headerlink" title="Planck"></a>Planck</h2><p>错误点比较集中，许多同学误用 <code>%.3g</code> ，但这个输出格式：</p><ul><li>并不都输出科学计数法</li><li>还会砍末尾 0 造成有效数字位数不对</li></ul><p>手册描述为证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 <span class="built_in">printf</span></span><br></pre></td></tr></table></figure><p><img src="image-20211025013753854.png" alt="image-20211025013753854"></p><blockquote><p>double 类型的参数会以 f 或 e 格式输出。数字指定有效数字位数，默认 6 位；如果指定 0 为，则输出 1 位。如果指数 &lt; -4 或 &gt;&#x3D; 精度则以 e 格式输出。<strong>分数部分的结尾 0 会被移除</strong>。小数点只会在其后至少跟随 1 位数字时出现。</p></blockquote><p>正确的做法：使用 <code>%.2e</code></p><h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p>常见错：没有把题目指定的所有输出格式都实现，可能是因为年份前补 0 会显得非常奇怪。</p><p>奇怪错误1：strncpy 并不自动添加字符串末尾 0，字符串又开小了，导致字符串全连在一起。示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> weekday[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> w[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, weekday);</span><br><span class="line">    <span class="built_in">strncpy</span>(w, weekday, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="image-20211025014855566.png" alt="image-20211025014855566"></p><p>以下讲解看不懂也没关系：</p><p>函数执行的时候，局部变量占用的是栈区内存。而栈区内存的使用是从高地址向低地址。所以先创建的变量就排在后创建变量的后面。</p><p>比如我们假定栈的空间是从（十六进制） 0x100 开始，那么定义了 <code>char weekday[10]</code> 后，它占用 10 字节，于是我们往前推 10，<code>weekday</code> 字符串的起始位置就是 0x100 - 10 &#x3D; 0xf6。</p><p>定义 <code>char w[3]</code> 则 <code>w</code> 的起始位置是 0xf3。</p><p>此时内存的状态是这样的，空格代表内容未知：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><br><span class="line"> f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff  100</span><br><span class="line">|     w     |                weekday                |</span><br></pre></td></tr></table></figure><p>读入了 <code>weekday</code> 之后，则是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   |   |   | S | u | n | d | a | y |\0 |   |   |   |   |</span><br><span class="line"> f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff  100</span><br><span class="line">|     w     |                weekday                |</span><br></pre></td></tr></table></figure><p>在进行了 <code>strncpy</code> 之后，由于 <code>strncpy</code> 没有添加末尾 \0 的行为，则变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| S | u | n | S | u | n | d | a | y |\0 |   |   |   |   |</span><br><span class="line"> f3  f4  f5  f6  f7  f8  f9  fa  fb  fc  fd  fe  ff  100</span><br><span class="line">|     w     |                weekday                |</span><br></pre></td></tr></table></figure><p>而对于 <code>printf</code> 来说，判断一个字符串结束的方式是遇 \0 则停止。于是输出了 ‘SunSunday’ 这样的结果。</p><p>为了避免，我们只要：</p><ul><li>定义 w[4]，留出末尾 0 的空间</li><li>手动设置 w[3] &#x3D; 0</li></ul><p>关于字符串的末尾 0，在第二周的作业中出现的错误则更是重量级。</p><h2 id="Weekday"><a href="#Weekday" class="headerlink" title="Weekday"></a>Weekday</h2><p>提交通过率最低的一题，仅 18.3%。</p><blockquote><p>这题有我们的失误，一是一开始数据出错了，二是我们假定了年份是 4 位数的。对于 3 位数年份，前两位则不是 Y &#x2F; 100 了。</p></blockquote><p>主要的问题是看漏题目的一个条件导致运算错误。</p><p>常出现的错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w = ...; <span class="comment">// a long formula</span></span><br><span class="line"><span class="keyword">if</span> (w &lt; <span class="number">0</span>) w += <span class="number">7</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, w % <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>这里注意到了条件，试图解决，但解得不是很决。<code>w += 7</code> 后，<code>w</code> 依然可能是负数。那么 <code>w % 7</code> 就依然是负数。</p><h3 id="重量级代码"><a href="#重量级代码" class="headerlink" title="重量级代码"></a>重量级代码</h3><p>足足写了 4 KB</p><img src="image-20211025021128332.png" alt="image-20211025021128332" style="zoom:33%;"><p>学计算机的目标就是让计算机替我们做事。这里完全可以写得更加简洁。比如 214、245 这种数字是根本不需要自己去计算的。</p><h2 id="Quine"><a href="#Quine" class="headerlink" title="Quine"></a>Quine</h2><p>在排除了各种偷鸡写法之后，现在只能在已知的正确代码上修改才能得到一份 <strong>事实上错误 但 判题机答案正确</strong> 的代码。</p><p>具体的评测思路是：将你的 output 放到 .c 文件中，再编译运行一遍得到新的输出。这个新的输出应该与你的输出也保持一致。（你的代码正确的必要不充分条件）</p><p>这里贴出 Special Judge 的源码。欢迎<strong>有闲工夫的人</strong>想点别的花样来绕过这个评测，如果对这份代码理解上有问题请戳作者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Author: Tilnel</span></span><br><span class="line"><span class="comment">   Date: 2021-10-14 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> code[<span class="number">4096</span>];</span><br><span class="line"><span class="type">char</span> output[<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// inf out ans</span></span><br><span class="line">    FILE *ouf = fopen(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(ouf)) != <span class="number">-1</span>)</span><br><span class="line">        code[i++] = ch;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    code[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> dir[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(dir, <span class="string">&quot;test-XXXXXX&quot;</span>);</span><br><span class="line">    mkdtemp(dir);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> file[<span class="number">24</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;%s/main.c&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(file, O_CREAT | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">    write(fd, code, i);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;gcc -D__FILE__=NULL %s -o %s.out&quot;</span>, file, dir); <span class="comment">// 卡掉了使用 __FILE__ 的做法</span></span><br><span class="line">    <span class="type">char</span> out[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(out, <span class="string">&quot;./%s.out&quot;</span>, dir);</span><br><span class="line">    </span><br><span class="line">    system(cmd);</span><br><span class="line">    FILE *fp = popen(out, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(output, i, <span class="number">1</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(code, output, i)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 助教工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为自己献上鲜花</title>
      <link href="/20210611-buy_flower_for_me/"/>
      <url>/20210611-buy_flower_for_me/</url>
      
        <content type="html"><![CDATA[<p>昨下午3点开始听卡门，躺在床上，以为自己至少能听到爱情像只自由鸟的唱段，但刚听到街童合唱那里就完全昏睡过去了。差不多五点的时候被新东方一个电话吵醒，强撑着不耐烦应付完之后（我他妈怎么就不知道可以挂电话呢，rnm）一看手机，已经开到第三幕了。</p><p>这下午本来的计划是要骑车出去散散心的。昨天晚上骑车出去了，晃荡了半天，唯一见到的新景色还是因为脑子抽了绕着金鹰的周围走，第一次到达金鹰湖的那一头。实在不是很满意，仙林大道的景色一成不变，骑车都快要看腻了。结果下午一场雨给我浇灭了，直接回宿舍躺着去了。</p><p>我们的女主人公昨天收到了一束满天星并大方地在朋友圈和空间都展示了。合理推测是女同学送的，但是性别无所谓，就算某天我被告知她和女同学相爱了我也毫不意外。于是这束花在我这里就坐实了是爱情的表示。这让人怎么可能痛快得起来！赶紧出去溜达去！这就有了昨晚散心一事。</p><p>骑在路上我问问自己说，要不要自己也买一束表示自己逝去的爱情（AC娘_扇子笑）带回学校去，挂到路灯上让大家自己一人取一枝。想到这里突然觉得还有点浪漫的，然后严词拒绝了自己，为啥花这冤枉钱<del>（明天就要花这冤枉钱了）</del>。</p><p>我从床上爬起来，跑到菜市场去，切了30块钱牛肉，拿了4块烧饼准备当晚饭。看到菜市场里的花店，我还是不由自主地往那边瞟了几眼。我想，我不送花，要么为自己插点花？就当是美化一下宿舍。挑了一把Carnation，挑了一个绿瓶子，一共花了50（败家）。</p><p>========转一下视角========</p><p>男孩背着包，提着装着花瓶和花的红色塑料袋一路骑车回到学校。似乎为了向大家展示这美丽的花，不惜绕路去了好几个地方。他走进超市，超市里的每一双眼睛都多少被男孩手里的几支花所吸引。在这学校里，鲜花兴许还是太少了！男孩这么想。</p><p>========我果然不会写东西，还是爬了========</p><p>突然不想写，放个图吧。无奖竞猜，sbw这几支花能活多久：</p><p><img src="2021-06-11-IMG_20210611_075703-1.jpg" alt="IMG_20210611_075703-1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逃向大他者</title>
      <link href="/20210609_escape_to_big_other/"/>
      <url>/20210609_escape_to_big_other/</url>
      
        <content type="html"><![CDATA[<p>她对我说，“不用了”。</p><p>我反复品尝着这句话。既干脆，又委婉，表面拒绝的是一次邀请，实际上也拒绝了我。我期待她再说点什么，但是十分钟过去，聊天窗口并没有一点变化。</p><p>于是我回：那行，就不打扰了。</p><p>我抱着从此当一个死人的心态关掉了聊天窗口。但也有点担心以后万一老在罗森碰头要怎么办。各种奇怪的架空场景在我脑海里一遍遍地演习着，就像是真的会发生一样。</p><p>“够了！”我打住了所有的思维，潜进qq群里，吼了一声。我下定决心，今晚要喝个痛快。</p><p>是忙碌的周二。以为能有一两位哥出来光喝酒吹吹牛逼就差不多了。也预想可能就是沉默地坐着，时不时默契地端起杯喝两口闷酒，然后归于沉默，就这样熬到11点。我完全不害怕这样的可能性，毕竟几个男生凑在一起又能干点啥呢？在体育场上键政真人快打？我习惯了在各种社交场合当中沉默，甚至对于沉默感到有些亲切。</p><p>我同样是耐不住寂寞的。也有不少人对我的评价是，一旦兴头起来了情绪就会变得很激动。在我的会议里，有特别激动的时候，就是金陵中学130周年校庆的时候，黄洪瑞从一中赶过来。那时候的我可真是开心，放开了大嗓门和化竞的同学谈笑风生，吵得不可开交。我到现在也还是一样地情绪化，遇到特别开心的事情还是压不住嗓门，乍乍乎乎的。</p><p>不成想，没一会儿就有几位哥回应了。波波、yuls、zt、zht、ljr。就因为突然的一句话，六个人凑在了一块。</p><p>我带着酒和花生，波波买了吃的，zt背着桌游，以前进四的速度奔向炜华运动场。</p><p>桌游很好玩，Asahi很好喝，Kirin的苦味突然能够接受了；波波带的串也很香，但是鸭翅鸭脖就不是很方便用手去抓着吃。这一两小时我什么都忘了，啥事也都没担心，大脑里什么都不剩了。美中不足就是，啤酒这玩意，喝多了只会让人想上厕所，玩桌游就得让哥几个等着，相当过意不去。</p><p>等到了11点，和大家挥手了，觉得没喝痛快，跑到Lawson又整了两罐。这大晚上11点，我倒开始担心她突然出现了。她似乎常来这里。</p><p>周日，合唱团的演出结束，吃了结团的蛋糕，换回自己衣服出了准备室，看到一队人扛着国旗出门。必然是国旗班了，大晚上九点半了还要训练。我决心跟过去看看，一看就看到11点，可算是结束了，我和她打了招呼后到她宿舍附近的地方等她。</p><p>“我就不拐弯抹角的了。嗯……我觉得你挺棒。”我以一个自认为还比较合适的方法表达了我的感情。</p><p>她转头，并没有立即回应这件事。“我先去罗森买点吃的。”我就在门外等着。</p><p>等着的这一分钟，大脑也没有闲着。有在想，她出来会怎么回答我；失败的预想多于成功的预想，算是自己给自己打预防针。她出来之后，我就跟在后面走到她宿舍的门口。</p><p>“那个，我先回去了……”她看起来也有些不知所措。我稍微有点着急：“你不打算回答点什么吗？”她想了一会儿，我又觉得我好像造成了一些奇怪的压迫感，于是说：“那你再想想，今天先回去吧！”她也这样同意了。</p><p>我跨上我的小车，一路唱着小曲，站着骑回去了。我仿佛感到自已有了一些勇气，能够面对我的“little object a”了。</p><p>但今晚，我这点勇气又消磨殆尽。我疯狂地逃向Big Other，逃向那个想象中的但实际上并不存在的共同体。这一刻我觉得我是撕裂的：理性上认识到了符号秩序、性化秩序的荒谬，但情感又受到这套荒谬秩序的支配。</p><p>挑了两罐酒，其中就有刚才没有喝到的Pilsner，并没有碰到她。大老远的跑到香雪海，坐在亭子里，掏出还没开封的一袋花生，嘴里却感到前所未有的苦。</p><p>以前的我甚至喝不下Kirin。高中某日回家，从超市买了一罐Kirin，到走到家，其苦味让我喝了大半罐，最后一点直接丢掉了。后来都喝清爽型的啤酒，为此还很久都没有喝过青岛啤酒。而今天这罐Pilsner让我回想起了那时的感觉。</p><p>二话不说，啥味道也不尝，直接吨吨吨往里灌就完事了。灌了大半，肚子开始胀。我就劝自己：“别他妈搁着虐待自己了，赶紧扔了回去吧。”</p><p>2公斤下去，这下骑车真是酒驾了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对于招生宣传节奏的一点看法</title>
      <link href="/20210608_tower/"/>
      <url>/20210608_tower/</url>
      
        <content type="html"><![CDATA[<p>核心争议：为什么总是由女性作为“被审美的对象”；为什么用女性的审美形象来代表NJU的审美形象</p><p>首先文案必然是欠考虑。不必看微博，只要看看这件事在校内引起的争议，听听认识的女性的真实想法就能理解这样的抗议是完全正当的</p><p>虽然有节奏，但是诉求的表达并不够。表达“不适”，顶多让学校撤销一次文案。但是对审美对象的需求是无法避免的，未来一定还会面临一样的情况</p><p>所以：要把男性拉下水，成为被审美的对象</p><p>使用例：我推荐大帅比 yls 也去拍两张海报为学校代言（（</p>]]></content>
      
      
      <categories>
          
          <category> 观点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OS MiniLab2 Libco实验感想</title>
      <link href="/20210531_minilab2/"/>
      <url>/20210531_minilab2/</url>
      
        <content type="html"><![CDATA[<p>Libco真是个好实验啊（迫真）</p><p>详尽的框架代码（指hello world）</p><p>不过实验讲义写的还是很清楚</p><p>最终采用的方案：</p><ul><li>类似于操作系统的进程切换，任何进程之间切换都必须要经过主进程，并且强制运行一次 <code>co_wait()</code> 中的循环</li><li>用 <code>malloc()</code> 和 .bss 方式分配栈空间在 OJ 上未见明显差异（但是有个坑，下面细说）</li><li>完全随机调度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当前工作环境的维护问题</title>
      <link href="/20210519_maintenance/"/>
      <url>/20210519_maintenance/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wiki.archlinux.org/title/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">ArchLinux System Maintenance Guide</a></p><p>感觉上来说，这个学期我工作的主线就一直是这件事。不断地配置环境啊，折腾备份、同步的东西。但是主要的工作感觉迟迟没有展开。磨刀磨了一学期，感觉快要开始了（快要结束了）。</p><p>谈谈系统维护，首先是从grub命令行引导进ArchLinux，这个已经演习了一万遍了。不过未来要是没有一个grub命令行给我操作的话，估计就要插入安装介质了。</p><p>恢复进系统以后就：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-install --efi-directory=/efi --bootloader-id=ArchLinux</span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>这样把grub装上就好 <del>下次还非正常关机，继续丢引导</del></p><p>其实Arch的配置并没有什么好讨论的，只要所有的包啊都在就行了。这里就贴出那个README</p><p>Update lists: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Qqe &gt; Archpkglist.txt</span><br></pre></td></tr></table></figure><p>Install packages from the list:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S --needed - &lt; Archpkglist.txt</span><br></pre></td></tr></table></figure><p>Filter out AUR packages</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S needed $(<span class="built_in">comm</span> -12 &lt; (pacman -Slq | <span class="built_in">sort</span>) &lt; (<span class="built_in">sort</span> Archpkglist.txt))</span><br></pre></td></tr></table></figure><p>Gitlab backup script</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># need sudo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $(<span class="built_in">whoami</span>) != <span class="string">&quot;root&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Need run as root</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Gitlab</span></span><br><span class="line"><span class="built_in">rm</span> /var/opt/gitlab/backups/*.tar</span><br><span class="line">gitlab-rake gitlab:backup:create</span><br><span class="line"><span class="built_in">cp</span> /var/opt/gitlab/backups/*.tar /mnt/e/Gitlab/</span><br><span class="line"><span class="built_in">cp</span> -r /etc/gitlab /mnt/e/Gitlab/</span><br><span class="line"><span class="built_in">chown</span> -R kaguya:kaguya /mnt/e/Gitlab</span><br></pre></td></tr></table></figure><p>Gitlab recover</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># need sudo</span></span><br><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br><span class="line"></span><br><span class="line"><span class="comment"># need package under /var/opt/gitlab/backups/*.tar</span></span><br><span class="line">gitlab-rake gitlab:backup:restore BACKUP=<span class="variable">$TIMESTAMP</span><span class="comment"># TIMESTAMP TBD</span></span><br><span class="line"><span class="comment">## OR</span></span><br><span class="line">gitlab-rake gitlab:backup:restore<span class="comment"># only have one bak</span></span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$GITLABCFG</span> /etc/gitlab</span><br><span class="line"></span><br><span class="line">gitlab-ctl start</span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>另外有 Ubuntu 服务器主机的每周备份：</p><p>Ubuntu backup: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> time tar cvpjf /mnt/e/$(<span class="built_in">date</span> -I)_backup.tar.bz2 --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/dev --exclude=/snap --exclude=/usr/var/lib --exclude=/home/kaguya/PicUploader/uploads/WHITE\ ALBUM2\ ～closing\ chapter～\ \[汉化硬盘版\].zip / 1&gt;/mnt/e/sysbak.log 2&gt;/mnt/e/sysbak.err &amp;</span><br></pre></td></tr></table></figure><p>排除 &#x2F;dev &#x2F;mnt &#x2F;sys &#x2F;proc &#x2F;tmp &#x2F;lost+found 之类的分区（mnt根本就打不下）</p><p>恢复就是把包copy一下，然后解包到 &#x2F;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> time tar cvpzf *.tar.bz2 -C /</span><br></pre></td></tr></table></figure><p>这个认为其实可以不在一个完整系统下做。只需要有一个ext4盘，挂到安装介质的 &#x2F;mnt 就可以开恢复了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklost+found</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对一个月的展望</title>
      <link href="/20210516_foresee_on_may16/"/>
      <url>/20210516_foresee_on_may16/</url>
      
        <content type="html"><![CDATA[<p>这一个月基本上是这一学期有效学习的最后一个月。满打满算也就是4周。6.16之后估计就要开始期末考试之类的，所以绝对不能放松了。</p><p>来看看我都挖下了什么天坑（</p><p>1、本次总结的最大头：</p><p>操作系统</p><ul><li>Lab0</li><li>Lab1</li><li>Lab2</li><li>M2</li><li>M3</li><li>M4</li></ul><p><del>我好勇哦</del> 还不赶快去补天。。</p><p>2、问题求解</p><p>事实上只有1次作业</p><p>但是前面的知识基本没怎么学会。。。</p><p>3、概率论与数理统计</p><p>建议整本重新学</p><p>4、数理逻辑</p><p>这个好像不太要担心的？按照我的突击速度，期中好像只花了一夜时间就结束了。</p><p><del>5、没有5</del></p><p>这些几乎就是全部了。MiniLab是好解决的，那么Lab要按照比一周一个还快的速度推进（你可千万不要真的拿一周时间来写Lab0）</p><p>下面是一些个人要求。</p><p>5、身体素质</p><p>2400米测试迫在眉睫，我还是建议自己要好好睡觉。今天已经通宵了，但是白天决不能睡觉。（我也没时间睡）。趁热打铁解决了OJ，然后去参加下午的训练，晚上去赴约就OK了。赴约回来切记好好睡觉。</p><p>之后每天就要逐步加练，基本隔天跑一个3km，以14min为目标这样子。初始的速度可以挂在16min，慢慢加就完事了。如果计算没有问题，最后考试是可以11.2min解决问题。</p><p>健身的话，在跑步的隔天来做。证每周3回，胸背腿就好。不熟悉可以去4组团。</p><p>6、欲望的虚无的核</p><p>每天完成洗衣服这件事；</p><p>每天必到图书馆坐一小时或看书或别的，就算没做什么事光思考也行。。。</p><p>7、自学任务</p><p>学会python和rust，这俩要到能写OJ的程度</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>未子劝学：为什么要好好学专业课</title>
      <link href="/20210516_weiziquanxue/"/>
      <url>/20210516_weiziquanxue/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Sh411S7Kk">原视频</a></p><p>有家长向未子反映，小孩看了wmz的视频以后不愿意读书上学了。故有这一期未子劝学。</p><p>核心的思想有几点：</p><ul><li>应试教育学的95%东西是必须的。这些东西能够锻炼人的能力，并且是能够运用上的。</li><li>在应试教育中取得成绩，事实上是用12年换取发展权和未来60年内的自由时间。</li><li>人的智力是可以一直保持、一直发展的。马克思直到晚年的思想都很猛。</li><li>学哲学的，要有聪明头脑。难道还学不会应试教育的知识吗？</li><li>应试教育的东西是必须的。如果因为其中的一些糟粕而舍弃掉必须的东西，那这个筛子的设计者不就得逞了吗？</li><li>语文锻炼你辨别假话的能力、给你一个情感宣泄&#x2F;释放的窗口（读诗写诗）；数学是文明的源语言，将可以动员为工程师；英语解锁了国际学术共同体、技术共同体…通过学英语去点开很多技能，是成为左翼理论家必备的。</li><li>理论能力、设计能力、编程能力、工程能力、组织能力、宣传能力、行动能力（体力）、公关能力。</li></ul><p>作为掌握了先进思想的左翼，更要对自己严格要求，将学习作为自己的首要任务。</p><p>列宁：我们一定要给自己提出这样的任务:第一,学习,第二是学习,第三还是学习。</p><p>我说：学习！学习！他妈的还是学习！</p><p>人才越来越多，声量越来越大，才能对革命作出贡献。</p><p>保存自己才能消灭敌人。</p><hr><p>我根本不认识你，也不懂得如何认同你。你们为何却都认得我？因我是水气中的尘土，助你们这些毫无瓜葛的匪类们凝结了么？云、泥都能够汇聚水，却无法令它们流动与坚硬。<br>而我不过是空中的一粒微尘罢了！<br>不必向我汇聚，要向着自己，汇聚为澄澈与完全的自己，然后，让我们在地面见，在山川、河流、平原、深谷，在大海见，在沙漠见！<br>至于天空？我们既可重逢，即刻冲锋。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毛选分享发言</title>
      <link href="/20210514_maoist/"/>
      <url>/20210514_maoist/</url>
      
        <content type="html"><![CDATA[<p>我的读书分享，是要分享《毛泽东选集》这本书。</p><p>这本书一共分为五卷，其中第五卷是社会主义革命和社会建设时期的著作。1967年7月中共中央决定出版第五卷，直指当时文化大革命的政治现实。1982年因该版本与《关于建国以来党的若干历史问题的决议》和当时实行的改革开放政策不符，第五卷已停止发行，后续各卷也从未出版。</p><p>为什么停止发行？因为第五卷是大“屠龙术”。你学会了里面的思想，估计立马就要反对现行的某些政策。所以不让看啊。</p><p>毛泽东思想是马克思列宁主义的一个合法分支。（另一个分支是托洛茨基主义）。</p><p>毛主义者认为，毛泽东思想的贡献包括：矛盾论，知识论；群众路线；新民主主义理论，殖民地半殖民地的革命道路，三大法宝——党的建设、人民军队和统一战线；持久人民战争理论和军事战争原则的发展；无产阶级政党的组织原则的发展（通过对路线斗争的认识），整风运动，批评和自我批评；正确处理社会主义过渡时期的矛盾；&#x3D;&#x3D;最后也是最重要的是&#x3D;&#x3D;，为巩固社会主义、反对现代修正主义和防止资本主义复辟，而发展出的无产阶级专政下&#x3D;&#x3D;继续革命&#x3D;&#x3D;的理论与实践。</p><p>什么是继续革命？</p><p>一个无产阶级专政的社会主义国家建立了，难道内部的敌人就不存在了吗？在《一九五七年夏季的形势》中，毛泽东说：“这一次批判资产阶级右派的意义，不要估计小了。这是一个在&#x3D;&#x3D;政治战线上和思想战线&#x3D;&#x3D;上的伟大的社会主义革命。单有一九五六年在&#x3D;&#x3D;经济战线&#x3D;&#x3D;上（在生产资料所有制上）的社会主义革命，是不够的，并且是不巩固的。匈牙利事件就是证明。必须还有一个政治战线上和一个思想战线上的彻底的社会主义革命。共产党在民主党派、知识界和工商界的一部分人（右派）中当然不可能有领导权，因为他们是敌人；在多数人（中间派）中的领导权不巩固；有些文教单位还根本没有建立党的领导。必须建立对中间派的巩固的领导权，并且尽可能早日巩固起来。资产阶级和资产阶级知识分子对共产党不心服，他们中的右派分子决心要同我们较量一下。较量了，他们失败了，他们才懂得他们的大势已去，没有希望了。只有在这时，他们中的多数人（中间派及一部分右派）才会逐渐老实起来，把自己的资产阶级立场逐渐抛弃，站到无产阶级方面来，下决心依靠无产阶级吃饭。少数人至死不改，只好让他们把他们的反动观点带到棺材里去。”</p><p>毛泽东认为，任何社会主义革命都有可能失败，因为社会主义是一个过渡阶段，因此仍然是一个阶级斗争时期，革命阶级还在试图完成其霸权（hegemony）。我们也懂得，革命是经常会失败的，哪怕是在社会主义阶段前。这并不是因为革命者缺乏对布尔什维主义的真正理解，也不是因为他们缺少一个有着魔法般的真正的民主集中制的政党，而是因为&#x3D;&#x3D;资本主义复辟本身就内禀于（immanent）社会主义革命的矛盾中&#x3D;&#x3D;。&#x3D;&#x3D;党本身也有路线斗争&#x3D;&#x3D;，有时最能代表资本主义道路的路线反而会胜利。</p><p>阶级斗争在无产阶级专政下继续进行的理论既解释了斯大林时期的失败，也解释了赫鲁晓夫时期的修正主义。斯大林不明白作为社会主义革命天然组成部分的资本主义复辟的可能性，也就是说，社会主义仍然是阶级社会，反革命的政治路线来自于仍保留在上层建筑中的资产阶级（甚至半封建）意识形态。因此，围绕斯大林聚集起来的力量，&#x3D;&#x3D;并不把那些在党内和苏联社会中可能或可能没有采取资产阶级政治路线的人看作是社会主义条件下必然发生的事情&#x3D;&#x3D;，而是简单地把这些个人、团体和思想看作是外国渗透或蓄意叛国的结果。此外，他们没有认识到&#x3D;&#x3D;党本身将是一个有机的路线斗争的战场&#x3D;&#x3D;。这反映了在社会主义条件下的阶级斗争的主导地位，&#x3D;&#x3D;党的领导层往往会存留资产阶级意识形态&#x3D;&#x3D;。这个理论最能解释为什么斯大林选择的继任者赫鲁晓夫也可以是修正主义者，尽管赫鲁晓夫最初很乐意在斯大林时期执行肃反和政治监察政策。这不是因为他是外国特务（如“斯大林主义”会假设的那样），也不是因为他是官僚（如托洛茨基主义会假设的那样），而是因为&#x3D;&#x3D;资产阶级意识形态和由此而来的修正主义总是具有强烈吸引力&#x3D;&#x3D;——特别是对处于党的领导职位上的人。</p>]]></content>
      
      
      <categories>
          
          <category> 观点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>想读书</title>
      <link href="/20210509_to_read/"/>
      <url>/20210509_to_read/</url>
      
        <content type="html"><![CDATA[<p>最近一直处于“整点没用的”的状态：不管做什么事情，都和当下必须要做的事情没有任何关系。而且在这基础上，兴趣点也远离了计算机。</p><p>造成我突然想读书的主要原因，是过于长时间的压抑。曾经我把没有好好读书归结于“时间都花在一些没什么用的事情上了”。而最近发现的是：摸鱼是不可避免的。</p><p>精神力是有限的，而做多少事就要消耗多少精神力。在精神力消耗完的情况下还要再凭空抽出来满足一些极需要精神力的课余活动，本身就不现实。所以恰恰是真的没有精力去面对严肃的书本。</p><p>而今天事情发生了变化：反正已经不想在专业学习上花费精力了，不如暂时把这些精力花在想做的事情上。比如没有读的旧书，也可以捡起来读一读；想写的东西，可以学着写一写。</p><p>还有两件事：一是为了写一篇文章，我感到自己的水平实在是低，需要学习一些文学方面的东西；另一是为了未明子的《面纱》的解读，去读一读英文版的原作。</p><p>在这篇文章开始之前，我在发疯一样地在宿舍找我的Kindle。手头弄了一堆电子书，正要把电子书装进去慢慢看。但我估计我这学期是没把Kindle带过来。这时我才意识到，自己实在是个傻子——我就身处学校。为什么我不去学校的图书馆看一看呢？有什么书是南京大学图书馆都没有的？</p><p>这下找到一条明路了。一直把图书馆当作自习的地方，从根本上就错了。图书馆就应该是读书的地方！</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的表达欲</title>
      <link href="/20210506-before_os_midterm/"/>
      <url>/20210506-before_os_midterm/</url>
      
        <content type="html"><![CDATA[<p>这学期在社交网络上的行为发生了一些变化，总结下来有这样几条：</p><ul><li>发言的频次稳定下来</li><li>发言的质量在上升</li><li>总的来说表达欲是被克制的</li></ul><p>表达欲这种事，不仅要看社交网络上的行为，还要看实际生活当中。譬如我现在的状态是一天下来根本说不了几句话。一般的调查认为，普通男性一天下来要说2000-4000个字，但是对于我来说，仅计算发出声音的说话，这个数字可以&lt;1000。</p><p>如果一天和舍友没有什么能唠的，那就纯不怎么说话；至于外出独来独往根本不太需要。</p><p>现实生活中说话少了，难免要找出口。于是网络就成了表达欲的主要发泄方式。无论是QQ里水群，发空间，发推特，还是像现在这样码博客。</p><p>要论哪种途径更能起到发泄的效果，应当是碎片化、时效性强的朋友圈式社交媒体比较合适。但人多眼杂，发文字的时候要照顾到看的人的心情，还要照顾到自己的心情：给话里添点趣味，讨好别人，再叫别人来讨好自己。不似在这里絮絮叨叨，想到哪里就写到哪里。玩朋友圈的，混久了，很多工作容易变成刻意地装点门面，说白了就是做给别人看的。慢慢地就失去了表达的本意。</p><p>写长文章絮叨有一个好：没人乐意看你搁着瞎bb，随手点个叉就走了，就能说得自由点。也有一个坏，就是没人会看。没人看也不叫表达。所以这个小博客，我是既希望有人来看，又不希望有很多人来看，更不希望某些人来看。这和锁空间、屏蔽朋友圈是一个道理。</p><p>但是我的空间是不锁的。很久以前我就在想，凭什么要锁呢？在保护好自己隐私的情况下，不就是应该亮出自己要表达的东西么？</p><p>最近有人给我留了QQ小号，空间里面有点东西，我一看，差不多是类似于小孩子的秘密基地那种。也许里面藏着什么秘密，但是我看了感觉没啥。我空间里也发过一些东西，写得不怎么样，而且文字里的当事人一眼都能看明白那种。咬咬牙发出去了，最后发现根本没什么。</p><p>说白了，说出来的能叫心里话不？以前对这句话嗤之以鼻，现在想想，所谓说出来是要有听者。既有听者，说话必然相当克制。但凡有一点怂了，就根本不用担心什么说漏嘴，因为自己心里那道防线就过不去。</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>眠れない、そしてJKを見ました。</title>
      <link href="/20210505_nemurenai_soshitejk/"/>
      <url>/20210505_nemurenai_soshitejk/</url>
      
        <content type="html"><![CDATA[<p>昨天夜里实在是没睡什么觉。要说原因可能就是因为我11点的时候主观上想睡觉，客观上我一直在看未明子、刷推。 本来到两点钟就应该睡觉了，然而谁知道我哪根筋搭错了，跑去看了看这几天有没有什么消息没有回。</p><p>结果您猜怎么着，还真就有一条5月2号的消息没有回，是一条学妹的消息。回想当天，我凌晨5点睡到11点，然后下午在床上就嗯躺着， 抱着笔记本以龟速在写一点点文字。吃完晚饭就又陷入了长达16小时的昏睡。</p><p>想想这时间跨度，不禁受到了一点惊吓，赶紧朝对方回复了，尽管是时隔三日。</p><p>平时我都是一个比较弧的人，回消息基本上都是随缘。平时发生这种事情我都是不当回事。坏就坏在这次学妹发的消息非同一般。要我比喻的话，就是<em><strong>小木曾</strong></em>在公园的秋千旁对<em><strong>北原春希</strong></em>说，“今晚让你见识一下真正的小木曾”。</p><p>我的DNA立马就动了起来，我可是资深白学家。这句话充分引起了我的兴趣，我本该第一时间就能够得到真相。但是没想到——因为高强度睡觉+玩疯了，我的回复来的很迟。对方毕竟是高中生，不能天天带着手机，意味着我至少要到周末才能得到回复，这也算是我弧人的报应吧。</p><p>事情坏起来了。可能是白色相簿玩多了，我一闭上眼睛就开始想象后续的剧情 ，这下睡不着了。😅</p><p>说起学妹，我们本来是没有机会认识的，因为她入学那年，我刚刚好就毕业了。所以应该是在她这届入学的一个学习经验讲谈的时候，有那么几个同学找我来要QQ号的其中一个。从低我3个年级这个意义上来说，也很像是<em><strong>杉浦小春</strong></em>（</p><p><strong>====先更到这里====</strong></p><p>接着写点：</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不想干活所以随便写点东西，一直写了4天才发出来</title>
      <link href="/20210505_retire/"/>
      <url>/20210505_retire/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说到底还是条懒狗</p></blockquote><p>1号3号和初中的hxd出去胡吃海喝，在karaoke合唱了一些经典曲目，包括但不限于薔薇より美しい、Never Gonna Give You Up、届かない恋。</p><p><img src="2021-05-02-IMG_20210502_153030.jpg" alt="eat"></p><p><img src="2021-05-02--63ef7a57fb7dd640.jpg" alt="p2"></p><p><strong>恰肉还是爽啊</strong></p><p>4号又和高中同学出去剧本杀，跑了一个又混乱又狗血的本子，4个半小时，我受不了力，最后全员自爆才结束了游戏。</p><hr><h2 id="工作方面的事"><a href="#工作方面的事" class="headerlink" title="工作方面的事"></a>工作方面的事</h2><p>上个月要交给CS的东西才刚刚开了一个头。干活是不可能干的，这一个月基本上都是在摸鱼，OSlab的进度落下了，问题求解的Lab也是，OOP根本学不会。</p><p>与此相对的，上个月净在整一些不太有用的东西，比如blog，比如gitlab（开了仓库，但是却不上传代码，xswl），再比如聊天室（危）。</p><p>虽然看起来弄了不少东西，但都不太正经。而且说实在的，搞这些东西还是在逃避真正重要的任务。就算是认真地做了重要的事情，也不会没有时间来搞定这点小事。</p><p><del>世界上只有一种英雄主义，就是工作压到双膝了，水淹到脖子了，还能抓紧时间摸个鱼。</del></p><h2 id="关于意识形态"><a href="#关于意识形态" class="headerlink" title="关于意识形态"></a>关于意识形态</h2><p>主要进展有两个，</p><p>一是弄清楚了，在实现自由解放的路上，极权作为手段的重要性。极权终会在自我否定中消灭。</p><p>二是看未师的视频，确定了自己对性别的态度。以前我也是持有类似的想法的，但是被搞对立的人整得有些动摇。这次听取了一个理论上的解释，使我自己信服了这件事。</p><p><a href="https://www.bilibili.com/video/BV1YZ4y1F7ve">【性的政治学】男权主义必然失败：“只有一种性别存在”——性多元主义与女性主义的联合之路</a></p><p>大意：</p><p>只有一种性别：+</p><p>死硬的男权主义者：认为自己的性别认同有形而上的依据，却以形而下的“阳具”作为实物载体，并且依托这个形而下的载体，划分出Masculine及其对立面Femiline，要求Femiline配合其形成这样的性别认同。</p><p>具体的体现：女性承担审美对象的功能。</p><p>为什么会有女权：女性的审美对象是女性本身，自我产生性别认同。</p><p>虚假的女权：把认同双方换个位置，继续玩这个荒谬的游戏。</p><p>真正的女权主义者：+</p><p>怎么做：拉拢不是“死硬的Capitalist”，让他们也成为审美的对象。</p><h2 id="再说回自身"><a href="#再说回自身" class="headerlink" title="再说回自身"></a>再说回自身</h2><p>差点想磕提升专注力的药。但是朝葵姐和我说这玩意会成瘾，而且还不如早睡早起建立身体机制来的靠谱，毕竟精力是不可能凭空跑出来的。这是很有道理。</p><p>回想起来其实这学期，一没怎么喝酒，二根本就没有喝过咖啡，三也没太喝过Monster。确实有可能是上个学期留下来的一点后遗症。。当然现在是要保持比较健康的状态了，不能这么年轻的时候就没有精神。</p><p>这学期其实本来是想到教室学习的，但是不知道我的大脑出现了什么问题。我感觉这次不能归结于单纯懒，应该找点更加深层次的原因才行。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>我们先来看一下5.3-5.5的手机屏幕时间统计信息：</p><p>QQ：7小时11分钟</p><p>twitter：之前卸掉了所以没显示，但是应该和QQ用的时间差不多久</p><p>bilibili：4小时31分钟</p><p>知乎：1小时49分钟</p><p>国际象棋：1小时26分钟</p><p>微信：1小时3分钟</p><p>Tape：这个居然有40分钟，但是已经没有人给我发过问题了，感觉匪夷所思</p><p>其实这些说是3天，可以说是两天。因为我是在5.5的上午写到这里的。现在由于通宵有一点小晕。。</p><p>事情就很明显了，主要问题就是水群刷推。这些是比较表面的。</p><p>具体到我到底看了点什么，包括以下：</p><p>1、qq主要水求问题解和20级匡院的群，主要话题是数码、摸鱼、ghs、政治</p><p>2、twitter则主要是看一些政治话题，另外搞点hs</p><p>问题主要是政治看得有点多。但是看完了以后学到了什么呢？我认为在经过中推圈几轮翻滚之后，对我有益的信息应该变少了。接下来应该主要以未明子的哲学视频为主，完善政治哲学方面的知识。</p><p>另外就是，水的很多数码、技术上面的事，其实根本就是同义反复（），所以尽量不要去跟这些话题。</p><p>到这里，还是非常的现象。我为什么会不停地看这些，但是根本不干活呢？</p><p><del>太jb烦了</del> 编程Lab令人头疼是真的。所以一直难以开始动工就是了。然后就落下的比较多了。</p><p>再往深入想一想，是不是根本就没有什么学习的动机？没有一点紧迫感是最要命的。近如现在是期中考试之前，我还是拿不出什么干劲来，甚至在考试前倒数第二夜通宵而什么都没有干。这种东西一旦松懈了，真的保不准什么时候才能把自己拉回正轨。</p><hr><h3 id="我给出的一点临时性的解决方案："><a href="#我给出的一点临时性的解决方案：" class="headerlink" title="我给出的一点临时性的解决方案："></a>我给出的一点临时性的解决方案：</h3><p>一是不用手机刷推特了。也不要再水群了，每天在20级群里面发个图就遁了。</p><p>二是期中考试过后就要好好睡觉，建立身体机制来保持较为良好的精神力。</p><ul><li>这可一点都不简单。有的时候自己想搞东西搞上头了，但是也要收住。我们在哲学上说，有限性是一个非常powerful的东西，甚至资本主义的秩序都是建立在各种有限性上的。</li></ul><p>三是为了免受各种消息的打扰，少发点动态吧，省得几秒就上去看一眼。。</p><hr><h3 id="一些长期性的东西："><a href="#一些长期性的东西：" class="headerlink" title="一些长期性的东西："></a>一些长期性的东西：</h3><p>一是多给自己上上紧箍咒。你难道没看到，五一出去玩的时候，wsy还在复习免疫学么？这样放松对自我的要求，怎么好意思待在南大呢？</p><p>二是要坚持哲学的学习。一方面审视自己，找出自身有什么毛病；另一方面坚定思想信念，获得精神上的动力。</p><p>三是，做任何事情都不要懒散；不要有一点不舒服就开始休息，要拿出顽强的意志力。多想想自己高考那阵子是怎么拼的，为什么现在不行？不要拿自己的年龄增长来说事，多鞭策自己。</p><p>四是要给自己创造良好的工作环境。有任何不舒服的地方短期要忍，但是长期的阻力不可估量。要多多改善环境，这才能保证高效。</p><p>比如，我现在虽然在打这段文字的时候感到有些疲倦，很想睡觉，但是还是能够坚持下来。不要一感到困就去睡觉，而是要和睡意的敌人搏斗。一上阵就缴械，感觉自己就不配叫合格的左翼。谨防在对待自己的事情的时候就变成右倾机会主义垃圾。</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于自由和极权的正确观点（转载）</title>
      <link href="/20210429_left_right_liberty_authority/"/>
      <url>/20210429_left_right_liberty_authority/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自知乎 <a href="https://www.zhihu.com/people/zhou-bo-wen-40">周博文</a> 的回答：<a href="https://www.zhihu.com/question/327694043/answer/1448756553">极左、极右到底是什么意思，看了好多网络搜索越看越迷糊，有通俗的解释吗？</a><br>转载许可：</p></blockquote><img src="https://files.tilnel.xyz/uploads/2021-04-29-repost.png" alt="repost.png" style="zoom: 80%;"><blockquote><p>所拟的标题，其原因在于答主阐述了“变革”的矛盾在于其自由目的与极权手段。以此将变革与“极权主义”所区别，击破保守的自由主义对于左派的“变革”力量的污名化。</p></blockquote><hr><p><strong>左&#x3D;激进</strong></p><p><strong>右&#x3D;保守</strong></p><p>极左&#x3D;极端激进</p><p>极右&#x3D;极端保守</p><p>直接代入公式不会错。</p><p>想通俗地稍微深入一点，往下看。</p><p><strong>左&#x3D;激进&#x3D;变革力量&#x3D;推动社会发展</strong></p><p><strong>右&#x3D;保守&#x3D;稳定力量&#x3D;保持社会稳定</strong></p><p>两者是矛盾的、冲突的，</p><p>两者又同时被社会需要。</p><p>就像开车一样，开得太快容易翻车，开得太慢又到不了终点。</p><p>说到这里，左和右，保守和激进的主体就很清晰了。“车”就是社会，“开车”就是社会运动（Social Movement），所谓左和右，就是车速快慢，即社会阶段运动。</p><p>那么这个速度是谁定的？</p><p>客观来说，是车的性能，也就是社会发展阶段，或者说生产力发展水平。</p><p>主观来说，是驾驶员，也就是占据统治地位的阶级。</p><p>在这个意义上，主观应该符合客观，而不是客观符合主观。驾驶员要就着车的性能开，一辆老旧破皮卡硬要开到200公里，那是会散架的，同理，柯尼塞格在八车道高速公路开20公里，无疑是一种极大地浪费。</p><p>问题是社会运动的进程，<strong>车能开多快、应该开多快，不同人有不同的理解</strong>。</p><p>有人认为120公里时太慢，有人认为80公里时太快，莫衷一是。好在按照正态分布，中间的人数是最多的，越极端（包括越激进和越保守）人数就越少。以多数人的观点为基准，比他们激进的就是左派，比他保守的就是右派。举个例子，10个人里8个觉得应该开100公里，1个觉得开120公里，1个觉得开80公里，那么在这10个人里面，120公里派就是左派，80公里派就是右派。如果有人觉得要开200公里，很简单，那他就是极端左派。</p><p>用上世纪的红色运动举例：</p><p>陈独秀右倾投降主义，说的是陈独秀对革命形势的估计过于保守，认为红色力量无法战胜白色政权，因此选择了放弃抵抗。他认为红色的车只能开20公里，旁边白色车虽然破破烂烂，但能开到60公里，还是可以的，所以自动让出了驾驶员的位置，加入白色车队。</p><p>王明左倾冒进主义，说的是王明对革命形势过于激进和乐观，认为红色力量能够快速夺取全国政权，立即实现社会变革，因此他组织红军进攻大城市。他觉得红色的车能开160公里，就开车跟白色车竞速，结果没开到80公里就散架了。</p><p>一般的左派和右派讨论仅止于此。</p><p>如果想继续深入，那就要从历史进程看了。</p><p>仔细想，大部分人觉得车能开到100公里，是不是说车真的就能开到100公里？</p><p>不是。</p><p>这就是主观和客观的不一致，而且是大众认知与实际情况的不一致，社会主流意识与历史发展水平的不一致。事实上，主观与客观完全符合的概率，是零，就像你从设计速度20-200公里中任选一个速度，刚好选到100公里的可能性虽然存在，但概率为零。何况你无法验证。</p><p>假如大众认为车能开到100公里，实际上车能开到120公里，那么其中大多数人才是右派，80公里派就成了极端右派，120公里派才是符合客观的现实派。又或者他们没有意识到自己开的不是车而是飞机，时速其实能达到1000公里时以上（这种情况并非不存在），那么所有人都是右派，而且都是极端右派。同理，也存在大多数人觉得车能开160公里但其性能只能达到100公里的情况，比如公社化运动。</p><p>这里的划分，与平时讨论的左右派是不同的。</p><p>平时说的左派和右派是以多数人的观点为基准的。虽然多数人的观点无法被确认，但是一时一地一群体的观点，还是能够大致被验证的。然而上面说的左派和右派不是以大众的观点为基准的，而是以社会运动的实际进程为基准的。<strong>前者是社会的左右派，后者是历史的左右派。</strong>但历史的派别无法参与讨论，因为它是历史的，激进派、保守派、极端左派、极端右派、中间派，每一派都认为自己是正确的，每一派都想证明自己代表历史的进程，是历史的现实派。然而谁才是历史的代表，只能被历史本身所证明。一辆车到底能开多快、应该开多快，只有到下一个阶段检修时才能被确认。</p><p>如果觉得我说清楚了，发出一个终极之问供你思考：</p><p>左和右讨论了激进和保守，那么方式和目的呢？</p><p><strong>你们一直在讨论车速，那用什么保证方向是正确的呢？</strong></p><p>答案是没有办法保证。</p><p>别说方向，就连目的地都没有办法保证。</p><p>所以你会看到无数主张不同车速、不同路线和不同驾驶方法的不同主义，同一个意识形态里都存在目的、方向和途径都完全不同的阵营。举个例子，如果你觉得红色高棉和TG只是车速不同，那就太天真了。反正对大部分人而言只是乘员，车总要往前开的，而我们都是中途下车，只要不是明天给你开下悬崖，目的地很重要吗？</p><p>很重要。</p><p>每一次的（社会运动概念上的）更迭、改良、革命，都是对目标和途径的一次审视。</p><p>人虽然无法确保目的和方向和正确性，却能感知大致的目的地从而规划路径，方法就是从人性中寻找。<strong>越符合人的天性，其主张和道德就越普适、越恒久，越能被坚持；越违背人的天性，其主张和道德就越狭隘、越短暂，越快速被抛弃。</strong>从人的天性中寻找普适恒久的特性，以当前历史和现实为基准加以修正，是我们接近目的地的最佳方式。</p><h2 id="一点迷思（不再含通俗解释）"><a href="#一点迷思（不再含通俗解释）" class="headerlink" title="一点迷思（不再含通俗解释）"></a>一点迷思（不再含通俗解释）</h2><h3 id="1-自由-x3D-右派？"><a href="#1-自由-x3D-右派？" class="headerlink" title="1.自由&#x3D;右派？"></a><strong>1.自由&#x3D;右派？</strong></h3><p>自由和左派和右派没有必然联系。</p><p>高票的树神彧说极左是极端追求平等，极右是极端追求自由。这不能说是准确的。</p><p>左派和右派是一个对子，自由和极权是一个对子，两两之间只有特殊的或然的从属关系，没有普遍的必然的从属关系。如果一定要概括，那就是：<strong>从整个人类社会的历史看，自由为左派所有；从具体的历史时期看，自由大多为右派所有</strong>。</p><p>要说清楚这个问题是真的不简单。</p><p>对前一个命题，一句话解释即：<strong>自由是人性恒久的追求，是社会变革的目的和归宿。</strong></p><p>此处借用马克思的人性解放论作论证：马克思认为，人的全面发展即人的劳动能力的全面发展，是一种才能、素质、道德品质的充分的全面的发展。人的天性的规定了人对自由全面发展的追求，这种追求过程就是人性解放的过程。而在对立面，资本主义的劳动成为一种商品，剩余价值被粉饰为经营利润，作为再生产的基础；劳动对个体劳动者而言从内在特质，转变为一种外在过程，也就是说被异化了。当再生产成为劳动的唯一目的，不用于再生产的项目将不能占据任何时间维度（此处的“时间”是社会学意义的时间），劳动者的自由被剥夺了。</p><p>正是由于自由是人的天性，是人的内在追求，因此自由的剥夺与人的异化必定被暴力反对。<strong>任何社会变革，都是反对当前社会系统中违反人性的部分，支持和弘扬合乎人性的部分，其主张归根结底都是实现更高的人性</strong>（自由、平等），所以说自由是变革的最终目的和归宿。人们对自由、平等的质疑，更多是认为过于激进（车速问题），即当前的社会历史条件和生产力发展水平，还不足以支持和适应那些左派所鼓吹的那种程度的自由和平等，并不是说对自由和平等（以及美好人性）的追求是错误的。很少有人过于悲观地否认人类对人性解放和全面发展的追求能到达更高的阶段。因此自由是变革的目的。由此我们论证得出第一个命题：<strong>从整个人类社会的历史看，自由为左派所有</strong>。</p><p>但是我们还必须认识到，从具体的历史时期看，自由大多为右派所有。</p><p>为什么呢？</p><p>因为变革本身是矛盾的——<strong>变革的目的是自由，变革的手段是极权</strong>，<strong>左派在推动社会变革时，大力鼓吹自由的未来；右派在阻遏社会变革的同时，大力鼓吹自由的当下</strong>。而自由在手段上是无法战胜极权的，因此必须无论是左派还是右派，都必须以极权战胜极权。正如教员所说：</p><blockquote><p>战争——这个人类互相残杀的怪物，人类社会的发展终究要把它消灭的，而且就在不远的将来会要把它消灭的。但是消灭它的方法只有一个，<strong>就是用战争反对战争。</strong></p></blockquote><p>由于变革必以极权，因此其性质是暴力的，非极权的暴力无以扫清政治道路的障碍。“变革”，只在障碍既除、政治目的得以实现时才结束，变革的实现是以破坏现存的部分甚至全部生产关系为手段，其暴力程度比反对变革的镇压手段暴力程度更甚、严酷程度更甚。简单说就是为了实现更高自由，那就必须先取缔当前的自由。</p><p>举个例子，18世纪末被称为自由派的左派，随着革命进程的深入，变得越来越极权和恐怖，其顶峰就是以罗伯斯庇尔为首的雅各宾派，特长是吊路灯和斩首，在巴黎疯狂地处决旧贵族、右派，甚至是不够激进的左派，极左内部政见不合者。在当时，相比采取过激和恐怖政策的雅各宾派，右派的保守党如热月党人反而成为自由的支持者。</p><p>同理，当前世界的英美资本主义，其右派通常是保守的自由主义者，亦称资本主义式自由者，比如支持个人持枪、反对管制和反对外在分配。其主张是无疑是自由派的。但要清醒地看到：自由是其反对社会变革的借口，当政府推行自由和平等的改革时，他们是持枪来反对的。</p><p>结论：正如辩证法既为唯物主义所有又为唯心主义所有一样，自由和极权作为对子，不为左派或右派所独有。</p><h3 id="2-极左的归宿"><a href="#2-极左的归宿" class="headerlink" title="2. 极左的归宿"></a><strong>2. 极左的归宿</strong></h3><p>对于极左的问题，教员在湖南农民运动考察报告开篇就说了：每个农村都<strong>必须造成一个短时间的恐怖现象</strong>，非如此不能镇压农村反革命派的活动，决不能打倒绅权。这是因为：</p><blockquote><p>革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。</p></blockquote><p><strong>矫枉必须过正，非过正不能矫枉</strong>。这句话概括历史以来极左与极右的斗争。</p><p>从人类历史的进程看，左和右对立统一，寓于社会运动的进程中。这个进程是螺旋上升的过程、循环往复的过程，左是上升，右是螺旋，或者说保守是常态，激进是非常态。他们不存在天然的平衡状态，要么是左压倒右，要么是右压倒左，原因就在于矫枉必须过正。从王朝更迭的进程看，既得利益者天然反对变革（得利即右倾），利益的积累同样有加速过程，会随时间向上集中；但这并非单向的，在利益向上集中的同时，变革力量也在向下沉淀（失利即左倾），普通的改良不能逆转只能延缓这个过程。任何试图逆转利益流向的行为都会被既得利益者暴力镇压，即：变革力量在彻底战胜镇压力量之前，变革派的利益诉求都会被压制，不会得到满足。最终，当变革力量超越镇压力量时，更迭就爆发了，正如为了抵御洪水而不断加高堤坝，那么当洪水最终摧毁一切障碍时，必定是长驱千里，绝无半点温和可言。</p><p>极左由于代表变革诉求，内在和本质决定了其不断加速的特点。只是随着社会文明程度变高，手段变得更温和，在清理进程中从倾向肉体毁灭进化为人格毁灭而已。在法国大革命中，作为发起者的吉伦特派就是典型左派，是信奉自由主义工商业阶层，他们联合无套裤汉组成反封建政权，以推翻国王为目标，与封建右派作斗争，应该说是自由激进的。然而随着革命进程的深化，左派提出的主张愈发激进，吉伦特派的主张已经无法满足下层人士的需求，他们主张的是一定限度的经济自由和管制，对现状感到满意；而下层人士要求完全的经济自由和社会平等，继续革命。此时，在“要不要继续革命”的问题上，大革命发起者吉伦特党人就从左倾变为右倾，吉伦特派已无法驾驭自己调动起来的变革力量，或者说他们被革命抛弃了，于是更激进的雅各宾派上台。为了清扫政治障碍，把大量吉伦特派支持者送上断头台。由此，左派将被极左击败，激进将被更激进击败。（广义的雅各宾俱乐部包含甚众，吉伦特派本身就属于雅各宾党，但我们通常所说的雅各宾派是指从雅各宾俱乐部中与吉伦特对立的山岳派发展出来的、以罗伯斯庇尔为首的极左团体）。</p><p>雅各宾各党派对于革命应该进行到什么程度的分歧极大（在此最激进者当属巴黎公社“不断革命直到社会主义的实现”，与此类似，红色时期的中国托派主张也被简化为“革命到鸭绿江边”）。这一方面为了集中力量打击反革命势力，保证革命成果不被篡夺，另一方面则是要把革命的领导权牢牢地掌握在本派别手中，保证自身不被更激进的革命党人清洗。当变革进入到极左自我清洗的程度，其手段是极其严肃和恐怖的，其内部斗争的惨烈程度远高于外部斗争。因此在丹东派提出放松恐怖政治时，埃贝儿派主张更严厉的恐怖政策（明面上说的是“对保皇党和反革命势力更彻底的制裁和打击”），于是丹东派迅速失势，其上层被处决。而埃贝儿派和巴黎公社又被更激进的罗伯斯庇尔打倒，他提出的“制裁人民公敌”的法令可以令所有自称极左的人汗颜：取消其他刑罚，判决成立一律处死；没有预审，只有终审，不允许辩护；判决无需证据，法官判定一律生效。于是法令颁布后48天内，巴黎断头台下砍死接近1400个人。</p><p>当左派决意集中一切力量去推动社会变革和攻击反对变革的右派时，这股力量必然会被极端的左派利用，进而被最极端地左派掌握，进而成为最极端左派中专政者专权的手段，成为排斥政见不合者甚至是屠杀异己的工具。</p><h3 id="3-如何彻底打倒右派"><a href="#3-如何彻底打倒右派" class="headerlink" title="3.如何彻底打倒右派"></a><strong>3.如何彻底打倒右派</strong></h3><p>我们要从极左的归宿和右派的开始说起。</p><p>左派代表的是进步的未来，天然地不被怀念。因为成功的变革就是使社会向人性之善更进一步，而这种变化由于合乎人性，会被变革后的世界认为是理所当然，没有丝毫的不适。而变革过程中的恐怖却会深刻地铭于社会意识，成为集体无意识的一部分。左派在不断加速中，以极权打击了反对变革的分子，维护了自身的领导权和变革的纯洁性，与此同时也在将自己送入极左的道路，不断与社会大众剥离，成为“孤家寡人”。其结局只有一个，就是在威权结束之时迎来右派的大反扑。</p><p>人不能怀念将来，只能怀念过去。极左的归宿，就是右派的开始。罗伯斯庇尔可以称得上是全人类历史上最激进的左派，但正因为他的激进无人能及，他的统治也极其短暂。在恐怖法令持续仅仅一个月后，他就被右派的热月党人用断头台斩杀，和斩断1400人脖子的断头台大概是同一个。临行的他突然发现自己早已成了少数派，连送他上路的人都零零星星。保皇党由此复辟，法国陷入长达百年的左右派的反复拉锯。</p><p>在这种你压倒我、我压倒你的拉锯中，右派是有锚点的，而左派没有，左派只有前进一途，换句话说右派知道自己想回到什么样的过去，左派不知道自己到达什么样的未来。做个思维实验：如果你问“人工智能发展起来了吗？”现在很多人大概会说还没有。但事实上，人工智能在上世纪80年代就已经取得长足的发展，你手机里的自动响应程序、聊天机器人、游戏里的AI玩家都是弱人工智能，只不过你在生活中接触到时，已经不认为它们是人工智能，人工智能一直是“很新的东西”。1997年深蓝战胜卡斯帕罗夫震惊世界，彼时深蓝还是两层楼高的大家伙；到了2007年，连一部普通民用手机的内置软件都能打败卡斯帕罗夫，人们却觉得理所应当。世事如此，变革亦然。新世界的人类对变革的成果和进步视为理所当然，他们对“过去”不心存恐惧和厌恶，反而有怀恋和不切实际的向往。</p><p><strong>变革过程中右派的失势是暂时的，只有变革过后旧右派的失势才是永远的。右派曾经掌握着社会的权力和秩序，代表着旧世界的记忆和影子，因此他们拥有极为强大的强大的潜在势力，随时会发起反扑，直到这种能量被完全消耗殆尽</strong>，外在表现为顽固与反复。</p><p>对于如何彻底打倒右派，变革者作出了无数尝试。其中最有效、最开明、最王道、最根本的方法，是把生产力发展水平提高到右派秩序无法容纳和适应的程度，让右派失去社会的历史的基础，再无立足之地。就像铁器和农具的推广，彻底摧毁了盘踞中国两千年以上的奴隶制。在TG的社会主义改革中，大炼钢铁等跃进运动，恐怕也有类似的考虑。再做一个极端的假设，假如今天核聚变技术研究成功，十年内恐怕现存的所有落后体制都会灰飞烟灭。这叫降维打击，<strong>当右派代表的生产关系与生产力脱节太过分，他们会自动被埋葬在历史的尘埃之中，由历史亲自动手</strong>。</p><p>然而大部分的左派，他们的先进性还不足以让右派自绝于历史，甚至有时他们本身就比右派更不符合历史发展的水平，此时打倒右派就只能采取一般的斗争方法：宣传、集权、肉体消灭、人格毁灭，请对号入座。当然这一套方法右派也能用，不过由于右派代表当前的社会秩序和保守的变革观，对宣传进步思想和发动人民有天然的恐惧。比如针对外来侵略，唤醒民众意识、开展人民战争是有效对策，但右派常常对此持有消极态度，不敢发动群众。因为“唤起民众”对左右双方的意义是不同的，对左派而言，叫散播火种，对右派而言，是为自己掘墓。何况维持社会稳定和秩序是右派的天性（“在乎些坛坛罐罐”），这不允许他们在体制上采取比左派更激进的手段，但凡在这一点上作死的右派都在实质上加速旧秩序的崩溃。</p><h3 id="4-学会娴熟地扣上帽子"><a href="#4-学会娴熟地扣上帽子" class="headerlink" title="4.学会娴熟地扣上帽子"></a><strong>4.学会娴熟地扣上帽子</strong></h3><p>左派和右派的反复拉锯，不独法国大革命，中国也普遍存在，其中时间最持久的当属春秋战国的百家争鸣。百家争鸣成体系的学说很多，归类比较困难，如果你能以左右派的视角作出分析，就会发现其观点主张分野异常清晰。</p><p>以简单粗暴的左右观来划分，四大显学中（严格意义的显学特指儒家和墨家），儒家是右派，道家是极右，法家是左派，墨家是极左。以此剖析其学派性质和主张异常有效。</p><p>首先，从生产力与生产关系、经济基础和上层建筑的基本情况上看，春秋战国处于社会转型和阶段性运动时期，奴隶制的生产关系和社会关系，已不适应当前的生产力水平，导致政治动荡和战乱频发。因此，社会变革将持续进行，直到生产力发展的要求被大致满足为止。<strong>儒墨道法的不同主张，直接动机是结束乱世，实质目的是为社会变革提出一个方向和程度的指导。</strong></p><p>其中儒家是右派，观点偏向保守，他们主张的是上一个时代的统治秩序，这个制度的外在表现是“礼”和“乐”，内在核心是等级阶层；他们认为乱世之乱，根源在于“礼坏乐崩”，所以我们要“克己复礼”，回到过去。这种观点是保守的和反动的（反对社会运动，或者说反对变革），他们没有注意到生产力已经发展到旧的生产关系无法容纳和适应的程度，提倡旧的生产关系已不可能，所以儒家在当前结束乱世的任务中他失败了。（以后他们会因为右倾的特点而复辟）</p><p>道家相比儒家，更反动、更保守，儒家克复的对象是周礼，道家克复的对象，是自然。他们反对人类社会一路以来建立的秩序、阶层和组织，主张回到三代以前的原始生活状态，小国寡民、无为而治、自由恣意。这种回卷已经极端到了近乎消极的地步，因此他们只是宣称回到自然的状态就会由乱而治，甚至没有在推行自己的主张上做过太多努力。这倒是和资本主义的田园派类似，反对一切工业成就，主张回到田园生活。只不过这种类型的极右太消极，连反对变革的力量都不具备，只能从个体内部着手，寻求自我的超脱。</p><p>儒道两家的克复，有一个精神的幌子，叫“三代以前”——尧舜禹，或者说尧舜。他们认为世道每况愈下、风气愈古愈纯的理论支柱，就是上古存在一个理想世界。但我们从社会历史的角度分析，那个上古的理想世界其实就和伊甸园一样根本不存在，实际上如果尧舜真的存在，他们的人们肯定以部落群居，通过半采集半耕种的方式挣扎求生，一部分茹毛饮血、时猎时迁，一部分尝试改良作物、驯养禽畜。和这种基本生存无法保障、每日都处于死亡边缘的上古时期相比，在井田里当农奴也算得上天堂了吧。儒家设想的大同社会，绝不可能存在于生产力极其落后的上古，只能存在于生产力极度发达的未来，这个未来只能通过漫长而反复的变革达成。通过反对变革，使社会倒退，回卷到理想的大同状态，那就是四个字：<strong>南辕北辙</strong>。</p><p>再说下左派。</p><p>很多人肯定会不理解，为什么法家是左派，而墨家是极左，不是应该反过来吗？</p><p>此处我必须引用一下自己：</p><blockquote><p>左&#x3D;激进<br>右&#x3D;保守<br>极左&#x3D;极端激进<br>极右&#x3D;极端保守<br>直接代入公式不会错。</p></blockquote><p><strong>判断左和右、极左和极右的标准只有一个，即其主张是激进还是保守。</strong>主张指向目的，这是根本，而手段不是。法家的手段确实极权和恐怖到了极点，但是在观点主张的激进性上，他们比墨家差得太远了。</p><p>法家主张“以法治国”。不过这个以法治国，从概念上和观念上，都和今天的“依法治国”完全不同。否则我可以直接把他打成极左派（笑）。法家的法，是刑罚（或赏罚）的意思，以法治国，就是用刑罚治理人民：你不按我说的做，我就收拾你，不管你是谁，我都要收拾（法不阿贵,绳不挠曲，刑过不避大臣，赏善不遗匹夫），我说得出做得到（徙木为信）。他本质上是统治者凌驾被统治者的一种手段，是驭民之术、权谋之术，在今天看来是相当落后、反动和反人性的，但在当时他是进步的、正动的，符合生产力发展水平和时代变革要求，所以他成功了。法家至少做到了几件事：</p><p>第一，打破了绝对的阶级和威权（打仗立功封爵，旧贵族的身份垄断被打破）；第二，极大地解放了生产力（废除井田、奖励耕战、赏赐耕地，土地私有后耕作积极性提高了）；第三，完成了新生产关系下的集权（其他国家很早就开始废井田、开阡陌，不过生产关系已经革新、上层建筑还是旧的，君主无法集权）。而且法家特别反对克复回卷，坚持治道不法古。做到了以上几件事，旧贵族很快死到了一边去。可以说法家是战国时社会的左派、历史的现实派，活该他成功。</p><p>不过法家无论是个人还是集团，都承受了右派强烈而漫长的反扑，直到将近200年后才基本平息。这里多说一句，军队是最适宜法家推行的地方，赏罚分明、令行禁止，不讲人性道德，只讲规则服从。这种机械的赏罚观持续了近两千年，到教员的手里才被打破。教员在红军里废除军饷制时，许多人（包括朱总、林总、彭总）都强烈反对，许多人都觉得他疯了。改革结果是军队管束不靠打骂，从士兵到将官不领粮饷，从战斗员到一般指挥员甚至司令员，吃一样的，用一样的，都可以参与政治和军事的讨论，此时人们才发现超越时代的体制原来是这样的。在这个领域，教员可以说是极左中的极左，然而军队和社会不同，是可以片面地极左和极右的，所以这支军队不仅能存在，而且能对伪现代军队实现降维打击。</p><p>法家的思想虽然进步，但糟粕也很多，像什么提倡肉刑、严刑峻法、什伍连坐之类的，在当时还好，现在看来保守落后野蛮之极。春秋战国说极左，还得看墨家。墨家的左，左到两千两百年后的我们看还觉得不切实际。孔子说仁爱，那还是一种有差别的爱，它的底层是等级和亲疏；墨子说兼爱，那就是无差别的爱了，它是反对阶层、等级、亲疏的，底层是平等。问题来了，对当时的社会而言，韩非的理论都算进步，墨家的兼爱得激进到什么程度！那时的社会历史条件，能支持墨家实践兼爱吗？显然不能。</p><p>墨子看到了自身主张的空想性。因此，他从兼爱出发，精心设计了墨家十律，为兼爱的理想提供具体的、实践上的指导，要求墨家门徒（墨者）身体力行。深入分析十律，其进步性和实践性固而有之，但从底层上还是在靠极权体制和集权手段在强推。尚贤和尚同，实际就是墨家倡导组织政权的形式：选举出天下最“贤”的人，大家与他保持一致。为什么墨家非要“一致”不可，“尚同”能不能妥协？这就问到问题的关键了，墨子说不能。如果说兼爱是墨子理论的核心，尚同才是实现兼爱和平等的手段，尚贤只不过是为尚同指明方向而已（至于非命、节用、节藏等，就更加是细枝末节了）。尚同提出的是下级同于上级，上级同于更上级，逐渐上同，最终天下同于“贤”，再由“贤”推行兼爱，实现墨家的终极理想。所以墨家的组织和纪律十分森严，集团内部实行一定程度的公共财产和共同劳作制，儒家形容墨者“摩顶放踵，而利天下”；钜子拥有非常大的权力，是墨家门徒精神和物理的双重领袖，法家形容墨者“赴汤蹈刃、死不旋踵”（也有为自己的“法”背书的目的）。相比儒家、道家，墨家更像一个中古时期的宗教，钜子在设计上代表了此世所有“贤”的集合，是贤的顶点、理想的化身，不尚同就是不尚贤。在外部，你不尚贤，墨者让你尚贤（墨辩）：钜子已经是最贤的人，你还不跟他保持一致，难道要我们跟你保持一致吗。在内部，你不尚贤，墨者帮你尚贤（墨法）。</p><p>墨家失败的原因，很简单就是太左了，也太理想了。这导致当时的生产力水平完全无法支持他主张的社会变革、生产关系和理想，注意到这个问题的墨子一面进行提高生产力的尝试，一面开始用组织约束力强行推动变革。但还是留下了尚同和尚贤的隐患，在墨子在世的时候这个问题还不大，他本人类似于耶稣行走，但其接班人又有什么能力和品行自称贤、让墨者同呢？所以墨子死后，墨家集团迅速分裂并且分崩离析，出现多位钜子，他们都只能说是一个墨家小团体的首领，再没有一位全天下墨者共同的钜子了。墨家的下场也是比较惨的，因为领先时代太多，右派毫不费力就将其湮灭在历史中，而封建王朝右倾的统治路线决定了极左的墨家没有任何利用价值，在两千年的更迭进程中再没有墨子学说的任何位置。</p><h3 id="5-当双标狗，做两面人"><a href="#5-当双标狗，做两面人" class="headerlink" title="5.当双标狗，做两面人"></a><strong>5.当双标狗，做两面人</strong></h3><p>高票答主培根煎蛋说了一个很有趣的观点，让我引用一下：</p><blockquote><p>在2020年的今天，有一些很明显的判断标准：<br>·左派认为不应该分国籍和人种，外国人和少数族裔应该享受相同权利，而右派坚持自国主流族裔优先。<br>·左派支持LGBT，女权，废除死刑等较新的社会意识，而右派坚持传统价值观。<br>·左派希望财富分配能够照顾到底层人民，右派却觉得多劳多得，自己不努力不要怪社会。<br>但是实际上这个标准并不通用，因为人类的本质是双标狗……所以划分左派右派是很没有意义的，因为一个人不可能保证他无论在地球任何地方，任何时间都是主流人群，所以每个人都会有成为少群弱势群体的时刻，针对社会议题的倾向也会改变，我称之为“左右派混合态”。</p></blockquote><p>按这个说法，一般人是无法被划分左派和右派的，或者说这个划分没有意。</p><p>是不是这样呢？</p><p>我认为不是，这个说法不能说是准确的。第一是他把实质和表征搞混了，第二是他把极端和少弱搞混了。</p><p><strong>政治观点只是表征，社会阶层利益才是实质，所在阶层的得利或失利程度决定激进或保守程度，大致地决定了个人的左和右的位置。</strong>也正是因此，观点分左右，个人也可以持有左右不同的观点——只要合乎自身利益。或者反过来说，个人决定观点时永远先从利益和目的出发，而不会考虑观点本身是激进还是保守。但人不能同时是左派和右派。</p><p>一个人不能同时是左派和右派，一个人不会因为同时持有左派的观点和右派的观点就变成左右混合派或者骑墙派。即使一个人持有九十九种右派观点和一种左派观点，他也不一定是右派，有可能是左派，甚至极左。如果你从表征（观点）分析，你永远弄不清楚一个人的派别，你只有从实质分析，才能确定，也正唯有这点能决定他是左派还是右派。</p><p>那么这个“激进保守程度”是由什么决定的？有很多因素，但起决定作用的是所处社会阶段所代表的利益（还是利益），规律也很简单，越穷越左，越富越右。得利者总是希望维护现有体制而反对变革，失利者总是希望打破或至少改良现有的体制而推动变革，这种情况在社会总体稳定、政治清明之下会演变为毫厘必较，而虹吸效应加剧了利益极端化的速度，使变革力量迅速增长，这是封建王朝由盛转衰的关键节点——健全而完善的体制下利益向上集中反而是加速的，资源优势者无论是向上发展和向下盘剥，无论是承受风险还是玩弄规则，都比下层娴熟多了。这也是答主培根煎蛋说得不太准确地第二点，少弱群体和极端没有必然关联，极端在于得到和失去利益的严重程度。少群（minority）被认为是易损失利益者（vulnerable)，因此被默认为左派，但实质上在少群在被保证话语权力的情况下，更像是披着左派的外衣的右倾者。从世界的历史的情况看少群对进步的革新的追求和实质努力，我觉得要打一个呵呵的问号。</p><p>由此，判断一个人是左派和右派，直接考察其所处阶层代表的利益，是大致准确的。虽然由于个体的经历、观念、理想、信仰等，会出现与所处阶级利益相差甚远乃至完全背离的情况，但一来这需要具体情况具体分析，二来完全背离本阶级利益后他实质上已不属于原阶级了，三来是这种情况并不多见。当此分析上升到群体，个人的特点就被完全抹平，剩下的就是赤裸裸的阶级利益，这过程如同从事物的普遍性中寻求特殊性一样。而且这个群体是紧紧跟随阶级利益的，不因其中个体的观念和志趣而转移。举个例子，解放战争时期的城市工商业者，他们本来是变革的反对者和现有秩序的维护者，在金圆券发行、民国政府信用破产之后，大部迅速左倾。无论你喜欢什么颜色，现在都变成红色了。</p><p>有了解题思路，我们来做一下答主培根煎蛋的题：</p><ul><li><p>一个生活在美国的华人直男，他可能希望改变亚洲人作为少数族裔的地位，但是同时又对LGBT极其厌恶。</p></li><li><p>一个生活在中国的女权主义者，她可能想要改变男权社会附加在女性身上的枷锁，但同时觉得底层男性比蝼蚁还没价值。</p></li></ul><p>信息非常有限，因为没有他和她的社会阶层情况，无法展开利益分析。</p><p>但我可以鲁莽地判断，前者在美国、后者在中国，都轻度右倾，属于小右派。</p><p>为什么？因为他们的诉求停留在个人志趣和直接群体的基础上，是对大的利益分配中的小利益的小修小补。从诉求表述上，看似激进实则十分保守，很可能属于既得利益者但得利十分轻微。在实际的社会变革中，他们往往被忽视、被要求保持中立，不具有被争取的价值。</p><p>真正要求变革的人和真正积蓄着变革力量的群体，真正保守并拥有着镇压力量的人，因极端而获得力量，他们的诉求不是这样的。</p><p>最后，我提供一下几个人的出身和阶级利益，供分析参考。</p><p>老子：前朝大贵族；分封型奴隶主。</p><p>孔子：小贵族；旧贵族（士大夫）。</p><p>韩非：小贵族；新贵族。</p><p>墨子：农民；农民，手工业者。</p><hr><h2 id="关于一些质疑的集中回应。理辨而明。"><a href="#关于一些质疑的集中回应。理辨而明。" class="headerlink" title="关于一些质疑的集中回应。理辨而明。"></a>关于一些质疑的集中回应。理辨而明。</h2><p><a href="http://www.zhihu.com/people/8967ba474f3a30cd9eb786ea4bf08134">@朱成蹊</a></p><p><img src="https://files.tilnel.xyz/uploads/2021-04-29-question1.jpg" alt="question1.jpg"></p><p>由于这段话的逻辑比较混乱，我们<strong>首先提取他驳论的观点：</strong></p><p>\1. 【没有单独存在的“左、右”的政治概念】</p><p>\2. 【没有任何参考语境的“左”或“右”的见解是对政治系谱的简化粗糙的认知】</p><p>\1. 对于第一点驳论的驳论：文章中从来没有提出过所谓“单独存在的左右”，非但如此我更强调左和右是相反相成、对立统一。区分左派和右派的方法，天然具有参考系的（即社会与历史的）；</p><p>\2. 对于第二点驳论的驳论：既然左和右是基于社会大众认知或给予历史认知的，我们就可以基于社会和历史作出判断。左与右本身有政治意义，否认政治学上的左与右的内涵，把规律视为现象，才是粗糙的认知。</p><p><strong>其次，我们驳斥他的主要论点。</strong>论者认为，左和右本身是没有意义的，只有赋予到具体的政治学称谓才有意义。<strong>简单地概括，论者认为必须具体地定义“左派、右派、左翼、右翼、左倾、右倾、极左、极右”，而不能从左和右的语义去理解它。</strong>可惜这个观点是完全错误的，不仅左与右本身有内涵语义，而且“左翼、右翼、左倾、右倾、极左、极右”都是从左和右的语义场中延伸的，是本源和派生的关系，下文将论证。</p><p>我们再分析他的所谓的“定义”：</p><blockquote><p>\1. 左派和右派的国际标准定义是倾向变革者和倾向保守者；<br>2.左翼和右翼是右派的内部进步亦或滞后的划分；<br>\3. 左倾和右倾指的是在思想组织上和行动上倾向于盲斗或妥协；<br>\4. 极左或极右分别指的是在政治斗争和思想辩论上打倒一切，毫无顾忌，和在政治斗争和思想辩论上主张维护传统社会制度和保护一切既得利益者的传统利益。</p></blockquote><p>【若忽略定义中明显的谬误和疏漏】，仅用文中提出的：“左&#x3D;激进&#x3D;变革力量&#x3D;推动社会发展，右&#x3D;保守&#x3D;稳定力量&#x3D;保持社会稳定”的观点去理解他们，有明显不符或不适合吗？没有。</p><p>所以论者等于把文中主张的分析思路重复了一遍，实在看不出他是在反对自己还是支持本人。而从正向角度走，这些被他认为只能单独定义和划分，不能用左右内涵“简单粗糙”理解的词语，实际上是由左右历史而来的。</p><p><strong>最后，我们指出语段中的谬误：</strong></p><p>\1.  【左派和右派的国际标准定义是倾向变革者和倾向保守者】</p><p>根本不存在国际标准定义（ISD），左派和右派的指称是约定俗成的，和语言任意性一样。</p><p>\2. 【左翼和右翼是右派的内部进步亦或滞后的划分】</p><p>完全是瞎定义。</p><p>左翼和右翼不从属于右派。通俗点，左翼和右翼不是包含在右派里面的，也不是他想象的、右派里进步团体是左翼，滞后的是右翼。<strong>左翼和右翼，左派和右派，在实质上的等同的</strong>。左翼&#x3D;左派，右翼&#x3D;右派，不区分语用时可以混用。</p><p>那么严格来说有什么不同？语义指向上左右翼更专有，原因是“the Left Wing”的用语源自法国大革命中的山岳派（与雅典民主时期的山地党异曲同工）。他们坐在议会左首，自称Liberal Left Wing，因此与之对立的团体被称为the Right Wing。此概念在东亚首先被日本翻译，通常限于议会政治中，是党争浓度比较高的用语，所以不及左派和右派泛用，但在议会政治以外并非不可以。举个例子，左翼进步作家团体。</p><p><strong>按论者的说法，“左翼和右翼是右派内部进步亦或滞后的划分”，那周树人的左翼作家联盟，本质上岂非是右派？</strong>容我一笑。</p><p>将左翼和右翼当成是右派中的两个小群体，显示出论者实在缺乏基本政治概念，也是我之前看到这里觉得有点乏力的原因。</p><p>\3. 【左倾和右倾指的是在思想组织上和行动上倾向于盲斗或妥协】</p><p>完全是瞎定义。</p><p>论者可能是看了我对陈独秀主义和王明主义的论述仿写出来的，如果不是，这种理解的解离破碎度也太高了点。左倾和右倾，指的是表现出来对左和右的态度和发展倾向，即支持变革和反对变革的倾向。举个明白的例子：</p><blockquote><p>以上海为例，美国灯泡在上海的售价为法币200元，而国产灯泡仅成本就在400元以上，美制六尺车床的售价为20万元，而国产成本却要120万元。所以46年上海工厂倒闭了四分之三，47年沈阳3000家工厂倒闭超过2000家，48年青岛所有工厂全部倒闭，平津两地倒闭的工厂数达到四分之三。<strong>本来民族资产阶级是中间派，这时候迅速左倾，成为左翼，纷纷开始反对国民党走上缓则的道路</strong>。</p></blockquote><p><strong>按论者的定义，“左倾指的是在思想组织上和行动上倾向于盲斗”，那民族资产阶级迅速左倾岂不是说民族资产阶级迅速盲斗化？岂不是说左翼民族资产阶级倾向于盲斗？</strong></p><p>\4. 【极左或极右分别指的是在政治斗争和思想辩论上打倒一切，毫无顾忌，和在政治斗争和思想辩论上主张维护传统社会制度和保护一切既得利益者的传统利益】</p><p>基本上瞎定义。</p><p>我们先忽略“保护一切既得利益者的传统利益”和文中观点的相似程度，从行为上定义极左和极右，这是走入歧途。由人组成的派别中，人的行为主张千形万状，不可穷述，因而对群体行为进行归纳，才能接近实质（关键点我已经说了，激进、保守）。</p><p><strong>极左，按照论者的说法，“要打倒一切，毫无顾忌”，那么极左的巴黎公社，他们要不要打倒自己TG主义最高理想？他们要不要顾忌雅各宾俱乐部各派别上层，要不要顾忌保皇党人反扑，要不要顾忌内外清洗的社会影响？</strong></p><p><strong>极右，按照论者定义，“主张维护传统社会制度和保护一切既得利益者的传统利益”，那么既得利益者有没有非传统的利益？要不要保护他们的非传统利益？保护一切既得利益者是不是意味不可放弃轻微得利者？</strong></p><p>这些所谓定义，认真起来稍一深究，都是千疮百孔，无法自圆其说的。</p><p>从论者对“左派、右派，左翼、右翼，左倾、右倾，极左、极右”四对概念的定义，每一个都有严重谬误看，就能知道作出标准定义的难度。<strong>像论者这样的机械式解释，恐怕才是对政治系谱的简化粗糙的认知。</strong></p><p><a href="http://www.zhihu.com/people/be4f35eea59b96d9229ed1cb19a4c9d3">@靜水微瀾</a></p><p><img src="https://files.tilnel.xyz/uploads/2021-04-29-question2.jpg" alt="question2.jpg"></p><p>对于不看文章直接反驳的情况，无力感Max。教员说我们不能自以为老子天下第一，你们都是错的，要虚心听取别人观点。一直以来我都以此自勉。提取观点，开工。</p><p><strong>一、</strong>【在中国，左和右的含义又不一样，比如右派一半（原文如此，应为“一般”）是指自由主义者，这可不能说是保守】【实际上在中国语境的左右含义就是有所不同，不能套进你的那个公式】</p><ol><li><strong>谁说的在中国右派一般是是指自由主义者？</strong></li></ol><p>反动右派指的是自由主义者，还是革命反对者和社会运动逆向者？</p><p>打倒右派的指向目的是打倒自由主义者还是打倒反革命分子？</p><p>按论者的说法，反对右派岂不是自由主义者？打倒右派岂不是打倒自由主义？</p><p>问题来了：从1957年TG中央《划分右派分子的标准》到1978《关于全部摘掉右派分子帽子的请示报告》，从反右和反反右，自由主义什么时候跟右派绑定在一起了？这可是最具中国特色和中国语境的文件，那么右派分子怎么和自由主义者联系在一起？如果</p><p>“右派一般指自由主义者”，这句话如果反过来再放在世界范围说，“自由主义者一般是右派”，我还姑且承认有正确性。说“在中国，右派一般指自由主义者”根本就是无稽之谈。在中国，右派一般且广泛地指称是反革命者，反对改革者，反对社会运动者。反右时期由于教员研判当前是建成社会主义社会的时期，因此资、修、民资一律等社会的右派一律被打成反革命。连这一点都不理解，就妄谈中国语境。</p><p><strong>2. 谁说的自由主义者不能是保守？</strong></p><p>我文中已详述，论者不看，我就再重复一次。</p><blockquote><p><strong>自由和左派、右派没有没有普遍的必然的从属关系。</strong><br>变革的目的是自由，变革的手段是极权，<strong>左派在推动社会变革时，大力鼓吹自由的未来；右派在阻遏社会变革的同时，大力鼓吹自由的当下。</strong><br><strong>当前世界的英美资本主义，其右派通常是保守的自由主义者，亦称资本主义式自由者，比如支持个人持枪、反对管制和反对外在分配。其主张是无疑是自由派的。</strong></p></blockquote><p><strong>“右派一般是指自由主义者，这可不能说是保守”这句话荒谬到什么程度？在政治派别的分野中，一向存在保守自由主义派。</strong>法国民主公民运、丹麦自由党、波兰新右会、德国自由民主党，都是典型的保守自由政党，甚至广泛意义上美国共和党也是保守的自由主义。在主张上，他们的主张兼具“社会道德的保守”和“经济活动的自由”，以此延展到“法律法规的保守”和“公民生活的自由”。至于他们政治诉求的本质，用引文的一句话破解即可：右派在阻遏社会变革的同时，大力鼓吹自由的当下。所谓的经济自由，是既得利益者用以排斥公权力干预利益分配的口号，所谓社会道德和法律法规的保守，是既得利益者利用公权力阻碍变革的借口。自由主义和保守主义，天然地就可以结合在一起，连这一点都不理解，怎么能对右派作保守和激进的判断呢？</p><p><strong>二、【变革必以极权？世界史的反例也有不少，不是只有大革命，也还有光荣革命那种东西】</strong></p><ol><li>为什么一直举法国大革命的例子？</li></ol><p>当然不是世界上只有法国大革命，而是因为：左和右的分野本身就滥觞于法国大革命，而且其进程太典型而易于分析。当然只要严格社会历史条件，我们可以用左和右的观点去对左右概念还未出现的社会运动作剖析，我也是这么做的，比如春秋战国的阶级分析。</p><p><strong>2. 为什么说论者对光荣革命本身缺乏认识？</strong></p><p>当然不是我在人身攻击。</p><p>光荣革命属于十七世纪英国议会革命的一个进程，也是终章。如果要类比，就是”英国议会革命对应法国大革命，光荣革命对应法兰西第三共和国建立（1870年资产阶级共和派与保皇党，在上院握手言和，共建法兰西第三共和国）把英国光荣革命单拎出来，以为革命可以不经过流血和斗争，以为民众自发的力量足以推翻阶级威权，这种想法是很天真的。</p><p>英国议会革命，在进入光荣革命之前，同样是经过左右派的反复拉扯的：从国王查理一世被断头，极左独裁者克伦威尔专政（一个罗伯斯庇尔式的人物），到护国公克伦威尔倒台枭首，詹姆士二世复辟；再到詹姆士二世倒行逆施，实行极度保守的右倾政策并迫害清教徒，到最终詹姆士二世被锐“民众”推翻，流亡法国，资产阶级新贵族取得阶段性胜利。每一次压倒都迎来反扑，每一个强权都最终妥协。</p><p>为什么光荣革命不流血？因为之前已经流太多的血了，统计一下从新贵族反乱到詹姆士二世垮台之间七十年，打过多少内外战争。遥相照应，法国大革命时期也是外战不断，左派上位的一个很有力的支持，是相比保皇党的软弱，他们外战能力更强。</p><p>为什么英国议会革命进程比法国大革命短？因为法国是因为启蒙运动作为先导，思想进步性更强，天赋人权、平等自由的观念深入人心。英国则是资产新贵自发的为争取权益而发动的革命，自觉程度低而妥协程度较高。孰优孰劣实在不好评判，时至今日，法国可以宣扬人人平等，英国则是女皇在上。</p><p><strong>那么英国议会革命，以及光荣革命，真的是非极权的变革吗？</strong>不是。</p><p>即使不考虑英国议会革命的总进程，单从光荣革命本身来看，其推行都是以极权手段，而且是高度的极权。如果说极权的典型标志就是公权力对于社会生活的介入和公民生活的规制，那么代表新资产阶级利益的清教徒则完全主张规制个人宗教生活，是极权者的代表。极权手段，被用以清除国教中天主教残余，这是英国新贵族对抗宗教旧贵族在思想上的一种斗争形式。而清教徒，毫无疑问是光荣革命乃至整个英国议会革命的主力。如果真的了解这一点，怎么可能用光荣革命来反驳“变革必以极权”这句话呢？</p><p><strong>3. 为什么说极权手段不等于极权主义？</strong></p><p>变革要以极权手段开展，并不是说变革者本身是极权主义者，两者有本质的差别</p><p>对于极权主义者，绝对的权力和管制就是制度的本质和目的，统治者或者公权力拥有者为了实现全能威权而建立绝对权力体制，反过来绝对权力的体制又赋予了全能威权以控制和镇压能力。正如韩非的“法”不是规范社会秩序的守则，是统治者摆弄权谋的工具，极权主义政权的全能威权不过是维系统治的强力管制，“没有一个极权主义制度不在肉体上和精神上惩罚它的公民，而且比民主社会严酷得多”。</p><p>变革者则相反，任何变革者都是反极权主义的，极权只是实现变革的工具，是通向民主自由的短暂阶段。教员在湖南农民运动考察报告中提出“每个农村都必须造成一个短时间的恐怖现象”，在中国的红色政权为什么能够存在中提出对边界割据的清算方略，同时他在井冈山的斗争、中国革命的战略问题、为争取千百万群众进入抗日民族统一战线等文章，贯穿整个民主革命时期，都在强调“民主”本身，强调“不论什么情况，民主的口号都能适应，民主对于中国人是缺乏而不是多余”。可见论者对我的指责：“只要存在任何暴力成分或者权力制约的因素就可以用‘极权’来概括”，这句话本身是多么荒谬。如果连极权手段、极权主义、暴力和管制的概念都搞不清楚，怎么理解变革本身？所以我才说，他对变革的理解十分有限。</p><p>回到光荣革命本身，这不是论者想象的完全反极权、无暴力的斗争。作为新贵族和王权派（大土地所有者）的最终妥协，他就和1870议会和解一样，不是看上去那么风平浪静的。他以为光荣革命是反对王权独裁的人为了民主权利，成群结队前往伦敦集会，逼迫詹姆士二世退位，实质上呢？是英国新贵族（议会党魁）、资产阶级大商人、新教信徒（天主教反对派、清教徒等等）联合威廉三世（国家视角就叫勾结外部势力）共同推翻现任国王的行动。游行民众不是自发前往首都的，而是经过大贵族、大资产阶级的严密组织，而游行队伍能直奔伦敦，并不是詹姆士二世已经众叛亲离到连暴力驱散平民的力量都没有，而是威廉三世的军队在托尔湾枕戈待旦，而右派势力王权党和左派秘密妥协，将詹姆士二世出卖了。后者之所以能保住性命流亡，也是右派努力的结果。即使是不流血的革命，光荣革命恐怕也和“非暴力”、“反极权”拉不上任何关系。</p>]]></content>
      
      
      <categories>
          
          <category> 观点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>由软链接/var/lib导致的snap安装时的挂载权限问题</title>
      <link href="/20210428_snap_mount_permission/"/>
      <url>/20210428_snap_mount_permission/</url>
      
        <content type="html"><![CDATA[<p>上篇文章说到，我为了空出 <code>/var</code> 的空间，把 <code>/var/lib</code> 制作成了软链接，一切看起来都非常的和平。直到今天：</p><p><img src="2021-04-28-can_yuls_can.png" alt="can_yuls_can.png"></p><p>于是我萌生了一个想法：既然TX不给玩，就自己弄一个IM吧！（指白嫖开源项目）</p><p>在Github上面找了一会儿，发现 <a href="https://github.com/RocketChat/Rocket.Chat">Rocket.Chat</a> 这个项目看起来比较靠谱。兴冲冲地 <code>sudo snap install rocketchat-server</code>。</p><p><img src="2021-04-28-snap_mount_permission_denied.png" alt="snap_mount_permission_denied.png"></p><p>发现，snap 作为沙盒化的软件包格式，单独挂载了自己的文件系统。如果 <code>/var/lib</code> 是软链接的话，就没有办法用 <code>mount --rbind</code> 来挂载了。</p><p><img src="2021-04-28-linked_var_lib.png" alt="linked_var_lib.png"></p><p>既然可以挂载目录到另一个目录，那我岂不是也可以把 <code>/usr/var/lib</code> 挂载到 <code>/var/lib</code> ?</p><p>说着，首先试了一波，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> /usr/var/lib/ /var/lib2</span><br><span class="line"><span class="built_in">ls</span> /var/lib2</span><br></pre></td></tr></table></figure><p><img src="2021-04-28-mount_diectory.png" alt="mount_diectory.png"></p><p>可以看到，目录被挂载过来，所有的文件都可以正常显示了。</p><p>这样，我们就可以把这个挂载项加进 <code>/etc/fstab</code> 让它开机自动挂载：</p><p><img src="2021-04-28-add_in_fstab.png" alt="add_in_fstab.png"></p><p>保存时候，用 <code>mount -fav</code> 测试一下写得对不对：</p><ul><li>-f, –fakedry run; skip the mount(2) syscall</li><li>-a, –allmount all filesystems mentioned in fstab</li><li>-v, –verbosesay what is being done</li></ul><p>得到以下输出：</p><p><img src="2021-04-28-test_automount.png" alt="test_automount.png"></p><p>这说明最后一项可以成功挂载。重启之后，重新运行安装：</p><p><img src="2021-04-28-snap_succesfully_installed.png" alt="snap_succesfully_installed.png"></p><p>成功！</p><div style="display: none"> 搜索优化：error: cannot perform the following tasks:- Run install hook of "rocketchat-server" snap if present (run hook "install": cannot perform operation: mount --rbind /var/lib/snapd /tmp/snap.rootfs_NhCo2X//var/lib/snapd: Permission denied) </div><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>crontab定时任务神秘失效，原来是$PATH的锅</title>
      <link href="/20210417_crontab/"/>
      <url>/20210417_crontab/</url>
      
        <content type="html"><![CDATA[<h5 id="前摇"><a href="#前摇" class="headerlink" title="前摇"></a><del>前摇</del></h5><blockquote><p> <strong>与问题只有时间上的先后关系，不一定有因果关系</strong></p></blockquote><p>昨天晚上<del>因为想发涩图</del>，给服务器的<a href="http://file.tilnel.com/">PicUploader</a>（<a href="http://172.26.41.176:4001/">校园网点此访问比较快</a>）上传了一张30MB的文件，然后卡住了。检查了一下log，提示我：</p><p><img src="2021-04-27-no_enouph_space.png" alt="no_enouph_space.png"></p><p>于是用<code>df -h</code>检查了一下硬盘空间，发现 &#x2F;var 分区只剩下 2.5 MB，存不下上传创建的临时文件了。。。</p><p>由于历史问题（其实就是当时脑瘫），分区的时候，只给 &#x2F;var 分了 9GB （后来才知道其实根本不用单独分区），直接导致了本次事件。</p><p>由于对于脑瘫分区的不满，我尝试把&#x2F;var, &#x2F;tmp, &#x2F;usr, &#x2F;boot 全都合并到根目录下，但是看到一系列危险操作的时候还是怂了。。。</p><p>看了看整个 &#x2F;var 分区，光 lib 目录就占了 6GB，好，就你了！登录到root，kill掉普通用户，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /var/lib /usr/var/</span><br><span class="line"><span class="built_in">ln</span> /usr/var/lib /var/lib</span><br></pre></td></tr></table></figure><p>把lib移动到别的地方然后创建了软链接。重新启动，一切正常。BW上传了涩图，心满意足地回去睡觉了。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>第二天晚上，BW发现，自己的博客访问不了了。</p><blockquote><p>由于hexo常常被神秘kill，BW创建了一个cronjob，每分钟运行一次检查hexo服务器运行状态的脚本。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ !$(pstree | grep hexo) ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">cd</span> ~/blog</span><br><span class="line">hexo server &gt;&gt; <span class="built_in">log</span> 2&gt;&gt; <span class="built_in">log</span> &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>原来，cron是能正常地维护hexo运行的。但是今天不知道抽了什么风，从<code>service cron status</code>能看到cron运行了这个脚本，但是hexo并没有被启动。</p><p>查看脚本的log，发现：</p><p><img src="2021-04-27-hexo_not_found.png" alt="hexo_not_found.png"></p><p>hexo命令就没找到。在脚本里加了一句<code>echo $PATH</code>，得到的结果居然是：</p><p><img src="2021-04-27-print_path.png" alt="print_path.png"></p><p>PATH神秘地不正常了。我检查了运行账户和 root 的 PATH, 都没有发现不正常的地方。甚至如果直接运行脚本，都是可以启动的。但唯独由 cron 运行的时候，PATH 就变了。</p><p>Google 了一下，发现 cron 本身会忽略 <font color="red">&#x2F;etc&#x2F;environment</font> 文件（但是为什么之前不会呢，小声逼逼）</p><p>于是给定时脚本的头部重新声明了 PATH …</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何看待讨论政治然后群被爆破同学被封号</title>
      <link href="/20210426_The_Banned_Group/"/>
      <url>/20210426_The_Banned_Group/</url>
      
        <content type="html"><![CDATA[<p><del>（还是太闲了）</del></p><p>中午搁群里讨论两岸问题和 Highest-Leader，提到Putin，也提到教员，一位同学（我现在已经查不到他说了什么了）参与比较积极。到晚饭的时候，可能是被大数据扫描到了，很快啊，群就无了。</p><p>据说有这么回事：</p><p><img src="2021-04-26-Politics_on_Keyboard_Forbidden.jpg" alt="Politics_on_Keyboard_Forbidden.jpg"></p><p>如何看待：</p><blockquote><p>我们的民主传统今年是一个很大的发展，以后要把大鸣、大放、大辩论、大字报这种形式传下去。这种形式充分发挥了社会主义民主。这种民主，只有社会主义国家才能有，资本主义国家不可能有。在这样的民主基础上，不是削弱集中，而是更加巩固了集中制，加强了无产阶级专政。因为无产阶级专政要靠广大的同盟军，单是无产阶级一个阶级不行。中国无产阶级数量少，只有一千多万人，它要靠几亿人口的贫农、下中农、城市贫民、贫苦的手工业者和革命知识分子，才能实行专政，不然是不可能的。我们现在发动了他们的积极性，无产阶级专政就巩固起来了。</p><p align="right">——《毛泽东选集》第五卷</p></blockquote><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 观点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高强度使用Seagate机械硬盘的悲惨下场</title>
      <link href="/20210426_HDDtragedy/"/>
      <url>/20210426_HDDtragedy/</url>
      
        <content type="html"><![CDATA[<p>省流大师：虽然本文没有发生任何悲剧，但数据无价，重要数据至少要有3份的冷备份。</p><p>不一定正确的个人观点：</p><p>机械盘不一定靠谱，要靠谱的机械盘至少得是黑盘吧。5年质保可以体现厂家对产品的信心。</p><p>固态放数据没那么容易死，颗粒是很耐艹的，主要是主控问题，如果能修主控，这玩意甚至能当传家宝。</p><p>固态太贵啦，一般建议上黑盘。</p><p>辣鸡硬盘raid1也不错。</p><hr><p>标题的“高强度使用”说得太轻了，机械盘上NTFS分区对4000个文件排序简直是雷普磁头。</p><hr><p>就在凌晨3点钟，BW为了找到聊天记录里的一张图，费了老鼻子劲翻QQ的文件，并试图对其按日期进行排序。4000个文件的一个文件夹，M$愣是卡了一个多小时，BW把它丢到后台了。</p><p>在某一个时刻，突然QQ卡了；QQ关不掉了；用任务管理器关QQ；任务管理器卡了；uTorrent卡了；v2ray卡了。</p><p>于是BW想都没想反手一个重新启动，结果关机卡了。</p><p><img src="2021-04-26-chubbycat.jpg" alt="chubbycat.jpg"></p><p>按主机上的 reset 按键，结果开机也卡在 Windows 转圈加载的地方。</p><p>伴随的是机箱上的硬盘灯常亮，BW一下就知道肯定是年纪最大的D盘出问题了。于是拔掉硬盘，果然开机。</p><p>等到白天，查了一下发现一条热知识：</p><blockquote><h3 id="SATA-可以热插拔"><a href="#SATA-可以热插拔" class="headerlink" title="SATA 可以热插拔"></a>SATA 可以热插拔</h3></blockquote><p>于是开着机<del>（冒着被电死的风险）</del>插上了SATA线，此时可以正常识别到并且挂载。至于当时开机不能开是因为有D盘上的启动项就是前文提的 utorrent 和 v2ray，挪到C盘发生过神秘错误于是就犯了懒。</p><p>经过3个小时的坏道检测，得到了如下结果：</p><p><a href="https://files.tilnel.xyz/uploads/2021-04-25-2021-04-25.png"><img src="http://file.tilnel.com/uploads/2021-04-25-2021-04-25.png" alt="2021-04-25.png"></a></p><p>备份了一波数据然后修好了，但只能好一点：</p><p><img src="2021-04-26-recovered.png" alt="recovered.png"></p><p>随后就正常开机了。</p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v2ray配置代理服务器</title>
      <link href="/20210425_v2ray_school_proxy/"/>
      <url>/20210425_v2ray_school_proxy/</url>
      
        <content type="html"><![CDATA[<p>清明节回老家一趟，没有校园网。本以为用南大提供的<code>EasyConnect</code>服务就可以从公网登上校园网做OJ，没想到这个软件在Android手机上可以以极慢的速度连接，在Windows上一直连接不上，在Linux上…甚至安装不了。</p><p>最后我的办法：在手机上看题；在电脑上写代码；发到手机上，复制粘贴提交。对于Lab这种要git的……我只能骂这个学校VPN到底是个什么$hit。</p><p><img src="2021-04-25-wdnmd.jpg" alt="wdnmd.jpg"></p><p>在那之后我的新机计划正式启动了，这就给了我极大的施展空间<del>（所以说这台主机到底够我氵多少篇博客）</del></p><p>从校外访问OJ，第一个方案是端口映射</p><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>上篇文章中介绍了proxyer，我们用proxyer将114.212.10.47:8085映射到公网服务器上的8085端口，然后尝试访问，Boom！成功了！</p><p><img src="2021-04-25-access.png" alt="access.png"></p><p>但是点开<code>login</code>，就会看到：</p><p><img src="2021-04-25-error.png" alt="error.png"></p><p>由于某些原因（<del>Aunt讲了但是我忘了</del>），这种访问方式无法获得OAuth的授权。</p><p>于是把目光转向了v2Ray代理，从校内主机访问网站总不可能被拒绝吧？</p><h2 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h2><p>因为时间隔了半个月，所以自己也不知道当时配置的时候到底踩了哪些坑了，就当做一个正确的流程来参考吧。</p><p>首先是安装v2ray。对于ArchLinux而言，直接<code>sudo pacman -S v2ray</code>就完事了。</p><p>其他的开发版就直接参考<a href="https://www.v2fly.org/guide/install.html">项目文档</a>。</p><p>关于v2ray的详细配置教学，可以参考<a href="https://toutyrater.github.io/">这个文档</a>。</p><p>安装完成之后，我的配置文件在<code>/etc/v2ray/config.json</code>，先上配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;loglevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;warning&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/v2acc.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/v2err.log&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">1234</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;***此处需要自行生成任意UUID***&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;alterId&quot;</span><span class="punctuation">:</span> <span class="number">64</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freedom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blackhole&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blocked&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;geoip:private&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blocked&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>首先，<code>log</code>是指定日志文件的路径；</p><p>v2ray 使用 inbound 和 outbound 的传入和传出的结构，代表数据包的流动方向。我们就可以把 v2ray 当作一个盒子。inbound 接受来自客户端的请求，outbound 则将数据包发到目标去。</p><p><code>inbounds</code> 入站规则，依次配置端口号、协议、对客户端的约定。其中 <code>id</code> 字段只需要自己随便生成一个UUID往里填就完事了。使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/random/uuid</span><br></pre></td></tr></table></figure><p><img src="2021-04-25-uuid.png" alt="uuid.png"></p><p><code>outbound</code> 出站规则，第一个为默认规则，配置协议为 freedom，即为直连。</p><p>保存配置文件，<code>v2ray &amp;</code> 启动代理。用 proxyer 工具将刚才配置填写的端口映射到公网服务器上的任意端口，服务端的建设就算是完成了。</p><p>客户端，以安卓端的 V2rayNG 为例，选择手动输入[Vmess]，依次填入服务器地址，端口号，刚才生成的UUID。alterId 填4，加密方式 auto，传输协议 TCP。保存并连接。这里注意，如果是要访问内网ip，在路由模式上就要选择全局代理，而不是绕过局域网地址。</p><p>然后就可以正常登录上 Online Judging 啦！</p><p>yls的肯定：</p><p><img src="2021-04-25-IMG_20210425_022245.jpg" alt="ylsnoadmit"></p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>青年男性花了8个月才将他的博客投入使用，这是他心态发生的变化</title>
      <link href="/20210423_firstpost/"/>
      <url>/20210423_firstpost/</url>
      
        <content type="html"><![CDATA[<p><del><strong>BW</strong> is a 20-year-old young man, presenting to the emergency room, dead on arrival.</del></p><p>事情是这样的：</p><p>去年（20年）8月份<del>考完期末没事干</del>整了一台阿里云的主机，想说搭个博客玩玩，花了几天的时间成功上线了（仅WordPress的默认主题页面）。后来这个人嫌主题太丑了一直懒得维护博客，一篇文章都没有发。</p><p><img src="1.png" alt="img"></p><p>时隔几个月，服务器从阿里换成了2C4G的腾讯（感谢群友的推荐，6M带宽真良心，当场就买了4年）。又得益于<del>脑子坏了</del>升级了一下主机，把旧的CPU和一些二手部件凑成了一台新的小主机（如图）。加上端口映射服务，服务器喜沦为端口映射工具，几乎所有的服务都跑在本地了，6C12T 16G的本地服务器它不香吗？</p><p><img src="image-20210423133158354.png" alt="image-20210423133158354"></p><p>屑BW连库都没删，直接让原来的阿里云主机自动释放就跑路了。</p><p>本来开了几个html和css的教程，想自己设计一个UI，最后<del>懒得学JS</del>。于是就有了这个基于HEXO框架的网页。</p><p><del>啊，现成的框架真香。</del>（懒人发言）</p><p>现在跑起来的：</p><p><a href="http://blog.tilnel.com/">hexo静态blog</a> （本站）</p><p><a href="https://git.tilnel.com/">gitlab</a>（开放注册，本地服务器内存随便吃）</p><p>vmess校园网代理（可以从校外访问校园网，yls用了都说好）</p><p><a href="https://github.com/khvysofq/proxyer">proxyer端口映射</a> （为公网IP省了一大笔钱，虽然速率受到服务器带宽限制）</p><p><img src="image-20210423134612284.png" alt="image-20210423134612284"></p><p align="right">    <font color="#0000ff">        &lt;EOF&gt;    </font></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在蒋炎岩的 Office Hour</title>
      <link href="/20201015-jyyofficehour/"/>
      <url>/20201015-jyyofficehour/</url>
      
        <content type="html"><![CDATA[<p>今天在蒋炎岩的office hour 厚颜无耻地过去咨询了一波。</p><p>大概问了这样一些问题：</p><p>问题求解学不好怎么办？</p><ul><li>基础的逻辑和离散数学去找两本书看看就行了</li><li>OJ方面，去刷Leetcode上面适合自己水平的难度的题目。其实问题求解课的OJ难度过高了，（教学事故！）</li></ul><p>计算机系统基础学不好怎么办？</p><ul><li>学习的初期会有低投入但是高回报的阶段，利用好这个阶段来找找信心。比如说，去看一些vim的比较短的tutorial，然后尽快地应用到PA当中。之后就慢慢升级就好了。</li><li>如果觉得PA比较难的话，就去学一学基础的C语言。</li></ul><p>时间管理。。。</p><p>然后就坐在那里听了一会儿蒋炎岩的组会。具体就是每个人把一周以来的工作都介绍一下。还有工作里出现的问题都讨论讨论。主要有几个内容：</p><ul><li><p>编译器优化\逻辑相关</p></li><li><p>QEMU 相关</p></li><li><p>还有一些PPT, 论文等</p></li></ul><p>和蒋炎岩聊天还是很舒适的。蒋炎岩并不会把事情怪在学生得头上，而是提出非常中肯的建议。</p><p>在组会的过程当中，也会和学生聊一些“家常”，这样就显得很亲切，不愧是老大哥(</p><p>会夸学生想出的方法是good idea</p><p>蒋炎岩的学生的思维也很活跃，我觉得我会喜欢这样的地方。不像是匡院内部，总觉得死气沉沉的，非常闷。虽然大家都很有才，也没人会yygq，但就是喜欢不起来这个地方，也许都是老社恐了吧(</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间管理</title>
      <link href="/20201009-time_manage/"/>
      <url>/20201009-time_manage/</url>
      
        <content type="html"><![CDATA[<h3 id="一、高效的时间管理-x3D-高效率-高效能"><a href="#一、高效的时间管理-x3D-高效率-高效能" class="headerlink" title="一、高效的时间管理 &#x3D; 高效率 + 高效能"></a>一、高效的时间管理 &#x3D; 高效率 + 高效能</h3><ul><li>高效率：同样的事情，比别人效率更高，用更少的时间完成</li><li>高效能：做同样的事情，获得更高的回报</li></ul><h5 id="在平时学习与工作中，注意避免不确定的因素，进而提升执行速度"><a href="#在平时学习与工作中，注意避免不确定的因素，进而提升执行速度" class="headerlink" title="在平时学习与工作中，注意避免不确定的因素，进而提升执行速度"></a>在平时学习与工作中，注意避免不确定的因素，进而提升执行速度</h5><h5 id="为什么计划总是完不成？"><a href="#为什么计划总是完不成？" class="headerlink" title="为什么计划总是完不成？"></a>为什么计划总是完不成？</h5><p>不确定的因素：要做的事情不甚明晰，驱动力不够</p><h4 id="3W原则："><a href="#3W原则：" class="headerlink" title="3W原则："></a>3W原则：</h4><p>WhenWhereWhat</p><p>明确在什么样的场景，什么时间点做什么事情，提前确定有计划，又行动清单的具体性落实计划</p><h3 id="二、只需一个行为，提升时间注意力"><a href="#二、只需一个行为，提升时间注意力" class="headerlink" title="二、只需一个行为，提升时间注意力"></a>二、只需一个行为，提升时间注意力</h3><h4 id="本子-笔"><a href="#本子-笔" class="headerlink" title="本子 + 笔"></a>本子 + 笔</h4><h5 id="专注做一件事情的时候，把手机放在离自己比较远的地方"><a href="#专注做一件事情的时候，把手机放在离自己比较远的地方" class="headerlink" title="专注做一件事情的时候，把手机放在离自己比较远的地方"></a>专注做一件事情的时候，把手机放在离自己比较远的地方</h5><p>一旦头脑中产生 任何和目前事情不想关的想法，就用笔记下来。只要有想法就马上先记下来。</p><p>及时记录下来，这些想法就不会反复跳出来，影响之后的进度。</p><h5 id="可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事"><a href="#可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事" class="headerlink" title="可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事"></a>可以设置好一个番茄钟时间，比如45分钟，在这段时间内，有计划有目的地专注一件事</h5><h3 id="三、善用时间进度条"><a href="#三、善用时间进度条" class="headerlink" title="三、善用时间进度条"></a>三、善用时间进度条</h3><h5 id="相对好用的方法"><a href="#相对好用的方法" class="headerlink" title="相对好用的方法"></a>相对好用的方法</h5><p>先制定一个限定时间，然后项目拆分成一个个小任务，如ABCDE计划，如果在A上花费很长时间没有结果的时候，跳过A任务，进入B任务。大脑在遇到问题的时候一般会进入死循环。这时候就需要自己去做一个 <code>Break;</code></p><p>完成另一件事之后，人的情绪也会得到释放</p><h4 id="树立一个观念：完成比完美更重要！！"><a href="#树立一个观念：完成比完美更重要！！" class="headerlink" title="树立一个观念：完成比完美更重要！！"></a>树立一个观念：完成比完美更重要！！</h4><p>比如说，为了完成一个文章，找一个开头素材就找了两个小时。或者说配置工作环境就配置了一整天。其实在不影响整体工作效率的时候，可以把这些细节的问题单独留下来，之后再安排时间来处理。这样比穿插其中效率要高。</p><h3 id="四、长久坚持一件事，寻找最短的时间路径"><a href="#四、长久坚持一件事，寻找最短的时间路径" class="headerlink" title="四、长久坚持一件事，寻找最短的时间路径"></a>四、长久坚持一件事，寻找最短的时间路径</h3><p>如何在短时间内获得最好的效果？</p><h4 id="三个维度"><a href="#三个维度" class="headerlink" title="三个维度"></a>三个维度</h4><h5 id="1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍"><a href="#1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍" class="headerlink" title="1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍"></a>1、障碍最少：当决定做一件事情的时候，提前准备好工作，排除障碍</h5><p>比如想早起晨跑，就前一晚准备好跑步的衣服和鞋子</p><h5 id="2、意义多维：赋予一件事有意义"><a href="#2、意义多维：赋予一件事有意义" class="headerlink" title="2、意义多维：赋予一件事有意义"></a>2、意义多维：赋予一件事有意义</h5><p>例如：跑步时可以听书或者听音乐，所以在前一晚准备好适合跑步的印品，适合跑步时间及节律的。</p><h5 id="3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话"><a href="#3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话" class="headerlink" title="3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话"></a>3、条件反射：当头脑中出现各种排斥坚持的时候，压迫换一种思维方式对话</h5><p>比如，从一开始想要跑步的时候，早起的时候自我提问：今天要不要跑步，往往就会冒出抗拒的想法。</p><p>后来换一种思维方式对话：我今天是要跑3公里还是5公里，这样思想的负担就感觉减轻了。</p><p>时间长了就会条件反射，跑步就是习惯的自然而然的事情了。</p><h3 id="五、把重要事件从紧急事件中去掉"><a href="#五、把重要事件从紧急事件中去掉" class="headerlink" title="五、把重要事件从紧急事件中去掉"></a>五、把重要事件从紧急事件中去掉</h3><h4 id="1、列重要事件清单"><a href="#1、列重要事件清单" class="headerlink" title="1、列重要事件清单"></a>1、列重要事件清单</h4><p>很多事候列出了重要的事情，都因为拖延的习惯变成了重要饮酒的事情</p><p>其实重要的事情需要提前做好准备。反复练习重要清单，避免拖拉，如果拖拉最后就会变成重要紧急的事件，让自己处于被动当中。</p><p>尽量在时间节点前很久就把事情做好，而不是等到最后一刻。</p><p>2、逐渐增加每天做重复时间的比例，直到50%</p><p>清单里面要增加重要但不紧急的时间，每天增加做一些，不往后拖，逐渐养成规律的习惯。</p><p>3、在重要的时间提前做重要的事情</p><p>写出自己的黄金时间，做重要的事件。其他时间从清单里挑重要非紧急事件，而不是重要紧急清单里的。注重养成做重要非紧急事件的习惯。</p><p>当你的清单里，常做的是重要非紧急的事件的时候，会慢慢地感觉到人生的掌控感。</p><h4 id="GTD的核心原则"><a href="#GTD的核心原则" class="headerlink" title="GTD的核心原则"></a>GTD的核心原则</h4><ul><li>收集：把任务从大脑里清出来，形成待办列表</li><li>整理：整理待办任务、分类任务</li><li>组织：下一步行动、形成项目、等待处理、将来处理</li><li>回顾：按日回顾、周回顾、月回顾来总结GTD系统</li><li>执行：Do it! 没什么好说的</li></ul><h3 id="六、每天精进一点点：日行动-周复盘-月度计划"><a href="#六、每天精进一点点：日行动-周复盘-月度计划" class="headerlink" title="六、每天精进一点点：日行动-周复盘-月度计划"></a>六、每天精进一点点：日行动-周复盘-月度计划</h3><p>定期总结与反思，有利于了解自己的不足，促进进步。</p><p>每天落实计划行动，每周进行复盘，分类总结的习惯。同时也要有月季花，并且是切实可行的行动计划。</p><p>每天临睡前都把第二天要做的事情写出来，并分类在各个象限里。每周进行一个小小的回顾，工作-学习-生活几个大模块进行复盘。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记 919</title>
      <link href="/20200922-for919/"/>
      <url>/20200922-for919/</url>
      
        <content type="html"><![CDATA[<p>​刚知道吴琳老师只比我的父亲大两岁，虽然老师的白头发很多，但用精神矍铄来形容显然不合适。初见吴琳是高一参加竞赛，第一年侥幸获得了参加初赛的资格，在省强化班上有幸聆听吴琳老师讲的有机课。白衬衫搭黑色西裤，永远挺直的高而瘦削的身板，俨然一翩翩君子。上课节奏之快让我直呼跟不上，但那些有机扎实的学生都非常爱听。</p><p>再见时是第二年的强化班，吴老装束未变，风度不减。自习一年有机后再听一遍合成课，每一步的思路都很顺畅，收获颇丰。</p><p>大一上纠结学业方向的时候，又前去听了几节课。节奏不似竞赛课上那样紧张，课堂问答时也是难得地看到了吴琳老师的笑容。</p><p>我对吴琳老师的记忆仅限于此。摘录知乎中的评价：</p><p>作者：杨涵<br>链接：<a href="https://www.zhihu.com/question/26620131/answer/45797384">https://www.zhihu.com/question/26620131/answer/45797384</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>接下来就是化院不得不提的少有的另无数学妹颤抖的男神老师吴琳了，大二教一部分人一年的《有机化学》（那一半，男神不爱你们，你们哭去吧）。没上大学之前，我以为大学老师都应该是那种，上课带个茶杯，把书往桌子上一扔，拿起粉笔一讲一节课的人，靠PPT的是什么鬼？可是上了大学才发现，其实很多老师还是很水的，拿着甚至不是自己做的PPT，然后念一个学期。而我心里面多希望的那种老师也遇到过，可大多数是文科的，理工科的就只见过吴琳男神了。</p><p>男神上课，从不看书，各种键能键角，信手拈来。跟着男神搞一年机，发现基本上邢大本真的能记得差不多，而且完全没有那种刻意去背的感觉。可是我现在早已都还给男神了<br>男神考核，木有平时成绩，不算期中考试成绩，第一学期期末考试默认考整个学期内容，第二学期期末默认考整个学年内容。考多少是多少（我就问你慌不慌！！）。真叫一个洒脱。</p><p>深耕于教学的老师，如今是副教授。</p><p>建议再翻翻耿柳娜的简历对比。</p><p>我要气死了</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一次去酒吧</title>
      <link href="/20200920_firsttimeinbar/"/>
      <url>/20200920_firsttimeinbar/</url>
      
        <content type="html"><![CDATA[<h6 id="记第一次独自去酒吧（给自己看-晨起写下的昨晚事"><a href="#记第一次独自去酒吧（给自己看-晨起写下的昨晚事" class="headerlink" title="记第一次独自去酒吧（给自己看)  晨起写下的昨晚事"></a>记第一次独自去酒吧（给自己看)  晨起写下的昨晚事</h6><p>​最近突然想起在附近转一转，找点一个人消遣的好地方。这就骑车跑到了仙林中心的金鹰附近。</p><p>​本来是想看一眼胡桃林那家怎么样的，可是到了跟前我踌躇了。且不说单看MENU这本质上只是一家餐馆，我看见一个中年男人抱着2岁大的幼儿出来，就觉得这里不是我要找的地方。当然更多还是因为我不敢往人这么多的地方走，老社恐了。</p><p>​一个人坐在树边的椅子上，像是和朋友约好出来玩却临时被人放鸽子一样划着手机，在找有没有下一个适合我的地方。看到大成里刚好有两三家。和金鹰不同，大成坐落在这个湖的角落，楼栋和金鹰广场的流光溢彩相比实属暗淡无光。如果说金鹰前的这片湖是情侣们约会的好地方，那么角落里灰头土脸的大成或多或少杀了一下风景。</p><p>​我非常诚实地动起了双腿，迅速绕过成群结对的人们，到达了湖对岸的大成。</p><p>​对面是公厕的布局摆明了这是一个很老的地方。走过附近时还能闻到垃圾桶散发的酸臭，我却分明看到有两个人坐在附近的长椅上，我有些惶恐。走进大成的小门，第一个看见的是一个图文工作室，里面几个大学生模样的人在忙些什么。旁边一家店里只有店主一个人，他注视着我。我对于这目光感到不适，于是赶紧上楼了。到了二楼，周围比一楼更加冷清，令我吃惊的是在这里姑且还开了一点服装店。原先想找的2楼酒馆，望了一圈竟发现一张催缴物业费的条子贴在被大长锁封印的铁门上。相比这么冷清的地方，跑路也是很正常的。</p><p>​我有点失落地下了楼，发现刚才那家店竟然同样是一家酒馆，只是在地图上哪里都看不见。抱着试一试的心态想要走进去。店主从玻璃墙里注视着我进了店门。</p><p>​我们从进门一直对到我因为心神不宁而找了一个地方坐下。“我是第一次来这种地方。”<br>​“你能找到这里也是挺厉害的。我们店一直都是低调宣传，来的基本上是熟客。”</p><p>​店主脸庞瘦削，头发像是天生的卷发，笑起来两颗门牙可见像只兔子。他顺手递了一根烟，摆手说不抽。一番攀谈了解到店主是附近南中医的学生，用业余时间在经营这家酒馆。现在已经开了3年了，而他本人也已经大四。他说他有点想要读个研，为了把这家酒馆继续开下去。</p><p>​环顾四周，能看见一些音响设备，和一架KeyBoard。电视机里放的是某摇滚主题的电影。这家店可以说是纯粹为了兴趣而开的，从照片墙上可以看见这里曾整过许多音乐活动，大家都是兴趣相投的人。这和很多快餐式的以约炮为目的的地方并不一样。店主给我拿了一瓶雪碧，告诉我曾经也有一个南大来到了这个地方，一直疯玩，最后；辍学去做中介了。听到这里我不禁对来到这里的自己的未来产生怀疑。或许我要步他的后尘，亦或者我被前人警醒。</p><p>​少过片刻，一位身材魁梧，胡须浓密的大哥背着挎包来了。刚一进门就说道：</p><p>​“我真羡慕你这长头发，我想留的结果被女朋友逼着剪了。”</p><p>​我和店主都笑了出来。这位是店主的合伙人，一进来就在捣鼓各种设备。不一会儿，音乐有了，这算是做好了开张的准备。</p><p>​人逐渐多了，进来了两个毛头小子，在一边摇骰作乐，聒噪不休。一伙男的带着一票女的走进店门。这真的是纯粹的地方吗？原来无关地方，不纯粹的始终都只有人而已。我开始感到有些不适，于是坐到吧台那儿去，边上是一位梳着背头，打扮颇为体面的酒客，看起来和这里的店主都互相熟悉。请技术员兼调酒狮为我推荐了一种酒。啤酒的沫满溢着玻璃杯，我正要举，边上的酒客这就与我碰了一杯，稍微有点不知所措但还是立刻摆出了笑容并且作领会状，小口啜饮着短梦中炽热的狂乐。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>发生了什么？</title>
      <link href="/20200728-chat/"/>
      <url>/20200728-chat/</url>
      
        <content type="html"><![CDATA[<p>王舒宇来找我聊了两次，说实话我是不太懂的。</p><p>“说不定我哪天想不开去学而思上班”</p><p>“上了大学发现上大学也没啥用”</p><p>“我读书读累了”</p><p>第二天又是</p><p>“话说，你一般几点睡”</p><p>我的错觉又来了。不过后来我们也没再说什么话。这样真的好么？我不知道她现在和王亦辰是什么状况了。</p><p>我真的怀疑，但是如果怀疑错了，那就没有朋友做了。怀疑的成本很高，还是装糊涂算了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.1 个小目标</title>
      <link href="/20200727-fire/"/>
      <url>/20200727-fire/</url>
      
        <content type="html"><![CDATA[<p>FIRE。在知乎上看到了这样的设想。Finalcial Independence Retire Early。尽早逃离费时费力的工作，然后享受人生。</p><p>基本逻辑：无论赚多少钱，都要过极简的生活，以求储蓄率达到 50% 甚至更高。攒够一年生活费的 25 倍后，就可以退休了。提早过上用被动收入覆盖所有开支的生活。</p><p>在 35 - 40 岁前安排好被动现金流，通过长期的金融工具来达成。如保险、股票与指数基金。可以在不受金钱的驱动下做自己认为更有意义的终身职业。</p><p>可能遇到的问题：</p><ul><li>房贷。只能说要考虑清楚。</li><li>通胀。飙升可能性不大。</li><li>负利率。配置长期锁定利率的产品。</li><li>黑天鹅风险。建立家庭保障系统。<ul><li>成年人：定期寿险 + 意外险 + 重疾险 + 医疗险</li><li>小孩：定期重疾险 + 意外险 + 意外险</li><li>老人：优先医疗险 + 意外险。有余力则重疾险 + 终身寿险</li></ul></li></ul><p>达成手段</p><p>读完研究生，那就要到 2026 年 6 月，25 周岁的时候。如果在这之前实习、兼职，每月存款顶天是 1-2k 原的情况下，最多有 100k 存款。显然是没有多大用处。</p><p>考虑到开销、买房买车，需要的年薪达到了恐怖的 2m。所以肯定是要把重心放在主业上，在领域内作出一些成绩。</p><p>不过，我还认为要设置另外一重标准：读大学期间是否能够攒到 1m。提前积累工作经验是好的。</p><p>那就要强化自己的能力了。当时想的是成为内容创作者。但是首先：要有内容。然后也可以运营网站。</p><p>为了大方向上的顺利执行，必须要改变日常的计划。<br>首先是要多以学业成绩为优先。也不是说放弃活动，而是要减少一些无所谓的娱乐和无所事事的额时间。要在提升自己这件事上更加地讲效率。以计算机专业课为重。</p><p>多学习开发相关的知识，要尽量全能一点。着手开发产品、制作渲染视频，可能能够提供不通的收入思路。</p><p>另外要多看书，提升思想。</p><p>平时消费注意开源节流，早日租房自己住。</p><p>养成良好的习惯。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回忆三哥</title>
      <link href="/20200309-memories/"/>
      <url>/20200309-memories/</url>
      
        <content type="html"><![CDATA[<p>关于王舒宇的一些回忆。</p><p>高一的时候，印象可能并不深刻。传说喜欢过江海洋，后来江本人也是认证了这个传闻。江海洋也是传奇人物。</p><p>后来分班和她分在一起，感觉还挺幸运。那个时候属于稍微接近一点就有好感的阶段。高二下她过生日的时候随便挑了个礼物送。</p><p>然后呢，然后呢？后来她就疯狂学习。一个人坐在教室后面埋头苦干。</p><p>有节语文课前的演讲她做了个关于天赋与努力的题材。我记得当时还是挺受鼓舞的。不过我至今也没有搞清楚自己到底是天赋型的还是努力型的。因为我平时不算顺利，那时候也不摆烂。天赋不如 wyc，努力不如 wsy，一半对一半，我是运气型。</p><p>现在她去了南医大，她已经努力惯了，对她来说虽然艰难但也得心应手吧。</p><p>每到不如意的时候就会回忆往事，然后继续不行动。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梦</title>
      <link href="/20200308-yume/"/>
      <url>/20200308-yume/</url>
      
        <content type="html"><![CDATA[<p>梦见自己停下大学的学业回金陵中学复读重考。最近感觉自己完全失去了学习的动力，总感觉实在是应付差事，没有积极性可言。可能是感到和想象中不太一样？</p><p>如果要从上学期的表现中找出一点端倪的话，那就是什么都图方便省事，最终是降低了学习效率，实际上是一种不思进取的感觉。</p><p>同时也是失去了一个拥有良好关系，互相爱惜的竞争对手，失去了老师一般的人物，现在没有这种人在背后注视我（录者注：凝视）。但是，总算不能被那家伙嘲笑呗。至少要一样强大才可以，否则就只能说是我的运气比她好。</p><p>我记得<br>你给我讲过的解析几何题<br>回南京高铁上的美梦<br>考前倒数第二天我们忍着热气在教室外面写完的试卷 - 为什么你也会出来呢？<br>你在运动会上的坚持<br>坐在教室后面，沉默的压迫感</p><p>かずさ、見つけた。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二月的尾巴</title>
      <link href="/20200229-mahjong/"/>
      <url>/20200229-mahjong/</url>
      
        <content type="html"><![CDATA[<p>今天是要自学物理然后写很多作业的一天。以及问求作业。。。</p><p>昨天买了 97 天的天凤有料，然后狂打 12 个半庄。1 + 4 + 5 + 2，非常难受。</p><p>没错，这种防守在特上肯定是要被打爆的。然后雪菜给我指明了这个问题，但我不太懂防守细节以及。。。手模切记不住啊。。。</p><p>想舒坦地打天凤就赶紧去做物理作业啊。。。</p><p>中午又吃了两个四，付出了 150pt 的惨痛代价，这样怎么才能升 7 ？</p><p>打着打着又不专心了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我又在闹笑话</title>
      <link href="/20200116-joke/"/>
      <url>/20200116-joke/</url>
      
        <content type="html"><![CDATA[<p>所以金乐怡 17 岁到底爱上的是谁呢？她现在已经 18 岁了。</p><p>我想真的可能是我吧。但她现在有新的男朋友了。祝她幸福。</p><p>做了个梦，梦见擦伤了去医务室，小姐姐看上去没比我大多少。她帮我清理伤口，很舒服，我忍不住吻了她，她没有抗拒。之后，她甚至主动发起进攻。但正在沉醉的时候，她不见了。</p><p>（。。？该怎么说，录这段的时候完全不知道当时在想什么）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>期末了。。。</title>
      <link href="/20200105-final/"/>
      <url>/20200105-final/</url>
      
        <content type="html"><![CDATA[<p>果然充实，不过是在 12 点起床的基础上的充实。</p><p>于是昨天也只学了没多久吧。。下午一直写 OJ 了。</p><p>今天下午 2 点到 4 点考试的话，那大概学到十一点半去吃饭，再看一小时就要去考场了。</p><p>还有思修、生物和微电子，烂完了。最重要的是生物还有作业。</p><p>没事，只要晚上不熬到两点半，还是有希望考好的。睡就睡了呗。懒得再碰类似的游戏了。。。</p><p>回顾一下过去的美食节。还是能够触动我的内心的。之后和同学在市中心转，但是没有一个地方能容得下我们玩的。跨年夜人也太多了。不过搜到了 royal 清吧，以后可以来玩玩。</p><p>有了一个新年愿望：想成为出色的内容创作者，想为美食节拍个纪录片。或许可以穿着校服混进来？待一整天可还行。或者说，要待好几天才对。</p><p>因此，要学习拍摄、剪辑、配音、写分镜、台本，并且准备好相关的器材。</p><p>为了获得足够的收益，可能需要先制作一点其他的内容。</p><p>不要无心复习啊。。还得考试呢。。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>舞台</title>
      <link href="/20191221-stage/"/>
      <url>/20191221-stage/</url>
      
        <content type="html"><![CDATA[<p>我果然是热爱舞台的。</p><p>上周的朗诵巨赞。我还是有点紧张，在恩玲这种大舞台上。但我并没有感到渺小，而是觉得台下其实也并没有那么大，没有什么怯场的感觉。</p><p>唱歌的时候虽然担心，但是也算从容。享受音乐，享受舞台的感觉。最近也是体会到了一些歌词的美妙：</p><p>“因为誓言不敢听，因为承诺不敢信。所以放心着你的沉默，去说服明天的命运。<br>没有风雨躲得过，没有坎坷不必走。所以安心地牵你的手，不去想该不该回头。”</p><p>还有一些歌词甚至能想象到画面：</p><p>“金色的城池，银色的港湾，我走过了多多少少”</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>沉思录 课堂随记</title>
      <link href="/20191211-Notes/"/>
      <url>/20191211-Notes/</url>
      
        <content type="html"><![CDATA[<p>课上就记得不太工整，各种缺失。只是打发时间做的。</p><p>但是是胡大平讲诶。我后来才知道他牛逼。</p><p>一、希腊晚期哲学<br>二、斯多葛主义<br>三、奥勒留：生平与思想<br>四、讨论</p><p>核心思想？选项是四个流派<br>A. 幸福就是过一种德性的生活</p><p>BC 322 - AD 524 . 从 Alestrote 逝世开始。</p><p>背景：城邦 - 塞琉古、托勒密、马其顿 - 罗马帝国</p><p>城邦公民 - 世界公民</p><p>时期： 希腊化时期&#x2F;罗马时期</p><p>特征： 伦理转向，世界主义，宗教因素</p><p>流派： 伊比鸠鲁主义，怀疑主义，新柏拉图主义，斯多葛主义</p><p>城邦制被取代，建立起超越城邦的王国，产生哲学的转向。</p><p>公民：具有自我意识的主观性这一重要意义。没有着落、根基的世界感。</p><p>伦理转向：从以思辨形而上学为主，到服务于伦理实践，做一个何样的人，怎样在世界中安定自身</p><p>宗教：过渡到中世纪。主要是新柏拉图主义。</p><p>伊比鸠鲁主义</p><ul><li>原子论 为本体论，由微粒组成，存在虚空。改造，非机械的，自由的</li><li>感觉主义 感觉统率理智、理性。感觉是第一性的，最可靠的。理性反而是有错的</li><li>快乐主义 身体性的是低级快乐。追求精神内心的宁静、平和</li></ul><p>新柏拉图主义 普罗提诺</p><ul><li>太一 最高最完满的存在 游离出时空</li><li>努斯 一种影子、摹写</li><li>人处于可感世界。灵魂向上，肉体向下</li><li>实现完满：观照</li></ul><p>怀疑主义 皮浪 悬搁判断 不动心</p><p>斯多葛主义 Stoa</p><ul><li>提翁的芝诺（晚一点的）</li></ul><p>中期：共和国时期 巴内修斯，西塞罗</p><p>晚期：罗马帝国</p><p>此时，斯多葛派学说几乎成为“官方学说”</p><p>越晚期，越低沉，越消极，贴近宿命论。</p><p>逻辑学：篱笆<br>伦理学：庄稼<br>物理学：土壤、树木</p><p>三者是一个整体，核心是伦理学，如何安身立命</p><p>自然哲学（物理学）</p><p>赫拉克利特 （形式与质料）<br>两种本源，主动的（形式），理性、“逻各斯”、尺度、神。被动的（Alestrote 式的质料）<br>微观层次：元素，火-气-水-土-火，一切由火的运动变化而成</p><p>伦理学</p><p>早期：德性知识论，善的目的论<br>顺从命运、禁欲主义、贤人政治、世界主义</p><p>马可・奥勒留 121-180 五贤帝时期，被立为储君，而传位给自己的儿子。<br>罗马由盛转衰。《爵斗士》</p><p>沉思录写在与日耳曼人作战期间，日记式的，碎片话，只是写给自己看的感悟。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑配置</title>
      <link href="/20191211-deleted/"/>
      <url>/20191211-deleted/</url>
      
        <content type="html"><![CDATA[<p>最终确定的是：</p><p>AMD Ryzen 2600<br>MSI B450M Mortar<br>Kingston 骇客神条 8GB<br>Kingston SSD 240GB<br>先马 机箱<br>爱国者 电源<br>亮机卡暂无</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于英语老师提问没答出来这档事</title>
      <link href="/20191210-loser/"/>
      <url>/20191210-loser/</url>
      
        <content type="html"><![CDATA[<p>怎么办呢，英语差就差了，阿 Q 一下吧。。。</p><p>我不喜欢无谓的提问。不知道为什么这些老师都喜欢问这种问题，就是“你有什么问题？”我表示没问题。讲清了就是讲清了，提问很没必要。</p><p>不过我站起来什么都没说的样子真的有够靓仔，脑子没有办法照着英文的逻辑去想。</p><p>不过大概没什么事，这种英语教育我反正是不用再接受了。大概讲日语会更自然一点。我就发现很多场合下我想不起一些很简单的英文。或者说不敢说？</p><p>关于过去的事情，就过去了吧。珍视就好了。想抽出一段时间写个回忆录，不然全忘了真的奥。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>葛院开会</title>
      <link href="/20191204-extreme/"/>
      <url>/20191204-extreme/</url>
      
        <content type="html"><![CDATA[<p>葛院找我们开会，问说大家都参加了几个社团。我谎称两个，仍然属组内最多。院长不免要关心关心我的学习情况，不过他是先问我参不参加校园歌手比赛，听了我说“大一不准备参加，不能影响学习”之后才像是放下心来。</p><p>没想到直到大学还会有长辈亲切地指导我要把学习放在首位。不过还是要细细听这番说法：<br>“就算你们别的方面再不好，学习肯定比别人要好啊！”</p><p>虽然不否认这句话，但是未免把学生的价值观看得过于单一。读书是一条保险的道路，却不一定是最精彩的道路。实话说，日常各种极限操作，加上各种社团的加成，我的生活算得上是丰富。我却仍然觉得它少了灵魂。</p><p>有人批评华晨宇的唱法不科学，容易毁嗓，华晨宇说，有的人通过科学的唱法可以唱到老，但他就是要用独特的唱法，在有限的生命周期里达到自身最高的艺术效果。持续的平淡有什么意思呢？我很敬Toby Ballentine，他凭一己之力在学生时代就游了欧洲许多国家。他在课上问我们，万一哪天成为了富翁，想要过simple life还是fancy life。那我自然是选fancy life的。Simple life 自然很好，我多半也会很羡慕，但它就是不对我胃口。</p><p>那么说回这个灵魂，可以说就是冒险吧。我倒确实不想搞坏自己的身体，并不想冒着损害身体健康的风险。但是年龄增长阅历增加，不能失去的东西变得越来越多。冒着险的同时还要小心翼翼地保护这些东西，这本就不是我能做到的。</p><p>躲避风险这倒不是来自于院长的教诲，而是人的本能，加上我本就胆小，又贪心，直至今日有些事情还是让我抖抖豁豁的。有时争取一个又要保全另一个。这就把自己搞得很累，再精彩的生活也变成权衡权衡权衡，乏味至极。可惜我终究不能冒着丢失的风险，要么逼自己累的像条狗，要么就放弃了争取。</p><p>这12月又将是我极限操作的一个月。首先希望诸事顺利吧。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>热爱的事</title>
      <link href="/20191128-zeal/"/>
      <url>/20191128-zeal/</url>
      
        <content type="html"><![CDATA[<p>已经不需要了。因为已经没有了。</p><p>老师给我们开完会后，我突然想搞好自己的 GPA 了。只要时间利用得当，兼顾成绩和娱乐其实是比较容易的。但就是架不住浪费呗。</p><p>就不轻率地谈恋爱了吧。感觉要认真地交心已经相当困难了。</p><p>上微电子课的时候我有那么一瞬间领悟到了自己的热爱。</p><p>（灵感转瞬即逝，我全忘了）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期活动</title>
      <link href="/20191127-activities/"/>
      <url>/20191127-activities/</url>
      
        <content type="html"><![CDATA[<p>很骄傲的是，和严格的吴经纬学长联系了一阵子后，我在正式演出时发挥良好。当然也有一段歌词进早了，不过由于声音不是很大，就没出什么问题，也算是从容处理。</p><p>小邹同学架子鼓表演成功的时候，也有些激动。希望以后能够更多地经历这样的舞台。在台上的感觉实在是很惬意，有一种错觉是自己其实是为舞台而生的。</p><p>今天也拿到了主持人队的队徽，还有季学长寄语的明信片。希望之后成为能够独当一面的人。因为可以去依赖的人已经越来越远了。。。毕竟当初没有作出那个选择。（录者：？是谁？是什么选择？我怎么不知道？）</p><p>结果比起所谓的前女友，更让我无法忘却的还是同学。。我们从未表过意，却大概有一种默契。那肯定不是巧合。</p><p>不过我唯一笃定的并非巧合的事也就只有与她的明示暗示。</p><p>有关 tsuki 的事，我的判断从来就没有准过；关于金乐怡，我自己都抱有怀疑。看来这次选择题又选错了吧。</p><p>以前我选择自立。现在就由不得我选了，必须要能够独当一面。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>期中考试总结</title>
      <link href="/20191119-exam/"/>
      <url>/20191119-exam/</url>
      
        <content type="html"><![CDATA[<p>感觉微积分考得还行，但是生物基本就是不及格水平了。</p><p>莫谈学事。最近搞了一些资源，一是音乐。想现学一点声学的知识再去理解 DSD 这种东西。今晚可以稍微听一听差异。二是写真集，嗯就是擦边的那种。以前觉得看 Cosplay 和写真没什么意思，现在才能理解其中的性感之处。拍摄角度、人物动作，包括暗示之类的。。。</p><p>啊感觉真是色情。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>补番列表</title>
      <link href="/20191107-bangumilist/"/>
      <url>/20191107-bangumilist/</url>
      
        <content type="html"><![CDATA[<p>写一个补番名单。（这里可能是看了什么动漫杂谈之类的）</p><p>鬼灭之刃 （already）</p><p>花开伊吕波 （一话弃。女主挺好看但是类型不对味）</p><p>未闻花名</p><p>有你的小镇</p><p>黑礁</p><p>绝对双刃</p><p>JOJO （already）</p><p>恋爱研究所</p><p>只有我不存在的街道</p><p>在地下城寻求邂逅是否搞错了什么</p><p>世纪末超自然学园</p><p>祝福的钟声</p><p>少女编号 （不喜欢的类型）</p><p>日常系的异能战斗</p><p>CHAOS; CHILD</p><p>游戏：想要传达给你的爱恋（？什么白学同人）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>体测记录</title>
      <link href="/20191106-test/"/>
      <url>/20191106-test/</url>
      
        <content type="html"><![CDATA[<p>引体向上：不标准的 10 个</p><p>50m：7.0s</p><p>立定跳远：2.59m</p><p>1000m：3min44s</p><p>什么时候 1000m 能跑到 3 分以内啊。。。。（是人吗？</p><p>今天晨跑的时候没看到方圆，不乐</p><p>想到了一种理解他人说话的方式：为什么这句话的言说如此理所当然？可能经历了什么？</p><p>（这都哪跟哪？）</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计划</title>
      <link href="/20191105-plans/"/>
      <url>/20191105-plans/</url>
      
        <content type="html"><![CDATA[<p> 填上上面的格子吧，这样会有一点点仪式感（指日记本上面的天气、星期。。。）</p><p>另外我感觉鞋子应当要规范但不拘束，也就是不要太小气。那就把字体写得大点，写成行楷就好了。</p><p>目前有一些急于要做的事</p><ul><li>确定下要买的衣服</li><li>买个行书的字帖（直到现在我还不会写行书）</li><li>确定下自己的 Routine</li><li>日程表，手写或打印</li></ul><p>DDL 当前，不得不养成习惯来适应这种生活。</p><p>最近想要去重庆看一看 tsung。有点想。不过。。（咦，我当时为什么想去找？）</p><p>院内的事：最近萌生了想要导演明年新生晚会的想法。看了 CS 的迎新，我感觉我们院的晚会弱爆了。</p><p>顺便说说盛宇坤。印象是家境比较好。性格上和我有一点相似，我挺敬仰他，他应该是个当领导者的料，敢说敢做。</p><p>关于陈旭对我空间的造访，我怀疑当初提的分手可能不是真实的。但我不会回头，我没能力认真爱一个人，只能投入自己了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Preface - 复盘大学新开的第一本日记本</title>
      <link href="/20191105-preface/"/>
      <url>/20191105-preface/</url>
      
        <content type="html"><![CDATA[<blockquote><p>是写在纸质的东西上的。我尽量克服羞耻感还原当时的写法。</p></blockquote><p>比较喜感地开始写这一本日记本，主要还是为了练字。老的那本放在家了，想拿过来。。。估计总会忘记。</p><p>其实很久都在纠结是该用电脑写还是写成纸质的，感觉用电脑写还是会分心。</p><p>这个本子在格式上不打算做其他任何要求，只有一点，那就是字一定要认真写才行。是时候回归练字这件事了。自从高中以来，已经放纵很久了。</p><p>另外一件事就是 Routine &amp; Habits。怪惭愧的，很多事情都半途而废了。想要把自己变成一个丰富的人。那就和自己做个约定吧！就算一次又一次地爽约，也定下约定吧。</p><p>我也有意要保研清北，当然显然是更加中意 PKU，不过现在还不知道自己最终会选择什么专业呢。</p><blockquote><p>录者注：最后摆烂整4年留在本校了。当时其实还在犹豫计算机还是化学。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定点规矩</title>
      <link href="/20191105-rules/"/>
      <url>/20191105-rules/</url>
      
        <content type="html"><![CDATA[<ul><li>要为了理想而奋斗，坚定信念</li><li>不做无结果的辩论（我还是很喜欢和人吵）不干涉他人表达，表达不被人干涉</li><li>课上有事干，闲事也是事</li><li>少熬夜；早起；多运动</li><li>困就直线滚去休息；不要久坐</li><li>练唱</li><li>少说没有用的话</li><li>要找女朋友的话，就去结识新朋友</li><li>静若处子，动若脱兔</li><li>以王舒宇为榜样</li><li>依赖你自己</li><li>活得丰富，不要浪费时间（我在这里录日记不是浪费时间？）<ul><li>直奔主题，不要 round about</li></ul></li><li>不管多么痛苦，都不要轻易逃到更轻松的一边</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日记补完计划 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
