<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Null"><title>对 kernel 中的 TCP 实现进行基于模型的测试(Model Based Testing) | Tilnel's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "ovuz7vaihk");
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">对 kernel 中的 TCP 实现进行基于模型的测试(Model Based Testing)</h1><a id="logo" href="/.">Tilnel's Blog</a><p class="description">我需要先行到光年以外，为列星指明公转的轨道，否则你便看不到下一夜的闪烁与纷纭。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">对 kernel 中的 TCP 实现进行基于模型的测试(Model Based Testing)</h1><div class="post-meta">2026-02-08<span> | </span><span class="category"><a href="/categories/Network/">Network</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.7k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/20250816-tcp/#vcomment"><span class="valine-comment-count" data-xid="/20250816-tcp/"></span><span> Comment</span></a><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>提问于 2025-08-16。最终做了一个较为简化的原型程序，测得结果参见 <a href="/20250925-freebsd_tcp/">FreeBSD TCP 的两个问题</a>。暂未开源，开源计划未知。思路供参考。</p>
<p>另误打误撞发现 Linux TCP 可能存在一处与重传超时有关的 Data Race 问题，但并未验明。有兴趣可以联系讨论。</p>
</blockquote>
<p>我问了 Gemini 这个问题，光是问题就阐述得很长。</p>
<hr>
<h1><a href="#wen-ti" class="header-anchor">#</a><span id="wen-ti">问题</span></h1><p>我现在正在做对 TCP 协议实现的验证功能。我的做法是这样的：先根据 RFC793&#x2F;RFC9293 的描述，构建一套 TCP 协议的连接状态转移的 spec，可以理解为一个状态机；然后从这套状态机出发，生成状态转移中发生的事件，包括用户调用、消息收发。具体参考 RFC793 的 EventProcess 部分，有 Listen, Connect, Send, Recv, Shutdown, SegmentArrive(Close&#x2F;Listen&#x2F;SynSent&#x2F;SynReceived&#x2F;Established&#x2F;FinWait1&#x2F;…)，TimeWaitTimeout, RetransmissionTimeout 等等。</p>
<p>状态机的状态，总体来说是一对 Socket 的状态，包括它们各自的 TCP 状态（CLOSE, LISTEN, ESTABLISHED, FINWAIT1, CLOSEWAIT 等），重传队列，segment receive buffer，stream receive buffer，send buffer，以及传输控制块（snd.nxt, snd.una, rcv.nxt，etc）</p>
<p>由此，事件还会进一步细化为以下的类型：</p>
<ul>
<li>server call invoke</li>
<li>server call return</li>
<li>client send segment</li>
<li>client receive segment</li>
</ul>
<p>目前，我对 TCP 的建模已经完成，它可以随机地在状态机中游走，生成序列。现在我将它与现实的 TCP 实现进行比较，目前在 linux TCP 上做实验。我的比较方式是这样的。首先有一端是 linux TCP 实现端，称为 server，另一端是测试框架端，称为 client。我按顺序处理状态机生成的序列：</p>
<ul>
<li>如果事件是在 server 上发生，则<ul>
<li>如果是 Call invoke 事件，则让server 进行对应的调用；</li>
<li>如果是 Call return 事件，则等待直到 server 的调用返回。</li>
</ul>
</li>
<li>如果事件是在 client 上发生，则<ul>
<li>如果是 Send segment，则发送对应的 segment</li>
<li>如果是 Receive segment，则等待对应的 segment 到来然后返回</li>
</ul>
</li>
</ul>
<p>client 通过 RAW socket 直接构造 IP datagram 进行发送，并接受 tcp server 端的 datagram并解析。</p>
<p>这一套机制目前能够勉强运转，其核心问题在于 linux TCP 对于事件的处理带有一定的不确定性，最终导致 client 端有可能在 receive segment 时接收不到期待的 segment。譬如 linux TCP 可能会根据延迟、窗口等不明确的具体运行时的变量，自行决定多个 send call 是否被合并作一个 segment 处理；或是在 client 卡着 ACK 不发送的情况下，linux TCP 会在 send() usercall 调用成功的同时，依然只对之前未确认的 segment 进行重传。</p>
<p>事实上就是，我的 model&#x2F;状态机几乎不可能与真实的事件序列严格匹配。</p>
<p>目前有模糊的想法，即在某些情况下把 Linux TCP 产生的真实 segment 输入到状态机当中，再进行下一步的生成。但这似乎违背了初衷：初衷是对 TCP 协议的行为进行验证；这样做相当于直接接受了 TCP 实现产生的行为是正确的。</p>
<p>希望从以下几个可能的方面得到解惑：</p>
<p>1、是否可以在一定程度上控制 linux TCP 的行为，使其符合生成的 trace？比如对于每一个 send 调用，其内容永远不被合并到一个 segment 发送？</p>
<p>2、是否可以通过模糊的方式进行 segment 的匹配，使得这样的对比序列的方式至少可以执行下去？</p>
<p>3、如果说把 linux TCP 产生的真实 segment 输入到状态机当中，那么在什么情况下可以这样做，使得我的验证框架能够保留一定的验证能力？</p>
<h1><a href="#hui-da" class="header-anchor">#</a><span id="hui-da">回答</span></h1><p>您好，您提出的问题非常专业且切中要害，是进行网络协议一致性测试时必然会遇到的核心挑战：<strong>如何处理规范（Spec&#x2F;Model）的确定性与现实实现（Implementation）的非确定性之间的鸿沟</strong>。</p>
<p>您的测试框架设计思路非常清晰，即基于模型（状态机）生成测试序列，然后通过一个测试驱动（Test Driver）来执行和观察真实系统的响应，这在测试领域被称为“Model-Based Testing”。您遇到的问题是这个领域的经典问题。</p>
<p>下面我将针对您提出的三个问题，结合协议测试的理论与实践，为您提供一些深入的解答和建议。</p>
<hr>
<h3><a href="#1-shi-fou-ke-yi-zai-yi-ding-cheng-du-shang-kong-zhi-linux-tcp-de-xing-wei-shi-qi-fu-he-sheng-cheng-de-trace" class="header-anchor">#</a><span id="1-shi-fou-ke-yi-zai-yi-ding-cheng-du-shang-kong-zhi-linux-tcp-de-xing-wei-shi-qi-fu-he-sheng-cheng-de-trace">1. 是否可以在一定程度上控制 Linux TCP 的行为，使其符合生成的 trace？</span></h3><p>是的，可以在一定程度上“驯服”Linux TCP 的行为，减少其不确定性，使其更接近一个理想化的模型。但这无法做到 100% 的控制。以下是一些关键的控制手段：</p>
<h4><a href="#a-kong-zhi-segment-de-he-bing-nagle-suan-fa" class="header-anchor">#</a><span id="a-kong-zhi-segment-de-he-bing-nagle-suan-fa">a. 控制 Segment 的合并（Nagle 算法）</span></h4><p>您提到的“多个 send call 是否被合并作一个 segment 处理”主要是由 Nagle 算法导致的。您可以通过设置 socket 选项来禁用它：</p>
<ul>
<li><strong><code>TCP_NODELAY</code></strong>: 这是最直接的方法。在一个 socket上设置 <code>TCP_NODELAY</code> 选项后，<code>send()</code> 或 <code>write()</code> 系统调用会尝试立即将数据包发送出去，而不会等待之前的小数据包被对端 ACK。<ul>
<li><strong>用法</strong>: 在您的 server 端代码中，对 accept 后的新 socket 设置此选项。</li>
<li><strong>效果</strong>: 设置后，每次 <code>send()</code> 调用（如果数据量小于 MSS）通常会对应一个独立的 TCP Segment。这可以极大地提高您的模型与实现行为的一致性。</li>
</ul>
</li>
</ul>
<h4><a href="#b-kong-zhi-ack-de-fa-song-shi-ji-delayed-ack" class="header-anchor">#</a><span id="b-kong-zhi-ack-de-fa-song-shi-ji-delayed-ack">b. 控制 ACK 的发送时机（Delayed ACK）</span></h4><p>Linux TCP 默认会启用延迟确认（Delayed ACK），即收到数据后不会立即发送 ACK，而是会等待一小段时间（例如 40ms），期望能将 ACK 和它自己要发送的数据“捎带”在一个 Segment 中。这会影响您在 client 端 <code>Receive segment</code> 的时机。</p>
<ul>
<li><strong><code>TCP_QUICKACK</code></strong>: 这个 socket 选项可以用来临时禁用 Delayed ACK。<ul>
<li><strong>用法</strong>: 调用 <code>setsockopt</code> 设置 <code>TCP_QUICKACK</code> 为 1 后，内核会立即发送一个 ACK。但请注意，<strong>这个选项是临时的</strong>，它会在下一次收到数据后被内核重置。因此，如果您希望每次收到数据都立即 ACK，您需要在每次 <code>recv()</code> 之后都重新设置 <code>TCP_QUICKACK</code>。</li>
<li><strong>效果</strong>: 这使得您可以更精确地控制 ACK 的时序，让 server 端的行为更容易预测。</li>
</ul>
</li>
</ul>
<h4><a href="#c-kong-zhi-tcp-segmentation-offload-tso-x2f-gso" class="header-anchor">#</a><span id="c-kong-zhi-tcp-segmentation-offload-tso-x2f-gso">c. 控制 TCP Segmentation Offload (TSO&#x2F;GSO)</span></h4><p>即使禁用了 Nagle，一个非常大的 <code>send()</code> 调用（大于 MSS）依然会被 TCP 协议栈分割成多个 Segments。更底层地，网卡驱动还可能有 TSO&#x2F;GSO (Generic Segmentation Offload) 功能，即协议栈将一个大的数据块传给网卡，由网卡硬件来负责切分成 TCP Segment。</p>
<ul>
<li><strong>控制方法</strong>:<ol>
<li><strong>应用层控制</strong>: 在您的测试用例生成中，确保每次 <code>send()</code> 调用的数据量都小于路径的 MSS (Maximum Segment Size)。这样可以避免 TCP 主动分片。</li>
<li><strong>系统级控制</strong>: 可以通过 <code>ethtool</code> 命令关闭网卡的 TSO&#x2F;GSO 功能 (<code>ethtool -K &lt;interface&gt; tso off gso off</code>)。这在测试环境中是可行的，能确保分片行为完全由内核 TCP 协议栈控制。</li>
</ol>
</li>
</ul>
<h4><a href="#d-kong-zhi-chong-chuan-chao-shi-rto" class="header-anchor">#</a><span id="d-kong-zhi-chong-chuan-chao-shi-rto">d. 控制重传超时 (RTO)</span></h4><p>重传行为由 RTO 决定，而 RTO 是根据动态变化的 RTT（Round-Trip Time）计算的。在测试环境中，可以尝试固定 RTO 来减少不确定性。</p>
<ul>
<li><strong>控制方法</strong>: 这通常比较困难，但可以通过 <code>ip route</code> 命令为特定路由设置固定的 RTT 和 RTO 初始值。例如： <code>ip route change 192.168.1.0/24 dev eth0 rtt 10ms rto_min 20ms</code> 这需要 root 权限，并且仅在受控的网络环境中有效。</li>
</ul>
<p><strong>小结</strong>: 通过组合使用 <code>TCP_NODELAY</code>、<code>TCP_QUICKACK</code>、控制发送数据大小以及在测试环境中关闭 TSO&#x2F;GSO，您可以显著降低 Linux TCP 的行为不确定性，让您的 trace 匹配成功率大大提高。</p>
<hr>
<h3><a href="#2-shi-fou-ke-yi-tong-guo-mo-hu-de-fang-shi-jin-xing-segment-de-pi-pei" class="header-anchor">#</a><span id="2-shi-fou-ke-yi-tong-guo-mo-hu-de-fang-shi-jin-xing-segment-de-pi-pei">2. 是否可以通过模糊的方式进行 segment 的匹配？</span></h3><p>完全正确，<strong>模糊匹配（Fuzzy Matching）或者说基于属性的匹配（Property-Based Matching）是解决这个问题的正道</strong>。与其期待一个完全一致的 Segment，不如验证收到的 Segment 是否满足“某些关键属性”。</p>
<p>您的 <code>Receive segment</code> 事件不应该等待一个字节完全相同的 Segment，而应该等待一个<strong>满足特定条件的 Segment</strong>。</p>
<h4><a href="#a-pi-pei-shi-me-hu-lue-shi-me" class="header-anchor">#</a><span id="a-pi-pei-shi-me-hu-lue-shi-me">a. 匹配什么，忽略什么？</span></h4><ul>
<li><strong>必须严格匹配的</strong>:<ul>
<li><strong>关键控制位 (Flags)</strong>: <code>SYN</code>, <code>FIN</code>, <code>RST</code>。这些标志直接定义了连接状态的转移，必须精确匹配。</li>
<li><strong>ACK 确认号 (<code>ack_seq</code>)</strong>: <code>ack_seq</code> 必须准确地确认了 client 发送的最后一个字节。这是协议正确性的核心。</li>
</ul>
</li>
<li><strong>需要模糊匹配的</strong>:<ul>
<li><strong>序列号和数据 (<code>seq</code> 和 payload)</strong>: 当期待数据时，不应期待一个特定 <code>seq</code> 和 <code>len</code> 的包。而应该维护一个“期望接收的数据流窗口”，例如 <code>[rcv.nxt, rcv.nxt + rcv.wnd)</code>。收到的任何 Segment，只要其数据范围 <code>[seg.seq, seg.seq + seg.len)</code> 在这个窗口内，并且是顺序的，就应该被接受。</li>
<li><strong>实现方式</strong>: client 端需要自己实现一个简化的接收缓冲区（Stream Receive Buffer）。当收到一个数据包时，将其放入缓冲区，然后检查缓冲区中是否已经凑齐了模型所期望的下一个应用层数据块（例如，一个完整的 <code>send</code> 调用对应的数据）。</li>
</ul>
</li>
<li><strong>应该忽略的</strong>:<ul>
<li><strong>窗口大小 (<code>window_size</code>)</strong>: 除非您正在专门测试流量控制，否则窗口大小是动态变化的，不应作为匹配的刚性条件。</li>
<li><strong>TCP 选项 (Options)</strong>: 像 Timestamps, SACK 等选项，其具体值是高度动态的，除非测试目标是这些选项本身，否则应该忽略其具体值，只检查其是否存在即可。</li>
<li><strong>源端口号 (Source Port)</strong>: 对于 server 发来的包，源端口是固定的。但对于 client 来说，它无关紧要。</li>
</ul>
</li>
</ul>
<h4><a href="#b-shi-li" class="header-anchor">#</a><span id="b-shi-li">b. 示例：</span></h4><p>假设您的模型生成了如下序列：</p>
<ol>
<li><code>server: send(&quot;hello&quot;)</code> -&gt; 期待 server 发送一个带 “hello” 的包。</li>
<li><code>server: send(&quot;world&quot;)</code> -&gt; 期待 server 发送一个带 “world” 的包。</li>
</ol>
<p>传统的严格匹配会失败，因为 Linux TCP 可能会发出一个包含 “helloworld” 的包。</p>
<p><strong>模糊匹配的做法</strong>:</p>
<ol>
<li>模型生成 <code>server: send(&quot;hello&quot;)</code>。测试驱动调用 <code>send(sock, &quot;hello&quot;, 5)</code>。</li>
<li>Client 的 <code>Receive segment</code> 事件不再是“等待一个 <code>seq=X, len=5, data=&#39;hello&#39;</code> 的包”，而是“<strong>等待凑齐’hello’这段数据</strong>”。</li>
<li>Client 开始接收。它可能会收到一个 <code>seq=X, len=10, data=&#39;helloworld&#39;</code> 的包。</li>
<li>Client 的匹配逻辑检查：<ul>
<li>收到的数据 <code>helloworld</code> 的前 5 个字节是 <code>hello</code>。匹配成功！</li>
<li>将 <code>helloworld</code> 存入 client 的接收缓冲区。</li>
<li>此时，第一个 <code>Receive</code> 事件完成。</li>
</ul>
</li>
<li>模型继续生成 <code>server: send(&quot;world&quot;)</code>。</li>
<li>Client 的 <code>Receive segment</code> 事件现在是“<strong>等待凑齐’world’这段数据</strong>”。</li>
<li>Client 检查其接收缓冲区，发现 <code>world</code> 已经存在。于是，这个 <code>Receive</code> 事件也立即完成。</li>
</ol>
<p>这种方式将匹配的粒度从单个网络包（Segment）提升到了应用层的数据块（Stream），这与 TCP 的本质（流式协议）是相符的。</p>
<hr>
<h3><a href="#3-ru-guo-ba-linux-tcp-chan-sheng-de-zhen-shi-segment-shu-ru-dao-zhuang-tai-ji-dang-zhong-ru-he-bao-liu-yan-zheng-neng-li" class="header-anchor">#</a><span id="3-ru-guo-ba-linux-tcp-chan-sheng-de-zhen-shi-segment-shu-ru-dao-zhuang-tai-ji-dang-zhong-ru-he-bao-liu-yan-zheng-neng-li">3. 如果把 Linux TCP 产生的真实 segment 输入到状态机当中，如何保留验证能力？</span></h3><p>这是非常高级且有效的测试思想，通常被称为**在线测试（On-the-fly Testing）**或**运行时监控（Runtime Monitoring）**。您完全没有违背初衷，反而让您的验证框架变得更加强大和实用。</p>
<p>关键思想是：<strong>您的模型不应再作为测试用例的“生成器”，而应作为真实系统行为的“裁决者”或“预言机”（Oracle）。</strong></p>
<h4><a href="#a-gong-zuo-liu-cheng-de-zhuan-bian" class="header-anchor">#</a><span id="a-gong-zuo-liu-cheng-de-zhuan-bian">a. 工作流程的转变：</span></h4><ol>
<li><strong>从“生成-执行”到“引导-观察-验证”</strong>:<ul>
<li><strong>引导 (Guide)</strong>: 您的模型不再生成一个严格的事件序列。而是根据当前状态，告诉测试框架：“现在，一个合法的外部事件可以是<code>用户调用send()</code>，或者<code>收到一个ACK包</code>，或者<code>重传计时器超时</code>”。它提供一个<strong>合法输入&#x2F;事件的集合</strong>。</li>
<li><strong>执行 (Act)</strong>: 测试框架从这个合法集合中选择一个事件来执行。例如，选择 <code>用户调用send()</code>，于是就去调用 Linux server 的 <code>send()</code>。</li>
<li><strong>观察 (Observe)</strong>: 测试框架捕获 Linux TCP 产生的<strong>真实输出</strong>（一个或多个 TCP Segments）。</li>
<li><strong>验证 (Verify)</strong>:<ol>
<li><strong>将观察到的真实输出（如收到的 Segment S’）作为输入，喂给您的状态机模型。</strong></li>
<li><strong>模型进行状态转移。</strong></li>
<li><strong>核心验证点</strong>：<ul>
<li><strong>合法性检查 (Legality Check)</strong>: 在模型当前的状态下，接收到 Segment S’ 是否是一个<strong>合法的、允许的</strong>转移？如果模型认为在当前状态下根本不应该收到这样的包（例如，在一个已经收到 FIN 的连接上收到了新的数据包），那么您就发现了一个协议实现缺陷。<strong>这就是验证能力所在！</strong></li>
<li><strong>状态一致性检查 (State Consistency Check)</strong>: 转移后，模型的新状态是否满足协议的不变量（Invariants）？例如，<code>snd.una &lt;= snd.nxt</code> 是否依然成立？各种缓冲区的状态是否逻辑自洽？</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4><a href="#b-zhe-chong-fang-shi-de-you-shi" class="header-anchor">#</a><span id="b-zhe-chong-fang-shi-de-you-shi">b. 这种方式的优势：</span></h4><ul>
<li><strong>拥抱不确定性</strong>: 它不再试图消除不确定性，而是将其作为测试的一部分。无论 Linux TCP 因为什么内部原因（调度、负载等）选择发送这个包而不是那个包，只要它发送的包是符合 RFC 规范的，测试就会继续。</li>
<li><strong>更强的发现能力</strong>: 这种方法可以探索到更多由静态序列生成无法覆盖的、由真实系统动态行为触发的边缘状态和路径。如果 Linux TCP 产生了一个模型完全没预料到的合法行为，您的模型会学习并跟随这条路径，继续进行验证。如果它产生了一个不合法的行为，测试就会立即失败并报告错误。</li>
<li><strong>解决了同步问题</strong>: 由于模型的状态总是由真实系统的输出驱动更新的，两者之间始终保持同步，避免了 trace 分歧导致测试无法继续的问题。</li>
</ul>
<p><strong>结论</strong>: 您应该大胆地采用这种方法。它并没有削弱您的验证能力，而是将验证的焦点从“<strong>你是否严格按照我写的剧本演？</strong>”（Trace a a’ la Trace B）转移到了“<strong>你的每一个即兴表演是否都符合戏剧（RFC）的基本规则？</strong>”（Is Action a’ valid in State S?）。后者显然是一种更深刻、更有效的验证。</p>
<p>希望以上分析能为您提供清晰的思路和方向。您的项目非常有价值，祝您成功！</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/Untitled/"></a><a class="next" href="/20260207-misc/">死是凉爽的夏夜</a></div><div class="nofancybox" id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var lang = 'en',
  langMode = {
      "nick": "NickName",
      "mail": "E-Mail",
      "link": "Website(http://)",
      "nickFail":"NickName cannot be less than 3 bytes.",
      "mailFail":"Please confirm your email address.",
      "sofa": "No comment yet.",
      "submit": "Submit",
      "reply": "Reply",
      "cancelReply": "Cancel reply",
      "comments": "Comments",
      "cancel": "Cancel",
      "confirm": "Confirm",
      "continue": "Continue",
      "more": "Load More...",
      "preview": "Preview",
      "emoji": "Emoji",
      "expand": "See more....",
      "seconds": "seconds ago",
      "minutes": "minutes ago",
      "hours": "hours ago",
      "days": "days ago",
      "now": "just now",
      "uploading":"Uploading ...",
      "uploadDone":"Upload completed!",
      "busy":"Submit is busy, please wait...",
      "code-98":"Valine initialization failed, please check your version of av-min.js.",
      "code-99": "Valine initialization failed, Please check the `el` element in the init method.",
      "code-100": "Valine initialization failed, Please check your appId and appKey.",
      "code-140":"The total number of API calls today has exceeded the development version limit.",
      "code-401": "Unauthorized operation, Please check your appId and appKey.",
      "code-403": "Access denied by API domain white list, Please check your security domain."
  };
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'2Sm5GfIvJtcJUva0FtUU3gUX-gzGzoHsz',
  appKey:'tMoFHUMjKt3Br9ql4XQuMdu7',
  lang: lang,
  langMode: langMode,
  serverURLs:'',
  placeholder:'Say something',
  avatar:' ',
  avatar_cdn: 'http://cravatar.cn/avatar/',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p>Great</p><a class="info-icon" href="mailto:502023330051@smail.nju.edu.cn" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Tilnel" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://coink.wang/" title="Coink" target="_blank">Coink</a><ul></ul><a href="https://yuruiii.github.io/" title="Meursault" target="_blank">Meursault</a><ul></ul><a href="https://chariri.moe/" title="茶栗" target="_blank">茶栗</a><ul></ul><a href="https://carawaykong.github.io/" title="Caraway" target="_blank">Caraway</a><ul></ul><a href="https://riverclouds.net/" title="江云" target="_blank">江云</a><ul></ul><a href="https://usernamenul1.github.io/" title="nul1" target="_blank">nul1</a><ul></ul><a href="https://huamurui.github.io/" title="花木瑞" target="_blank">花木瑞</a><ul></ul><a href="https://eaglebear2002.github.io/" title="熊丘桓" target="_blank">熊丘桓</a><ul></ul><a href="https://blog.sakiyary.cn/" title="Sakiyary" target="_blank">Sakiyary</a><ul></ul><a href="https://huoxj.github.io/" title="Runz" target="_blank">Runz</a><ul></ul><a href="https://www.erinwithbmq.xin/" title="ErinwithBMQ" target="_blank">ErinwithBMQ</a><ul></ul><a href="https://mzy0624.github.io/" title="HaibaraAI" target="_blank">HaibaraAI</a><ul></ul><a href="https://blog.azifan.club/" title="水龙之魂" target="_blank">水龙之魂</a><ul></ul><a href="https://aliasrevir.github.io/" title="XiEn" target="_blank">XiEn</a><ul></ul><a href="https://www.doowzs.com/" title="张天昀" target="_blank">张天昀</a><ul></ul><a href="https://jyywiki.cn/" title="蒋炎岩" target="_blank">蒋炎岩</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Deprecated/">Deprecated</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DisAlg/">DisAlg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Misc/">Misc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Uncategorized/">Uncategorized</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E6%BC%AB/">动漫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A9%E6%95%99%E5%B7%A5%E4%BD%9C/">助教工作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%93%B2%E5%AD%A6/">哲学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%96%9C%E5%89%A7/">喜剧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%95%E6%8B%BE/">夕拾</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BD%B1%E8%A7%86/">影视</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%83%85%E6%84%9F/">情感</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%AC%E8%BF%90/">搬运</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%94%BF%E6%B2%BB/">政治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E8%AE%B0%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/">日记补完计划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%B6%E5%B0%9A/">时尚</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BF%BB%E8%AF%91/">翻译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B0%A2%E6%9E%97/">谢林</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%85%92/">酒</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div>Total<span id="busuanzi_container_site_pv"><span> </span><span id="busuanzi_value_site_pv"></span></span><span rel="nofollow"> </span>hits</div>Copyright ©  2019-2026 <a href="/." rel="nofollow">Tilnel's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script></div></body></html>