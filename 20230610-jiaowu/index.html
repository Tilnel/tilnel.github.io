<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Null"><title>教务处要的东西 | Tilnel's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "ovuz7vaihk");
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">教务处要的东西</h1><a id="logo" href="/.">Tilnel's Blog</a><p class="description">我们坐在一起，一整晚，一动不动</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">教务处要的东西</h1><div class="post-meta">2023-06-10<span> | </span><span class="category"><a href="/categories/%E5%8A%A9%E6%95%99%E5%B7%A5%E4%BD%9C/">助教工作</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 27.6k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 100</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/20230610-jiaowu/#vcomment"><span class="valine-comment-count" data-xid="/20230610-jiaowu/"></span><span> Comment</span></a><div class="post-content"><h1 id="期中项目选题及要求"><a href="#期中项目选题及要求" class="headerlink" title="期中项目选题及要求"></a>期中项目选题及要求</h1><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>在现代的编程语言中，表达式求值是必须要支持的一部分，比如 <code>Python</code> 的命令行模式，可以作为一个增强版的计算器来使用。</p>
<p>![image](Untitled 2.assets&#x2F;python-command-line.png.34cf22df)</p>
<p>本项目要求实现一个类似的表达式求值工具，接受变量赋值（比如 <code>a = 233</code>）和表达式求值（比如 <code>a + 114514</code>）两种语句，检查输入的错误，并计算表达式的值。</p>
<h3 id="项目指南"><a href="#项目指南" class="headerlink" title="项目指南"></a>项目指南</h3><p>2022.12.08 upd：项目指南更新，修正了一些错误与遗漏之处，欢迎大家找错误。</p>
<p><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/914aebbc04c347db879e/">新版链接</a>。</p>
<p>2022.12.26 upd：李清扬助教对手册的讲解：<a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/0dd03c818a644077979c/">点此链接</a></p>
<p>旧版请查看 <a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/dd2244548a2b43bcb59a/">NJU Box 链接</a> （可下载）。</p>
<h3 id="评分标准"><a href="#评分标准" class="headerlink" title="评分标准"></a>评分标准</h3><p>本题为客观题，由 dotOJ 黑箱测试自动评分，根据通过的测试点客观给分，OJ 得分即为你期中项目的得分。与主观题不同，你<strong>不</strong>需要提交项目文档。</p>
<p>你可以及时看到得分，但无法得知错误的测试数据点（<strong>助教不会给</strong>，保证公平性），与平时编程练习的形式<strong>完全相同</strong>，可多次提交，取最高分，以 dotOJ 显示为准。</p>
<blockquote>
<p>蔡之恒：感觉师姐去年造数据的时候有点偷懒，今年想办法加强一波（</p>
</blockquote>
<p>本题将同其他作业一样参与查重，并按照 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p>
<p>选做该题目，将有<del>较大</del>机会得到期中项目的满分。其中，正确实现所有必做部分，可得到 70% 的分数；每正确实现一个选做部分，将额外得到 10%，也就是说，实现题面中所有部分，将得到满分。</p>
<p>除去该题之外，其余题目均为主观题，都将在期中项目截止后人工验收，因此选做本项目的同学的得分分布将会作为其他项目评分的参考标准，我们会尽力保证期中项目所有选择的在评分时的公平性。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含若干行，每行为一个表达式或赋值语句，关于输入输出的详细规约请参考<a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/dd2244548a2b43bcb59a/">项目指南</a>。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个输入的表达式或赋值语句，输出 <code>Error</code> 或相应的值。</p>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2</span><br></pre></td></tr></table></figure>

<h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>





<h2 id="小恐龙"><a href="#小恐龙" class="headerlink" title="小恐龙"></a>小恐龙</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：李薛成</p>
<p>验题人：李薛成</p>
</blockquote>
<h3 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h3><p>机房电脑上除了<a target="_blank" rel="noopener" href="https://oj.cpl.icu/contest/27/problem/45"><em>扫雷</em></a>、<a target="_blank" rel="noopener" href="https://oj.cpl.icu/contest/34/problem/159"><em>蜘蛛纸牌</em></a>，还是要数<em>Chrome</em>的小恐龙最好玩了，一玩就是一节信息课（）</p>
<p>没玩过的同学们也可以现在就打开 <em>Chrome</em>，在地址栏输入 <code>chrome://dino</code> （或者断网）就可以畅玩了！（<em>Edge</em>的小恐龙被换成冲浪了没法玩）</p>
<p>Sakiyary 在高中每节信息课都和同学比拼小恐龙赛跑，但自从上了大学，时移事易，物是人非（还记得2016年夏的守望先锋吗.jpg），Sakiyary 再也找不回当年玩小恐龙的感觉（再也没有超过高中时的最高纪录）。</p>
<p>现在请你来帮帮他，写一个 C 语言的小恐龙并和 Sakiyary 一起比拼，让他找回当年的感觉！</p>
<hr>
<h3 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用命令行的字符界面或图形界面来制作并运行游戏。</p>
<p>建议用键盘来操控小恐龙而不是鼠标。（Chrome 的小恐龙使用了空格键与上下两个方向键来操控）</p>
<p>你可以用命令行字符或图形界面的贴图绘出小恐龙，<strong>题目注解</strong>中提供了一种可能的字符小恐龙画法，请根据小恐龙的大小决定整个场景的大小，障碍物同理。（小恐龙之外的形象也可以，但不能是竖线、正方形、圆形等简单几何图形。下文均以“小恐龙”来指代玩家所操控的角色）</p>
<p>你需要至少实现两种障碍物，即需要跳跃的障碍物（如仙人掌）和需要下蹲的障碍物（如飞鸟）。</p>
<p>你需要让你的代码能够在别人的电脑上（按照你自己给出的<strong>环境要求与规定</strong>）<strong>编译并正确运行</strong>。</p>
<p>Sakiyary 将人工审查你的代码（与其他同学、各大开源平台上的开源代码进行比对与查重）并按照 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p>
<hr>
<p>你需要正确地实现游戏进程：</p>
<ol>
<li>如何实现小恐龙向前跑动与障碍物迎面而来的效果与动画？</li>
<li>如何实现小恐龙跳起落下、下蹲的效果与动画？</li>
<li>如何实现按键操控且保证键盘输入<strong>不冲突不积压</strong>？</li>
<li>如何判断小恐龙与障碍物的碰撞与 Game Over？</li>
<li>如何计算与记录小恐龙跑出的分数？</li>
<li>如何暂停游戏、继续游戏？</li>
<li>如何<strong>在不重启程序的情况下</strong>重新开始一局新的游戏？</li>
</ol>
<p>关于上述第3点，给出一些补充：</p>
<ol>
<li>根据正常操控逻辑，跳跃键（如空格键）需要点按生效，下蹲键（如下方向键）需要长按生效。</li>
<li>如果一边按毫无意义的按键（如字母键），一边按跳跃键，小恐龙能否不卡顿地正常起跳？</li>
<li>如果长按或快速按跳跃键，小恐龙会飞上天吗？还是只能一下一下地跳？</li>
<li>如果在跳跃的过程中按下蹲键，小恐龙会有什么表现？</li>
<li>如果按住下蹲键的同时按跳跃键，小恐龙会有什么表现？</li>
</ol>
<p>按键操控有许多细节，大家都可以在原版小恐龙游戏中尝试，并在自己的代码中体现出来。若能完美实现，获得一定的加分，见下。</p>
<hr>
<p>关于两种界面的实现，分别给出一定的要求：</p>
<h3 id="命令行字符界面"><a href="#命令行字符界面" class="headerlink" title="命令行字符界面"></a>命令行字符界面</h3><p>推荐使用 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">Windows Terminal</a> 来运行程序，你需要锁定整个命令行界面的大小，可以自定义命令行字体大小，自行判断小恐龙与整个场景的比例。</p>
<p>字符的动画可以通过清屏+重新输出全部来实现（但这种做法效率很低哦），游戏的帧率与动画速度需要自行把控。</p>
<p>但显然，这个游戏越流畅越好玩。思考怎样让界面的字符动画能够尽可能流畅且屏幕不闪烁。</p>
<h3 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h3><p>图形界面的难点就是你要去自学怎么写好图形界面……参见本课程 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<p>但在绘制小恐龙与场景与实现动画保证流畅度的时候会比字符界面简单非常多。</p>
<p>故就难度而言其实与命令行字符界面差不多，甚至更加简单。但要求也会更高哦~</p>
<hr>
<h3 id="评分标准-1"><a href="#评分标准-1" class="headerlink" title="评分标准"></a>评分标准</h3><p>Sakiyary 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p>
<p>使用图形界面并<strong>不会得到更高的分数</strong> ，若图形界面不符合<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p>
<p>剩余分数由相应的加分条件给出：</p>
<ul>
<li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li>
<li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li>
<li>实现一些扩展功能：<ul>
<li>随得分增长小恐龙加速；</li>
<li>更多种类的障碍物；</li>
<li>道具与状态（飞行、无敌、冲刺）；</li>
<li>符合游戏逻辑的情况下自由发挥</li>
</ul>
</li>
<li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li>
</ul>
<hr>
<h3 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）</li>
</ul>
<p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<h3 id="题目注解"><a href="#题目注解" class="headerlink" title="题目注解"></a>题目注解</h3><ol>
<li><p>小恐龙越大，整个场景就越大，字符界面动画的显示就越卡顿，碰撞判断就越困难。</p>
<p>这里提供一种使用<strong>扩展ascii码</strong>的 12×812×8 的小恐龙画法（仅限 Windows mingw gcc）：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SetConsoleOutputCP(<span class="number">437</span>);</span><br><span class="line">    <span class="type">char</span> dino[<span class="number">8</span>][<span class="number">12</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">200</span>, <span class="number">205</span>, <span class="number">181</span>&#125;,</span><br><span class="line">        &#123;<span class="number">47</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">206</span>, <span class="number">181</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">218</span>, <span class="number">196</span>, <span class="number">217</span>&#125;,</span><br><span class="line">        &#123;<span class="number">92</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">208</span>, <span class="number">208</span>, <span class="number">217</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">198</span>, <span class="number">203</span>, <span class="number">187</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">95</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">179</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;,</span><br><span class="line">        &#123;<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">207</span>, <span class="number">205</span>, <span class="number">32</span>, <span class="number">207</span>, <span class="number">205</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++, <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, dino[i][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预览效果：</p>
<p>![image](Untitled 2.assets&#x2F;QQ图片20221121145105.png.2e50b1e5)</p>
<p>TODO（持续更新ing……）</p>
<h3 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>



<h2 id="羊了个🐏"><a href="#羊了个🐏" class="headerlink" title="羊了个🐏"></a>羊了个🐏</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：张哲恺</p>
<p>验题人：张哲恺</p>
</blockquote>
<h3 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h3><p>没玩过<em>羊了个羊</em>的人只能度过一些相对美好的夜晚😄</p>
<p><em>羊了个羊</em>是一款突然也不知道为什么就火起来了的<strong>垃圾</strong>游戏，玩家可以选择地图中随机出的卡片放到界面下方的卡槽中，卡槽中每具有三张同种类的卡片就可以消除掉它们，如果地图中的卡片被全部消除则 You Win，如果卡槽中卡片堆满了则 Game Over。</p>
<p>可以参考<a target="_blank" rel="noopener" href="https://search.bilibili.com/all?keyword=%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A&from_source=webtop_search&spm_id_from=333.1007&search_source=5">一些视频</a>来了解具体的游戏流程。</p>
<hr>
<p>Corax 在接触到<em>羊了个羊</em>之后很快就恨上了这款随机无解的垃圾游戏，在无数的夜晚向文件传输助手转发了无数的广告之后，Corax终于破防了，然而他的好胜心不允许他征服不了这款游戏，于是他决定让你帮他写一个<strong>更合理</strong>的<em>羊了个羊</em>，以此来通关这个游戏曲线救国。</p>
<hr>
<h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏</p>
<p>游戏的逻辑需要正确实现，例如当地图上的卡片被清空或者卡槽中的卡片堆满且无法消除时游戏要能够正常结束，卡槽中同种类的卡片应该堆放在<strong>相邻</strong>的位置，每三张相同卡牌要能够正常消除等</p>
<p>卡牌要能够明确地分辨其边界，地图中需要有<strong>多层卡牌</strong>，并且能通过上层卡牌看到部分下层卡牌（可参考实机游戏画面，字符界面会在后面说明），下层卡牌上面的数张上层卡牌未被清空前不可选择下层的卡牌（具体要求在后面说明），你需要保证游戏有解，即不会存在剩下两张或一张某种卡牌的情况</p>
<p>你还需要实现一些附加的游戏道具功能，如洗牌（即重新打乱地图中卡牌的位置，但你仍然需要保证游戏有解），撤销（即将最近一张放入卡槽的卡牌放回其原有的位置），移出卡牌（即将卡槽中现有的卡牌移出，并放置于地图中的随机位置）</p>
<p>游戏中要能够暂停、继续、退出游戏，在游戏结束后要能够重新开始，而不是关掉程序重新打开</p>
<hr>
<h3 id="图形界面附加要求"><a href="#图形界面附加要求" class="headerlink" title="图形界面附加要求"></a>图形界面附加要求</h3><p>首先请仔细阅读课程网站上的<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<p>如果你选择使用图形界面运行游戏，那么需要通过鼠标点击卡牌进行操作，通过设置图片的饱和度或给图片蒙一层半透明蒙版等来区分可选择的上层卡牌和暂时不可选择，仅可见的下层卡牌。</p>
<h3 id="字符界面附加要求"><a href="#字符界面附加要求" class="headerlink" title="字符界面附加要求"></a>字符界面附加要求</h3><p>如果你选择使用字符的命令行界面运行游戏，那么需要通过键盘进行操作，为了区分卡牌的边界和能看见下层的卡牌，你需要给每一张卡牌画上边界，可参考下图</p>
<p>![img](Untitled 2.assets&#x2F;image.png.0ab1f489)</p>
<p>示例中用<code>+</code>和<code>-</code>绘制了地图边界，用<strong>扩展ascii码</strong>中的 <code>191</code>，<code>192</code>，<code>217</code> 和 <code>218</code> 以及 <code>-</code> 和 <code>|</code> 绘制了卡牌的边框，为了在你的代码中使用扩展ascii码（关于什么是扩展ascii码以及更多其中的符号请自行STFW），你可以尝试以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SetConsoleOutputCP(<span class="number">437</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将输出的编码标准切换至允许使用扩展ascii编码的标准，你也可以使用其他的字符来绘制边框，总之你的游戏中卡牌的边框要可见。但卡槽中的卡片可以没有边框，否则会显得有些冗杂</p>
<p>选择卡牌时可以通过<code>↑</code>，<code>↓</code>，<code>←</code>，<code>→</code>或者WASD来控制选择光标的移动，并将选中的卡牌编号或者整张卡牌的颜色切换为显眼的颜色，因此你的程序逻辑要<strong>正确地控制光标的移动</strong>，例如在上面的图片中按下右键，22号卡牌变回白色，33号卡牌变为红色，再按下右键，应该是位于顶层可被选中的11号卡牌变为红色，而非位于第二层且仍被第一层卡牌压住的55号卡牌变为红色，（如果5号卡牌上没有第一层卡牌，那么应该是它被选中）另外，如果Corax <strong>输入一系列预期之外的字符你的程序应该无视并且仍然能够正常运行</strong></p>
<p>为了改变输出的字符颜色，你可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is white now. U&#x27;ll change it to red.\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is red now. U&#x27;ll change it again\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It turns back to white.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以尝试改变 <code>SetConsoleTextAttribute</code> 函数的第二个参数来获得不同的颜色。</p>
<p>至于按下键盘上的哪个键将当前选中的卡牌放入卡槽可由你自己定义。</p>
<p>tips：以上代码均仅适用于 Windows 操作系统环境，如果是 Linux&#x2F;macos 用户请自行 STFW&#x2F;RTFM，应该需要用到 UTF-8 字符集。</p>
<hr>
<h3 id="评分标准-2"><a href="#评分标准-2" class="headerlink" title="评分标准"></a>评分标准</h3><p>Corax 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p>
<p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p>
<p>剩余分数由相应的加分条件给出：</p>
<ul>
<li>基础功能十分完善，界面美观，没有 bug。（bug 太多会倒扣）</li>
<li>Corax 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li>
<li>实现一些扩展功能：<ul>
<li>若Corax在一定时间内消除了足够数量的卡牌，即可进入<code>狂热模式</code>，在此期间他可以快速地消除地图上的卡牌，但你需要通过一定手段保证狂热模式结束后游戏仍然有解，并且Corax在游戏期间要能看见狂热模式的积攒条；</li>
<li>除此之外，你还可以设计一些其他有趣的功能。</li>
</ul>
</li>
<li>对于图形界面，实现正确的图片动态移入卡槽可酌情加分。</li>
<li>对于命令行字符界面，实现附加的选牌逻辑加分，附加的选牌逻辑如下：<ul>
<li>当输入→后如果当前卡牌的正右方没有卡牌，但右下&#x2F;上方有卡牌，那么应该移动到右下&#x2F;上方的卡牌，其他三个方向同理；</li>
<li>除此之外，你需要用另外一种颜色来标记可以被选中的卡牌，区分不可被选中的卡牌和已经被选中的卡牌。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="技术要求-1"><a href="#技术要求-1" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）。</li>
</ul>
<p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<h3 id="提交方式-1"><a href="#提交方式-1" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>



<h2 id="飞行棋"><a href="#飞行棋" class="headerlink" title="飞行棋"></a>飞行棋</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：浦亮</p>
<p>验题人：浦亮</p>
</blockquote>
<h3 id="项目概述-2"><a href="#项目概述-2" class="headerlink" title="项目概述"></a>项目概述</h3><p>飞行棋是<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%8D%81%E5%AD%97%E6%88%B2%E9%A1%9E%E9%81%8A%E6%88%B2">十字戏类游戏</a>，以模拟飞机飞航为主题，游戏以飞机由机场起飞至目的地，所以称为飞行棋。飞行棋是<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B">中国</a>参考<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E5%8D%81%E5%AD%97%E6%88%B2">英国十字戏</a>发展出来的，而<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%8B%B1%E5%9C%8B%E5%8D%81%E5%AD%97%E6%88%B2">英国十字戏</a>是从<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%8D%B0%E5%BA%A6%E5%8D%81%E5%AD%97%E6%88%B2">印度十字戏</a>演变出来的。</p>
<p>在这个项目里，需要大家完成一个简易版本的飞行棋游戏，最终呈现的效果可以是命令行呈现，也可以是自己学习图形库后以GUI的形式呈现。</p>
<p>![image](Untitled 2.assets&#x2F;QQ图片20221102224124.png.0d47332e)</p>
<h3 id="项目要求-1"><a href="#项目要求-1" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用命令行的字符界面或图形界面来制作并运行游戏。最终实现的效果既可以是通过在终端里打印飞行棋的棋盘来表现，也可以是完整的图形界面。但要求一定要对棋盘上的情况有所呈现。</p>
<p>shuilongzhihun 将人工审查你的代码（与其他同学、各大开源平台上的开源代码进行比对与查重）并按照 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/plagiarize">抄袭与惩罚</a> 执行。</p>
<h3 id="简化版飞行棋规则-游戏基本逻辑"><a href="#简化版飞行棋规则-游戏基本逻辑" class="headerlink" title="简化版飞行棋规则(游戏基本逻辑)"></a>简化版飞行棋规则(游戏基本逻辑)</h3><ol>
<li>有2-4个“玩家”。</li>
<li>每个“玩家”操控一个颜色对应的棋子，“玩家”可以是真人控制也可以是电脑控制，<strong>“玩家”可以全是真人也可以全是电脑。</strong>真人通过与实现系统交互来进行游戏，电脑玩家自动进行游戏。</li>
<li>每个玩家四颗棋子，初始都在机场不能出门，按顺序投骰子（1-6点的骰子）。如果玩家骰子抛出6，则可以让自己一个在机场的棋子在起点准备出发，并且再抛一次骰子决定可以出门走几格（该次抛骰子无论抛出几都只能作为刚刚准备出发的棋子前进的步数）。<ol>
<li>如果玩家的每个棋子都在机场或者终点处，且没有抛到6，则该玩家这个回合结束。</li>
<li>如果玩家抛出的点数是1-5，且有至少一个既不在机场也不在终点的棋子，则可以选择一个棋子根据点数往前移动一定步数。在简化实现中，所有的棋子都共享一条直线型的跑道！</li>
<li>如果玩家同时有棋子在机场和已经出发，在抛到6的情况下如何处理留给同学自行设计（可以设计成只能让棋子出发，或者也可以设计成可以选择让已经出发的前进，或其他设计）。</li>
<li>为了方便大家的实现，在这里做了简化处理。如果有同学想实现原版的效果，可以作为扩展功能实现。</li>
</ol>
</li>
<li>同时要求 <strong>直线型的跑道格子数量不低于15个</strong>，也就是下图中中间的深蓝色格子不少于15个。</li>
<li><strong>终点的格子数应该为6个</strong></li>
</ol>
<p>![image](Untitled 2.assets&#x2F;r1.png.2925d469)</p>
<ol>
<li>在终点前要进行分流，各自进入对应颜色的分流终点。然后进入终点分流阶段。</li>
</ol>
<p>![image](Untitled 2.assets&#x2F;r2.png.5e82d363)</p>
<p>如图，绿色的棋子如果此时是抛出了某些点数，或者是因为前面抛出了点数走到了这个位置还有几步没有走完，接下来都应该进入绿色对应的终点区域</p>
<ol>
<li>在终点区域，到达终点的判定是正好走到最后一格。如果没有走到则等待下一轮抛投，如果走到最后一格还有剩余步数，则需要反弹剩余步数。</li>
</ol>
<p>![image](Untitled 2.assets&#x2F;r3.png.16a0cb13)</p>
<p>如上图，在当前位置时，如果抛出的点数是3，则正好到达终点。如果抛出的点数是5，则反弹效果如图所示。</p>
<p>![image](Untitled 2.assets&#x2F;r4.png.23a43eea)</p>
<ol>
<li>一颗棋子达到终点的时候，就将这个棋子移出整个棋盘，记为成功到达。玩家胜利的条件是让全部的四颗棋子都到达终点。</li>
<li>对于同格子情况的处理：有不同的规则版本，在此处统一：<ol>
<li>对于途径的其他棋子无视，不论那个途径的格子里有几个棋子。</li>
<li>如果本次移动最终落点处是己方棋子，则这两个棋子可以同时存在这个格子里（但是不采取某些可以叠子的规则，后续再进行移动的时候同一格的棋子仍然视为多个分开的个体前进）</li>
<li>如果本次移动最终落点处有敌方棋子，则己方棋子占据这个格子，所有在这个格子的敌方棋子不论数量都返回机场（也就是需要抛到6才能再出发的状态）</li>
</ol>
</li>
</ol>
<h3 id="电脑操作"><a href="#电脑操作" class="headerlink" title="电脑操作"></a>电脑操作</h3><p>对于上述提到的电脑玩家操作，应当保证电脑的表现正常，即不存在非法操作（比如没有投到6但是让一个棋子出发），而且所有操作都是正常操作（比如不会在投了骰子且有棋子可以移动的情况下什么都不做）。</p>
<p>电脑玩家的操作也应当以某种方式（输出日志或其他）展现出来。</p>
<h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><p>上述描述的实现标准是一个简化改进版本的要求，同学们可以在现有的基础上尝试实现更多效果，包括但不限于：</p>
<ul>
<li>一个实现得非常好的命令行交互系统或者图形界面；</li>
<li>体现简化版本中没有提到的“飞”，即在某个满足特定要求的特定位置时可以飞到另外一格；</li>
<li>体现简化版本中没有提到的“跳”，即给中间的深蓝色格子进行染色，当棋子移动的最终落点在同色的格子上时可以往前跳到下一个同色格子上；</li>
<li>把跑道改为原版中的环形跑道的设计；</li>
<li>……</li>
</ul>
<p>你可以随意添加功能，<strong>但是理论上不能破坏现在的基本规则或者是使得规则变得更简单改动</strong>（例如删除终点的反弹但是又不设计一个更复杂的规则代替将会反过来影响你的成绩）。</p>
<hr>
<p>关于两种界面的实现，分别给出一定的要求：</p>
<h3 id="命令行字符界面-1"><a href="#命令行字符界面-1" class="headerlink" title="命令行字符界面"></a>命令行字符界面</h3><p>参见本课程 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/cli_req">命令行字符界面要求</a>，只是简单的将模拟的棋盘用一些代表特殊意义的字符不断的输出在屏幕上是可以的。</p>
<h3 id="图形界面-1"><a href="#图形界面-1" class="headerlink" title="图形界面"></a>图形界面</h3><p>参见本课程 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<hr>
<h3 id="评分标准-3"><a href="#评分标准-3" class="headerlink" title="评分标准"></a>评分标准</h3><p>shuilongzhihun 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p>
<p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p>
<p>剩余分数由相应的加分条件给出：</p>
<ul>
<li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li>
<li>shuilongzhihun 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li>
<li>实现上述的扩展功能或自行发挥。</li>
</ul>
<h3 id="技术要求-2"><a href="#技术要求-2" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）</li>
</ul>
<p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<h3 id="项目注解"><a href="#项目注解" class="headerlink" title="项目注解"></a>项目注解</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>该部分仅作为参考的建议和提示，如果你有更好的设计思路和实现，完全可以自己采用。</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>对于棋子和棋盘格状态的存储，用数组和变量的方式就可以实现。比如用数组来记录当前棋子的位置和当前的状态，再用一些数组来存储棋盘格子内的状态。</p>
<h4 id="游戏控制"><a href="#游戏控制" class="headerlink" title="游戏控制"></a>游戏控制</h4><p>对于游戏整体逻辑控制 可以参考如下的设计</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!game_ends)&#123;</span><br><span class="line">    player=(player+<span class="number">1</span>)%player_num;<span class="comment">//切换玩家</span></span><br><span class="line">    die_point=<span class="built_in">getDieRes</span>();<span class="comment">//投骰子</span></span><br><span class="line">    <span class="built_in">move</span>(player,die_point);<span class="comment">//移动部分的判断</span></span><br><span class="line">    game_ends=<span class="built_in">judge</span>();<span class="comment">//判断游戏是否结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命令行字符界面呈现"><a href="#命令行字符界面呈现" class="headerlink" title="命令行字符界面呈现"></a>命令行字符界面呈现</h4><p>只是简单的将模拟的棋盘用一些代表特殊意义的字符不断的输出在屏幕上是可以的。例如像下面的模拟输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------</span><br><span class="line">GG</span><br><span class="line">GG                         DDDDD(green)</span><br><span class="line">  □□□□□□□□□□□□□□□□□□□□□□□□□</span><br><span class="line">YY                         DDDDD(yellow)</span><br><span class="line">YY</span><br><span class="line">Green team throw the die and get 2 point!</span><br><span class="line">Green team ubable to move!</span><br><span class="line">------------------------------------------------</span><br><span class="line">GG</span><br><span class="line">GG                         DDDDD(green)</span><br><span class="line">  □Y□□□□□□□□□□□□□□□□□□□□□□□</span><br><span class="line">Y□                         DDDDD(yellow)</span><br><span class="line">YY</span><br><span class="line">Yellow team throw the die and get 6 point!</span><br><span class="line">Yellow team throw the die again and get 2 point!</span><br><span class="line">Yellow team moves.</span><br></pre></td></tr></table></figure>

<p>当然，如果你对字符进行了染色并且实现了刷屏的效果(屏幕上不是通过类似上述分隔符分隔的多次输出来展示，而是通过清屏再输出或者修改屏幕上显示的某些字符来实现)，这个设计可以被认为是一个扩展功能，根据效果可以作为评分标准里扩展功能部分的分数。</p>
<h4 id="DEBUG模式"><a href="#DEBUG模式" class="headerlink" title="DEBUG模式"></a>DEBUG模式</h4><p>为了方便助教测试和自己debug，推荐自己在程序里加入一个“外挂”，比如在输入某些指令后，或者全局定义某些变量值为1或自定义宏(例如#define DEBUG)开启自己定义的debug模式，你可以编写操控骰子投出的点数的代码，从而可以控制棋子的走动。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="comment">//假设这是一个用于得到投骰子结果点数的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDieRes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该部分不计入分数，但是强烈推荐做一下。</strong></p>
<h4 id="先动脑-再动手！"><a href="#先动脑-再动手！" class="headerlink" title="先动脑 再动手！"></a>先动脑 再动手！</h4><p>由于在很多地方都存在共通之处，同学们在编写代码的时候可以先思考一下有些地方的代码是不是可以抽象出来作为一个函数在多个地方复用，而通过设置一些变量来进行区分，这样可以很好的实现代码的压缩，防止出现屎山，也会减少在复制的时候有些地方没改完全导致出错!</p>
<p>对于每个玩家阵营，很多流程是一样的，是否可以把里面的一些操作抽象出来，而不是在每回合的循环里复制四遍代码？</p>
<p>比如对于每个棋子（飞机）可以增加一个标签来标记他是什么颜色的棋子，这样对于棋子的一些操作就可以通用了。</p>
<p>比如对于真人和电脑玩家的区分，本质区别其实只有在移动的时候有区别，而且移动都要检查是否合法，那么可以考虑一个设计是：对于玩家的每个棋子，判断投出骰子对应点数的移动是否合法，如果合法，那么就返回一个所有可以选择移动的棋子列表，电脑是从中随机选一个移动，而真人是自己选择。这样真人和电脑的代码差异就变得很小了。</p>
<h3 id="提交方式-2"><a href="#提交方式-2" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>



<h2 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：肖江</p>
<p>验题人：肖江</p>
</blockquote>
<h3 id="项目概述-3"><a href="#项目概述-3" class="headerlink" title="项目概述"></a>项目概述</h3><p>单色蜘蛛纸牌是一款经典的休闲益智纸牌游戏，该游戏基本规则如下：</p>
<ul>
<li>有 �<em>N</em> 副牌，�<em>M</em> 个牌槽，�<em>K</em>次发牌机会</li>
<li>初始牌槽中有 �×13−�×�<em>N</em>×13−<em>K</em>×<em>M</em> 张牌</li>
<li>只可以移动牌槽最上层的连续牌组</li>
<li>移动的目的地要么是空牌槽，要么能够和被移动牌组连接上</li>
<li>形成一组完整的连续牌组后（�<em>A</em>~�<em>K</em>），该牌组被从牌槽中收回</li>
<li>可以申请发牌，每个牌槽中新增一张牌，新增的牌可以和原牌组不连续</li>
<li>所有牌全部收回时判定胜利</li>
<li>无法进行有效操作时判定失败</li>
</ul>
<p>比如有4个牌槽：</p>
<p>![image](Untitled 2.assets&#x2F;image.png.7bba8639)</p>
<p>那么此时可以进行的操作是：</p>
<ol>
<li>将牌槽1的 <code>A, 2, 3</code>移动到牌槽2；</li>
<li>将牌槽1的 <code>A, 2</code> 移动到牌槽3；</li>
<li>将牌槽3的 <code>3</code> 移动到牌槽2；</li>
<li>申请发牌。</li>
</ol>
<p>其余均为非法操作。</p>
<p>更具体的规则过程可以观看如下两个视频</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1s64y1s7aP">判定胜利</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XS4y1C7kh">判定失败</a></li>
</ul>
<h3 id="项目要求-2"><a href="#项目要求-2" class="headerlink" title="项目要求"></a>项目要求</h3><p>我们需要在字符界面或者图形界面实现一个单色的蜘蛛纸牌。</p>
<p>该蜘蛛纸牌共包含88副牌（�<em>A</em>~�<em>K</em>），1010 个牌槽，初始时 1010 个牌槽各拥有 66、66、66、66、55、55、55、55、55、55 张牌，最上层的牌可见，其余牌不可见，有 55 次发牌机会，每次给 1010 个牌组各发一张牌，其余规则和游戏介绍中的一致。</p>
<h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4><ul>
<li>初始化牌桌，展示牌槽，可发牌次数和已收回牌组；</li>
<li>移动牌组；</li>
<li>发牌；</li>
<li>收回已形成的完整牌组；</li>
<li>结束判定。</li>
</ul>
<h4 id="扩展功能-1"><a href="#扩展功能-1" class="headerlink" title="扩展功能"></a>扩展功能</h4><ul>
<li>撤回一次或多次操作；</li>
<li>提示有效操作：<ul>
<li>需要按照要求和优先级进行提示，详见项目注解；</li>
</ul>
</li>
<li>计时器；</li>
<li>多色的游戏模式。</li>
</ul>
<hr>
<p>关于两种界面的实现，分别给出一定的要求：</p>
<h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>部分功能仍然需要实现动画，详见项目注解中命令行交互方式，并遵守<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/cli_req">命令行字符界面要求</a>。</p>
<h3 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h3><p>可以直接参考游戏介绍中的视频，使用拖拽，高亮，鼠标点击按钮等交互方式，但请遵守<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<hr>
<h3 id="评分标准-4"><a href="#评分标准-4" class="headerlink" title="评分标准"></a>评分标准</h3><p>875C 人工评判，实现要求基本正常即可得到 8080% 以上的分数。</p>
<p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p>
<p>剩余分数由相应的加分条件给出：</p>
<ul>
<li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会<strong>倒扣</strong>）</li>
<li>875C 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li>
<li>实现上述的扩展功能或自行发挥。</li>
</ul>
<h3 id="技术要求-3"><a href="#技术要求-3" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）</li>
</ul>
<p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<h3 id="项目注解-1"><a href="#项目注解-1" class="headerlink" title="项目注解"></a>项目注解</h3><p>接下来对失败条件判定和有效操作提示，以及交互方式做更进一步的解释</p>
<h4 id="失败条件判定和有效操作提示"><a href="#失败条件判定和有效操作提示" class="headerlink" title="失败条件判定和有效操作提示"></a>失败条件判定和有效操作提示</h4><p>由于失败条件以及有效操作的定义和证明不属于C语言课程的范围，在这里我们直接给出它的定义，大家按照定义实现即可。</p>
<p>首先定义最大上层连续牌组，即一个牌槽内的上层的最多的连续牌组，如一个牌槽自底向上的牌是<code>?, ?, ?, K, Q, 9, 7, 8, 3, 2, A</code>（<code>?</code>表示未翻面的牌），则最大上层连续牌组为<code>3, 2, A</code>。</p>
<h4 id="失败条件"><a href="#失败条件" class="headerlink" title="失败条件"></a>失败条件</h4><p>失败条件为同时满足以下三条：</p>
<ol>
<li>所有牌槽的最大上层连续牌组<strong>并集不包含</strong>完整的一副牌；</li>
<li>无法移动任何最大上层连续牌组；</li>
<li>无剩余发牌次数。</li>
</ol>
<h4 id="失败条件示例"><a href="#失败条件示例" class="headerlink" title="失败条件示例"></a>失败条件示例</h4><p>假设一共有 33 个牌槽且无法发牌（项目要求是 1010 个，这里示例用 33 个展示逻辑过程）</p>
<p>![image](Untitled 2.assets&#x2F;image.png.303ee8c1)</p>
<p>他们的最大上层连续牌组为 <code>&#123;A, 2, 3&#125;, &#123;8, 9, 10&#125;, &#123;5,6&#125;</code>，并集为 <code>&#123;A, 2, 3, 5, 6, 8, 9, 10&#125;</code>，不包含 �<em>A</em>~�<em>K</em>，且所有最大上层连续牌组都无法移动，且无法发牌，故判定失败。</p>
<h4 id="有效操作"><a href="#有效操作" class="headerlink" title="有效操作"></a>有效操作</h4><p>有效操作包括以下三种，<strong>按优先级从高到低排序，即“能提示1，就不要提示23”</strong>：</p>
<ol>
<li>通过移动牌组，将一副牌直接收回；</li>
<li>移动某个牌槽的最大上层连续牌组（但不能是全牌组和空牌组互换）；</li>
<li>发牌。</li>
</ol>
<h4 id="有效操作1示例"><a href="#有效操作1示例" class="headerlink" title="有效操作1示例"></a>有效操作1示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p>
<p>![image](Untitled 2.assets&#x2F;image.png.1a93a157)</p>
<p>此时可以通过将牌槽2的A移动到牌槽3，再将牌槽3的A,2,3移动到牌槽1，将一整副牌收回。</p>
<p>提示并不需要提示完整的操作过程，只需要高亮最大上层连续牌组并集能包含 �<em>A</em>~�<em>K</em> 的牌槽即可，样例中可以高亮牌槽1, 2, 3。</p>
<h4 id="有效操作2示例"><a href="#有效操作2示例" class="headerlink" title="有效操作2示例"></a>有效操作2示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p>
<p>![image](Untitled 2.assets&#x2F;image.png.34a931dc)</p>
<p>他们的最大上层连续牌组为<code>&#123;A, 2, 3&#125;, &#123;4&#125;, &#123;5, 6, 7&#125;</code>，你可以提示将牌槽1的 <code>A, 2, 3</code> 移动到牌槽2，也可以提示将牌槽2的 <code>4</code> 移动到牌槽3，但是不可以提示将牌槽3的所有牌移动到牌槽4。</p>
<h4 id="有效操作3示例"><a href="#有效操作3示例" class="headerlink" title="有效操作3示例"></a>有效操作3示例</h4><p>假设一共有 44 个牌槽（项目要求是 1010 个，这里示例用 44 个展示逻辑过程）</p>
<p><img src="https://oj.cpl.icu/image/image.png.00ecbcd9" alt="image"></p>
<p>他们的最大上层连续牌组为<code>&#123;A, 2, 3, 4&#125;, &#123;4&#125;, &#123;6, 7&#125;, &#123;K&#125;</code>，此时既没有有效操作1，也没有有效操作2，可以直接提示发牌。（如果无法发牌就说明应该判定失败了）</p>
<h3 id="命令行交互方式"><a href="#命令行交互方式" class="headerlink" title="命令行交互方式"></a>命令行交互方式</h3><h4 id="初始化牌桌，展示牌槽，可发牌次数和已收回牌组"><a href="#初始化牌桌，展示牌槽，可发牌次数和已收回牌组" class="headerlink" title="初始化牌桌，展示牌槽，可发牌次数和已收回牌组"></a>初始化牌桌，展示牌槽，可发牌次数和已收回牌组</h4><p>无需动画，直接展示，可发牌次数和已收回牌组可以使用数字展示。</p>
<p>牌槽牌面最简单也需要使用：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--+</span><br><span class="line">| A|</span><br><span class="line">+--+</span><br></pre></td></tr></table></figure>

<p>展示，不能只有一个字符。</p>
<h4 id="移动牌组"><a href="#移动牌组" class="headerlink" title="移动牌组"></a>移动牌组</h4><p>可以直接使用命令进行交互，如 <code>m 3 2 1</code> 表示牌槽3移动到牌槽2，移动1张牌。</p>
<p>也可以使用，选定原牌槽-&gt;选定牌组-&gt;选定目标牌槽的方式进行移动。</p>
<p>动画至少需要三个关键帧，即原牌桌，移动到半途的牌桌，移动完毕的牌桌。</p>
<h4 id="发牌"><a href="#发牌" class="headerlink" title="发牌"></a>发牌</h4><p>可以使用按键发牌。</p>
<p>动画需要至少两个关键帧，展示要发的牌，将牌发到各个牌槽。</p>
<h4 id="收回已形成的完整牌组"><a href="#收回已形成的完整牌组" class="headerlink" title="收回已形成的完整牌组"></a>收回已形成的完整牌组</h4><p>动画至少需要两个关键帧，高亮完整牌组，收回牌组且计数器增加&#x2F;牌组增加。</p>
<h4 id="结束判定"><a href="#结束判定" class="headerlink" title="结束判定"></a>结束判定</h4><p>弹窗，不要覆盖牌桌，因为需要截图展示，可以在牌桌旁展示弹窗提示胜利或失败。</p>
<h4 id="撤回操作"><a href="#撤回操作" class="headerlink" title="撤回操作"></a>撤回操作</h4><p>无需动画，直接使用弹窗提示撤回的操作类型——发牌&#x2F;移动，并还原牌桌状态。</p>
<h4 id="提示有效操作"><a href="#提示有效操作" class="headerlink" title="提示有效操作"></a>提示有效操作</h4><p>按照有效操作一节中的要求和优先级进行有效操作提示，使用按键或命令激活提示。</p>
<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>直接展示即可，不要出现跳表情况，即不能出现 <code>00:01</code> 直接变成 <code>00:04</code>。</p>
<h3 id="提交方式-3"><a href="#提交方式-3" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>



<h2 id="苏联块"><a href="#苏联块" class="headerlink" title="苏联块"></a>苏联块</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：孙博文</p>
<p>验题人：孙博文</p>
<p>Sakiyary：我摆烂了，不想格式化题面了，和其他项目题总要求是一样的……</p>
</blockquote>
<p>“俄罗斯方块”（Tetris）是一个经久不衰的小游戏。我们这就来做一个：</p>
<p>原版游戏当中Tetra4。我们做一个 Extended Edition</p>
<p>硬性要求：不做掉大分。</p>
<ul>
<li><p>掉落的方块，在原游戏基础上增加几种：</p>
<p>3方块的 “L” 和 “l” 型, 5 方块的 3 种 “L” 型。</p>
</li>
<li><p>容纳方块大小至少为 12 列 16 行。游戏界面自适应当前终端，如果终端尺寸不够放下全部内容，则不能启动并给出一行提示。</p>
</li>
<li><p>使用上下左右方向键！方向键！方向键！实时控制方块旋转与下落，直到方块的下表面与已有方块接触，则刷出下一个方块</p>
</li>
<li><p>旋转前后，如果没有卡上游戏 tick （即向下掉落一格的时刻），方块的最下端高度不应变化</p>
</li>
<li><p>输入不合法的字符，不应使你的程序卡顿、崩溃、异常。</p>
</li>
<li><p>行填满需要消除，下落。并计分。</p>
</li>
<li><p>屏幕内给出操控指示。支持暂停，和重新开始。</p>
</li>
</ul>
<p>软性：</p>
<ul>
<li>最好能打印出较为标准的正方形。比如终端内打印两个黑方块▇▇来组成一个。<del>否则方块旋转后会变形</del></li>
<li>按下方向下键时方块速度增加</li>
<li>支持计分榜等扩展功能</li>
</ul>
<p>本实验选题不会奖励写图形界面的同学。如果图形界面有bug还可能导致多的扣分。</p>
<p>命令行界面简洁而完整。</p>
<h3 id="评分标准-5"><a href="#评分标准-5" class="headerlink" title="评分标准"></a>评分标准</h3><p>请仅提交三个文件放在 .zip 压缩包内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">submission.zip</span><br><span class="line">  - tetris.c</span><br><span class="line">  - tetris.exe / tetris.out</span><br><span class="line">  - report.txt</span><br></pre></td></tr></table></figure>

<p>我们会运行你的程序。基本能玩就给 80 分。游戏交互逻辑较好并且没 bug 就是一伯分。</p>
<p>我们会做包括但不限于下列操作：</p>
<ul>
<li>正常地游玩游戏</li>
<li>键盘随机输入一大堆随机字母数字，并观察你程序的行为</li>
</ul>
<p>项目报告</p>
<ul>
<li>你的平台(Windows&#x2F;Linux&#x2F;MacOS)，编译选项，（依赖的图形库），具体交互方式(图形化拖拽 or 命令行按键)</li>
<li>简单思路</li>
<li>完成项目的感想和意见</li>
<li>建议使用 txt 纯文本</li>
<li>不要过长，不超过两页，主要是将前两项说清楚，方便助教验收，前两项说清楚就是满分，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可</li>
</ul>
<h1 id="期末项目选题及要求"><a href="#期末项目选题及要求" class="headerlink" title="期末项目选题及要求"></a>期末项目选题及要求</h1><h2 id="冬津羽戏"><a href="#冬津羽戏" class="headerlink" title="冬津羽戏"></a>冬津羽戏</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：张哲恺</p>
<p>验题人：张哲恺</p>
</blockquote>
<h3 id="项目概述-4"><a href="#项目概述-4" class="headerlink" title="项目概述"></a>项目概述</h3><p>俗名打砖块😄打砖块是一款总共可以发射数个小球，并通过控制挡板位置，反弹小球使其击碎路径上砖块并不断反弹的游戏。</p>
<p>同样可以参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rb411c7RF/?spm_id_from=333.337.search-card.all.click&vd_source=20202ec91c1882d95954b8843ae70102">一些视频</a>来了解具体的游戏流程。</p>
<hr>
<p>Corax 收到大冒险家 Sakiyary 想要自己做一个打砖块游戏的委托但是却不知所措，于是他决定转发委托，并作为中间商在其中狠狠捞一笔。不过纯粹的打砖块太过次时代缺乏趣味性，只能让Sakiyary 获得 3030% 的满意度，为了让产品能 100100% 使委托人满意，他需要你附加实现<strong>双人联机mod</strong>和<strong>奇幻之旅DLC</strong>。</p>
<hr>
<h3 id="实现要求-1"><a href="#实现要求-1" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p>
<p>如果你选择使用图形界面，请仔细阅读课程网站上的<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<p>游戏的逻辑需要正确实现，例如挡板只能在一定的区域内移动，当小球从地图下边界离开时要重新发球，地图中所有砖块都被击碎后要结束游戏或进入下一关（刷新地图），挡板和砖块要能够反弹小球，砖块反弹小球后要判定其受到撞击，反弹的角度需要对称等等。</p>
<p>砖块的不同种类要能够区分（具体内容将在下面继续说明）</p>
<hr>
<h3 id="双人联机mod要求"><a href="#双人联机mod要求" class="headerlink" title="双人联机mod要求"></a>双人联机mod要求</h3><p>你需要使用socket网络编程实现两个客户端在同一局游戏中操控两个不同的挡板一起游戏，采用客户端、服务端二分的模式，因此你需要编写<strong>两个程序</strong>。</p>
<p>服务端：</p>
<ul>
<li>监听某个主机的某个端口</li>
<li>监听并应答来自客户端的连接和请求</li>
<li>维护游戏状态，包括两个玩家各自的挡板位置等，因此在多人模式下，你需要<strong>对两个玩家的挡板做出相应的区分</strong></li>
</ul>
<p>客户端：</p>
<ul>
<li>向服务端发起请求或通讯</li>
<li>维护游戏状态，包括小球的运动轨迹，地图的状态（此状态也可交由服务器维护，具体做法由你自己决定）等</li>
</ul>
<p>在联机游玩的两个客户端程序之间画面的延迟不能太高，状态要能够正确维护。</p>
<p>参考的思路是：服务端创建<strong>监听线程</strong>，每接收到一个消息，将其放入一个全局队列中，等待处理；另一个线程负责<strong>处理来自客户端的请求</strong>，while(1) 循环从队列中取一条消息，然后分析其中的内容。客户端创建与服务端连接的线程，负责<strong>与服务端进行通信</strong>；另一个线程，负责<strong>计算游戏进程和输出游戏图形</strong>。这里需要用到<strong>多线程</strong>，具体的做法请STFW&#x2F;RTFM，至于原因你不妨让服务端对某一种客户端请求一直不做应答试试看:D</p>
<p><strong>既然只是mod，你也需要支持单机游玩</strong>，毕竟 Corax 虽然不能双人成行，但是他单人也行，<strong>请注意你应该如何实现单机和联机两种模式，减少代码克隆的现象。</strong></p>
<hr>
<h3 id="奇幻之旅DLC要求"><a href="#奇幻之旅DLC要求" class="headerlink" title="奇幻之旅DLC要求"></a>奇幻之旅DLC要求</h3><p>你需要给砖块和小球附加不同的元素属性，砖块可以添加生命值属性（需要额外进行数次撞击才能彻底击碎），还需要添加一系列道具。</p>
<p>不同元素属性的砖块需要通过<strong>颜色</strong>来区分，例如红色代表火元素，深蓝色代表水元素，浅蓝色代表冰元素，紫色代表雷元素，黄色代表暂时还没有元素。</p>
<p>对于字符界面选手来说，可以使用自己喜欢的符号或画出的图形来代表小球和砖块，为了改变输出的字符颜色，你可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is white now. U&#x27;ll change it to red.\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The color is red now. U&#x27;ll change it again\n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It turns back to white.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以尝试改变 <code>SetConsoleTextAttribute</code> 函数的第二个参数来获得不同的颜色。</p>
<p>tips：以上代码均仅适用于 Windows 操作系统环境，如果是 Linux&#x2F;macos 用户请自行 STFW&#x2F;RTFM，应该需要用到 UTF-8 字符集。</p>
<p>对于砖块和小球的元素属性，你可以设计丰富有趣的机制，小球的元素可以由<strong>上次与挡板相撞时挡板的元素属性</strong>来确定，玩家可以控制并改变挡板的元素属性。例如火元素与雷元素相遇会爆炸，对半径一定范围内的砖块全部造成一次攻击；水元素与雷元素、冰元素相遇会引发链式反应，导致相邻的水元素方块全部受到一次攻击；雷元素与冰元素相遇会强化小球，使其在下次与地图边界相撞并反弹前不会被砖块反弹；暂时无元素方块在被相应元素小球撞击后会附着上相应元素等等。</p>
<p>你需要设计一系列丰富有趣的道具，例如在地图下边界暂时生成防护墙保护小球不会离开地图，小球与挡板或砖块碰撞后生成额外的小球，挡板自身发射垂直向前的子弹攻击砖块等等，道具的触发条件也可以多种多样，可以由击碎砖块后随机触发，可以由击碎特殊砖块触发，也可以由当前小球击碎数个砖块后触发。</p>
<p>你可以从<a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/636b2c46f0c240a08031/">链接中的视频</a>参考上述描述的具体实现。</p>
<hr>
<h3 id="评分标准-6"><a href="#评分标准-6" class="headerlink" title="评分标准"></a>评分标准</h3><p>打砖块本体占分比重 30%，奇幻之旅DLC占分比重 40%，双人联机mod占分比重 30%，后两者的分数<strong>依赖于打砖块本体</strong>，也即如果你只写了一个实现完美的联机mod你的分数也只会是 0 分</p>
<p>Corax 人工评判，以上三个模块实现每个模块内的要求基本正常即可得到各自模块内 80% 以上的分数（也可以通过前两项拿满分，第三项水一水来得到 80% 以上的分数）。</p>
<p>使用图形界面并<strong>不会得到更高的分数</strong>，若图形界面不符合<a target="_blank" rel="noopener" href="https://oj.cpl.icu/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p>
<p>剩余分数由相应的加分条件给出：</p>
<ul>
<li>基础功能十分完善，界面美观，没有 bug。（bug 太多会倒扣）</li>
<li>Corax 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li>
<li>对于打砖块本体，能够实现挡板的普通速度和双倍速度移动，一定范围内的上下移动并根据与小球相撞时挡板的移动方向和速度改变小球的反弹方向（不要求严格按照物理规律，有<strong>不惊动牛顿棺材板</strong>的影响即可，当然如果能模拟真实物理情况也很好，你同样可以参考<a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/636b2c46f0c240a08031/">链接中的视频</a>）加分。</li>
<li>对于奇幻之旅DLC，不同元素的反应和道具丰富有趣无bug，能够实现砖块生命值大于等于2时元素产生反应后自身附着元素消失，根据反应给周围的方块附着元素（例如水与雷的链式反应可能可以使与路径上的砖块相邻的砖块附着上雷元素等），并且小球与挡板发生的元素反应可以使小球的下次碰撞产生相应的反应（例如火球与雷元素挡板相撞并反弹后，下次与砖块相撞时引发爆炸等等，此时小球具有的反应状态应该在程序内对玩家可见）即可加分。（<strong>每一点都可以加分，不是全部实现才加分</strong>）</li>
<li>对于双人联机mod，能够实现游玩过程中两个客户端画面延迟非常小，多线程和要求中提到的问题完成较好即可加分。</li>
</ul>
<hr>
<h3 id="技术要求-4"><a href="#技术要求-4" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）。</li>
</ul>
<p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<h3 id="提交方式-4"><a href="#提交方式-4" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>



<h2 id="中国象棋"><a href="#中国象棋" class="headerlink" title="中国象棋"></a>中国象棋</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：肖江</p>
<p>验题人：肖江</p>
</blockquote>
<h3 id="项目概述-5"><a href="#项目概述-5" class="headerlink" title="项目概述"></a>项目概述</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/278314">中国象棋</a>是一种起源于中国，历史悠久的棋类游戏。你需要实现一个双人联机对战的象棋游戏。</p>
<h3 id="实现要求-2"><a href="#实现要求-2" class="headerlink" title="实现要求"></a>实现要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p>
<p>如果你选择使用图形界面，请仔细阅读课程网站上的<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<p>游戏的逻辑需要正确实现，比如各类棋子不能有非法移动，最终胜负判定能够正常进行</p>
<h3 id="联机要求"><a href="#联机要求" class="headerlink" title="联机要求"></a>联机要求</h3><p>你需要使用socket网络编程实现两个客户端在同一棋局内对弈的功能，采用客户端，服务端分离的模式，因此你需要实现<strong>两个程序</strong>。</p>
<p>你可以采取<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36884005">状态同步或者帧同步</a>的方式对客户端和服务端进行分工。</p>
<p>状态同步：棋盘的运算都发生在服务端，客户端只负责和用户交互</p>
<p>帧同步：棋盘的运算都发生在客户端，服务端只负责转发客户端动作消息到对手侧</p>
<p>在联机游玩的两个客户端程序之间画面的延迟不能太高，状态要能够正确维护。</p>
<p>参考的思路是：服务端创建<strong>监听线程</strong>，每接收到一个消息，将其放入一个全局队列中，等待处理；另一个线程负责<strong>处理来自客户端的请求</strong>，while(1) 循环从队列中取一条消息，然后分析其中的内容。客户端创建与服务端连接的线程，负责<strong>与服务端进行通信</strong>；另一个线程，负责<strong>计算游戏进程和输出游戏图形</strong>。这里需要用到<strong>多线程</strong>，具体的做法请STFW&#x2F;RTFM。</p>
<h3 id="额外功能"><a href="#额外功能" class="headerlink" title="额外功能"></a>额外功能</h3><p>你可以实现一部分额外功能以获得更高的分数，包括但不限于</p>
<ul>
<li>悔棋</li>
<li>倒计时</li>
<li>打赏&#x2F;催促对方<ul>
<li>“你这么菜你老师不会生气吧哥哥”</li>
<li>“每一盘都当最后一盘，然后也不要怕输”</li>
<li>“3,2,1，落子！”</li>
</ul>
</li>
<li>添加道具&#x2F;技能<ul>
<li>改变棋子的行为规则</li>
<li>改变整个棋局的状态，比如添加棋子，转换棋子等</li>
<li>可以参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1Q72G">万宁象棋</a></li>
</ul>
</li>
</ul>
<h3 id="评分标准-7"><a href="#评分标准-7" class="headerlink" title="评分标准"></a>评分标准</h3><p>原生象棋移动和胜负判定占分比重 60%，额外功能占分比重 15%，联机功能占分比重 20%，代码风格，项目组织占分比重 5%。</p>
<p>875C 人工评判，以上三个模块实现每个模块内的要求基本正常即可得到各自模块内 80% 以上的分数。</p>
<p>使用图形界面<strong>并不会得到更高的分数</strong>，若图形界面不符合要求或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p>
<h2 id="技术要求-5"><a href="#技术要求-5" class="headerlink" title="技术要求"></a>技术要求</h2><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a>自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）。</li>
<li>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</li>
</ul>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<h2 id="提交方式-5"><a href="#提交方式-5" class="headerlink" title="提交方式"></a>提交方式</h2><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile/ CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>





<h2 id="落井大战"><a href="#落井大战" class="headerlink" title="落井大战"></a>落井大战</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：李薛成</p>
<p>验题人：李薛成</p>
</blockquote>
<h3 id="项目概述-6"><a href="#项目概述-6" class="headerlink" title="项目概述"></a>项目概述</h3><p>Downwell，是一款风靡全球的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Roguelike/10973209">Roguelike</a> 竖版过关游戏，是一位日本音乐专业的大佬在大四折腾出来的小游戏。你可能从没听说过这款游戏，那么你可以从下面几个链接中初步了解一下：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20589067">Downwell - 日本独立游戏佳作 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26949872">《下井大战》的游戏性是你难以想象的 - 知乎</a></p>
<p>也可以上这款游戏的官网 <a target="_blank" rel="noopener" href="https://downwellgame.com/">Downwell (downwellgame.com)</a> 购买&#x2F;下载体验，或者上 B 站看大佬的通关视频<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uE411j7ew/">视频链接</a>。</p>
<p><del>（速去 Steam 买！优惠只要 ￥4.5，1月6日0点结束！）</del></p>
<hr>
<h3 id="项目要求-3"><a href="#项目要求-3" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。</p>
<p>如果你选择使用图形界面，请仔细阅读课程网站上的<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<p>首先我们要明确你需要做一个什么样的游戏出来。显然，如果你能模仿原作实现它的绝大部分功能，拿到满分应该很大。但我们还是来解构一下这款游戏的要素：</p>
<h3 id="基础要素"><a href="#基础要素" class="headerlink" title="基础要素"></a>基础要素</h3><ul>
<li>一位可以操控的主角，主角需要三种基础交互：左、右移动、跳跃&#x2F;向下射击。</li>
<li>一个竖版的地图（井），地图上随机生成有方块拼成的各种形状平台供主角落脚。</li>
<li>怪物们，可以是在墙上爬、在平台上爬、在空中飞、同时会或不会发射子弹攻击、带刺或不带刺的怪物。</li>
<li>主角在平台上时只能跳跃，在空中可以向下射击子弹，发射的同时获得一定的滞空，同时消耗弹夹中的子弹数量。弹夹需主角停留在平台上方可自动地逐渐地回满。</li>
<li>主角与怪物都有各自的血量，如主角有 4 格血、怪物有 8 格血，受到一次攻击就掉相应的血。</li>
<li>主角踩在不带刺的怪物上方可以对怪物造成伤害，踩在带刺的怪物身上会受到伤害。</li>
</ul>
<p>到这里，游戏最最基本的解构就完成了。</p>
<h3 id="Rougelike-要素"><a href="#Rougelike-要素" class="headerlink" title="Rougelike 要素"></a>Rougelike 要素</h3><p>但原作是 Rougelike 游戏，所谓肉鸽（Rougelike），首先是在一定固定规则上的随机，如随机地形、随机怪物，其次就是通过阶段性的随机奖励&#x2F;道具，来提升或改变角色的能力（攻击力、攻击方式、弹夹容量、血量、恢复力等等）。同时，地图并不是一图到底无限延伸，而是分为一个个关卡。怪物也会随着关卡层数（下降层数）变强，数量、种类更多、速度更快、攻击更猛。在关底（最后的关卡）有强力 Boss，打败 Boss 游戏就算通关。来解构一下这一部分的要素：</p>
<ul>
<li>随机性，地形随机生成，怪物（符合关卡难度的基础上）随机生成，道具随机生成等等。</li>
<li>要让主角变强，就要获得奖励&#x2F;道具。道具可由击杀怪物掉落，或者通过击杀怪物得到的货币来到随机生成的商店处购买（商店内道具随机生成）。这也使得主角需要更多的交互操作，如在商店中购买道具、开启主动技能等等。同时需要有货币机制。</li>
<li>关卡设计，如每次下降一定的单位长度就自动进入下一关，每过一关主角可以获得一些随机道具。关卡中的怪物需要体现递进，即越来越难。难度的提升可以体现在怪物活动方式、攻击方式上的不同与递进。</li>
<li>在关底设计 Boss，拥有独特的存在方式、活动方式与攻击方式，可以模仿上述视频中 Boss 的行为与机制。</li>
<li>通关机制，评分机制。</li>
</ul>
<p>那么 Rougelike 要素就差不多了，这只是一些粗浅的解构，但对本项目已经足够了。</p>
<hr>
<p>在初步解构完要素的基础上，开始提出具体的要求：</p>
<ul>
<li>和<a target="_blank" rel="noopener" href="https://oj.cpl.icu/contest/34/problem/156">小恐龙🦖（dino）</a>中大部分要求基本相同。</li>
<li>地图中随机平台的生成，不能完全堵住路，也不能太过散乱。</li>
<li>子弹（我方或敌方）的路线设计（直线、曲线、跟踪）与内存管理。</li>
<li>至少实现三种不同机制的怪物（如只爬动不攻击、爬动且带刺、只飞行不攻击）。</li>
<li>合理的碰撞判定与扣血机制。</li>
<li>弹夹消耗与补充机制，发射子弹时主角的滞空机制。</li>
<li>关于 Rougelike 要素的具体要求全凭你自己的理解，随意发挥即可。</li>
</ul>
<hr>
<h3 id="评分标准-8"><a href="#评分标准-8" class="headerlink" title="评分标准"></a>评分标准</h3><p>Sakiyary 人工评判，正确实现<strong>基础要素</strong>与其相关的具体要求即可得到 8080% 以上的分数。</p>
<p>使用图形界面并<strong>不会得到更高的分数</strong> ，若图形界面不符合<a target="_blank" rel="noopener" href="https://docs.cpl.icu/#/project/gui_req">要求</a>或 bug 太多，得分甚至会比命令行字符界面的实现更低。</p>
<p>剩余分数由相应的加分条件给出：</p>
<ul>
<li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会 <strong>倒扣</strong> ）</li>
<li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li>
<li>实现 Rougelike 要素的相关功能与具体要求。</li>
<li>模拟出原作的更多机制与游戏性。（不是贴图，是游戏机制）</li>
<li>在不改变原有游戏性的前提下，实现超出原作的合理的扩展功能。</li>
<li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li>
</ul>
<hr>
<h3 id="技术要求-6"><a href="#技术要求-6" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）</li>
</ul>
<p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<h3 id="提交方式-6"><a href="#提交方式-6" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>



<h2 id="滑雪冒险"><a href="#滑雪冒险" class="headerlink" title="滑雪冒险"></a>滑雪冒险</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>出题人：李薛成</p>
<p>验题人：不知道</p>
</blockquote>
<h3 id="项目概述-7"><a href="#项目概述-7" class="headerlink" title="项目概述"></a>项目概述</h3><p>好耶，是滑雪大冒险！这款游戏的 BGM 应该耳熟能详吧，不熟也不要紧，我们直接来看 B 站大佬的魔改版👉 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1VK411R7BM/">我做了个滑雪大冒险，但是纳西妲！</a></p>
<hr>
<h3 id="项目要求-4"><a href="#项目要求-4" class="headerlink" title="项目要求"></a>项目要求</h3><p>你可以使用图形界面，也可以使用字符的命令行界面来运行游戏。（等一下，这道题真的能用字符界面吗？）</p>
<p>如果你选择使用图形界面，请仔细阅读课程网站上的<a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/project/gui_req">图形界面要求</a>。</p>
<p>首先我们要明确你需要做一个什么样的游戏出来。显然，如果你能模仿原作实现它的绝大部分功能，拿到满分应该很大。但我们还是来解构一下这款游戏的要素：</p>
<h3 id="基础要素-1"><a href="#基础要素-1" class="headerlink" title="基础要素"></a>基础要素</h3><ul>
<li>一位可以操控的主角，主角只需要一种交互：跳跃。</li>
<li>一个无限延伸山坡，作为地图。</li>
<li>追赶主角的雪崩，随分数升高速度逐渐增大（小幅度）。</li>
<li>主角的“装备”们（如雪橇、企鹅、雪怪、摩托、鹰等）</li>
<li>坡道上的障碍物（石块），碰到障碍物时，若主角无装备，则摔倒；若有装备，则按一定的顺序掉一件装备。</li>
</ul>
<p>到这里，游戏最最基本的解构就完成了。</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>这个游戏其实有几个难点，如山坡的生成、雪崩跟着山坡的滑动、装备们的组合等。</p>
<ol>
<li>山坡可以是固定的斜着的波浪线，也可以是随机参数的线性函数的平滑拼接。</li>
<li>雪崩甚至可以直接用一个长方形来模拟，意思到了就行，也可以将雪崩精细地实现为随山坡滑动的有宽度（高度？）的曲线。</li>
<li>装备的组合首先是视觉上的位置关系，其次就是你想将这个实现到哪种程度，粗糙一些也可以，十分精细也可以。</li>
</ol>
<p>实现全看自己的想法，但是给分也会根据你实现各难点的方式与难度来评判。</p>
<hr>
<p>在初步解构完要素的基础上，开始提出具体的要求（<strong>基础版</strong>）：</p>
<ul>
<li>和<a target="_blank" rel="noopener" href="https://oj.cpl.icu/contest/34/problem/156">小恐龙🦖（dino）</a>中大部分要求基本相同。</li>
<li>地图中坡道的生成，曲线要有起伏，不能有断崖或太多的小疙瘩。（可以用固定模式生成）</li>
<li>随分数增长不断加速的追赶主角的雪崩。（可以用简单的图形模拟）</li>
<li>随机出现的障碍物。（如大大小小的石头）</li>
<li>“装备”们的运动，至少实现三种装备，且能以合理的不同的方式各自组合。</li>
<li>合理的碰撞判定与穿装备&#x2F;掉装备&#x2F;摔倒机制。</li>
</ul>
<hr>
<h3 id="评分标准-9"><a href="#评分标准-9" class="headerlink" title="评分标准"></a>评分标准</h3><p>不知道谁人工评判，正确实现<strong>基础版</strong>要求（即用最简单的方式完成各个难点）即可得到 8080% 以上的分数。</p>
<p>（不好意思，这道题我真不知道字符界面怎么做……）</p>
<p>剩余分数由相应的加分条件给出：</p>
<ul>
<li>基础功能十分完善，界面美观，动画流畅，没有 bug。（bug 太多会 <strong>倒扣</strong> ）</li>
<li>Sakiyary 认为你的代码结构非常合理，或是对 C 语言的掌握较好。</li>
<li>将上述三个难点用精细的方式实现。</li>
<li>模拟出原作的更多机制与游戏性。（不是贴图，是游戏机制）</li>
<li>在不改变原有游戏性的前提下，实现超出原作的合理的扩展功能。</li>
<li>对于命令行字符界面，实现流畅的动画、绘制更美观且比例适当的字符画则加分。</li>
</ul>
<hr>
<h3 id="技术要求-7"><a href="#技术要求-7" class="headerlink" title="技术要求"></a>技术要求</h3><p>编写项目文档（实验报告），须放在项目中容易找到的地方。</p>
<p>文档写得必须简洁，超过两页<strong>倒扣</strong>分数。</p>
<p>可以是任意格式，推荐 Markdown 格式，清晰即可，不必拘泥于排版（也不会加任何分）。</p>
<p>Markdown 可以在 <a target="_blank" rel="noopener" href="http://docs.cpl.icu/#/resources?id=%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91">课程资源-教程视频-Markdown</a> 自行学习。</p>
<p>文档中请务必指出：</p>
<ul>
<li>平台（操作系统）</li>
<li>C 语言环境（mingw、msvc等及其详细的版本）</li>
<li>编译选项（CMakeLists、MakeFile、编译指令等）</li>
<li>使用的第三方库</li>
<li>游戏方式（你设计的键位、操作等）</li>
</ul>
<p>可以少许地介绍项目设计思路，以及你认为你写的特别好的地方。</p>
<p>同时，你也可以写一些感想与意见，如果你能写出充实的感想或有价值的意见，你将获得教学团队的认可！</p>
<hr>
<h3 id="提交方式-7"><a href="#提交方式-7" class="headerlink" title="提交方式"></a>提交方式</h3><p>如果使用了第三方库，可以自行针对自己选择的库查阅如何生成release版本的可执行的文件（也就是打包发布的方法，而不是只是单纯在提交的压缩包里复制一个编译生成的可执行文件，这样的文件在使用第三方库的情况下多半是无法在另外一台电脑上直接运行的）并放在bin目录下；如果你没有使用第三方库（比如只是CLI界面），那么直接复制编译生成的可执行文件可能是可行的。注意要注明你的编译生成文件对应的平台，此项不作为强制要求，但是这样的操作可以让你把游戏分享给其他人进行游玩。</p>
<p>将源码的压缩包提交到课程系统中（打开代码编辑器-&gt;上传压缩文件），保持原始的目录结构，并在文档中说明如何你的源码如何编译生成对应的可执行文件和基本操作的方式</p>
<p><strong>可以参考如下的结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--学号_姓名.zip</span><br><span class="line">|  |--src //(源码文件夹)</span><br><span class="line">|  |  |--a.c</span><br><span class="line">|  |  |--b.c</span><br><span class="line">|  |  |--Makefile / CMakeLists.txt</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--bin //(可执行文件文件夹，如果有)   </span><br><span class="line">|  |  |--win</span><br><span class="line">|  |  |  |--game_x64.exe</span><br><span class="line">|  |  |--……</span><br><span class="line">|  |--实验报告_学号_姓名.pdf</span><br></pre></td></tr></table></figure>



<h2 id="内存文件系统"><a href="#内存文件系统" class="headerlink" title="内存文件系统"></a>内存文件系统</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>出好实验要求了。本题由 OJ 进行自动测试，OJ 最大的特点就是严格，不能蒙混过关了。</p>
<p><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/0dd09ebfbbb3457fbaad/">实验要求（简单版）</a> 请查看群文件的最新版。部分测试用例也在群文件中。</p>
<p>推荐使用 linux，git，make。可以先尝试着提交，任何问题请提出。</p>
<p>Windows 上的提交不能用 make submit。你需要手动将你的目录下的 <strong>.git 文件夹</strong>压缩成 zip 手动在 OJ 那里上传。</p>
<p>按时提交即得 20 分诚信分。（与 gitm 一样）前言</p>
<p>这可能是大家第一次做类似的工作：你不是编写一个完整的程序，而是按照要求实现一些函数。这些函数将会被我们调用，以检测是否实现了所要求的功能。</p>
<p><strong>本要求为（基本上是）最终版本。其中重要的描述修正将以这样的形式标出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+++ 这里是修改过的描述，请注意检查 +++</span><br></pre></td></tr></table></figure>





<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>文件系统是操作系统的重要组成部分。调用文件系统 api，我们可以轻松地将数据持久化到磁盘上。C 语言中为我们提供了一组 api，它们基于操作系统 api，允许我们对文件进行操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 Linux 操作系统中，上述的 C 文件操作 api 是基于一组操作系统的文件 api 实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>现要求你实现一个内存文件系统（ramfs）。顾名思义，这个文件系统的所有数据并不持久化到磁盘上，而是保存到内存当中，是一个易失性的文件管理系统。</p>
<h3 id="文件系统的约定"><a href="#文件系统的约定" class="headerlink" title="文件系统的约定"></a>文件系统的约定</h3><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><p>Ramfs 的目录结构与 Linux 的树形结构一致。在初始状态下，只存在根目录 “&#x2F;“。文件系统中存在两类对象，目录与文件。目录下可以存放其他对象，而文件不可以。即在树形结构中，文件只能是叶子节点。</p>
<p>例 (#)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── 1.txt            &quot;/1.txt&quot;</span><br><span class="line">├── 2.txt            &quot;/2.txt&quot;</span><br><span class="line">└── dir              &quot;/dir&quot;</span><br><span class="line">    ├── 1.txt        &quot;/dir/1.txt&quot;</span><br><span class="line">    └── 2.txt        &quot;/dir/2.txt&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到，在根目录下一共有 3 个项目：两个文件，一个目录 dir，而 dir 下还可以拥有两个文件。右侧的字符串称为对象的“绝对路径”。</p>
<p>单个文件和目录名长度 &lt;&#x3D; 32 字节，</p>
<h6 id="修订1"><a href="#修订1" class="headerlink" title="修订1"></a>修订1</h6><p>+++ <strong>是字母、数字、英文句点的任意组合。例如，’.’ 不是当前目录，’..’ 也不是上级目录</strong> +++</p>
<p>对于存在<strong>不合法文件名</strong>的路径，你的文件系统 api 应当统一通过返回 -1 来拒绝此类操作。</p>
<p>所有 api 调用中，路径长度 &lt;&#x3D; 1024 字节。（也就是说，文件系统的路径深度是存在上限的）。</p>
<p>文件系统 api 统一使用绝对路径，即以 ‘&#x2F;‘ 开头。在未创建任何文件时，就已经存在 “&#x2F;“ 指向的根目录。该目录可打开，不可删除，其余性质与一般目录一致。</p>
<h4 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h4><p>整个文件系统同时存在的所有文件内容不会超过 512 MiB（不含已经删去的文件和数据），给予 1GiB 的内存限制。</p>
<p>同时存在的文件与目录不会超过 65536 个。</p>
<p>同时活跃着的文件描述符不会超过 4096 个。</p>
<p>对于所有数据点，文件操作读写的总字节数不会超过 10GiB。时限将给到一个非常可观的量级。</p>
<p>各数据点的性质：</p>
<ol>
<li><p>如原始的 main.c</p>
</li>
<li><p>根目录下少量文件创建 + ropen + rwrite + rclose</p>
</li>
<li><p>在 2 的基础上，测试 O_APPEND，rseek</p>
</li>
<li><p>在 3 的基础上扩大规模</p>
</li>
<li><p>少量子目录创建（&lt;&#x3D; 5 层）+ 文件创建与随机读写</p>
</li>
<li><p>在 5 的基础上，测试 rrmdir, runlink。</p>
</li>
<li><p>大文件测试。多 fd 对少量大文件大量读写 + rseek + O_TRUNCATE</p>
</li>
<li><p>复杂的文件树结构测试。大量的 O_CREAT，rmkdir, rrmdir, runlink。少量读写</p>
</li>
<li><p>文件描述符管理测试。大量 ropen、rclose，多 fd 单文件</p>
</li>
<li><p>综合场景的大型测试。模拟真实的系统。</p>
</li>
</ol>
<p>错误将会分散在各个数据点中。你需要保证你的 API 能正确地判断错误的情况并按照要求的返回值退出。</p>
<p>如果你获得 ”Wrong Answer“，说明仅仅是程序行为与 API 不一致。如读写的结果不正确，应该打开失败的文件却成功了…</p>
<p>如果获得 ”Runtime Error”，说明你的程序会出现运行错误而 crash。比如你在遍历文件树时，解引用了空指针…</p>
<h4 id="接口简述"><a href="#接口简述" class="headerlink" title="接口简述"></a>接口简述</h4><p>我们要求你实现如下的 api，以实现文件系统的管理。其具体行为将会在 api 说明部分阐释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>注意，我们要求你实现的是内存操作系统。故你的程序应当使用内存管理 api（malloc、free）来存放文件所需的数据结构，以及文件的所有内容。请小心地管理好内存注意不要超限。</p>
<h3 id="开始你的项目"><a href="#开始你的项目" class="headerlink" title="开始你的项目"></a>开始你的项目</h3><p>我们为你准备了一个 git repo。请基于这个 git repo 进行你的项目。如果你不会 git，请学着使用。</p>
<p>在 git repo 中我们为你提供了一个自动编译脚本 Makefile。并且为你配置好了记录自动追踪。请不要随意修改 Makefile。你的修改记录将成为查重时证明独立完成的重要证据。</p>
<p>推荐在 Linux 操作系统中完成本作业。如果你要使用 Windows，产生的问题由你自己解决。</p>
<p>获取代码框架：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://git.nju.edu.cn/Tilnel/ramfs.git&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：请在默认的 master 分支上进行开发。最终 OJ 的评分也将以你的 master 分支为准。</p>
<p><strong>你应当在 ramfs.c 中包含你的所有实现</strong>（包括指定的函数和你使用的所有数据结构）。评测机会用我们自己的 Makefile（和分发版本一致）、ramfs.h（和分发版本一致）、main.c（包含更强力的测试用例）进行编译运行。因此你对 ranfs.h 和 main.c 以及 Makefile 的修改在 OJ 上不会产生效果。</p>
<p>提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make submit TOKEN=<span class="variable">$&#123;你的token&#125;</span></span><br></pre></td></tr></table></figure>

<p>请在题目中“打开代码编辑器”后，获取你的提交 token。注意在校园网环境下提交。然后你就能在提交列表中看到你的提交。</p>
<blockquote>
<p>由于服务器现可以通过 public.oj.cpl.icu 访问，你可以对 Makefile 中 submit 目标下的 url 进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@ -25,5 +25,5 @@ submit:</span><br><span class="line">     @cd .. &amp;&amp; zip -qr $&#123;FILE&#125; $&#123;BASE&#125;/.git</span><br><span class="line">     @echo &quot;Created submission archive $&#123;FILE&#125;&quot;</span><br><span class="line">     @curl -m 5 -w &quot;\n&quot; -X POST -F &quot;TOKEN=$&#123;TOKEN&#125;&quot; -F &quot;FILE=@$&#123;FILE&#125;&quot; \</span><br><span class="line">-               https://oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">+               http://public.oj.cpl.icu/api/v2/submission/lab</span><br><span class="line">        @rm -r $&#123;TEMP&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意在 make submit 之前，你需要将最新的改动 commit。同样注意保持你的工作目录整洁，如果你的 git repo 超过 20MiB（这一定是因为你放了很多很多奇怪的玩意），则没有办法提交。</p>
<p>你的 git repo 中不应当包含各种形式的编译产生的中间文件、编译结果。我们的 Makefile 只会在 build 目录下产生文件，我们也会配置好 .gitignore 文件避免 track 这些文件。</p>
<h3 id="API-手册"><a href="#API-手册" class="headerlink" title="API 手册"></a>API 手册</h3><h6 id="修订2"><a href="#修订2" class="headerlink" title="修订2"></a>修订2</h6><p>+++ <strong>你的实现不应当有任何输出</strong> +++</p>
<p>以下注意区分两种对象的定义：文件（file），目录（directory）。</p>
<p>另一个重要的对象是：文件描述符（file descriptocr），简称 FD。它是所有<strong>打开的文件和目录的指示符</strong>，为一个非负整数。在 Windows 操作系统中称之为“句柄”。我们使用路径打开一个文件或目录，操作系统就会为这一次文件的打开分配一个文件描述符，它就像是一个“把手”一样。我们用这个文件描述符来指示打开的文件，进行对文件的操作。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);  <span class="comment">// open 返回一个文件描述符</span></span><br><span class="line">read(fd, buf, <span class="number">5</span>);                   <span class="comment">// 从打开的 fd (/1.txt) 中读取五个字节</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ropen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="修订3"><a href="#修订3" class="headerlink" title="修订3"></a>修订3</h6><p>+++ 打开 ramfs 中的<strong>文件或目录</strong>。如果成功，返回一个文件描述符（一个非负整数），用于标识这个对象。+++</p>
<p>如果打开失败，则返回一个 -1。</p>
<p>pathname 为一个字符串，为一个绝对路径。<strong>对于所有存在的文件和目录，你的 ropen 调用都应当成功</strong>。特别地，在指示一个目录时，pathname 的末尾可以有多余的 ‘&#x2F;‘。pathname 中间同样可以有冗余的 ‘&#x2F;‘。</p>
<p>例如，在上文的例 (#) 中，以下的绝对路径是合法的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dir/        =/dir</span><br><span class="line">////dir       =/dir</span><br><span class="line">/1.txt        =/1.txt</span><br><span class="line">//dir/1.txt   =/dir/1.txt</span><br></pre></td></tr></table></figure>

<p>以下的绝对路径是不存在的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/3.txt</span><br><span class="line">/1.txt/       (文件路径后不可以有多余的&#x27;/&#x27;)</span><br><span class="line">/di/r/1.txt   (不存在这个路径)</span><br></pre></td></tr></table></figure>

<p>flag 指示打开方式，这些打开方式仅对<strong>文件</strong>起作用。如果被打开的是目录则自动忽略。其取值有如下可能（或可以是它们的组合）：</p>
<p>注意，在 C 中，以 0 开头的数字采用 8 进制表示法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_APPEND  02000 以追加模式打开文件。即打开后，文件描述符的偏移量指向文件的末尾。若无此标志，则指向文件的开头</span><br><span class="line">O_CREAT   0100 如果 pathname 不存在，就创建这个文件，但如果这个目录中的父目录不存在，则创建失败；如果存在则正常打开</span><br><span class="line">O_TRUNC   01000 如果 pathname 是一个存在的文件，并且同时以可写方式 (O_WRONLY/O_RDWR) 打开了文件，则文件内容被清空</span><br><span class="line">O_RDONLY  00 以只读方式打开</span><br><span class="line">O_WRONLY  01 以只写方式打开</span><br><span class="line">O_RDWR    02 以可读可写方式打开</span><br></pre></td></tr></table></figure>

<p>这些标志位的组合方式是使用按位的或运算。即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O_TRUNC | O_RDWR   (可读可写，打开时清空)</span><br><span class="line">+++ O_CREAT | O_WRONLY (若不存在，创建后以只写方式打开；否则以只写方式直接打开) +++ （原来写成读写了）</span><br><span class="line">+++ O_APPEND   (文件描述符的偏移量指向文件末尾，并可读) +++</span><br></pre></td></tr></table></figure>

<h6 id="修订8"><a href="#修订8" class="headerlink" title="修订8"></a>修订8</h6><p>+++ O_TRUNC 但文件以只读方式打开时，在 Linux 中为 unspecified 行为。此处约定为正常只读打开而不清空。 （1.15 聊天记录）+++</p>
<h6 id="修订4"><a href="#修订4" class="headerlink" title="修订4"></a>修订4</h6><p>+++ 注意点：+++</p>
<p>+++ <code>O_RDWR | O_WRONLY</code> 共同存在时，取只写的语义； +++</p>
<p>+++ 由于 <code>O_RDONLY</code> 是 0，因此若未指定任何读写方式时，默认是只读的； +++</p>
<p>+++ 同时，易得 <code>O_RDONLY | O_WRONLY == O_WRONLY</code>。因此组合只读只写得到的结果是只写。 +++</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rclose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>关闭打开的文件描述符，并返回 0。如果不存在一个打开的 fd，则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>向 fd 中的<em><strong>偏移量</strong></em>（马上解释）位置写入以 buf 开始的至多 count 字节，覆盖文件原有的数据。如果 count 超过 buf 的大小，仍继续写入（数据保证不因此而产生段错误），将 fd 的<em><strong>偏移量</strong></em>后移 count，并返回实际成功写入的字节数。如果写入的位置超过了原来的文件末尾，则自动为该文件扩容。</p>
<p>如果 fd 不是一个可写的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p>
<p>在本实验中，ramfs 中同时存在的文件大小不会超过限制。因此你的 rwrite 对于一个能够写入的文件，事实上总应返回 count。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>从 fd 中的<em><strong>偏移量</strong></em>位置读出至多 count 字节到 buf 指向的内存空间当中，</p>
<h6 id="修订5"><a href="#修订5" class="headerlink" title="修订5"></a>修订5</h6><p>+++ 将<em><strong>偏移量</strong></em>后移实际读出的字节数，并返回实际读出的字节数。+++</p>
<p>因为可能会读到文件末尾，因此返回值有可能小于 count。</p>
<p>如果 fd 不是一个可读的文件描述符，或 fd 指向的是一个目录，则返回 -1。</p>
<h4 id="偏移量（offset）"><a href="#偏移量（offset）" class="headerlink" title="偏移量（offset）"></a>偏移量（offset）</h4><p>想象你用手指指着读一本书，offset 相当于你手指指向的位置。你每读一个字，手指就向前前进一个字；如果你想改写书本上的字，每改写一个字，手指也向前前进一个字。</p>
<p>每一个文件描述符都拥有一个偏移量，用来指示读和写操作的开始位置。这个偏移量对应的是文件描述符，而不是“文件”对象。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/1.txt&quot;</span>, O_WRONLY | O_CREAT);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDONLY);</span><br><span class="line">write(fd1, <span class="string">&quot;helloworld&quot;</span>, <span class="number">11</span>);</span><br><span class="line">read(fd2, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h6 id="修订6"><a href="#修订6" class="headerlink" title="修订6"></a>修订6</h6><p>--- 此时 buf 中将从文件的开头读到”hello\0”。但如果换一种方式： ---  </p>
<p>+++ 此时 buf 中将从文件的开头读到”hellow”。但如果换一种方式： +++</p>
<p>假设 “&#x2F;1.txt” 中原来有数据 “helloworld\0”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/1.txt&quot;</span>, O_RDWR);</span><br><span class="line">write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">read(fd, buf, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>此时，write 在读取时，将文件指针前移了 5 个字节。于是read在读取的时候，将会从第6个字节开始读取。也即，read 将会读到 “world\0”。对于同一个文件描述符，读取和写入操作是共享偏移量的；对于不同的文件描述符，它们的偏移量则是各自独立的。</p>
<p>对于 open 操作，如果没有 O_APPEND 标志来将偏移量指向末尾，那么默认指向文件开头。</p>
<p>如何自由地修改和获取文件描述符的偏移量呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">rseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数用于修改 fd 表示的文件描述符的偏移量，并返回当前文件的实际偏移量。</p>
<p>whence有三种取值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEEK_SET 0   将文件描述符的偏移量设置到 offset 指向的位置</span><br><span class="line">SEEK_CUR 1   将文件描述符的偏移量设置到 当前位置 + offset 字节的位置</span><br><span class="line">SEEK_END 2   将文件描述符的偏移量设置到 文件末尾 + offset 字节的位置</span><br></pre></td></tr></table></figure>

<p>rseek 允许将偏移量设置到文件末尾之后的位置，但是并不会改变文件的大小，<strong>直到它在这个位置写入了数据</strong>。在 超过文件末尾的地方写入了数据后，原来的文件末尾到实际写入位置之间可能出现一个空隙，我们规定应当以 “\0” 填充这段空间。</p>
<p>+++ 但不允许将偏移量设置到文件开头之前，也就是一个负数的绝对偏移量。这种情况下返回 -1。 +++</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>创建目录，成功则返回 0。如果目录的父目录不存在或此路径已经存在，则失败返回 -1。</p>
<p>如，原来系统中只存在根目录 “&#x2F;“，调用：<code>rmkdir(&quot;/path/to/dir&quot;)</code> 返回 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rrmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>删除一个空目录，成功则返回 0。如果目录不存在或不为空，或 pathname 指向的不是目录，返回 -1。测试保证不对打开的 pathname 做 rrmdir。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">runlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>删除一个文件，成功则返回 0。如果文件不存在或 pathname 指向的不是文件，则返回 -1。测试保证不对打开的 pathname 做 runlink。</p>
<p>额外的一个 api：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void init_ramfs();</span><br></pre></td></tr></table></figure>

<p><strong>可以</strong>用于初始化你的文件系统。比如创建根目录。我们用于测试的 main() 将总会包含它。（要在里面做什么取决于你自己！）</p>
<p>我们的测试用例长什么样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* our main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ramfs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();     <span class="comment">// 你的初始化操作</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/dir&quot;</span>) == <span class="number">0</span>);   <span class="comment">// 应当成功</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;//dir&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为目录已存在</span></span><br><span class="line">  assert(rmkdir(<span class="string">&quot;/a/b&quot;</span>) == <span class="number">-1</span>);  <span class="comment">// 应当给出 error，因为父目录不存在</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  assert((fd = ropen(<span class="string">&quot;//dir///////1.txt&quot;</span>, O_CREAT | O_RDWR)) &gt; <span class="number">0</span>);  <span class="comment">// 创建文件应当成功</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 应当完整地写入</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_CUR) == <span class="number">5</span>);  <span class="comment">// 当前 fd 的偏移量应该为 5</span></span><br><span class="line">  assert(rseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">0</span>);  <span class="comment">// 应当成功将 fd 的偏移量复位到文件开头</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(rread(fd, buf, <span class="number">7</span>) == <span class="number">5</span>);   <span class="comment">// 只能读到 5 字节，因为文件只有 5 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>);   <span class="comment">// rread 应当确实读到 &quot;hello&quot; 5 个字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">3</span>, SEEK_END) == <span class="number">8</span>);  <span class="comment">// 文件大小为 5，向后 3 字节则是在第 8 字节</span></span><br><span class="line">  assert(rwrite(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);  <span class="comment">// 再写 5 字节</span></span><br><span class="line">  assert(rseek(fd, <span class="number">5</span>, SEEK_SET) == <span class="number">5</span>);  <span class="comment">// 将偏移量重设到 5 字节</span></span><br><span class="line">  assert(rread(fd, buf, <span class="number">8</span>) == <span class="number">8</span>);   <span class="comment">// 在第 8 字节后写入了 5 字节，文件大小 13 字节；那么从第 5 字节后应当能成功读到 8 字节</span></span><br><span class="line">  assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0world&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>); <span class="comment">// 3 字节的空隙应当默认填 0</span></span><br><span class="line">  assert(rclose(fd) == <span class="number">0</span>); <span class="comment">// 关闭打开的文件应当成功</span></span><br><span class="line">  assert(rclose(fd + <span class="number">1</span>) == <span class="number">-1</span>); <span class="comment">//关闭未打开的文件应当失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="修订7"><a href="#修订7" class="headerlink" title="修订7"></a>修订7</h6><p>+++ 我们将会在这份手册的最后，提供几份测试代码供大家参考。大家可以将这些代码放到你的 <code>main.c</code> 中，并使用 <code>make run</code> 进行测试。+++</p>
<h3 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h3><p>首先是目录树。这里给出一个参考的文件对象结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> FILE_NODE, DIR_NODE &#125; type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">dirents</span>;</span>  <span class="comment">// if it&#x27;s a dir, there&#x27;s subentries</span></span><br><span class="line">    <span class="type">void</span> *content;         <span class="comment">// if it&#x27;s a file, there&#x27;s data content</span></span><br><span class="line">    <span class="type">int</span> nrde;              <span class="comment">// number of subentries for dir</span></span><br><span class="line">    <span class="type">int</span> size;              <span class="comment">// size of file</span></span><br><span class="line">    <span class="type">char</span> *name;            <span class="comment">// it&#x27;s short name</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>

<p>目录的子项的数量会变化；文件的内容大小也会变化。因次我们可能需要对 <code>dirents</code> 或 <code>content</code> 的内存大小进行动态的改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这一函数会创建一段新的空间，将原来的内容复制到新的空间上，并释放原来的指针。注意原有指针一定也是动态分配的。</p>
<p>其次是文件描述符。对于文件描述符来说，其重要的只有这几个属性：读写性质，偏移量，指向的实际文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FD</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    node *f;</span><br><span class="line">&#125; FD;</span><br></pre></td></tr></table></figure>



<p>最初的根文件可以直接定义成全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node root;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>init_ramfs</code> 中进行初始化。</p>
<p>接下来的事情，就很显然了：</p>
<p>添加文件和目录，就是往树里添加节点；</p>
<p>删除文件，就是删除节点；</p>
<p>读取内容，就是从 content 里复制出一段…</p>
<p>一个小建议：使用 <code>memcpy</code> 而不是 <code>strcpy</code>。（区别在哪？读手册）</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>第一个数据点已经给出。</p>
<p>test2:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">notin</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[i] == fd) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">genfd</span><span class="params">(<span class="type">int</span> *fds, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (notin(i, fds, n))</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  init_ramfs();</span><br><span class="line">  <span class="type">int</span> fd[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line">  assert(ropen(<span class="string">&quot;/abc==d&quot;</span>, O_CREAT) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_RDONLY)) == <span class="number">-1</span>);</span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_WRONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    assert(rwrite(fd[<span class="number">0</span>], <span class="string">&quot;\0\0\0\0\0&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">1</span>], <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">2</span>], <span class="string">&quot;world&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    assert(rwrite(fd[<span class="number">3</span>], <span class="string">&quot;\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  assert(rclose(genfd(fd, <span class="number">4</span>)) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  assert((fd[<span class="number">0</span>] = ropen(<span class="string">&quot;/0&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">1</span>] = ropen(<span class="string">&quot;/1&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">2</span>] = ropen(<span class="string">&quot;/2&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert((fd[<span class="number">3</span>] = ropen(<span class="string">&quot;/3&quot;</span>, O_CREAT | O_RDONLY)) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">1</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  assert(rwrite(fd[<span class="number">3</span>], buf, <span class="number">1</span>) == <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\0\0\0\0\0\0\0\0\0\0&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;hellohello&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;worldworld&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">    assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">10</span>);</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(buf, <span class="string">&quot;\x001\x002\x003\x0fe\x0ff\x001\x002\x003\x0fe\x0ff&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(rread(fd[<span class="number">0</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">1</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">2</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rread(fd[<span class="number">3</span>], buf, <span class="number">10</span>) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">0</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">1</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">2</span>]) == <span class="number">0</span>);</span><br><span class="line">  assert(rclose(fd[<span class="number">3</span>]) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他的请再等等吧（</p>
<p>2023.1.14 补：</p>
<p>上线了测试点 4，在 main() 的开头做了一件事：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rread(<span class="number">-100000000</span>, buf, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>所有人都炸掉了。但按照手册，它应该返回 -1。这只是测试中不合理数据的一角，请大家保证自己的实现的可靠性。</p>
<p>如果你对某些特例会产生什么行为抱有疑问，欢迎提问。</p>
<h6 id="修订9"><a href="#修订9" class="headerlink" title="修订9"></a>修订9</h6><p>+++ 再次强调请小心地管理内存，否则内存容易超限，特别是注意释放掉已经不用的空间。</p>
<p>+++ OJ 评测结果解释：</p>
<p>+++ 答案错误：你的函数行为与规定的行为不一致。可能是文件系统中的内容不一致，也可能是函数返回值不符合约定。</p>
<p>+++ 运行错误：你的函数在内部崩溃了。</p>
<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p><a target="_blank" rel="noopener" href="https://box.nju.edu.cn/f/8ef6cedb59de48f8a0b7/">实验要求</a> 请看群文件最新版。</p>
<p>项目框架将发布在 <a target="_blank" rel="noopener" href="https://git.nju.edu.cn/Tilnel/gitm.git">https://git.nju.edu.cn/Tilnel/gitm.git</a></p>
<p><del>目前题目只有一个样例，直接交就是一伯分</del>。但我出好数据之后会重新评测。</p>
<p>有一个送分样例。正确按时提交保底 20 分。</p>
<p>Windows 上的提交不能用 make submit。你需要手动将你的目录下的 .git 文件夹压缩成 zip 手动在 OJ 那里上传。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>git 是当今世界上最流行的版本控制系统。本实验要求你通过提交 git repo 的方式来提交一个迷你版的命令行工具 gitm(inus)。</p>
<p><strong>注意：本实验将只能在 Linux 操作系统中完成</strong>，因为你不得不使用系统调用，而 OJ 是 Linux 的。提交 Windows 上可以编译运行的代码，在评测机上注定不可兼容。</p>
<p>首先，你需要学习 git ，否则你将完全不明白 gitm 的功能，并且也无法用 git 来管理本次作业的代码。</p>
<blockquote>
<p>是的！我们将会发布一个由 git 管理的框架代码，并且要求你一直使用 git 来管理，最终提交一个 git repo。</p>
</blockquote>
<p>获取框架代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.nju.edu.cn/Tilnel/gitm.git</span><br></pre></td></tr></table></figure>



<h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><p>所有代码，包括 .c 和 .h 文件需要放在 git repo 的根目录下。对自己使用的头文件的引用请以双引号的形式，以便编译脚本能够正常工作。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitm</span><br><span class="line">├── gitm.c</span><br><span class="line">├── gitm.h</span><br><span class="line">├── whateveryouwant.c</span><br><span class="line">├── whateveryouwant.h</span><br><span class="line">├── ...</span><br><span class="line">└── Makefile</span><br><span class="line"></span><br><span class="line">/* gitm.c */</span><br><span class="line">#include &quot;gitm.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>你可以修改 Makefile，但请不要删除其中的 git 目标依赖。我们在 Makefile 中确保了你的每一次编译运行都能够自动进行 git commit。这些自动的 commit 可以帮助你回滚到自己想要的任意版本，并且在未来查重工作中产生疑问时，良好的 commit 记录将成为重要的证明。</p>
<p>在你的 git repo 里请包含所有编译所需的源文件，但不要出现编译不需要的多余的源文件。</p>
<p>尝试编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>你将看到根目录下产生了一个名为 gitm 的可执行文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gitm version</span><br></pre></td></tr></table></figure>

<p>你将看到一个小彩蛋（你之后可以自由地删掉它或修改掉，不影响成绩）。</p>
<p>注意：本次实验你编写的是一个 “命令行工具”。也就是说，我们将以和使用 git 相同的方式来使用它：在命令行里输入命令和参数。这意味着，这次你需要真正 “解析参数” （被 parse.c 支配的恐惧）。</p>
<p>而且，这次我们将会在运行中多次调用你的程序。也就是说，你的程序并不是在一直运行着，每一次调用都会做不同的事。你存储在内存里的数据都将随着功能完成，进程结束而消失。所以，关于 gitm repository 的有用的信息，你需要将它们持久化到磁盘上，以便进行后续的操作。因此学习 C 语言的文件操作是必不可少的。</p>
<p>为了实现一个 git，首先你要了解 git 的功能</p>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>假设我们当前在一个文件夹 dir 下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm init</span><br></pre></td></tr></table></figure>

<p>初始化当前的 dir 为一个 gitm repository。如果当前 dir 已经是一个 gitm repo，则不做任何操作。</p>
<p>此时的 gitm 中应当不存在任何 commit，gitm 的仓库中应不存在任何文件。</p>
<p>具体来说，你可以在当前目录下创建一个 <code>.gitm</code> 目录，用于存放一些记录仓库状态的文件。</p>
<blockquote>
<p>对，就像 git 的 .git 那样！</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm commit</span><br></pre></td></tr></table></figure>

<p>将当前仓库中文件改动后状态作为一个提交，并记录下来。然后不重复地给出一个长度为 8 的小写十六进制数（例如 3bdc8902），用于唯一地指示这一次 commit。</p>
<p>git 中的提交是一个树形的结构。我们希望你在 gitm 中，同样实现这样的树形结构。</p>
<img src="git-brance.svg" alt="img" style="zoom: 100%;">

<p>gitm 中不要求实现对分支的命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout commit</span><br></pre></td></tr></table></figure>

<p>checkout 用于将当前目录的状态切换到 commit 所指示的提交上。</p>
<p>若当前目录的状态较 gitm <strong>当前所处的 commit</strong> 有改动，则拒绝本次 checkout，并且<strong>你的 main() 函数以返回值 1 退出</strong>。</p>
<p>checkout 正常完成后，你目录中文件的状态（除了 .gitm 目录以外）必须与指定的 commit 相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm checkout .</span><br></pre></td></tr></table></figure>

<p>特殊地，这一条命令用于将目录文件恢复到当前所处的 commit 时的状态。也就是说，放弃此时对文件的所有改动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitm merge commit</span><br></pre></td></tr></table></figure>

<p>找到当前所处 commit 与命令指定的 commit 的公共祖先，并将两个 commit 合并起来。</p>
<p>具体来说，是将命令指定的 commit 相对于公共祖先的修改，应用于当前所处的 commit。</p>
<p>如果合并的两个 commit 相对于公共祖先，均对同一个文件产生了修改（创建、删除、编辑），那么命令直接拒绝执行，输出 “conflict\n” <strong>并使 main 函数返回 1</strong>。</p>
<p>在其他情况下，你需要合并，并产生一个新的 commit。逻辑上，这个 commit 将成为被合并的两个 commit 的共同后继。</p>
<blockquote>
<p>我们如何检测这一点？</p>
<p>假设有 commit a-g，b, c 由 a 分支而来，d 由 b, c 合并而来，e 是 b 的后继，f 是 c 的后继，g 是 d 的后继。</p>
<p>你的程序应当有能力找到 e, g 的公共祖先是 b，f, g 公共祖先是 c，在此基础上合并是无冲突的。如果你只能找到 a，则合并有可能产生冲突，因为 e 相对 a 改变了 a.c，而 g 相对 a 也改变了 a.c。</p>
</blockquote>
<img src="image-20230103113625830.png" alt="image-20230103113625830" style="zoom: 67%;">

<h3 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h3><p>我们会将你的 repo 里所有的 C 源文件和头文件收集起来进行编译，并生成一个名为 <code>gitm</code> 的可执行文件。然后原地创建一个文件夹，作为你的 gitm 需要管理的 repository。例如（其中 &gt; 开头的行表示命令行输出）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">dir</span></span><br><span class="line">../gitm init</span><br><span class="line">../gitm commit</span><br><span class="line">&gt; 3bce5ff0                       <span class="comment"># 空 commit，我们的 OJ 一定会创建一个空 commit 作为第一个</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; hello.txt   <span class="comment"># 创建文件并写入</span></span><br><span class="line">../gitm commit</span><br><span class="line">&gt; b926d817</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is my git&quot;</span> &gt; readme.txt</span><br><span class="line">../gitm checkout 3bce5ff0</span><br><span class="line">&gt; You<span class="string">&#x27;ve made change. Please commit or garbage your change.</span></span><br><span class="line"><span class="string">echo $?                          # 给出上一条命令的返回值。正常退出的程序应当为 0</span></span><br><span class="line"><span class="string">&gt; 1</span></span><br><span class="line"><span class="string">../gitm commit</span></span><br><span class="line"><span class="string">&gt; ef938aa6</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt readme.txt .gitm</span></span><br><span class="line"><span class="string">../gitm checkout b926d817</span></span><br><span class="line"><span class="string">ls -a</span></span><br><span class="line"><span class="string">&gt; hello.txt .gitm</span></span><br></pre></td></tr></table></figure>

<p>随着时间的流逝，我将会发布进一步的实验指南。</p>
<h3 id="实现要求-3"><a href="#实现要求-3" class="headerlink" title="实现要求"></a>实现要求</h3><ul>
<li>你创建的所有文件都要放到运行目录的 .gitm 目录下。<ul>
<li>+++ 对目录的体积要求：不要每一次都追踪没有发生变化的文件即可。不需要对每个文件进行增量存储。 +++</li>
</ul>
</li>
<li>commit 数量不会超过 10000 个。</li>
<li>你的 gitm 只需要管理文本类型的文件。其他类型的文件不会出现。</li>
<li>不要求追踪空目录</li>
</ul>
<p>本实验的测试点预计如下：</p>
<p>1、hello world（保留 gitm version 的打印信息即得分）</p>
<p>2、和上面的脚本相似的一段小测试，基础功能</p>
<p>3、文件数量增加，提交数量增加；但并不会出现子目录</p>
<p>4、在 3 的基础上，有一定的目录结构</p>
<p>5、在 4 的基础上，测试 merge 功能（不会很刁钻，只要该拒绝的拒绝，该成功的 merge 对就行了）</p>
<p>6、测试 .gitm 的空间管理，<strong>要求未发生改动的文件不重复存储，不要求单文件的增量存储</strong></p>
<p>能够恢复对文件就可以了，不会太刁钻。</p>
<h3 id="实现指南-1"><a href="#实现指南-1" class="headerlink" title="实现指南"></a>实现指南</h3><p>一个更加 naïve 的思路。从一个 commit 刚刚被提交说起…</p>
<p>此时，所有的目录结构和文件改动都被提交了，我们可以在当下的目录中进行新的改动。为了能够恢复到刚刚提交的“干净”状态，我们需要为当下的状态做一个暂存，以便之后进行对比。</p>
<p>现在我们做了一些改动，想要 commit。这里，需要记录下改动的部分，没有改动的部分则默认是保持的。我们可以用文件系统的 api 遍历当前目录和暂存下来的目录，检测文件的增删等。对于依然存在的文件，则需要逐字符对比其中的改动。当所有的改动全部检测完毕后，在 .git 下保存好本次改动中：</p>
<ul>
<li>删除了哪些文件</li>
<li>增加了哪些文件和这些文件的内容</li>
<li>编辑了哪些文件和这些文件的新版本</li>
</ul>
<p>并将本次 commit 及其父节点 commit 号记录下来。</p>
<p>可以使用的一些函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;     <span class="comment">// 打开目录</span></span><br><span class="line">       <span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;  <span class="comment">// 读取目录中的项目</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;  <span class="comment">// 创建新目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;   <span class="comment">// 删除目录</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>如何更简单地判断新文件是否发生改动，特别是较大文件？</p>
</blockquote>
<p>可以对所有存储下来的文件做 <code>md5sum</code>，为文件生成一个摘要。之后再有文件变动时，先去找是否存在相同的 md5，如果新旧文件的 md5 相同，就不用重复保存了。</p>
<p>如何调用命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="废弃的旧思路（依然可以尝试）"><a href="#废弃的旧思路（依然可以尝试）" class="headerlink" title="废弃的旧思路（依然可以尝试）"></a>废弃的旧思路（依然可以尝试）</h3><p>一个 naïve 的思路。</p>
<p>首先介绍两个工具，一个叫做 diff，一个叫做 patch。这两个工具是大部分发行版自带的。<strong>看到这里请打开你的命令行</strong>一起尝试一下。</p>
<p>准备任意一个代码文件 a.c，复制到 b.c，在 b.c 中加入一些行，删去一些行，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure>

<p>能看到：</p>
<img src="Screenshot_20230115_000047.png" alt="img" style="zoom:75%;">

<p>可知，diff 可以计算出两个文本文件之间的差距。</p>
<p>用重定向将这一结果定向到 <code>diff.out</code> 中，我们再用 patch:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patch a.c diff.out</span><br><span class="line">diff a.c b.c</span><br></pre></td></tr></table></figure>

<p>这次什么也没有输出。a.c 和 b.c 变成一样的了。</p>
<p>diff 不仅可以给 a.c 打补丁，还可以把补丁从文件中拆下来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -r b.c diff.out</span><br></pre></td></tr></table></figure>

<p>再打开 b.c，就能发现文件变回了之前  a.c 的样子。</p>
<p>great。所以只要你能够在 commit 的时候遍历目录中的所有文件，挨个 diff 一下，就可以算出当前版本和上个版本的差距了。然后你把这些差距全都写 .gitm 中的某一个文件，大功告成。</p>
<p>diff 和 patch 可以对两个目录直接计算差值和补丁&#x2F;回退。如果你学会怎么用，省去很多麻烦事。</p>
<p>如何调用命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;  <span class="comment">// 执行命令，读取它的输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结：在 .gitm 中我们需要存储的元素</p>
<ul>
<li>一个文件，能指示当前所处的提交</li>
<li>一个文件，包含了所有的提交号，并需要能够指明每个提交在树结构上的祖先节点。对于新 commit 是一个，对于 merge 是两个（这与 git 并不完全相同）</li>
<li>若干个目录，每个代表一个 commit；每个目录若干个文件，记录它相对祖先节点的变化：增减文件目录，编辑文件</li>
<li>一个目录，包含了当前 commit 的暂存状态，以便之后用于与编辑后的状态进行比较</li>
</ul>
<p>在 gitm 执行的过程中，有这样一些子功能需要实现：</p>
<ul>
<li>解析参数，执行对应功能</li>
<li>遍历当前文件树，与已提交的文件树对比</li>
<li>将对比的文件树中公共部分进行比较</li>
<li>分析 commit 记录，确定提交之间的关系</li>
<li>通过提交之间关系，决定前进或后退</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/20230626-explode/">组会论文</a><a class="next" href="/20230605-cphil1/">中国哲学史 阅读笔记 I</a></div><div class="nofancybox" id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var lang = 'en',
  langMode = {
      "nick": "NickName",
      "mail": "E-Mail",
      "link": "Website(http://)",
      "nickFail":"NickName cannot be less than 3 bytes.",
      "mailFail":"Please confirm your email address.",
      "sofa": "No comment yet.",
      "submit": "Submit",
      "reply": "Reply",
      "cancelReply": "Cancel reply",
      "comments": "Comments",
      "cancel": "Cancel",
      "confirm": "Confirm",
      "continue": "Continue",
      "more": "Load More...",
      "preview": "Preview",
      "emoji": "Emoji",
      "expand": "See more....",
      "seconds": "seconds ago",
      "minutes": "minutes ago",
      "hours": "hours ago",
      "days": "days ago",
      "now": "just now",
      "uploading":"Uploading ...",
      "uploadDone":"Upload completed!",
      "busy":"Submit is busy, please wait...",
      "code-98":"Valine initialization failed, please check your version of av-min.js.",
      "code-99": "Valine initialization failed, Please check the `el` element in the init method.",
      "code-100": "Valine initialization failed, Please check your appId and appKey.",
      "code-140":"The total number of API calls today has exceeded the development version limit.",
      "code-401": "Unauthorized operation, Please check your appId and appKey.",
      "code-403": "Access denied by API domain white list, Please check your security domain."
  };
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'2Sm5GfIvJtcJUva0FtUU3gUX-gzGzoHsz',
  appKey:'tMoFHUMjKt3Br9ql4XQuMdu7',
  lang: lang,
  langMode: langMode,
  serverURLs:'',
  placeholder:'Say something',
  avatar:' ',
  avatar_cdn: 'http://cravatar.cn/avatar/',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p>Great</p><a class="info-icon" href="mailto:502023330051@smail.nju.edu.cn" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Tilnel" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://coink.wang/" title="Coink" target="_blank">Coink</a><ul></ul><a href="https://chariri.moe/" title="茶栗" target="_blank">茶栗</a><ul></ul><a href="https://riverclouds.net/" title="江云" target="_blank">江云</a><ul></ul><a href="https://czxingchen.github.io/" title="XiaoZhi" target="_blank">XiaoZhi</a><ul></ul><a href="https://usernamenul1.github.io/" title="nul1" target="_blank">nul1</a><ul></ul><a href="https://huamurui.github.io/" title="花木瑞" target="_blank">花木瑞</a><ul></ul><a href="https://eaglebear2002.github.io/" title="熊丘桓" target="_blank">熊丘桓</a><ul></ul><a href="https://www.doowzs.com/" title="张天昀" target="_blank">张天昀</a><ul></ul><a href="https://mzy0624.github.io/" title="毛子钰" target="_blank">毛子钰</a><ul></ul><a href="https://jyywiki.cn/" title="蒋炎岩" target="_blank">蒋炎岩</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/COJ/">COJ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DisAlg/">DisAlg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DisSys/">DisSys</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-Systems/">Distributed Systems</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Misc/">Misc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E6%BC%AB/">动漫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A9%E6%95%99%E5%B7%A5%E4%BD%9C/">助教工作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%93%B2%E5%AD%A6/">哲学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%96%9C%E5%89%A7/">喜剧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%95%E6%8B%BE/">夕拾</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E7%90%86%E5%AD%A6/">心理学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%83%85%E6%84%9F/">情感</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%AC%E8%BF%90/">搬运</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%B8%E9%B1%BC/">摸鱼</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E8%AE%B0%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/">日记补完计划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%B6%E5%B0%9A/">时尚</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%B5%E8%A7%86%E5%89%A7/">电视剧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94/">科研</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%81%E9%97%BB/">见闻</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%82%E5%BD%B1/">观影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%82%E7%82%B9/">观点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%B2%E7%A8%BF/">讲稿</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E6%96%87%E7%8C%AE/">读文献</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B0%A2%E6%9E%97/">谢林</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%85%92/">酒</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div>Total<span id="busuanzi_container_site_pv"><span> </span><span id="busuanzi_value_site_pv"></span></span><span rel="nofollow"> </span>hits</div>Copyright © 2025 <a href="/." rel="nofollow">Tilnel's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script></div></body></html>